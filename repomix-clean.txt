This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: text_copies/**, **/package-lock.json, addon/godot-plugin/**, addon/mcp-server/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.editorconfig
.gitattributes
.gitignore
addon/.gitignore
addon/claude_desktop_config.json
addon/LICENSE
addon/PROJECT_PLAN.md
addon/README.md
addon/SUMMARY.md
addon/VISUAL_TREE_ROADMAP.md
audio/click.wav.import
audio/error.wav.import
audio/relay.wav.import
claude_desktop_config.json
data/city_map/level_6_1_02.json
data/city_map/level_6_1_03.json
data/city_map/level_6_1.json
data/city_map/level_6_2_02.json
data/city_map/level_6_2_03.json
data/city_map/level_6_2.json
data/city_map/level_6_3_02.json
data/city_map/level_6_3_03.json
data/city_map/level_6_3.json
data/city_map/pack_6_1_A.json
data/city_map/pack_6_2_B.json
data/city_map/pack_6_3_C.json
data/clues_levels.json
data/final_report_a_levels.json
data/final_report_b_levels.json
data/final_report_c_levels.json
data/matrix_ladder_levels.json
data/network_trace_a_levels.json
data/network_trace_b_levels.json
data/network_trace_c_levels.json
data/quest_b_levels.json
data/quest_c_levels.json
data/suspect_a_levels.json
export_presets.cfg
icon.svg
icon.svg.import
LICENSE
PROJECT_PLAN.md
project.godot
README.md
scenes/BitKnob.gd
scenes/Blur.gdshader
scenes/Blur.gdshader.uid
scenes/case_01/CluesQuestA.gd
scenes/case_01/CluesQuestA.tscn
scenes/case_01/DigitalResusQuestA.gd
scenes/case_01/DigitalResusQuestA.tscn
scenes/case_01/DigitalResusQuestB.gd
scenes/case_01/DigitalResusQuestB.tscn
scenes/case_01/DigitalResusQuestC.gd
scenes/case_01/DigitalResusQuestC.tscn
scenes/case_07/da7_data_archive_a.tscn
scenes/case_07/da7_data_archive_b.tscn
scenes/case_07/da7_data_archive_c.tscn
scenes/case_08/fr8_final_report_a.tscn
scenes/case_08/fr8_final_report_b.tscn
scenes/case_08/fr8_final_report_c.tscn
scenes/CityMapQuestA.gd
scenes/CityMapQuestA.tscn
scenes/CityMapQuestB.gd
scenes/CityMapQuestB.tscn
scenes/CityMapQuestC.gd
scenes/CityMapQuestC.tscn
scenes/Decryptor.gd
scenes/Decryptor.gd.uid
scenes/Decryptor.tscn
scenes/decryptor/DecryptorUI.tscn
scenes/decryptor/MatrixDecryptorUI.tscn
scenes/DisarmQuestC.tscn
scenes/LearnSelect.gd
scenes/LearnSelect.tscn
scenes/LogicQuestA.gd
scenes/LogicQuestA.gd.uid
scenes/LogicQuestA.tscn
scenes/LogicQuestB.gd
scenes/LogicQuestB.tscn
scenes/LogicQuestC.gd
scenes/LogicQuestC.tscn
scenes/MainMenu.gd
scenes/MainMenu.gd.uid
scenes/MainMenu.tscn
scenes/MatrixDecryptor.gd
scenes/MatrixDecryptor.gd.uid
scenes/MatrixDecryptor.tscn
scenes/NetworkTraceQuest.gd
scenes/NetworkTraceQuestA.tscn
scenes/NetworkTraceQuestB.tscn
scenes/NetworkTraceQuestC.tscn
scenes/QuestSelect.gd
scenes/QuestSelect.gd.uid
scenes/QuestSelect.tscn
scenes/radio_intercept/RadioQuestA.tscn
scenes/RadioQuestA.gd
scenes/RadioQuestA.tscn
scenes/RadioQuestB.gd
scenes/RadioQuestB.tscn
scenes/RadioQuestC.gd
scenes/RadioQuestC.tscn
scenes/RestoreQuestB.tscn
scenes/SuspectQuestA.tscn
scenes/TimeKnob.gd
scenes/ui/ClueItem.tscn
scenes/ui/ConfigCard.tscn
scenes/ui/DiagnosticsPanelB.tscn
scenes/ui/DiagnosticsPanelC.tscn
scenes/ui/FixMenuC.tscn
scenes/ui/InspectBadge.tscn
scenes/ui/InspectorPopup.tscn
scenes/ui/NetItem.tscn
scenes/ui/NetSlot.tscn
scenes/ui/network_trace/NetworkTraceDeviceCard.tscn
scenes/ui/pipeline/ModuleCard.tscn
scenes/ui/pipeline/PipelineSlot.tscn
scenes/ui/ResultStamp.tscn
scenes/ui/ResusPartItem.tscn
scenes/ui/subnet/BitCell.tscn
scenes/ui/subnet/LockIndicator.tscn
scenes/ui/subnet/MaskOverlay.tscn
scenes/ui/subnet/SubnetRuler.tscn
scenes/ui/TagFragmentItem.tscn
scenes/ui/TagPileZone.tscn
scenes/ui/TagSlotZone.tscn
scenes/ui/TimelineCard.tscn
scripts/AudioManager.gd
scripts/case_01/ResusData.gd
scripts/case_01/ResusScoring.gd
scripts/case_07/da7_cases_a.gd
scripts/case_07/da7_cases_b.gd
scripts/case_07/da7_cases_c.gd
scripts/case_07/da7_cases.gd
scripts/case_07/da7_data_archive_a.gd
scripts/case_07/da7_data_archive_b.gd
scripts/case_07/da7_data_archive_c.gd
scripts/case_08/fr8_data.gd
scripts/case_08/fr8_final_report_a.gd
scripts/case_08/fr8_final_report_b.gd
scripts/case_08/fr8_final_report_c.gd
scripts/case_08/fr8_scoring.gd
scripts/case_08/fr8b_data.gd
scripts/case_08/fr8b_scoring.gd
scripts/case_08/fr8c_data.gd
scripts/case_08/fr8c_scoring.gd
scripts/DisarmQuestC.gd
scripts/GlobalMetrics.gd
scripts/GlobalMetrics.gd.uid
scripts/quests/network_trace/NetworkTraceQuestA.gd
scripts/quests/network_trace/NetworkTraceQuestB.gd
scripts/quests/network_trace/NetworkTraceQuestC.gd
scripts/radio_intercept/RadioQuestA.gd
scripts/RestoreQuestB.gd
scripts/sign.py
scripts/ssot/network_trace_errors.gd
scripts/SuspectQuestA.gd
scripts/TrialV2.gd
scripts/ui/ClueBucketZone.gd
scripts/ui/ClueItem.gd
scripts/ui/CodeBlock.gd
scripts/ui/ConfigCard.gd
scripts/ui/ConnectorOverlay.gd
scripts/ui/DiagnosticsPanelB.gd
scripts/ui/DiagnosticsPanelC.gd
scripts/ui/DropZone.gd
scripts/ui/FixMenuC.gd
scripts/ui/InspectorPopup.gd
scripts/ui/NetItem.gd
scripts/ui/NetSlot.gd
scripts/ui/network_trace/network_trace_device_card.gd
scripts/ui/network_trace/topology_board_a.gd
scripts/ui/pipeline/ModuleCard.gd
scripts/ui/pipeline/PipelineSlot.gd
scripts/ui/ResultStamp.gd
scripts/ui/ResusDropZone.gd
scripts/ui/ResusPartItem.gd
scripts/ui/ResusPileZone.gd
scripts/ui/subnet/BitCell.gd
scripts/ui/subnet/LockIndicator.gd
scripts/ui/subnet/MaskDropTarget.gd
scripts/ui/subnet/MaskOverlay.gd
scripts/ui/subnet/SubnetRuler.gd
scripts/ui/TagFragmentItem.gd
scripts/ui/TagPileZone.gd
scripts/ui/TagSlotZone.gd
scripts/ui/TimelineCard.gd
shaders/blur.gdshader
shaders/blur.gdshader.uid
SUMMARY.md
ui/overlays/NoirOverlay.gd
ui/overlays/NoirOverlay.tscn
ui/shaders/crt_overlay.gdshader
ui/shaders/noir_pencil_overlay.gdshader
ui/theme_noir_detective.tres
ui/theme_noir_pencil.tres
ui/theme_terminal_amber.tres
ui/theme_terminal_green.tres
ui/theme_untformatic.tres
VISUAL_TREE_ROADMAP.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".editorconfig">
root = true

[*]
charset = utf-8
</file>

<file path=".gitattributes">
# Normalize EOL for all files that Git considers text files.
* text=auto eol=lf
</file>

<file path=".gitignore">
# Godot 4+ specific ignores
.godot/
/android/
</file>

<file path="audio/click.wav.import">
[remap]

importer="wav"
type="AudioStreamWAV"
uid="uid://c2ft5g74r8cei"
path="res://.godot/imported/click.wav-fd13f10d6f727710e39f04648321cf68.sample"

[deps]

source_file="res://audio/click.wav"
dest_files=["res://.godot/imported/click.wav-fd13f10d6f727710e39f04648321cf68.sample"]

[params]

force/8_bit=false
force/mono=false
force/max_rate=false
force/max_rate_hz=44100
edit/trim=false
edit/normalize=false
edit/loop_mode=0
edit/loop_begin=0
edit/loop_end=-1
compress/mode=0
</file>

<file path="audio/error.wav.import">
[remap]

importer="wav"
type="AudioStreamWAV"
uid="uid://c4se3pomlhl5s"
path="res://.godot/imported/error.wav-7758481f0b630740b3553187f425c005.sample"

[deps]

source_file="res://audio/error.wav"
dest_files=["res://.godot/imported/error.wav-7758481f0b630740b3553187f425c005.sample"]

[params]

force/8_bit=false
force/mono=false
force/max_rate=false
force/max_rate_hz=44100
edit/trim=false
edit/normalize=false
edit/loop_mode=0
edit/loop_begin=0
edit/loop_end=-1
compress/mode=0
</file>

<file path="audio/relay.wav.import">
[remap]

importer="wav"
type="AudioStreamWAV"
uid="uid://b7yubqykijwtw"
path="res://.godot/imported/relay.wav-116b448ac11417a04cb15209b9a5dfbb.sample"

[deps]

source_file="res://audio/relay.wav"
dest_files=["res://.godot/imported/relay.wav-116b448ac11417a04cb15209b9a5dfbb.sample"]

[params]

force/8_bit=false
force/mono=false
force/max_rate=false
force/max_rate_hz=44100
edit/trim=false
edit/normalize=false
edit/loop_mode=0
edit/loop_begin=0
edit/loop_end=-1
compress/mode=0
</file>

<file path="icon.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128"><rect width="124" height="124" x="2" y="2" fill="#363d52" stroke="#212532" stroke-width="4" rx="14"/><g fill="#fff" transform="translate(12.322 12.322)scale(.101)"><path d="M105 673v33q407 354 814 0v-33z"/><path fill="#478cbf" d="m105 673 152 14q12 1 15 14l4 67 132 10 8-61q2-11 15-15h162q13 4 15 15l8 61 132-10 4-67q3-13 15-14l152-14V427q30-39 56-81-35-59-83-108-43 20-82 47-40-37-88-64 7-51 8-102-59-28-123-42-26 43-46 89-49-7-98 0-20-46-46-89-64 14-123 42 1 51 8 102-48 27-88 64-39-27-82-47-48 49-83 108 26 42 56 81zm0 33v39c0 276 813 276 814 0v-39l-134 12-5 69q-2 10-14 13l-162 11q-12 0-16-11l-10-65H446l-10 65q-4 11-16 11l-162-11q-12-3-14-13l-5-69z"/><path d="M483 600c0 34 58 34 58 0v-86c0-34-58-34-58 0z"/><circle cx="725" cy="526" r="90"/><circle cx="299" cy="526" r="90"/></g><g fill="#414042" transform="translate(12.322 12.322)scale(.101)"><circle cx="307" cy="532" r="60"/><circle cx="717" cy="532" r="60"/></g></svg>
</file>

<file path="scenes/Blur.gdshader">
shader_type canvas_item;

uniform float lod: hint_range(0.0, 5.0) = 0.0;
uniform vec4 modulate: source_color = vec4(0.0, 0.0, 0.0, 0.8);

void fragment() {
	vec4 color = texture(TEXTURE, UV, lod);
	COLOR = color * modulate;
}
</file>

<file path="scenes/Blur.gdshader.uid">
uid://cfcttjjhg0ff6
</file>

<file path="scenes/Decryptor.gd.uid">
uid://bhtu3gcydl223
</file>

<file path="scenes/LogicQuestA.gd.uid">
uid://halel5kevhfj
</file>

<file path="scenes/MainMenu.gd.uid">
uid://dbkn8k0aa003
</file>

<file path="scenes/MatrixDecryptor.gd.uid">
uid://pmdbb6uujm4h
</file>

<file path="scenes/QuestSelect.gd.uid">
uid://bdwp1mh211r68
</file>

<file path="scripts/GlobalMetrics.gd.uid">
uid://bwe0if03e7s1m
</file>

<file path="scripts/sign.py">
import wave
import struct
import math
import random

def generate_wav(filename, duration, volume=0.5, func=None):
    # Параметры звука
    sample_rate = 44100.0  # Частота дискретизации (Гц)
    num_samples = int(duration * sample_rate)
    
    # Открываем файл на запись
    with wave.open(filename, 'w') as wav_file:
        # Устанавливаем параметры: 1 канал (моно), 2 байта на семпл (16 бит), частота
        wav_file.setparams((1, 2, int(sample_rate), num_samples, 'NONE', 'not compressed'))
        
        for i in range(num_samples):
            t = i / sample_rate
            # Генерируем значение амплитуды через переданную функцию
            value = func(t, duration, volume)
            
            # Ограничиваем амплитуду и переводим в 16-битное целое число
            sample = int(max(-1, min(1, value)) * 32767)
            wav_file.writeframes(struct.pack('<h', sample))

# 1. Механический клик (короткий импульс с затуханием)
def click_sound(t, duration, volume):
    # Высокочастотный синус с очень быстрым экспоненциальным затуханием
    freq = 1500
    decay = math.exp(-t * 100)
    return volume * math.sin(2 * math.pi * freq * t) * decay

# 2. Звук реле (двойной щелчок с небольшим шумом)
def relay_sound(t, duration, volume):
    # Два коротких щелчка
    click1 = math.exp(-t * 80) * math.sin(2 * math.pi * 1200 * t)
    click2 = 0
    if t > 0.05:
        click2 = math.exp(-(t-0.05) * 80) * math.sin(2 * math.pi * 1000 * (t-0.05))
    
    # Добавляем немного механического шума
    noise = (random.random() * 2 - 1) * math.exp(-t * 40) * 0.2
    return volume * (click1 + click2 + noise)

# 3. Звук ошибки (низкочастотный "баззер")
def error_sound(t, duration, volume):
    # Прямоугольная волна (дает характерный "игровой" звук ошибки)
    freq = 120
    if math.sin(2 * math.pi * freq * t) > 0:
        return volume * 0.5
    else:
        return -volume * 0.5

# Генерация файлов
print("Генерация звуковых эффектов...")

# Краткий клик (0.05 сек)
generate_wav("click.wav", 0.05, volume=0.6, func=click_sound)

# Реле (0.15 сек)
generate_wav("relay.wav", 0.15, volume=0.5, func=relay_sound)

# Ошибка (0.3 сек)
generate_wav("error.wav", 0.3, volume=0.4, func=error_sound)

print("Готово! Файлы click.wav, relay.wav и error.wav созданы.")
</file>

<file path="shaders/blur.gdshader.uid">
uid://de5yrwj0keuus
</file>

<file path="addon/.gitignore">
# Dependencies
node_modules/

# Build output
dist/

# OS files
.DS_Store
.DS_Store?
._*

# IDE
.vscode/
.idea/

# Claude
.claude/

# Environment
.env
.env.local
</file>

<file path="addon/claude_desktop_config.json">
{
  "mcpServers": {
    "godot": {
      "command": "node",
      "args": ["/Users/tomeryud/godot-mcp/mcp-server/dist/index.js"]
    }
  }
}
</file>

<file path="addon/LICENSE">
MIT License

Copyright (c) 2025-2026 Tomer Yud

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="addon/PROJECT_PLAN.md">
# Godot MCP Server - Complete Project Plan

## Overview

This document contains everything needed to build a **Godot MCP Server** that integrates Godot game engine tools with the RAGy application via the Model Context Protocol (MCP).

**Goal:** Create a clean, modular MCP server that exposes Godot editor functionality (scene manipulation, script editing, file operations) to any MCP-compatible AI client, with RAGy as the primary client.

---

## Project Paths

```
/Users/tomeryud/
├── projects/RAGy/                    # RAGy app (MCP client) - REFERENCE
├── godot-ai-assistant/               # Old Godot app - REFERENCE (do not modify)
└── godot-mcp/                        # NEW PROJECT (build here)
    ├── mcp-server/                   # Node.js MCP server
    └── godot-plugin/                 # Minimal GDScript plugin
```

---

## Part 1: Understanding RAGy (The MCP Client)

### What is RAGy?

RAGy is an Electron desktop app for building RAG (Retrieval-Augmented Generation) systems. It allows users to:
- Upload documents and chunk them
- Generate embeddings and build vector databases
- Chat with AI using RAG context
- Use MCP tools for extended functionality

### RAGy's MCP Architecture

RAGy already has MCP infrastructure. Key files to study:

#### MCP Client Manager
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`

This manages connections to MCP servers. Key code pattern:

```javascript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

class MCPClientManager {
  constructor() {
    this.clients = new Map(); // serverName -> { client, transport }
    this.initialized = false;
  }

  async initialize() {
    // Connect to each MCP server as a child process
    await this.connectToServer('memory', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/memory-server.js')],
    });

    await this.connectToServer('rag', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/rag-server.js')],
    });

    // TODO: Add godot server here
    // await this.connectToServer('godot', {
    //   command: 'node',
    //   args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
    // });
  }

  async connectToServer(serverName, config) {
    const client = new Client({ name: 'ragy-chat-client', version: '1.0.0' }, { capabilities: {} });
    const transport = new StdioClientTransport({ command: config.command, args: config.args });
    await client.connect(transport);
    this.clients.set(serverName, { client, transport, config });
  }

  async getAllTools() {
    // Collects tools from all connected servers
    const allTools = [];
    for (const [serverName, { client }] of this.clients) {
      const response = await client.listTools();
      const toolsWithServer = response.tools.map(tool => ({ ...tool, _mcpServer: serverName }));
      allTools.push(...toolsWithServer);
    }
    return allTools;
  }

  async callTool(toolName, args, serverName) {
    const serverInfo = this.clients.get(serverName);
    return await serverInfo.client.callTool({ name: toolName, arguments: args });
  }
}
```

#### Example MCP Server (RAG Server)
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp-servers/rag-server.js`

This shows the pattern for building MCP servers:

```javascript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';

const server = new Server(
  { name: 'ragy-rag-server', version: '1.0.0' },
  { capabilities: { tools: {} } }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'search_documents',
        description: 'Semantic search across the knowledge base',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: 'Search query' },
            top_k: { type: 'number', description: 'Number of results' }
          },
          required: ['query']
        }
      }
    ]
  };
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === 'search_documents') {
    // Execute the tool and return result
    const results = await doSearch(args.query, args.top_k);
    return {
      content: [{ type: 'text', text: JSON.stringify(results) }]
    };
  }
});

// Start server
const transport = new StdioServerTransport();
await server.connect(transport);
```

#### AI Service with Tools
**Path:** `/Users/tomeryud/projects/RAGy/server/services/ai-with-tools.service.js`

This shows how RAGy uses MCP tools with AI providers. Key points:
- Gets tools via `mcpClientManager.getToolsForOpenAI()` or `getToolsForAnthropic()`
- Sends tools to AI provider
- When AI returns tool_call, executes via `mcpClientManager.callTool()`
- Returns result to AI for final response

### RAGy Tech Stack
- **Frontend:** React 18 + Vite
- **Backend:** Express.js (port 3001)
- **Desktop:** Electron
- **MCP SDK:** `@modelcontextprotocol/sdk`

---

## Part 2: Understanding the Old Godot AI Assistant (Reference)

### What is it?

The old Godot AI Assistant is a standalone app with:
- Express.js server with AI integration (multiple providers)
- React frontend for chat UI
- Godot plugin that polls server for tool invocations
- 33 tools for Godot manipulation

**Important:** Do NOT modify this project. Use it only as reference for tool implementations.

### Key Files to Reference

#### Tool Schemas (Copy tool definitions from here)
**Path:** `/Users/tomeryud/godot-ai-assistant/tool_schemas/`

Files:
- `openaiTools.js` - Tool definitions in OpenAI format
- `geminiTools.js` - Tool definitions in Gemini format
- `anthropicTools.js` - Tool definitions in Anthropic format

These contain the 33+ tool definitions with names, descriptions, and parameter schemas. Convert these to MCP format.

#### Tool Implementations in Godot Plugin
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/`

This contains GDScript implementations for each tool:
- `file_operations/` - read_file, list_dir, search_project
- `scene_operations/` - read_scene, create_scene, add_node, modify_node
- `script_operations/` - create_script, apply_diff_preview

Study these to understand what each tool does and how to implement in the new plugin.

#### Tool Registry (Tool routing logic)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/tool_registry.gd`

Shows how tools are registered and routed to handlers.

#### External App Communicator (HTTP polling - replace with WebSocket)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/external_app_communicator.gd`

This uses HTTP polling (bad). Replace with WebSocket in new implementation.

### Complete Tool List (33 Tools)

**File System (6 tools):**
1. `list_dir` - List files/folders in a directory
2. `read_file` - Read text file contents
3. `search_project` - Regex/substring search across project
4. `list_scripts` - List all GDScript files
5. `create_script` - Create new GDScript file
6. `open_in_godot` - Open file at specific line in editor

**Scene Operations (10 tools):**
7. `scene_tree_dump` - Get current scene tree structure
8. `read_scene` - Parse .tscn file to get node structure
9. `create_scene` - Create new .tscn file with nodes
10. `add_node` - Add node to existing scene
11. `remove_node` - Remove node from scene
12. `rename_node` - Rename a node
13. `move_node` - Reorder node in hierarchy
14. `modify_node_property` - Change node properties
15. `get_node_properties` - Discover properties for node type
16. `set_collision_shape` - Configure collision shape

**Script Operations (4 tools):**
17. `apply_diff_preview` - Apply surgical code edits (1-10 lines)
18. `validate_script` - Check script syntax
19. `attach_script` - Attach script to node
20. `detach_script` - Remove script from node

**Project Configuration (4 tools):**
21. `get_project_settings` - Access window size, physics settings
22. `get_input_map` - Query input actions and bindings
23. `get_collision_layers` - Access collision layer names
24. `get_render_settings` - Graphics/render configuration

**Debugging (3 tools):**
25. `get_console_log` - Access Godot editor output
26. `get_errors` - Get structured error data
27. `clear_console_log` - Clear console

**Asset Operations (3 tools):**
28. `set_sprite_texture` - Set texture on Sprite2D
29. `generate_2d_asset` - Generate 2D graphics
30. `customize_and_run_workflow` - Run asset workflows

**Workflow (3 tools):**
31. `inspect_runninghub_workflow` - Inspect workflows
32. `search_comfyui_nodes` - Search node library
33. `manage_task_list` - Task management

---

## Part 3: New Architecture

### High-Level Design

```
┌─────────────────────────────────────────────────────────────┐
│  RAGy (or any MCP client)                                   │
│      │                                                      │
│      │ stdio (MCP protocol)                                 │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  godot-mcp-server (Node.js)                         │    │
│  │  - Speaks MCP via stdio                             │    │
│  │  - Speaks WebSocket to Godot plugin                 │    │
│  │  - Defines all Godot tools                          │    │
│  │  - Routes tool calls to Godot                       │    │
│  └──────────────────────┬──────────────────────────────┘    │
│                         │                                   │
│                         │ WebSocket (port 6505)             │
│                         │ (bidirectional, real-time)        │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  Godot Plugin (minimal)                             │    │
│  │  - Connects via WebSocket                           │    │
│  │  - Receives tool invocation requests                │    │
│  │  - Executes tools in Godot context                  │    │
│  │  - Returns results immediately                      │    │
│  │  - Shows connection status (minimal UI)             │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### WebSocket Protocol

Messages between MCP server and Godot plugin:

**Tool Invocation (Server → Godot):**
```json
{
  "type": "tool_invoke",
  "id": "unique-request-id",
  "tool": "read_scene",
  "args": {
    "scene_path": "res://scenes/player.tscn"
  }
}
```

**Tool Result (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": true,
  "result": { "nodes": [...] }
}
```

**Error (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": false,
  "error": "Scene file not found"
}
```

**Connection Status:**
```json
{ "type": "ping" }
{ "type": "pong" }
{ "type": "godot_ready", "project_path": "/path/to/project" }
```

---

## Part 4: Directory Structure

```
/Users/tomeryud/godot-mcp/
├── PROJECT_PLAN.md                   # This file
│
├── mcp-server/                       # Node.js MCP server
│   ├── package.json
│   ├── src/
│   │   ├── index.js                  # Main entry point
│   │   ├── godot-bridge.js           # WebSocket connection to Godot
│   │   ├── tools/
│   │   │   ├── index.js              # Exports all tools
│   │   │   ├── file-tools.js         # list_dir, read_file, etc.
│   │   │   ├── scene-tools.js        # read_scene, create_scene, etc.
│   │   │   ├── script-tools.js       # apply_diff, validate_script, etc.
│   │   │   ├── project-tools.js      # get_project_settings, etc.
│   │   │   └── debug-tools.js        # get_console_log, get_errors, etc.
│   │   └── utils/
│   │       └── logger.js             # Logging utility
│   └── README.md
│
└── godot-plugin/                     # Godot 4.x plugin
    ├── addons/
    │   └── godot_mcp/
    │       ├── plugin.cfg            # Plugin configuration
    │       ├── plugin.gd             # Main plugin script
    │       ├── mcp_client.gd         # WebSocket client
    │       ├── tool_executor.gd      # Routes and executes tools
    │       ├── tools/
    │       │   ├── file_tools.gd
    │       │   ├── scene_tools.gd
    │       │   ├── script_tools.gd
    │       │   └── project_tools.gd
    │       └── ui/
    │           └── status_indicator.gd  # Minimal connection status
    └── project.godot                 # Test project for development
```

---

## Part 5: Implementation Phases

### Phase 1: Skeleton MCP Server

**Goal:** Working MCP server that RAGy can connect to, with mock tools.

**Files to create:**

1. `mcp-server/package.json`:
```json
{
  "name": "godot-mcp-server",
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "ws": "^8.18.0"
  }
}
```

2. `mcp-server/src/index.js`:
- Create MCP server using `@modelcontextprotocol/sdk`
- Register 3 mock tools: `list_dir`, `read_file`, `read_scene`
- Return fake data for testing
- NO WebSocket yet (Phase 2)

**Test:**
1. Add to RAGy's mcp-client.js
2. Start RAGy
3. Ask AI: "List the files in my Godot project"
4. Verify mock response received

---

### Phase 2: WebSocket Bridge

**Goal:** MCP server can communicate with Godot via WebSocket.

**Files to create/modify:**

1. `mcp-server/src/godot-bridge.js`:
```javascript
import { WebSocketServer } from 'ws';

class GodotBridge {
  constructor(port = 6505) {
    this.port = port;
    this.godotConnection = null;
    this.pendingRequests = new Map(); // id -> { resolve, reject, timeout }
  }

  start() {
    this.wss = new WebSocketServer({ port: this.port });
    this.wss.on('connection', (ws) => this.handleConnection(ws));
  }

  handleConnection(ws) {
    this.godotConnection = ws;
    ws.on('message', (data) => this.handleMessage(JSON.parse(data)));
    ws.on('close', () => { this.godotConnection = null; });
  }

  async invokeTool(toolName, args) {
    if (!this.godotConnection) {
      throw new Error('Godot not connected');
    }

    const id = crypto.randomUUID();

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(id);
        reject(new Error('Tool execution timeout'));
      }, 30000);

      this.pendingRequests.set(id, { resolve, reject, timeout });

      this.godotConnection.send(JSON.stringify({
        type: 'tool_invoke',
        id,
        tool: toolName,
        args
      }));
    });
  }

  handleMessage(message) {
    if (message.type === 'tool_result') {
      const pending = this.pendingRequests.get(message.id);
      if (pending) {
        clearTimeout(pending.timeout);
        this.pendingRequests.delete(message.id);
        if (message.success) {
          pending.resolve(message.result);
        } else {
          pending.reject(new Error(message.error));
        }
      }
    }
  }

  isConnected() {
    return this.godotConnection !== null;
  }
}
```

2. Update `mcp-server/src/index.js`:
- Import GodotBridge
- Start WebSocket server on startup
- Route tool calls through bridge (if connected) or return "not connected" error

**Test:**
1. Start MCP server
2. Connect with `wscat -c ws://localhost:6505`
3. Verify connection established
4. Send fake tool_result, verify handling

---

### Phase 3: Minimal Godot Plugin

**Goal:** Godot plugin connects to MCP server via WebSocket.

**Files to create:**

1. `godot-plugin/addons/godot_mcp/plugin.cfg`:
```ini
[plugin]
name="Godot MCP"
description="MCP server integration for AI assistants"
author="Your Name"
version="0.1.0"
script="plugin.gd"
```

2. `godot-plugin/addons/godot_mcp/plugin.gd`:
```gdscript
@tool
extends EditorPlugin

var mcp_client: MCPClient

func _enter_tree():
    mcp_client = MCPClient.new()
    add_child(mcp_client)
    mcp_client.connect_to_server()

func _exit_tree():
    if mcp_client:
        mcp_client.disconnect_from_server()
        mcp_client.queue_free()
```

3. `godot-plugin/addons/godot_mcp/mcp_client.gd`:
```gdscript
extends Node
class_name MCPClient

signal connected
signal disconnected
signal tool_invoked(id: String, tool_name: String, args: Dictionary)

var socket: WebSocketPeer
var server_url := "ws://localhost:6505"
var is_connected := false

func _ready():
    socket = WebSocketPeer.new()

func _process(_delta):
    if socket.get_ready_state() == WebSocketPeer.STATE_OPEN:
        socket.poll()
        while socket.get_available_packet_count() > 0:
            var packet = socket.get_packet()
            _handle_message(packet.get_string_from_utf8())

func connect_to_server():
    var err = socket.connect_to_url(server_url)
    if err != OK:
        push_error("Failed to connect to MCP server")

func _handle_message(json_string: String):
    var message = JSON.parse_string(json_string)
    if message.type == "tool_invoke":
        tool_invoked.emit(message.id, message.tool, message.args)

func send_result(id: String, success: bool, result = null, error: String = ""):
    var response = {
        "type": "tool_result",
        "id": id,
        "success": success
    }
    if success:
        response["result"] = result
    else:
        response["error"] = error
    socket.send_text(JSON.stringify(response))
```

**Test:**
1. Start MCP server
2. Open Godot project with plugin enabled
3. Verify "Connected" in Godot output
4. Verify MCP server logs connection

---

### Phase 4: First Real Tools (File Operations)

**Goal:** Implement file tools end-to-end.

**Tools to implement:**
- `list_dir` - List directory contents
- `read_file` - Read file contents

**MCP Server side (`mcp-server/src/tools/file-tools.js`):**
```javascript
export const fileTools = [
  {
    name: 'list_dir',
    description: 'List files and folders in a Godot project directory',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Directory path (e.g., "res://", "res://scenes/")'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'read_file',
    description: 'Read contents of a file in the Godot project',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'File path (e.g., "res://scripts/player.gd")'
        },
        start_line: {
          type: 'number',
          description: 'Optional start line (1-indexed)'
        },
        end_line: {
          type: 'number',
          description: 'Optional end line (1-indexed)'
        }
      },
      required: ['path']
    }
  }
];
```

**Godot side (`godot-plugin/addons/godot_mcp/tools/file_tools.gd`):**
```gdscript
extends Node
class_name FileTools

func list_dir(args: Dictionary) -> Dictionary:
    var path = args.get("path", "res://")
    var dir = DirAccess.open(path)
    if dir == null:
        return {"error": "Cannot open directory: " + path}

    var files = []
    var folders = []

    dir.list_dir_begin()
    var file_name = dir.get_next()
    while file_name != "":
        if dir.current_is_dir():
            folders.append(file_name)
        else:
            files.append(file_name)
        file_name = dir.get_next()
    dir.list_dir_end()

    return {"files": files, "folders": folders}

func read_file(args: Dictionary) -> Dictionary:
    var path = args.get("path", "")
    if not FileAccess.file_exists(path):
        return {"error": "File not found: " + path}

    var file = FileAccess.open(path, FileAccess.READ)
    var content = file.get_as_text()
    file.close()

    return {"content": content, "path": path}
```

**Test:**
1. Start MCP server
2. Open Godot with plugin
3. In RAGy, ask: "List the files in my Godot project's root directory"
4. Verify real file listing returned

---

### Phase 5: Scene Tools

**Tools to implement:**
- `read_scene` - Parse .tscn file structure
- `create_scene` - Create new scene
- `add_node` - Add node to scene
- `modify_node_property` - Change node property

Reference the old implementations:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/scene_operations/`

---

### Phase 6: Script Tools

**Tools to implement:**
- `create_script` - Create new GDScript
- `apply_diff_preview` - Apply code edits
- `validate_script` - Check syntax

Reference:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/script_operations/`

---

### Phase 7: All Remaining Tools

Port remaining tools from old project:
- Project settings tools
- Debug tools
- Asset tools

---

### Phase 8: RAGy Integration

**Goal:** Add Godot MCP server to RAGy with settings UI.

**Files to modify in RAGy:**

1. `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`:
```javascript
// Add in initialize():
if (settings.godotEnabled) {
  await this.connectToServer('godot', {
    command: 'node',
    args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
  });
}
```

2. Add settings for enabling/disabling Godot tools
3. Add UI indicator for Godot connection status

---

## Part 6: Testing Checklist

### Phase 1 Tests
- [ ] MCP server starts without errors
- [ ] RAGy connects to MCP server
- [ ] Mock tools appear in AI tool list
- [ ] AI can call mock tools and get responses

### Phase 2 Tests
- [ ] WebSocket server starts on port 6505
- [ ] External WebSocket client can connect
- [ ] Messages sent/received correctly
- [ ] Timeout handling works

### Phase 3 Tests
- [ ] Plugin loads in Godot without errors
- [ ] Plugin connects to MCP server
- [ ] Connection status updates correctly
- [ ] Reconnection works after disconnect

### Phase 4 Tests
- [ ] `list_dir` returns real directory contents
- [ ] `read_file` returns real file contents
- [ ] Errors handled gracefully
- [ ] Full flow works: RAGy → AI → MCP → Godot → result

### Phase 5-7 Tests
- [ ] Each tool works individually
- [ ] Complex workflows work (create scene, add nodes, add script)
- [ ] Error handling for all edge cases

### Phase 8 Tests
- [ ] Godot tools can be enabled/disabled in RAGy
- [ ] Connection status shows in RAGy UI
- [ ] Graceful handling when Godot not connected

---

## Part 7: Key Technical Details

### MCP Protocol Basics

MCP uses JSON-RPC over stdio (stdin/stdout). The SDK handles this.

**Tool definition format:**
```javascript
{
  name: 'tool_name',
  description: 'What the tool does',
  inputSchema: {
    type: 'object',
    properties: {
      param1: { type: 'string', description: '...' },
      param2: { type: 'number', description: '...' }
    },
    required: ['param1']
  }
}
```

**Tool result format:**
```javascript
{
  content: [
    { type: 'text', text: 'Result as string or JSON' }
  ]
}
```

### Godot 4.x WebSocket API

```gdscript
var socket = WebSocketPeer.new()
socket.connect_to_url("ws://localhost:6505")

# In _process:
socket.poll()
while socket.get_available_packet_count() > 0:
    var data = socket.get_packet().get_string_from_utf8()
    # Handle data

# Send:
socket.send_text(JSON.stringify(message))
```

### Error Handling Strategy

1. **MCP Server errors:** Return error in content with `isError: true`
2. **Godot not connected:** Return clear error message
3. **Tool execution timeout:** 30 second timeout with clear error
4. **Invalid arguments:** Validate and return specific error

---

## Part 8: Commands Reference

### Development Commands

```bash
# Navigate to project
cd /Users/tomeryud/godot-mcp

# Install MCP server dependencies
cd mcp-server && npm install

# Start MCP server standalone (for testing)
cd mcp-server && npm start

# Test WebSocket connection
npx wscat -c ws://localhost:6505
```

### RAGy Commands

```bash
# Navigate to RAGy
cd /Users/tomeryud/projects/RAGy

# Start RAGy (includes MCP servers)
npm run dev
```

---

## Summary

This project creates a clean, modular bridge between Godot and RAGy:

1. **MCP Server (Node.js):** Speaks MCP to RAGy, WebSocket to Godot
2. **Godot Plugin (GDScript):** Minimal, focused on tool execution
3. **Architecture:** Clean separation, reusable, testable

Follow the phases in order, testing each before moving to the next. Use the old godot-ai-assistant as reference for tool implementations but don't modify it.

Start with Phase 1: Create the skeleton MCP server with mock tools.
</file>

<file path="addon/README.md">
# Godot MCP

**Give your AI assistant full access to the Godot editor.**

Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching. AI reads, writes, and manipulates your scenes, scripts, nodes, and project settings directly.

> Godot 4.x · 32 tools · Interactive project visualizer · MIT license

---

## Quick Start

### 1. Add the MCP server to your AI client

The server is hosted on npm — no cloning or building required.

**Claude Desktop** — edit `~/Library/Application Support/Claude/claude_desktop_config.json`:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**Cursor** — add to MCP settings (Settings → MCP → Add Server):
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

Works with any MCP-compatible client.

### 2. Install the Godot plugin

Copy the `godot-plugin/addons/godot_mcp/` folder into your Godot project's `addons/` directory. Then enable it: Project → Project Settings → Plugins → **Godot MCP** → Enable.

### 3. Restart Godot

Check the **top-right corner** of the editor. You should see **MCP Connected** in green. You're ready to go — start talking to your AI about your game.

---

## What Can It Do?

### 32 Tools Across 6 Categories

| Category | Tools | Examples |
|----------|-------|---------|
| **File Operations** | 4 | Browse directories, read files, search project, create scripts |
| **Scene Operations** | 11 | Create scenes, add/remove/move nodes, set properties, attach scripts, assign collision shapes and textures |
| **Script Operations** | 6 | Apply code edits, validate syntax, rename/move files with reference updates |
| **Project Tools** | 9 | Read project settings, input map, collision layers, console errors, scene tree dumps |
| **Asset Generation** | 4 | Generate 2D sprites from SVG, ComfyUI node search, RunningHub workflow execution |
| **Visualization** | 1 | Interactive browser-based project map |

### Interactive Visualizer

Run `map_project` and get a browser-based explorer at `localhost:6510`:
- Force-directed graph of all scripts and their relationships
- Click any script to see variables, functions, signals, and connections
- Edit code directly in the visualizer — changes sync to Godot in real time
- Scene view with node property editing
- Find usages before refactoring

### What Developers Are Saying AI + Godot Is Missing

| Problem | Godot MCP |
|---------|-----------|
| AI can't see my project — constant copy-pasting | **Solved** — AI reads/writes directly |
| `.tscn` files are unreadable to AI | **Solved** — structured scene tools |
| "What properties does this node have?" | **Solved** — full property discovery |
| Debugging is slow — digging through console | **Solved** — AI reads errors and dumps scene tree |
| Can't see the big picture of my project | **Solved** — interactive visualizer |
| Need placeholder art to prototype | **Solved** — SVG generation + AI art pipelines |
| Refactoring breaks things | **Partially solved** — rename with references + find usages |
| AI hallucinates wrong Godot APIs | **Partially solved** — AI sees your actual project context |

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — runs on localhost, no remote connections
- **Single connection** — one Godot instance at a time
- **Editor only** — works in the editor, not in exported games
- **No undo** — changes save directly (use version control)
- **No runtime control** — can't press play or simulate input
- **AI is still limited in Godot knowledge** — it can't create 100% of the game alone, but it can help debug, write scripts, and tag along for the journey

---

## Full Documentation

See [SUMMARY.md](SUMMARY.md) for the complete tool reference, feature list, and detailed pain point analysis.

---

## Development

To build from source instead of using npm:

```bash
cd mcp-server
npm install
npm run build
```

Then point your AI client at `mcp-server/dist/index.js` instead of using `npx`.

---

## License

MIT

---

**[npm package](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="addon/SUMMARY.md">
# Godot MCP — AI-Powered Godot Development

**Give your AI assistant full access to the Godot editor.** Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching, no friction.

> Works with Godot 4.x · Open source (MIT) · 32 tools · Visual project explorer included

---

## What Is This?

Godot MCP is a bridge between AI assistants and the Godot editor. It lets AI read, write, and manipulate your project directly — scenes, scripts, nodes, assets, settings — all through natural conversation.

```
You ↔ AI Assistant ↔ MCP Server ↔ Godot Editor
         (Claude, Cursor, etc.)    (WebSocket)     (Plugin)
```

Install the Godot plugin, point your AI client at the MCP server, and start building.

---

## Tools (32)

### File Operations (4 tools)
| Tool | What it does |
|------|-------------|
| `list_dir` | Browse project directories (`res://` paths) |
| `read_file` | Read any text file with optional line ranges |
| `search_project` | Full-text search across the project with glob filtering |
| `create_script` | Scaffold new GDScript files |

### Scene Operations (11 tools)
| Tool | What it does |
|------|-------------|
| `create_scene` | Create `.tscn` files with a node hierarchy |
| `read_scene` | Parse and inspect scene structure |
| `add_node` | Add nodes to existing scenes |
| `remove_node` | Remove nodes from scenes |
| `modify_node_property` | Set any node property (transforms, colors, physics, etc.) |
| `rename_node` | Rename nodes |
| `move_node` | Reparent nodes in the scene tree |
| `attach_script` | Attach a GDScript to a node |
| `detach_script` | Remove a script from a node |
| `set_collision_shape` | Assign collision shapes (Circle, Rectangle, Capsule, etc.) |
| `set_sprite_texture` | Assign textures to sprites (image, placeholder, gradient, noise) |

### Script Operations (6 tools)
| Tool | What it does |
|------|-------------|
| `apply_diff_preview` | Apply targeted code edits to GDScript files |
| `validate_script` | Check GDScript syntax without running |
| `list_scripts` | List all `.gd` files in the project |
| `create_folder` | Create directories |
| `delete_file` | Delete files (with safety checks) |
| `rename_file` | Rename/move files with optional reference updates |

### Project Tools (9 tools)
| Tool | What it does |
|------|-------------|
| `get_project_settings` | Read project configuration (window size, renderer, physics) |
| `get_input_map` | Inspect all input actions and their bindings |
| `get_collision_layers` | Read physics collision layer names |
| `get_node_properties` | Discover every property a node type supports |
| `get_console_log` | Read the editor output log |
| `get_errors` | Extract only errors from the console |
| `clear_console_log` | Clear the console |
| `open_in_godot` | Open a file in the editor (jumps to line for scripts) |
| `scene_tree_dump` | Dump the running scene tree for debugging |

### Asset Generation (4 tools)
| Tool | What it does |
|------|-------------|
| `generate_2d_asset` | Generate 2D sprites from SVG code |
| `search_comfyui_nodes` | Search 10,500+ ComfyUI nodes for AI art pipelines |
| `inspect_runninghub_workflow` | Inspect RunningHub workflow parameters |
| `customize_and_run_workflow` | Execute RunningHub workflows for asset generation |

### Visualization (1 tool)
| Tool | What it does |
|------|-------------|
| `map_project` | Build an interactive visual map of your entire project |

---

## Features

### Core
- **Live editor connection** — WebSocket bridge between MCP server and Godot editor. Changes happen in real time.
- **Works with any MCP client** — Claude Desktop, Cursor, RAGy, or anything that speaks MCP.
- **Mock mode** — Test and develop without Godot running.
- **Auto-reconnect** — Plugin reconnects automatically if the connection drops.

### Scene Manipulation
- Create scenes from scratch with full node hierarchies
- Add, remove, rename, move, and reparent nodes
- Set any node property with automatic type parsing (Vector2, Color, etc.)
- Attach/detach scripts, assign collision shapes and textures
- Read and inspect existing scene structures

### Script Intelligence
- Apply surgical code edits with snippet matching
- Validate GDScript syntax before saving
- Full project-wide text search
- Scaffold new scripts from templates
- Rename/move files with reference tracking

### Project Awareness
- AI can read your project settings, input map, and collision layers
- Console log and error access for debugging
- Scene tree dumps of the running game
- Property discovery — AI can look up what properties any node type supports

### Asset Pipeline
- Generate 2D placeholder sprites from SVG descriptions
- ComfyUI node search for AI art workflow building
- RunningHub integration for automated asset generation

### Interactive Visualizer
- **Browser-based project explorer** served at `localhost:6510`
- Force-directed graph of all scripts and their relationships
- Color-coded by folder, searchable, zoomable
- Click any script to inspect variables, functions, signals, and connections
- **Inline editing** — edit variables, function bodies, and signals directly in the visualizer
- **Scene view** — browse scene hierarchies and edit node properties
- **Find usages** — check where a function or variable is used before changing it
- Changes sync back to Godot in real time

---

## Godot Developer Pain Points

| Pain Point | Status | How |
|-----------|--------|-----|
| **"AI can't see my project"** — context switching between AI chat and editor | **Solved** | AI reads/writes your project directly through 32 tools |
| **"Scene files are unreadable"** — `.tscn` is a custom text format AI struggles with | **Solved** | Structured scene tools abstract away the format |
| **"I have to copy-paste code back and forth"** — manual AI workflow | **Solved** | AI edits scripts in-place, validates syntax, and opens files in editor |
| **"I don't know what properties a node has"** — memorizing the API | **Solved** | `get_node_properties` lets AI discover any node's full property list |
| **"Debugging is slow"** — checking console, finding errors | **Solved** | AI reads console logs, extracts errors, dumps the scene tree |
| **"I can't visualize my project structure"** — hard to see the big picture | **Solved** | Interactive visualizer maps scripts, scenes, and their connections |
| **"Setting up input maps / collision layers is tedious"** | **Solved** | AI reads and understands your input map and collision layers |
| **"I need placeholder art to prototype"** | **Solved** | SVG-based 2D asset generation, ComfyUI/RunningHub integration |
| **"Refactoring is scary"** — renaming breaks things | **Partially solved** | File rename with reference updates + find usages in visualizer |
| **"GDScript has no LSP-quality AI support"** | **Partially solved** | Syntax validation + property discovery, but no autocomplete or go-to-definition |
| **"AI generates code for the wrong Godot version"** | **Partially solved** | AI sees your actual project settings and node types, reducing hallucination |
| **"I need AI to playtest / run my game"** | **Not yet** | Scene tree dump works, but no automated play/test/input simulation |
| **"Shader editing is painful"** | **Not yet** | No shader-specific tools (files can be read/written as text) |
| **"Managing exports and builds"** | **Not yet** | No export/build pipeline tools |
| **"Tilemap and level design"** | **Not yet** | No tilemap-specific tools |
| **"Animation editing"** | **Not yet** | No AnimationPlayer/AnimationTree tools |
| **"Version control integration"** | **Not yet** | No built-in git tools (use your AI client's native git support) |
| **"Multi-file refactoring"** | **Not yet** | Single-file edits only; no cross-file rename symbol |

---

## Quick Start

**1. Add the MCP server to your AI client**

No installation needed — the server is on npm. Add to your AI client config:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**2. Install the Godot plugin**
Copy `godot-plugin/addons/godot_mcp/` into your project's `addons/` folder. Enable it in Project → Project Settings → Plugins.

**3. Restart Godot.** Check the top-right corner of the editor — you should see **MCP Connected** in green. You're ready to go.

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — WebSocket runs on localhost, no remote connections or auth
- **Single connection** — One Godot instance at a time
- **Editor only** — Plugin runs in `@tool` mode, not in exported games
- **No undo** — Changes are saved directly (use version control)
- **Regex-based parsing** — Script analysis may miss edge cases in complex GDScript
- **No runtime control** — Can't press play, simulate input, or automate testing
- **All AI is limited in Godot knowledge** - scene editing, GDScript, editing node properties, building and placing UI elements. It cant create 100% of the game alone but it can help debug, write scripts, and tag along for the journey :)
---

## What's Next (maybe)

- Animation tools (AnimationPlayer, tweens)
- Tilemap and level design tools  
- Shader editing support
- Automated playtesting and input simulation
- Multi-file refactoring
- Plugin marketplace / asset library integration
- improvements to current tools

---

## License

MIT — use it however you want.

**[GitHub](https://github.com/tomyud1/godot-mcp)** · **[npm](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="addon/VISUAL_TREE_ROADMAP.md">
# Visual Tree Roadmap

## Completed
- [x] Inline variable/signal editing
- [x] @onready toggle
- [x] Function code editing with syntax highlighting
- [x] Usage detection before delete
- [x] Floating usage panel with navigation
- [x] Right-click context menu
- [x] New script creation
- [x] Draggable/resizable panels
- [x] Scene View tab (Phase 4 - Core)
  - Scene overview with cards showing scene info
  - Click scene → expand to full node hierarchy tree
  - Visual node tree with parent-child connections
  - Sibling order indicators (for 2D draw order)
  - Click node → dynamic properties panel
  - Inline editing of all node properties
  - Property controls: toggles, sliders, vectors, colors, enums
  - Back navigation to scene overview

## In Progress
- [ ] Function deletion with usage check

## Planned

### Phase 2: Visual Connections
- Drag from signal → function to create `.connect()` code
- Visual ports on node edges when hovering

### Phase 3: Script Management
- Right click to add a new node (script)
- Script templates (Node2D, State Machine, Singleton, etc.)
- Delete/rename scripts

### Phase 4: Scene View (Enhancements)
- Drag to reorder siblings (change draw order)
- Right-click context menu on scene nodes (add child, delete, rename)
- Drag scripts onto scene nodes to attach
- Cross-scene signal visualization

### Phase 5: Advanced
- Minimap
- Node grouping
- Full-text search in function bodies
- Refactoring (rename across files)
- Undo/redo
- Git integration (modified files indicator)

### Phase 6: Polish
- Documentation generation
- Dependency analysis (circular deps, unused scripts)
- Code snippets library
</file>

<file path="claude_desktop_config.json">
{
  "mcpServers": {
    "godot": {
      "command": "node",
      "args": ["/Users/tomeryud/godot-mcp/mcp-server/dist/index.js"]
    }
  }
}
</file>

<file path="data/city_map/level_6_1_02.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_1_02",
  "directed": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 7,
  "min_path_examples": [
    ["A", "B", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "nodes": [
    {"id": "A", "label": "A", "pos": {"x": 0.10, "y": 0.50}},
    {"id": "B", "label": "B", "pos": {"x": 0.35, "y": 0.25}},
    {"id": "C", "label": "C", "pos": {"x": 0.35, "y": 0.75}},
    {"id": "D", "label": "D", "pos": {"x": 0.62, "y": 0.75}},
    {"id": "E", "label": "E", "pos": {"x": 0.88, "y": 0.50}}
  ],
  "edges": [
    {"id": "e1", "from": "A", "to": "B", "w": 2},
    {"id": "e2", "from": "A", "to": "C", "w": 4},
    {"id": "e3", "from": "C", "to": "B", "w": 2},
    {"id": "e4", "from": "C", "to": "D", "w": 4},
    {"id": "e5", "from": "B", "to": "E", "w": 5},
    {"id": "e6", "from": "D", "to": "E", "w": 2}
  ],
  "rules": {
    "input_regex": "^[0-9]+$",
    "require_end_node_to_submit": true
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5
  },
  "analytics": {
    "enabled": true
  }
}
</file>

<file path="data/city_map/level_6_1_03.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_1_03",
  "directed": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 7,
  "min_path_examples": [
    ["A", "C", "B", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "nodes": [
    {"id": "A", "label": "A", "pos": {"x": 0.10, "y": 0.50}},
    {"id": "B", "label": "B", "pos": {"x": 0.35, "y": 0.25}},
    {"id": "C", "label": "C", "pos": {"x": 0.35, "y": 0.75}},
    {"id": "D", "label": "D", "pos": {"x": 0.62, "y": 0.75}},
    {"id": "E", "label": "E", "pos": {"x": 0.88, "y": 0.50}}
  ],
  "edges": [
    {"id": "e1", "from": "A", "to": "B", "w": 6},
    {"id": "e2", "from": "A", "to": "C", "w": 2},
    {"id": "e3", "from": "C", "to": "B", "w": 1},
    {"id": "e4", "from": "C", "to": "D", "w": 6},
    {"id": "e5", "from": "B", "to": "E", "w": 4},
    {"id": "e6", "from": "D", "to": "E", "w": 1}
  ],
  "rules": {
    "input_regex": "^[0-9]+$",
    "require_end_node_to_submit": true
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5
  },
  "analytics": {
    "enabled": true
  }
}
</file>

<file path="data/city_map/level_6_2_02.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_2_02",
  "directed_default": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 9,
  "min_path_examples": [
    ["A", "B", "F", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "constraints": {
    "must_visit": ["F"]
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_transit": 25,
    "penalty_cycle": 10,
    "overtime_div": 2
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.50 } },
    { "id": "B", "label": "B", "pos": { "x": 0.25, "y": 0.24 } },
    { "id": "C", "label": "C", "pos": { "x": 0.45, "y": 0.50 } },
    { "id": "D", "label": "D", "pos": { "x": 0.25, "y": 0.76 } },
    { "id": "E", "label": "E", "pos": { "x": 0.82, "y": 0.50 } },
    { "id": "F", "label": "F", "pos": { "x": 0.62, "y": 0.24 } },
    { "id": "G", "label": "G", "pos": { "x": 0.62, "y": 0.76 } },
    { "id": "H", "label": "H", "pos": { "x": 0.92, "y": 0.24 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 3, "two_way": false },
    { "id": "e2", "from": "A", "to": "D", "w": 5, "two_way": false },
    { "id": "e3", "from": "D", "to": "C", "w": 3, "two_way": false },
    { "id": "e4", "from": "B", "to": "C", "w": 5, "two_way": true },
    { "id": "e5", "from": "B", "to": "F", "w": 2, "two_way": false },
    { "id": "e6", "from": "C", "to": "F", "w": 2, "two_way": true },
    { "id": "e7", "from": "C", "to": "G", "w": 4, "two_way": true },
    { "id": "e8", "from": "F", "to": "E", "w": 4, "two_way": false },
    { "id": "e9", "from": "G", "to": "E", "w": 5, "two_way": false },
    { "id": "e10", "from": "D", "to": "G", "w": 7, "two_way": false },
    { "id": "e11", "from": "F", "to": "H", "w": 2, "two_way": false },
    { "id": "e12", "from": "H", "to": "E", "w": 4, "two_way": false }
  ],
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_2"
  }
}
</file>

<file path="data/city_map/level_6_2_03.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_2_03",
  "directed_default": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 7,
  "min_path_examples": [
    ["A", "D", "G", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "constraints": {
    "must_visit": ["G"]
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_transit": 25,
    "penalty_cycle": 10,
    "overtime_div": 2
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.50 } },
    { "id": "B", "label": "B", "pos": { "x": 0.25, "y": 0.24 } },
    { "id": "C", "label": "C", "pos": { "x": 0.45, "y": 0.50 } },
    { "id": "D", "label": "D", "pos": { "x": 0.25, "y": 0.76 } },
    { "id": "E", "label": "E", "pos": { "x": 0.82, "y": 0.50 } },
    { "id": "F", "label": "F", "pos": { "x": 0.62, "y": 0.24 } },
    { "id": "G", "label": "G", "pos": { "x": 0.62, "y": 0.76 } },
    { "id": "H", "label": "H", "pos": { "x": 0.92, "y": 0.24 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 4, "two_way": false },
    { "id": "e2", "from": "A", "to": "D", "w": 2, "two_way": false },
    { "id": "e3", "from": "D", "to": "C", "w": 3, "two_way": false },
    { "id": "e4", "from": "B", "to": "C", "w": 5, "two_way": true },
    { "id": "e5", "from": "B", "to": "F", "w": 6, "two_way": false },
    { "id": "e6", "from": "C", "to": "F", "w": 2, "two_way": true },
    { "id": "e7", "from": "C", "to": "G", "w": 5, "two_way": true },
    { "id": "e8", "from": "F", "to": "E", "w": 3, "two_way": false },
    { "id": "e9", "from": "G", "to": "E", "w": 2, "two_way": false },
    { "id": "e10", "from": "D", "to": "G", "w": 3, "two_way": false },
    { "id": "e11", "from": "F", "to": "H", "w": 2, "two_way": false },
    { "id": "e12", "from": "H", "to": "E", "w": 4, "two_way": false }
  ],
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_2"
  }
}
</file>

<file path="data/city_map/level_6_3_02.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_3_02",
  "time_limit_sec": 140,
  "start_node": "A",
  "end_node": "L",
  "min_sum": 65,
  "min_path_examples": [
    ["A", "B", "C", "G", "K", "L"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.12 } },
    { "id": "B", "label": "B", "pos": { "x": 0.28, "y": 0.12 } },
    { "id": "C", "label": "C", "pos": { "x": 0.48, "y": 0.12 } },
    { "id": "D", "label": "D", "pos": { "x": 0.68, "y": 0.12 } },
    { "id": "E", "label": "E", "pos": { "x": 0.08, "y": 0.45 } },
    { "id": "F", "label": "F", "pos": { "x": 0.28, "y": 0.45 } },
    { "id": "G", "label": "G", "pos": { "x": 0.48, "y": 0.45 } },
    { "id": "H", "label": "H", "pos": { "x": 0.68, "y": 0.45 } },
    { "id": "I", "label": "I", "pos": { "x": 0.18, "y": 0.80 } },
    { "id": "J", "label": "J", "pos": { "x": 0.38, "y": 0.80 } },
    { "id": "K", "label": "K", "pos": { "x": 0.58, "y": 0.80 } },
    { "id": "L", "label": "L", "pos": { "x": 0.82, "y": 0.80 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 10 },
    { "id": "e2", "from": "B", "to": "C", "w": 10 },
    { "id": "e3", "from": "C", "to": "D", "w": 10 },
    { "id": "e4", "from": "A", "to": "E", "w": 15 },
    { "id": "e5", "from": "B", "to": "F", "w": 15 },
    { "id": "e6", "from": "C", "to": "G", "w": 15 },
    { "id": "e7", "from": "D", "to": "H", "w": 15 },
    { "id": "e8", "from": "E", "to": "F", "w": 12 },
    { "id": "e9", "from": "F", "to": "G", "w": 12 },
    { "id": "e10", "from": "G", "to": "H", "w": 12 },
    { "id": "e11", "from": "E", "to": "I", "w": 20 },
    { "id": "e12", "from": "F", "to": "J", "w": 20 },
    { "id": "e13", "from": "G", "to": "K", "w": 20 },
    { "id": "e14", "from": "H", "to": "L", "w": 20 },
    { "id": "e15", "from": "I", "to": "J", "w": 10 },
    { "id": "e16", "from": "J", "to": "K", "w": 10 },
    { "id": "e17", "from": "K", "to": "L", "w": 10 },
    { "id": "e18", "from": "B", "to": "G", "w": 25 },
    { "id": "e19", "from": "F", "to": "C", "w": 25 },
    {
      "id": "e_patrol_1",
      "from": "C",
      "to": "H",
      "w": 12,
      "schedule": [
        { "t_from": 0, "t_to": 45, "w": 12, "state": "open" },
        { "t_from": 45, "t_to": 999, "w": 100, "state": "closed" }
      ],
      "tags": ["patrol"]
    },
    {
      "id": "e_patrol_2",
      "from": "I",
      "to": "L",
      "w": 35,
      "schedule": [
        { "t_from": 0, "t_to": 70, "w": 35, "state": "open" },
        { "t_from": 70, "t_to": 999, "w": 90, "state": "open" }
      ],
      "tags": ["patrol", "close_trap"]
    }
  ],
  "constraints": {
    "must_visit": ["G"],
    "blacklist_nodes": ["F"],
    "xor_groups": [
      { "id": "xor_corridor", "type": "AT_MOST_ONE", "nodes": ["C", "H"] }
    ]
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_logic_violation": 30,
    "ambush_multiplier": 0.5,
    "overtime_div": 2,
    "fail_threshold": 10
  },
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_3"
  }
}
</file>

<file path="data/city_map/level_6_3_03.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_3_03",
  "time_limit_sec": 150,
  "start_node": "A",
  "end_node": "L",
  "min_sum": 60,
  "min_path_examples": [
    ["A", "E", "I", "L"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.12 } },
    { "id": "B", "label": "B", "pos": { "x": 0.28, "y": 0.12 } },
    { "id": "C", "label": "C", "pos": { "x": 0.48, "y": 0.12 } },
    { "id": "D", "label": "D", "pos": { "x": 0.68, "y": 0.12 } },
    { "id": "E", "label": "E", "pos": { "x": 0.08, "y": 0.45 } },
    { "id": "F", "label": "F", "pos": { "x": 0.28, "y": 0.45 } },
    { "id": "G", "label": "G", "pos": { "x": 0.48, "y": 0.45 } },
    { "id": "H", "label": "H", "pos": { "x": 0.68, "y": 0.45 } },
    { "id": "I", "label": "I", "pos": { "x": 0.18, "y": 0.80 } },
    { "id": "J", "label": "J", "pos": { "x": 0.38, "y": 0.80 } },
    { "id": "K", "label": "K", "pos": { "x": 0.58, "y": 0.80 } },
    { "id": "L", "label": "L", "pos": { "x": 0.82, "y": 0.80 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 10 },
    { "id": "e2", "from": "B", "to": "C", "w": 10 },
    { "id": "e3", "from": "C", "to": "D", "w": 10 },
    { "id": "e4", "from": "A", "to": "E", "w": 15 },
    { "id": "e5", "from": "B", "to": "F", "w": 15 },
    { "id": "e6", "from": "C", "to": "G", "w": 15 },
    { "id": "e7", "from": "D", "to": "H", "w": 15 },
    { "id": "e8", "from": "E", "to": "F", "w": 12 },
    { "id": "e9", "from": "F", "to": "G", "w": 12 },
    { "id": "e10", "from": "G", "to": "H", "w": 12 },
    { "id": "e11", "from": "E", "to": "I", "w": 20 },
    { "id": "e12", "from": "F", "to": "J", "w": 20 },
    { "id": "e13", "from": "G", "to": "K", "w": 20 },
    { "id": "e14", "from": "H", "to": "L", "w": 20 },
    { "id": "e15", "from": "I", "to": "J", "w": 10 },
    { "id": "e16", "from": "J", "to": "K", "w": 10 },
    { "id": "e17", "from": "K", "to": "L", "w": 10 },
    { "id": "e18", "from": "B", "to": "G", "w": 25 },
    { "id": "e19", "from": "F", "to": "C", "w": 25 },
    {
      "id": "e_patrol_1",
      "from": "C",
      "to": "H",
      "w": 10,
      "schedule": [
        { "t_from": 0, "t_to": 50, "w": 10, "state": "open" },
        { "t_from": 50, "t_to": 999, "w": 45, "state": "open" }
      ],
      "tags": ["patrol"]
    },
    {
      "id": "e_patrol_2",
      "from": "I",
      "to": "L",
      "w": 25,
      "schedule": [
        { "t_from": 0, "t_to": 60, "w": 25, "state": "open" },
        { "t_from": 60, "t_to": 999, "w": 100, "state": "closed" }
      ],
      "tags": ["patrol", "close_trap"]
    }
  ],
  "constraints": {
    "must_visit": ["E"],
    "blacklist_nodes": ["G"],
    "xor_groups": [
      { "id": "xor_entry", "type": "AT_MOST_ONE", "nodes": ["B", "E"] }
    ]
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_logic_violation": 30,
    "ambush_multiplier": 0.5,
    "overtime_div": 2,
    "fail_threshold": 10
  },
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_3"
  }
}
</file>

<file path="data/matrix_ladder_levels.json">
{
  "levels": [
    {
      "id": "C_LADDER_001",
      "stages": [
        { "size": 2, "base": "DEC", "row_targets": [3, 0] },
        { "size": 3, "base": "DEC", "row_targets": [3, 4, 2] },
        { "size": 4, "base": "OCT", "row_targets": ["13", "14", "02", "16"] },
        { "size": 5, "base": "OCT", "row_targets": ["13", "34", "22", "16", "05"] },
        { "size": 6, "base": "HEX", "row_targets": ["2B", "1C", "32", "0E", "25", "17"] }
      ],
      "options": {
        "lock_previous": true,
        "show_live_row_sum": true,
        "enable_shields": true
      }
    }
  ]
}
</file>

<file path="export_presets.cfg">
[preset.0]

name="Android"
platform="Android"
runnable=true
advanced_options=false
dedicated_server=false
custom_features=""
export_filter="all_resources"
include_filter=""
exclude_filter=""
export_path="../UNTformatic.apk"
encryption_include_filters=""
encryption_exclude_filters=""
encrypt_pck=false
encrypt_directory=false
script_export_mode=2

[preset.0.options]

custom_template/debug=""
custom_template/release=""
gradle_build/use_gradle_build=false
gradle_build/gradle_build_directory=""
gradle_build/android_source_template=""
gradle_build/compress_native_libraries=false
gradle_build/export_format=0
gradle_build/min_sdk=""
gradle_build/target_sdk=""
architectures/armeabi-v7a=false
architectures/arm64-v8a=true
architectures/x86=false
architectures/x86_64=false
version/code=1
version/name=""
package/unique_name="kz.enu.ent_informatics"
package/name=""
package/signed=true
package/app_category=2
package/retain_data_on_uninstall=false
package/exclude_from_recents=false
package/show_in_android_tv=false
package/show_in_app_library=true
package/show_as_launcher_app=false
launcher_icons/main_192x192=""
launcher_icons/adaptive_foreground_432x432=""
launcher_icons/adaptive_background_432x432=""
graphics/opengl_debug=false
xr_features/xr_mode=0
screen/immersive_mode=true
screen/support_small=true
screen/support_normal=true
screen/support_large=true
screen/support_xlarge=true
user_data_backup/allow=false
command_line/extra_args=""
apk_expansion/enable=false
apk_expansion/SALT=""
apk_expansion/public_key=""
permissions/custom_permissions=PackedStringArray()
permissions/access_checkin_properties=false
permissions/access_coarse_location=false
permissions/access_fine_location=false
permissions/access_location_extra_commands=false
permissions/access_mock_location=false
permissions/access_network_state=false
permissions/access_surface_flinger=false
permissions/access_wifi_state=false
permissions/account_manager=false
permissions/add_voicemail=false
permissions/authenticate_accounts=false
permissions/battery_stats=false
permissions/bind_accessibility_service=false
permissions/bind_appwidget=false
permissions/bind_device_admin=false
permissions/bind_input_method=false
permissions/bind_nfc_service=false
permissions/bind_notification_listener_service=false
permissions/bind_print_service=false
permissions/bind_remoteviews=false
permissions/bind_text_service=false
permissions/bind_vpn_service=false
permissions/bind_wallpaper=false
permissions/bluetooth=false
permissions/bluetooth_admin=false
permissions/bluetooth_privileged=false
permissions/brick=false
permissions/broadcast_package_removed=false
permissions/broadcast_sms=false
permissions/broadcast_sticky=false
permissions/broadcast_wap_push=false
permissions/call_phone=false
permissions/call_privileged=false
permissions/camera=false
permissions/capture_audio_output=false
permissions/capture_secure_video_output=false
permissions/capture_video_output=false
permissions/change_component_enabled_state=false
permissions/change_configuration=false
permissions/change_network_state=false
permissions/change_wifi_multicast_state=false
permissions/change_wifi_state=false
permissions/clear_app_cache=false
permissions/clear_app_user_data=false
permissions/control_location_updates=false
permissions/delete_cache_files=false
permissions/delete_packages=false
permissions/device_power=false
permissions/diagnostic=false
permissions/disable_keyguard=false
permissions/dump=false
permissions/expand_status_bar=false
permissions/factory_test=false
permissions/flashlight=false
permissions/force_back=false
permissions/get_accounts=false
permissions/get_package_size=false
permissions/get_tasks=false
permissions/get_top_activity_info=false
permissions/global_search=false
permissions/hardware_test=false
permissions/inject_events=false
permissions/install_location_provider=false
permissions/install_packages=false
permissions/install_shortcut=false
permissions/internal_system_window=false
permissions/internet=false
permissions/kill_background_processes=false
permissions/location_hardware=false
permissions/manage_accounts=false
permissions/manage_app_tokens=false
permissions/manage_documents=false
permissions/manage_external_storage=false
permissions/master_clear=false
permissions/media_content_control=false
permissions/modify_audio_settings=false
permissions/modify_phone_state=false
permissions/mount_format_filesystems=false
permissions/mount_unmount_filesystems=false
permissions/nfc=false
permissions/persistent_activity=false
permissions/post_notifications=false
permissions/process_outgoing_calls=false
permissions/read_calendar=false
permissions/read_call_log=false
permissions/read_contacts=false
permissions/read_external_storage=false
permissions/read_frame_buffer=false
permissions/read_history_bookmarks=false
permissions/read_input_state=false
permissions/read_logs=false
permissions/read_phone_state=false
permissions/read_profile=false
permissions/read_sms=false
permissions/read_social_stream=false
permissions/read_sync_settings=false
permissions/read_sync_stats=false
permissions/read_user_dictionary=false
permissions/reboot=false
permissions/receive_boot_completed=false
permissions/receive_mms=false
permissions/receive_sms=false
permissions/receive_wap_push=false
permissions/record_audio=false
permissions/reorder_tasks=false
permissions/restart_packages=false
permissions/send_respond_via_message=false
permissions/send_sms=false
permissions/set_activity_watcher=false
permissions/set_alarm=false
permissions/set_always_finish=false
permissions/set_animation_scale=false
permissions/set_debug_app=false
permissions/set_orientation=false
permissions/set_pointer_speed=false
permissions/set_preferred_applications=false
permissions/set_process_limit=false
permissions/set_time=false
permissions/set_time_zone=false
permissions/set_wallpaper=false
permissions/set_wallpaper_hints=false
permissions/signal_persistent_processes=false
permissions/status_bar=false
permissions/subscribed_feeds_read=false
permissions/subscribed_feeds_write=false
permissions/system_alert_window=false
permissions/transmit_ir=false
permissions/uninstall_shortcut=false
permissions/update_device_stats=false
permissions/use_credentials=false
permissions/use_sip=false
permissions/vibrate=false
permissions/wake_lock=false
permissions/write_apn_settings=false
permissions/write_calendar=false
permissions/write_call_log=false
permissions/write_contacts=false
permissions/write_external_storage=false
permissions/write_gservices=false
permissions/write_history_bookmarks=false
permissions/write_profile=false
permissions/write_secure_settings=false
permissions/write_settings=false
permissions/write_sms=false
permissions/write_social_stream=false
permissions/write_sync_settings=false
permissions/write_user_dictionary=false
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025-2026 Tomer Yud

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="PROJECT_PLAN.md">
# Godot MCP Server - Complete Project Plan

## Overview

This document contains everything needed to build a **Godot MCP Server** that integrates Godot game engine tools with the RAGy application via the Model Context Protocol (MCP).

**Goal:** Create a clean, modular MCP server that exposes Godot editor functionality (scene manipulation, script editing, file operations) to any MCP-compatible AI client, with RAGy as the primary client.

---

## Project Paths

```
/Users/tomeryud/
├── projects/RAGy/                    # RAGy app (MCP client) - REFERENCE
├── godot-ai-assistant/               # Old Godot app - REFERENCE (do not modify)
└── godot-mcp/                        # NEW PROJECT (build here)
    ├── mcp-server/                   # Node.js MCP server
    └── godot-plugin/                 # Minimal GDScript plugin
```

---

## Part 1: Understanding RAGy (The MCP Client)

### What is RAGy?

RAGy is an Electron desktop app for building RAG (Retrieval-Augmented Generation) systems. It allows users to:
- Upload documents and chunk them
- Generate embeddings and build vector databases
- Chat with AI using RAG context
- Use MCP tools for extended functionality

### RAGy's MCP Architecture

RAGy already has MCP infrastructure. Key files to study:

#### MCP Client Manager
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`

This manages connections to MCP servers. Key code pattern:

```javascript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

class MCPClientManager {
  constructor() {
    this.clients = new Map(); // serverName -> { client, transport }
    this.initialized = false;
  }

  async initialize() {
    // Connect to each MCP server as a child process
    await this.connectToServer('memory', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/memory-server.js')],
    });

    await this.connectToServer('rag', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/rag-server.js')],
    });

    // TODO: Add godot server here
    // await this.connectToServer('godot', {
    //   command: 'node',
    //   args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
    // });
  }

  async connectToServer(serverName, config) {
    const client = new Client({ name: 'ragy-chat-client', version: '1.0.0' }, { capabilities: {} });
    const transport = new StdioClientTransport({ command: config.command, args: config.args });
    await client.connect(transport);
    this.clients.set(serverName, { client, transport, config });
  }

  async getAllTools() {
    // Collects tools from all connected servers
    const allTools = [];
    for (const [serverName, { client }] of this.clients) {
      const response = await client.listTools();
      const toolsWithServer = response.tools.map(tool => ({ ...tool, _mcpServer: serverName }));
      allTools.push(...toolsWithServer);
    }
    return allTools;
  }

  async callTool(toolName, args, serverName) {
    const serverInfo = this.clients.get(serverName);
    return await serverInfo.client.callTool({ name: toolName, arguments: args });
  }
}
```

#### Example MCP Server (RAG Server)
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp-servers/rag-server.js`

This shows the pattern for building MCP servers:

```javascript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';

const server = new Server(
  { name: 'ragy-rag-server', version: '1.0.0' },
  { capabilities: { tools: {} } }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'search_documents',
        description: 'Semantic search across the knowledge base',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: 'Search query' },
            top_k: { type: 'number', description: 'Number of results' }
          },
          required: ['query']
        }
      }
    ]
  };
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === 'search_documents') {
    // Execute the tool and return result
    const results = await doSearch(args.query, args.top_k);
    return {
      content: [{ type: 'text', text: JSON.stringify(results) }]
    };
  }
});

// Start server
const transport = new StdioServerTransport();
await server.connect(transport);
```

#### AI Service with Tools
**Path:** `/Users/tomeryud/projects/RAGy/server/services/ai-with-tools.service.js`

This shows how RAGy uses MCP tools with AI providers. Key points:
- Gets tools via `mcpClientManager.getToolsForOpenAI()` or `getToolsForAnthropic()`
- Sends tools to AI provider
- When AI returns tool_call, executes via `mcpClientManager.callTool()`
- Returns result to AI for final response

### RAGy Tech Stack
- **Frontend:** React 18 + Vite
- **Backend:** Express.js (port 3001)
- **Desktop:** Electron
- **MCP SDK:** `@modelcontextprotocol/sdk`

---

## Part 2: Understanding the Old Godot AI Assistant (Reference)

### What is it?

The old Godot AI Assistant is a standalone app with:
- Express.js server with AI integration (multiple providers)
- React frontend for chat UI
- Godot plugin that polls server for tool invocations
- 33 tools for Godot manipulation

**Important:** Do NOT modify this project. Use it only as reference for tool implementations.

### Key Files to Reference

#### Tool Schemas (Copy tool definitions from here)
**Path:** `/Users/tomeryud/godot-ai-assistant/tool_schemas/`

Files:
- `openaiTools.js` - Tool definitions in OpenAI format
- `geminiTools.js` - Tool definitions in Gemini format
- `anthropicTools.js` - Tool definitions in Anthropic format

These contain the 33+ tool definitions with names, descriptions, and parameter schemas. Convert these to MCP format.

#### Tool Implementations in Godot Plugin
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/`

This contains GDScript implementations for each tool:
- `file_operations/` - read_file, list_dir, search_project
- `scene_operations/` - read_scene, create_scene, add_node, modify_node
- `script_operations/` - create_script, apply_diff_preview

Study these to understand what each tool does and how to implement in the new plugin.

#### Tool Registry (Tool routing logic)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/tool_registry.gd`

Shows how tools are registered and routed to handlers.

#### External App Communicator (HTTP polling - replace with WebSocket)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/external_app_communicator.gd`

This uses HTTP polling (bad). Replace with WebSocket in new implementation.

### Complete Tool List (33 Tools)

**File System (6 tools):**
1. `list_dir` - List files/folders in a directory
2. `read_file` - Read text file contents
3. `search_project` - Regex/substring search across project
4. `list_scripts` - List all GDScript files
5. `create_script` - Create new GDScript file
6. `open_in_godot` - Open file at specific line in editor

**Scene Operations (10 tools):**
7. `scene_tree_dump` - Get current scene tree structure
8. `read_scene` - Parse .tscn file to get node structure
9. `create_scene` - Create new .tscn file with nodes
10. `add_node` - Add node to existing scene
11. `remove_node` - Remove node from scene
12. `rename_node` - Rename a node
13. `move_node` - Reorder node in hierarchy
14. `modify_node_property` - Change node properties
15. `get_node_properties` - Discover properties for node type
16. `set_collision_shape` - Configure collision shape

**Script Operations (4 tools):**
17. `apply_diff_preview` - Apply surgical code edits (1-10 lines)
18. `validate_script` - Check script syntax
19. `attach_script` - Attach script to node
20. `detach_script` - Remove script from node

**Project Configuration (4 tools):**
21. `get_project_settings` - Access window size, physics settings
22. `get_input_map` - Query input actions and bindings
23. `get_collision_layers` - Access collision layer names
24. `get_render_settings` - Graphics/render configuration

**Debugging (3 tools):**
25. `get_console_log` - Access Godot editor output
26. `get_errors` - Get structured error data
27. `clear_console_log` - Clear console

**Asset Operations (3 tools):**
28. `set_sprite_texture` - Set texture on Sprite2D
29. `generate_2d_asset` - Generate 2D graphics
30. `customize_and_run_workflow` - Run asset workflows

**Workflow (3 tools):**
31. `inspect_runninghub_workflow` - Inspect workflows
32. `search_comfyui_nodes` - Search node library
33. `manage_task_list` - Task management

---

## Part 3: New Architecture

### High-Level Design

```
┌─────────────────────────────────────────────────────────────┐
│  RAGy (or any MCP client)                                   │
│      │                                                      │
│      │ stdio (MCP protocol)                                 │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  godot-mcp-server (Node.js)                         │    │
│  │  - Speaks MCP via stdio                             │    │
│  │  - Speaks WebSocket to Godot plugin                 │    │
│  │  - Defines all Godot tools                          │    │
│  │  - Routes tool calls to Godot                       │    │
│  └──────────────────────┬──────────────────────────────┘    │
│                         │                                   │
│                         │ WebSocket (port 6505)             │
│                         │ (bidirectional, real-time)        │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  Godot Plugin (minimal)                             │    │
│  │  - Connects via WebSocket                           │    │
│  │  - Receives tool invocation requests                │    │
│  │  - Executes tools in Godot context                  │    │
│  │  - Returns results immediately                      │    │
│  │  - Shows connection status (minimal UI)             │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### WebSocket Protocol

Messages between MCP server and Godot plugin:

**Tool Invocation (Server → Godot):**
```json
{
  "type": "tool_invoke",
  "id": "unique-request-id",
  "tool": "read_scene",
  "args": {
    "scene_path": "res://scenes/player.tscn"
  }
}
```

**Tool Result (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": true,
  "result": { "nodes": [...] }
}
```

**Error (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": false,
  "error": "Scene file not found"
}
```

**Connection Status:**
```json
{ "type": "ping" }
{ "type": "pong" }
{ "type": "godot_ready", "project_path": "/path/to/project" }
```

---

## Part 4: Directory Structure

```
/Users/tomeryud/godot-mcp/
├── PROJECT_PLAN.md                   # This file
│
├── mcp-server/                       # Node.js MCP server
│   ├── package.json
│   ├── src/
│   │   ├── index.js                  # Main entry point
│   │   ├── godot-bridge.js           # WebSocket connection to Godot
│   │   ├── tools/
│   │   │   ├── index.js              # Exports all tools
│   │   │   ├── file-tools.js         # list_dir, read_file, etc.
│   │   │   ├── scene-tools.js        # read_scene, create_scene, etc.
│   │   │   ├── script-tools.js       # apply_diff, validate_script, etc.
│   │   │   ├── project-tools.js      # get_project_settings, etc.
│   │   │   └── debug-tools.js        # get_console_log, get_errors, etc.
│   │   └── utils/
│   │       └── logger.js             # Logging utility
│   └── README.md
│
└── godot-plugin/                     # Godot 4.x plugin
    ├── addons/
    │   └── godot_mcp/
    │       ├── plugin.cfg            # Plugin configuration
    │       ├── plugin.gd             # Main plugin script
    │       ├── mcp_client.gd         # WebSocket client
    │       ├── tool_executor.gd      # Routes and executes tools
    │       ├── tools/
    │       │   ├── file_tools.gd
    │       │   ├── scene_tools.gd
    │       │   ├── script_tools.gd
    │       │   └── project_tools.gd
    │       └── ui/
    │           └── status_indicator.gd  # Minimal connection status
    └── project.godot                 # Test project for development
```

---

## Part 5: Implementation Phases

### Phase 1: Skeleton MCP Server

**Goal:** Working MCP server that RAGy can connect to, with mock tools.

**Files to create:**

1. `mcp-server/package.json`:
```json
{
  "name": "godot-mcp-server",
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "ws": "^8.18.0"
  }
}
```

2. `mcp-server/src/index.js`:
- Create MCP server using `@modelcontextprotocol/sdk`
- Register 3 mock tools: `list_dir`, `read_file`, `read_scene`
- Return fake data for testing
- NO WebSocket yet (Phase 2)

**Test:**
1. Add to RAGy's mcp-client.js
2. Start RAGy
3. Ask AI: "List the files in my Godot project"
4. Verify mock response received

---

### Phase 2: WebSocket Bridge

**Goal:** MCP server can communicate with Godot via WebSocket.

**Files to create/modify:**

1. `mcp-server/src/godot-bridge.js`:
```javascript
import { WebSocketServer } from 'ws';

class GodotBridge {
  constructor(port = 6505) {
    this.port = port;
    this.godotConnection = null;
    this.pendingRequests = new Map(); // id -> { resolve, reject, timeout }
  }

  start() {
    this.wss = new WebSocketServer({ port: this.port });
    this.wss.on('connection', (ws) => this.handleConnection(ws));
  }

  handleConnection(ws) {
    this.godotConnection = ws;
    ws.on('message', (data) => this.handleMessage(JSON.parse(data)));
    ws.on('close', () => { this.godotConnection = null; });
  }

  async invokeTool(toolName, args) {
    if (!this.godotConnection) {
      throw new Error('Godot not connected');
    }

    const id = crypto.randomUUID();

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(id);
        reject(new Error('Tool execution timeout'));
      }, 30000);

      this.pendingRequests.set(id, { resolve, reject, timeout });

      this.godotConnection.send(JSON.stringify({
        type: 'tool_invoke',
        id,
        tool: toolName,
        args
      }));
    });
  }

  handleMessage(message) {
    if (message.type === 'tool_result') {
      const pending = this.pendingRequests.get(message.id);
      if (pending) {
        clearTimeout(pending.timeout);
        this.pendingRequests.delete(message.id);
        if (message.success) {
          pending.resolve(message.result);
        } else {
          pending.reject(new Error(message.error));
        }
      }
    }
  }

  isConnected() {
    return this.godotConnection !== null;
  }
}
```

2. Update `mcp-server/src/index.js`:
- Import GodotBridge
- Start WebSocket server on startup
- Route tool calls through bridge (if connected) or return "not connected" error

**Test:**
1. Start MCP server
2. Connect with `wscat -c ws://localhost:6505`
3. Verify connection established
4. Send fake tool_result, verify handling

---

### Phase 3: Minimal Godot Plugin

**Goal:** Godot plugin connects to MCP server via WebSocket.

**Files to create:**

1. `godot-plugin/addons/godot_mcp/plugin.cfg`:
```ini
[plugin]
name="Godot MCP"
description="MCP server integration for AI assistants"
author="Your Name"
version="0.1.0"
script="plugin.gd"
```

2. `godot-plugin/addons/godot_mcp/plugin.gd`:
```gdscript
@tool
extends EditorPlugin

var mcp_client: MCPClient

func _enter_tree():
    mcp_client = MCPClient.new()
    add_child(mcp_client)
    mcp_client.connect_to_server()

func _exit_tree():
    if mcp_client:
        mcp_client.disconnect_from_server()
        mcp_client.queue_free()
```

3. `godot-plugin/addons/godot_mcp/mcp_client.gd`:
```gdscript
extends Node
class_name MCPClient

signal connected
signal disconnected
signal tool_invoked(id: String, tool_name: String, args: Dictionary)

var socket: WebSocketPeer
var server_url := "ws://localhost:6505"
var is_connected := false

func _ready():
    socket = WebSocketPeer.new()

func _process(_delta):
    if socket.get_ready_state() == WebSocketPeer.STATE_OPEN:
        socket.poll()
        while socket.get_available_packet_count() > 0:
            var packet = socket.get_packet()
            _handle_message(packet.get_string_from_utf8())

func connect_to_server():
    var err = socket.connect_to_url(server_url)
    if err != OK:
        push_error("Failed to connect to MCP server")

func _handle_message(json_string: String):
    var message = JSON.parse_string(json_string)
    if message.type == "tool_invoke":
        tool_invoked.emit(message.id, message.tool, message.args)

func send_result(id: String, success: bool, result = null, error: String = ""):
    var response = {
        "type": "tool_result",
        "id": id,
        "success": success
    }
    if success:
        response["result"] = result
    else:
        response["error"] = error
    socket.send_text(JSON.stringify(response))
```

**Test:**
1. Start MCP server
2. Open Godot project with plugin enabled
3. Verify "Connected" in Godot output
4. Verify MCP server logs connection

---

### Phase 4: First Real Tools (File Operations)

**Goal:** Implement file tools end-to-end.

**Tools to implement:**
- `list_dir` - List directory contents
- `read_file` - Read file contents

**MCP Server side (`mcp-server/src/tools/file-tools.js`):**
```javascript
export const fileTools = [
  {
    name: 'list_dir',
    description: 'List files and folders in a Godot project directory',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Directory path (e.g., "res://", "res://scenes/")'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'read_file',
    description: 'Read contents of a file in the Godot project',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'File path (e.g., "res://scripts/player.gd")'
        },
        start_line: {
          type: 'number',
          description: 'Optional start line (1-indexed)'
        },
        end_line: {
          type: 'number',
          description: 'Optional end line (1-indexed)'
        }
      },
      required: ['path']
    }
  }
];
```

**Godot side (`godot-plugin/addons/godot_mcp/tools/file_tools.gd`):**
```gdscript
extends Node
class_name FileTools

func list_dir(args: Dictionary) -> Dictionary:
    var path = args.get("path", "res://")
    var dir = DirAccess.open(path)
    if dir == null:
        return {"error": "Cannot open directory: " + path}

    var files = []
    var folders = []

    dir.list_dir_begin()
    var file_name = dir.get_next()
    while file_name != "":
        if dir.current_is_dir():
            folders.append(file_name)
        else:
            files.append(file_name)
        file_name = dir.get_next()
    dir.list_dir_end()

    return {"files": files, "folders": folders}

func read_file(args: Dictionary) -> Dictionary:
    var path = args.get("path", "")
    if not FileAccess.file_exists(path):
        return {"error": "File not found: " + path}

    var file = FileAccess.open(path, FileAccess.READ)
    var content = file.get_as_text()
    file.close()

    return {"content": content, "path": path}
```

**Test:**
1. Start MCP server
2. Open Godot with plugin
3. In RAGy, ask: "List the files in my Godot project's root directory"
4. Verify real file listing returned

---

### Phase 5: Scene Tools

**Tools to implement:**
- `read_scene` - Parse .tscn file structure
- `create_scene` - Create new scene
- `add_node` - Add node to scene
- `modify_node_property` - Change node property

Reference the old implementations:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/scene_operations/`

---

### Phase 6: Script Tools

**Tools to implement:**
- `create_script` - Create new GDScript
- `apply_diff_preview` - Apply code edits
- `validate_script` - Check syntax

Reference:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/script_operations/`

---

### Phase 7: All Remaining Tools

Port remaining tools from old project:
- Project settings tools
- Debug tools
- Asset tools

---

### Phase 8: RAGy Integration

**Goal:** Add Godot MCP server to RAGy with settings UI.

**Files to modify in RAGy:**

1. `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`:
```javascript
// Add in initialize():
if (settings.godotEnabled) {
  await this.connectToServer('godot', {
    command: 'node',
    args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
  });
}
```

2. Add settings for enabling/disabling Godot tools
3. Add UI indicator for Godot connection status

---

## Part 6: Testing Checklist

### Phase 1 Tests
- [ ] MCP server starts without errors
- [ ] RAGy connects to MCP server
- [ ] Mock tools appear in AI tool list
- [ ] AI can call mock tools and get responses

### Phase 2 Tests
- [ ] WebSocket server starts on port 6505
- [ ] External WebSocket client can connect
- [ ] Messages sent/received correctly
- [ ] Timeout handling works

### Phase 3 Tests
- [ ] Plugin loads in Godot without errors
- [ ] Plugin connects to MCP server
- [ ] Connection status updates correctly
- [ ] Reconnection works after disconnect

### Phase 4 Tests
- [ ] `list_dir` returns real directory contents
- [ ] `read_file` returns real file contents
- [ ] Errors handled gracefully
- [ ] Full flow works: RAGy → AI → MCP → Godot → result

### Phase 5-7 Tests
- [ ] Each tool works individually
- [ ] Complex workflows work (create scene, add nodes, add script)
- [ ] Error handling for all edge cases

### Phase 8 Tests
- [ ] Godot tools can be enabled/disabled in RAGy
- [ ] Connection status shows in RAGy UI
- [ ] Graceful handling when Godot not connected

---

## Part 7: Key Technical Details

### MCP Protocol Basics

MCP uses JSON-RPC over stdio (stdin/stdout). The SDK handles this.

**Tool definition format:**
```javascript
{
  name: 'tool_name',
  description: 'What the tool does',
  inputSchema: {
    type: 'object',
    properties: {
      param1: { type: 'string', description: '...' },
      param2: { type: 'number', description: '...' }
    },
    required: ['param1']
  }
}
```

**Tool result format:**
```javascript
{
  content: [
    { type: 'text', text: 'Result as string or JSON' }
  ]
}
```

### Godot 4.x WebSocket API

```gdscript
var socket = WebSocketPeer.new()
socket.connect_to_url("ws://localhost:6505")

# In _process:
socket.poll()
while socket.get_available_packet_count() > 0:
    var data = socket.get_packet().get_string_from_utf8()
    # Handle data

# Send:
socket.send_text(JSON.stringify(message))
```

### Error Handling Strategy

1. **MCP Server errors:** Return error in content with `isError: true`
2. **Godot not connected:** Return clear error message
3. **Tool execution timeout:** 30 second timeout with clear error
4. **Invalid arguments:** Validate and return specific error

---

## Part 8: Commands Reference

### Development Commands

```bash
# Navigate to project
cd /Users/tomeryud/godot-mcp

# Install MCP server dependencies
cd mcp-server && npm install

# Start MCP server standalone (for testing)
cd mcp-server && npm start

# Test WebSocket connection
npx wscat -c ws://localhost:6505
```

### RAGy Commands

```bash
# Navigate to RAGy
cd /Users/tomeryud/projects/RAGy

# Start RAGy (includes MCP servers)
npm run dev
```

---

## Summary

This project creates a clean, modular bridge between Godot and RAGy:

1. **MCP Server (Node.js):** Speaks MCP to RAGy, WebSocket to Godot
2. **Godot Plugin (GDScript):** Minimal, focused on tool execution
3. **Architecture:** Clean separation, reusable, testable

Follow the phases in order, testing each before moving to the next. Use the old godot-ai-assistant as reference for tool implementations but don't modify it.

Start with Phase 1: Create the skeleton MCP server with mock tools.
</file>

<file path="README.md">
# Godot MCP

**Give your AI assistant full access to the Godot editor.**

Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching. AI reads, writes, and manipulates your scenes, scripts, nodes, and project settings directly.

> Godot 4.x · 32 tools · Interactive project visualizer · MIT license

---

## Quick Start

### 1. Add the MCP server to your AI client

The server is hosted on npm — no cloning or building required.

**Claude Desktop** — edit `~/Library/Application Support/Claude/claude_desktop_config.json`:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**Cursor** — add to MCP settings (Settings → MCP → Add Server):
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

Works with any MCP-compatible client.

### 2. Install the Godot plugin

Copy the `godot-plugin/addons/godot_mcp/` folder into your Godot project's `addons/` directory. Then enable it: Project → Project Settings → Plugins → **Godot MCP** → Enable.

### 3. Restart Godot

Check the **top-right corner** of the editor. You should see **MCP Connected** in green. You're ready to go — start talking to your AI about your game.

---

## What Can It Do?

### 32 Tools Across 6 Categories

| Category | Tools | Examples |
|----------|-------|---------|
| **File Operations** | 4 | Browse directories, read files, search project, create scripts |
| **Scene Operations** | 11 | Create scenes, add/remove/move nodes, set properties, attach scripts, assign collision shapes and textures |
| **Script Operations** | 6 | Apply code edits, validate syntax, rename/move files with reference updates |
| **Project Tools** | 9 | Read project settings, input map, collision layers, console errors, scene tree dumps |
| **Asset Generation** | 4 | Generate 2D sprites from SVG, ComfyUI node search, RunningHub workflow execution |
| **Visualization** | 1 | Interactive browser-based project map |

### Interactive Visualizer

Run `map_project` and get a browser-based explorer at `localhost:6510`:
- Force-directed graph of all scripts and their relationships
- Click any script to see variables, functions, signals, and connections
- Edit code directly in the visualizer — changes sync to Godot in real time
- Scene view with node property editing
- Find usages before refactoring

### What Developers Are Saying AI + Godot Is Missing

| Problem | Godot MCP |
|---------|-----------|
| AI can't see my project — constant copy-pasting | **Solved** — AI reads/writes directly |
| `.tscn` files are unreadable to AI | **Solved** — structured scene tools |
| "What properties does this node have?" | **Solved** — full property discovery |
| Debugging is slow — digging through console | **Solved** — AI reads errors and dumps scene tree |
| Can't see the big picture of my project | **Solved** — interactive visualizer |
| Need placeholder art to prototype | **Solved** — SVG generation + AI art pipelines |
| Refactoring breaks things | **Partially solved** — rename with references + find usages |
| AI hallucinates wrong Godot APIs | **Partially solved** — AI sees your actual project context |

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — runs on localhost, no remote connections
- **Single connection** — one Godot instance at a time
- **Editor only** — works in the editor, not in exported games
- **No undo** — changes save directly (use version control)
- **No runtime control** — can't press play or simulate input
- **AI is still limited in Godot knowledge** — it can't create 100% of the game alone, but it can help debug, write scripts, and tag along for the journey

---

## Full Documentation

See [SUMMARY.md](SUMMARY.md) for the complete tool reference, feature list, and detailed pain point analysis.

---

## Development

To build from source instead of using npm:

```bash
cd mcp-server
npm install
npm run build
```

Then point your AI client at `mcp-server/dist/index.js` instead of using `npx`.

---

## License

MIT

---

**[npm package](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="scenes/BitKnob.gd">
extends Control

signal value_changed(new_value: int)

@export var min_value: int = 1
@export var max_value: int = 12
@export var value: int = 1:
	set(v):
		value = clampi(v, min_value, max_value)
		queue_redraw()
@export var min_angle_deg: float = -135.0
@export var max_angle_deg: float = 135.0

var is_dragging: bool = false

func _ready():
	custom_minimum_size = Vector2(220, 220)
	mouse_filter = MOUSE_FILTER_STOP

func _gui_input(event):
	var is_active = false

	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.pressed:
				is_dragging = true
				is_active = true
			else:
				is_dragging = false

	elif event is InputEventScreenTouch:
		if event.pressed:
			is_dragging = true
			is_active = true
		else:
			is_dragging = false

	elif (event is InputEventMouseMotion or event is InputEventScreenDrag) and is_dragging:
		is_active = true

	if is_active:
		_process_input_pos(get_local_mouse_position())

func _process_input_pos(local_pos: Vector2):
	var center = size / 2.0
	var angle = (local_pos - center).angle() # Radians -PI to PI
	var deg = rad_to_deg(angle)

	# Rotate so -90 (up) is 0 for easier calc if needed,
	# but simple clamping to min/max angle range works better standardly.
	# Godot 0 is Right (3 o'clock). -90 is Up. 90 is Down.
	# Our range is typically -135 (South-West) to +135 (South-East) going clockwise via Top.
	# This crosses the -180/180 discontinuity if we go via bottom, but via top (-135 to -180... wait)
	# Let's map typical knob:
	# Min (-135 deg) -> 7-8 o'clock
	# Max (135 deg) -> 4-5 o'clock
	# 0 deg -> 3 o'clock. -90 -> 12 o'clock.
	# The range -135 to +135 is continuous if we treat it as -135...0...+135.
	# But input `angle` returns -180..180.
	# If input is 170 (bottom left), it's outside our range > 135.
	# If input is -170 (bottom left), it's < -135.
	# So simple clamp works for the top hemisphere.

	# Actually, usually knobs have 0 at -90 (Up) or -135 (Start).
	# Let's shift so MinAngle is 0.0 internal progress.

	# Let's just project to closest point in range.
	# Check if angle is in the "dead zone" at the bottom.
	# Dead zone is roughly 135 to 180 and -180 to -135.
	if deg > max_angle_deg and deg < 180:
		deg = max_angle_deg
	elif deg < min_angle_deg and deg > -180:
		deg = min_angle_deg
	elif deg >= 180 or deg <= -180:
		# Bottom center, snap to closest boundary
		if abs(deg - max_angle_deg) < abs(deg - min_angle_deg):
			deg = max_angle_deg
		else:
			deg = min_angle_deg

	# Map deg to value
	var t = (deg - min_angle_deg) / (max_angle_deg - min_angle_deg)
	t = clampf(t, 0.0, 1.0)

	var new_val = roundi(lerp(float(min_value), float(max_value), t))

	if new_val != value:
		value = new_val
		value_changed.emit(value)
		queue_redraw()

func _draw():
	var center = size / 2.0
	var radius = min(size.x, size.y) / 2.0 - 10.0

	# 1. Base/Glow
	draw_circle(center, radius, Color(0.1, 0.1, 0.1, 1.0))
	draw_circle(center, radius * 0.95, Color(0.2, 0.2, 0.2, 1.0))

	# Glow effect (faint rings)
	draw_arc(center, radius * 0.8, 0, TAU, 32, Color(0.2, 1.0, 0.2, 0.05), 4.0)
	draw_arc(center, radius * 0.6, 0, TAU, 32, Color(0.2, 1.0, 0.2, 0.05), 4.0)

	# 2. Ticks
	var total_steps = max_value - min_value
	for i in range(total_steps + 1):
		var t = float(i) / total_steps
		var angle_rad = deg_to_rad(lerp(min_angle_deg, max_angle_deg, t))
		var dir = Vector2.from_angle(angle_rad)
		var p1 = center + dir * (radius - 15)
		var p2 = center + dir * (radius - 5)

		# Highlight active tick
		var val_i = min_value + i
		var color = Color(0.4, 0.4, 0.4)
		var width = 2.0

		if val_i <= value:
			color = Color(0.2, 1.0, 0.2) # Active range
		if val_i == value:
			color = Color(1.0, 1.0, 1.0) # Current value tick
			width = 3.0

		draw_line(p1, p2, color, width, true)

	# 3. Indicator (Needle)
	var t_curr = float(value - min_value) / total_steps
	var angle_curr = deg_to_rad(lerp(min_angle_deg, max_angle_deg, t_curr))
	var dir_curr = Vector2.from_angle(angle_curr)

	draw_line(center, center + dir_curr * (radius - 20), Color(1, 1, 1), 4.0, true)
	draw_circle(center, 8.0, Color(0.8, 0.8, 0.8)) # Pivot cap
</file>

<file path="scenes/TimeKnob.gd">
extends Control

signal value_changed(value: float, delta: float)

@export var min_value: float = 0.0
@export var max_value: float = 30.0
@export var step: float = 0.1
@export var start_angle_deg: float = -225.0
@export var end_angle_deg: float = 45.0
@export var value: float = 0.0

var _dragging: bool = false

func _ready() -> void:
	mouse_filter = Control.MOUSE_FILTER_STOP
	value = _quantize(clampf(value, min_value, max_value))
	queue_redraw()

func _gui_input(event: InputEvent) -> void:
	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			_dragging = true
			_set_value_from_pos(touch_event.position)
		else:
			_dragging = false
	elif event is InputEventScreenDrag:
		if _dragging:
			var drag_event: InputEventScreenDrag = event
			_set_value_from_pos(drag_event.position)
	elif event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT:
			_dragging = mouse_event.pressed
			if mouse_event.pressed:
				_set_value_from_pos(mouse_event.position)
	elif event is InputEventMouseMotion and _dragging:
		var motion_event: InputEventMouseMotion = event
		_set_value_from_pos(motion_event.position)

func _draw() -> void:
	var center: Vector2 = size * 0.5
	var radius: float = minf(size.x, size.y) * 0.42
	if radius <= 2.0:
		return

	var base_color: Color = Color(0.15, 0.15, 0.15, 1.0)
	var active_color: Color = Color(0.2, 0.9, 0.4, 1.0)
	var pointer_color: Color = Color(0.95, 0.95, 0.95, 1.0)

	draw_circle(center, radius, base_color)
	draw_circle(center, radius * 0.82, Color(0.06, 0.06, 0.06, 1.0))

	var start_rad: float = deg_to_rad(start_angle_deg)
	var sweep_rad: float = _get_sweep_rad()
	var current_t: float = _value_to_t(value)

	draw_arc(center, radius * 0.95, start_rad, start_rad + sweep_rad, 64, Color(0.25, 0.25, 0.25, 1.0), 5.0, true)
	draw_arc(center, radius * 0.95, start_rad, start_rad + sweep_rad * current_t, 64, active_color, 6.0, true)

	var marker_angle: float = start_rad + sweep_rad * current_t
	var marker_dir: Vector2 = Vector2(cos(marker_angle), sin(marker_angle))
	var marker_pos: Vector2 = center + marker_dir * radius * 0.70
	draw_circle(marker_pos, radius * 0.10, pointer_color)

func set_knob_value(new_value: float, emit_change: bool = false) -> void:
	var normalized: float = _quantize(clampf(new_value, min_value, max_value))
	if is_equal_approx(normalized, value):
		return

	var delta: float = normalized - value
	value = normalized
	queue_redraw()
	if emit_change:
		value_changed.emit(value, delta)

func _set_value_from_pos(pos: Vector2) -> void:
	var center: Vector2 = size * 0.5
	var local: Vector2 = pos - center
	if local.length() < 4.0:
		return

	var angle: float = atan2(local.y, local.x)
	var t: float = _angle_to_t(angle)
	var new_value: float = min_value + (max_value - min_value) * t
	set_knob_value(new_value, true)

func _get_sweep_rad() -> float:
	var start_rad: float = deg_to_rad(start_angle_deg)
	var end_rad: float = deg_to_rad(end_angle_deg)
	var sweep: float = wrapf(end_rad - start_rad, 0.0, TAU)
	if sweep <= 0.0:
		sweep += TAU
	return sweep

func _angle_to_t(angle: float) -> float:
	var start_rad: float = deg_to_rad(start_angle_deg)
	var sweep: float = _get_sweep_rad()
	var rel: float = wrapf(angle - start_rad, 0.0, TAU)
	var t: float = rel / sweep
	return clampf(t, 0.0, 1.0)

func _value_to_t(current_value: float) -> float:
	if max_value <= min_value:
		return 0.0
	return clampf((current_value - min_value) / (max_value - min_value), 0.0, 1.0)

func _quantize(input_value: float) -> float:
	if step <= 0.0:
		return input_value
	var steps: float = round((input_value - min_value) / step)
	return min_value + steps * step
</file>

<file path="scenes/ui/subnet/BitCell.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/BitCell.gd" id="1_script"]

[node name="BitCell" type="PanelContainer"]
custom_minimum_size = Vector2(50, 50)
mouse_filter = 2
script = ExtResource("1_script")

[node name="LabelValue" type="Label" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
horizontal_alignment = 1
vertical_alignment = 1
text = "-"
</file>

<file path="scenes/ui/subnet/SubnetRuler.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/SubnetRuler.gd" id="1_script"]

[node name="SubnetRuler" type="Control"]
custom_minimum_size = Vector2(0, 132)
size_flags_horizontal = 3
script = ExtResource("1_script")
</file>

<file path="scenes/ui/TagPileZone.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TagPileZone.gd" id="1_script"]

[node name="TagPileZone" type="PanelContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1_script")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="PileTitle" type="Label" parent="VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СКЛАД"

[node name="Scroll" type="ScrollContainer" parent="VBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ItemsGrid" type="GridContainer" parent="VBox/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2
</file>

<file path="scripts/AudioManager.gd">
extends Node

var sounds = {
	"click": load("res://audio/click.wav"),
	"relay": load("res://audio/relay.wav"),
	"error": load("res://audio/error.wav")
}

func play(sound_name: String):
	if sounds.has(sound_name):
		var player = AudioStreamPlayer.new()
		add_child(player)
		player.stream = sounds[sound_name]
		player.play()
		player.finished.connect(player.queue_free)
</file>

<file path="scripts/case_08/fr8_data.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = [
	"id",
	"briefing",
	"format",
	"validator_profile",
	"allowed_containers",
	"slots",
	"fragments",
	"expected_sequence",
	"scoring_model",
	"feedback_rules"
]

const REQUIRED_FRAGMENT_KEYS: Array[String] = ["fragment_id", "label", "kind", "token"]
const REQUIRED_RULE_KEYS: Array[String] = ["code", "min_state", "points", "stability_delta", "verdict_code"]
const REQUIRED_DEFAULT_RULE_KEYS: Array[String] = ["code", "points", "stability_delta", "verdict_code"]
const REQUIRED_FEEDBACK_KEYS: Array[String] = ["UNBALANCED_TAG", "HIERARCHY_VIOLATION", "ORDER_MISMATCH", "OK"]
const SUPPORTED_PROFILES: Array[String] = ["LIST_BASIC", "NAV_MENU", "TABLE_LOG", "FORM_SIMPLE", "ARTICLE_NOTE", "FIGURE_MEDIA"]

static func load_levels(path: String) -> Array:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("FR8Data: failed to open %s" % path)
		return []

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("FR8Data: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return []

	if typeof(json.data) != TYPE_ARRAY:
		push_error("FR8Data: root in %s must be an array" % path)
		return []

	var levels: Array = []
	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_data: Dictionary = level_var as Dictionary
		if validate_level(level_data):
			levels.append(level_data)
		else:
			push_error("FR8Data: invalid level contract: %s" % str(level_data.get("id", "UNKNOWN")))

	return levels

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("FR8Data: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "TAG_ORDERING":
		push_error("FR8Data: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var profile: String = str(level.get("validator_profile", "")).strip_edges().to_upper()
	if not (profile in SUPPORTED_PROFILES):
		push_error("FR8Data: unsupported validator_profile '%s' in level %s" % [profile, str(level.get("id", "UNKNOWN"))])
		return false

	var slots: Array = level.get("slots", []) as Array
	if slots.size() < 5 or slots.size() > 7:
		push_error("FR8Data: level %s must have 5-7 slots" % str(level.get("id", "UNKNOWN")))
		return false

	var slot_ids: Dictionary = {}
	for slot_var in slots:
		var slot_id: String = str(slot_var).strip_edges()
		if slot_id.is_empty() or slot_ids.has(slot_id):
			push_error("FR8Data: duplicate/empty slot id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		slot_ids[slot_id] = true

	var allowed_containers: Array = level.get("allowed_containers", []) as Array
	if allowed_containers.is_empty():
		push_error("FR8Data: level %s has no allowed_containers" % str(level.get("id", "UNKNOWN")))
		return false

	var allowed_map: Dictionary = {}
	for container_var in allowed_containers:
		var container_name: String = str(container_var).strip_edges().to_lower()
		if container_name.is_empty():
			continue
		allowed_map[container_name] = true
	if allowed_map.is_empty():
		push_error("FR8Data: level %s allowed_containers are invalid" % str(level.get("id", "UNKNOWN")))
		return false

	if level.has("allowed_inner_kinds") and typeof(level.get("allowed_inner_kinds")) != TYPE_ARRAY:
		push_error("FR8Data: allowed_inner_kinds must be array in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for req_key in ["required_tags_all", "required_tags_any", "required_kinds_all", "required_kinds_any"]:
		if level.has(req_key) and typeof(level.get(req_key)) != TYPE_ARRAY:
			push_error("FR8Data: %s must be array in level %s" % [req_key, str(level.get("id", "UNKNOWN"))])
			return false

	var fragments: Array = level.get("fragments", []) as Array
	if fragments.is_empty():
		push_error("FR8Data: level %s has empty fragments list" % str(level.get("id", "UNKNOWN")))
		return false

	var fragment_ids: Dictionary = {}
	for fragment_var in fragments:
		if typeof(fragment_var) != TYPE_DICTIONARY:
			push_error("FR8Data: fragment entry must be a dictionary")
			return false
		var fragment: Dictionary = fragment_var as Dictionary
		for key in REQUIRED_FRAGMENT_KEYS:
			if not fragment.has(key):
				push_error("FR8Data: fragment is missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
				return false
		var fragment_id: String = str(fragment.get("fragment_id", "")).strip_edges()
		if fragment_id.is_empty() or fragment_ids.has(fragment_id):
			push_error("FR8Data: duplicate/empty fragment_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		fragment_ids[fragment_id] = true

	var expected_sequence: Array = level.get("expected_sequence", []) as Array
	if expected_sequence.size() != slots.size():
		push_error("FR8Data: expected_sequence length mismatch in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for expected_var in expected_sequence:
		var expected_id: String = str(expected_var).strip_edges()
		if expected_id == "(EMPTY)":
			continue
		if expected_id.is_empty():
			push_error("FR8Data: expected_sequence cannot contain empty ids (use '(EMPTY)') in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not fragment_ids.has(expected_id):
			push_error("FR8Data: expected fragment '%s' missing in level %s" % [expected_id, str(level.get("id", "UNKNOWN"))])
			return false

	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = scoring_model.get("rules", []) as Array
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	if rules.is_empty() or default_rule.is_empty():
		push_error("FR8Data: scoring_model is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for rule_var in rules:
		if typeof(rule_var) != TYPE_DICTIONARY:
			push_error("FR8Data: scoring rule must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var rule: Dictionary = rule_var as Dictionary
		for rule_key in REQUIRED_RULE_KEYS:
			if not rule.has(rule_key):
				push_error("FR8Data: scoring rule key '%s' is missing in level %s" % [rule_key, str(level.get("id", "UNKNOWN"))])
				return false
		var min_state: String = str(rule.get("min_state", "")).to_upper()
		if not (min_state in ["ORDER_OK", "SYNTAX_OK", "FAIL", "ANY"]):
			push_error("FR8Data: unsupported min_state '%s' in level %s" % [min_state, str(level.get("id", "UNKNOWN"))])
			return false

	for default_key in REQUIRED_DEFAULT_RULE_KEYS:
		if not default_rule.has(default_key):
			push_error("FR8Data: default_rule key '%s' is missing in level %s" % [default_key, str(level.get("id", "UNKNOWN"))])
			return false

	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	for feedback_key in REQUIRED_FEEDBACK_KEYS:
		if not feedback_rules.has(feedback_key):
			push_error("FR8Data: feedback rule '%s' missing in level %s" % [feedback_key, str(level.get("id", "UNKNOWN"))])
			return false

	return true
</file>

<file path="scripts/case_08/fr8_scoring.gd">
extends RefCounted

const PROFILE_LIST_BASIC := "LIST_BASIC"
const PROFILE_NAV_MENU := "NAV_MENU"
const PROFILE_TABLE_LOG := "TABLE_LOG"
const PROFILE_FORM_SIMPLE := "FORM_SIMPLE"
const PROFILE_ARTICLE_NOTE := "ARTICLE_NOTE"
const PROFILE_FIGURE_MEDIA := "FIGURE_MEDIA"

const STATE_INCOMPLETE := "INCOMPLETE"
const STATE_ORDER_OK := "ORDER_OK"
const STATE_SYNTAX_OK := "SYNTAX_OK"
const STATE_FAIL := "FAIL"

const ERROR_INCOMPLETE := "INCOMPLETE"
const ERROR_UNBALANCED := "UNBALANCED_TAG"
const ERROR_HIERARCHY := "HIERARCHY_VIOLATION"
const ERROR_REQUIRED := "REQUIRED_TAG_MISSING"
const ERROR_ORDER := "ORDER_MISMATCH"
const ERROR_OK := "OK"

static func normalize_expected_sequence(level: Dictionary) -> Array[String]:
	var raw_expected: Array = level.get("expected_sequence", []) as Array
	var normalized: Array[String] = []
	for expected_var in raw_expected:
		var expected_id: String = str(expected_var).strip_edges()
		normalized.append("" if expected_id == "(EMPTY)" else expected_id)
	return normalized

static func evaluate(level: Dictionary, sequence: Array, fragment_by_id: Dictionary) -> Dictionary:
	var expected_sequence: Array[String] = normalize_expected_sequence(level)
	var checks: Dictionary = {
		"container_ok": false,
		"hierarchy_ok": false,
		"required_ok": false,
		"order_ok": false
	}

	if _is_incomplete(sequence, expected_sequence):
		return {
			"state": STATE_INCOMPLETE,
			"error_code": ERROR_INCOMPLETE,
			"incomplete": true,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}

	var first_index: int = -1
	var last_index: int = -1
	for i in range(sequence.size()):
		var fragment_id: String = str(sequence[i]).strip_edges()
		if fragment_id.is_empty():
			continue
		if first_index < 0:
			first_index = i
		last_index = i

	if first_index < 0 or last_index <= first_index:
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_UNBALANCED,
			"incomplete": false,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}

	var profile: String = str(level.get("validator_profile", PROFILE_LIST_BASIC)).to_upper()

	var open_id: String = str(sequence[first_index]).strip_edges()
	var close_id: String = str(sequence[last_index]).strip_edges()
	var open_kind: String = _fragment_kind(fragment_by_id, open_id)
	var close_kind: String = _fragment_kind(fragment_by_id, close_id)
	if open_kind != "CONTAINER_OPEN" or close_kind != "CONTAINER_CLOSE":
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_UNBALANCED,
			"incomplete": false,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}

	var allowed_containers: Dictionary = {}
	for container_var in level.get("allowed_containers", []) as Array:
		allowed_containers[str(container_var).strip_edges().to_lower()] = true

	var open_tag: String = _container_tag(fragment_by_id, open_id)
	var close_tag: String = _container_tag(fragment_by_id, close_id)
	if open_tag.is_empty() or close_tag.is_empty() or open_tag != close_tag or not allowed_containers.has(open_tag):
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_UNBALANCED,
			"incomplete": false,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}
	checks["container_ok"] = true

	var allowed_inner_kinds: Dictionary = _allowed_inner_kind_map(level, profile)
	var inner_fragment_ids: Array[String] = []
	for i in range(first_index + 1, last_index):
		var inner_id: String = str(sequence[i]).strip_edges()
		if inner_id.is_empty():
			return {
				"state": STATE_FAIL,
				"error_code": ERROR_HIERARCHY,
				"incomplete": false,
				"checks": checks,
				"container_ok": true,
				"hierarchy_ok": false,
				"order_ok": false
			}
		inner_fragment_ids.append(inner_id)
		var inner_kind: String = _fragment_kind(fragment_by_id, inner_id)
		if not allowed_inner_kinds.has(inner_kind):
			return {
				"state": STATE_FAIL,
				"error_code": ERROR_HIERARCHY,
				"incomplete": false,
				"checks": checks,
				"container_ok": true,
				"hierarchy_ok": false,
				"order_ok": false
			}
	checks["hierarchy_ok"] = true

	var required_result: Dictionary = _check_required(level, profile, inner_fragment_ids, fragment_by_id)
	if not bool(required_result.get("ok", false)):
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_REQUIRED,
			"incomplete": false,
			"checks": checks,
			"container_ok": true,
			"hierarchy_ok": true,
			"order_ok": false
		}
	checks["required_ok"] = true

	var order_ok: bool = _sequence_equals_expected(sequence, expected_sequence)
	checks["order_ok"] = order_ok

	if order_ok:
		return {
			"state": STATE_ORDER_OK,
			"error_code": ERROR_OK,
			"incomplete": false,
			"checks": checks,
			"container_ok": true,
			"hierarchy_ok": true,
			"order_ok": true
		}

	return {
		"state": STATE_SYNTAX_OK,
		"error_code": ERROR_ORDER,
		"incomplete": false,
		"checks": checks,
		"container_ok": true,
		"hierarchy_ok": true,
		"order_ok": false
	}

static func resolve_score(level: Dictionary, evaluation: Dictionary) -> Dictionary:
	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = scoring_model.get("rules", []) as Array
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	var state: String = str(evaluation.get("state", STATE_FAIL))
	var incomplete: bool = bool(evaluation.get("incomplete", false))

	var max_points: int = 0
	for rule_var in rules:
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule_data: Dictionary = rule_var as Dictionary
		max_points = max(max_points, int(rule_data.get("points", 0)))

	var selected_rule: Dictionary = {}
	if incomplete:
		selected_rule = default_rule
	else:
		for rule_var in rules:
			if typeof(rule_var) != TYPE_DICTIONARY:
				continue
			var rule: Dictionary = rule_var as Dictionary
			var min_state: String = str(rule.get("min_state", "ANY")).to_upper()
			if _state_matches(state, min_state):
				selected_rule = rule
				break

	if selected_rule.is_empty():
		selected_rule = {
			"code": "FALLBACK",
			"points": 0,
			"stability_delta": -30,
			"verdict_code": "FAIL"
		}

	var is_fit: bool = false
	var is_correct: bool = false
	if not incomplete:
		if state == STATE_ORDER_OK:
			is_fit = true
			is_correct = true
		elif state == STATE_SYNTAX_OK:
			is_fit = true

	return {
		"rule_code": str(selected_rule.get("code", "SCORING_RULE")),
		"points": int(selected_rule.get("points", 0)),
		"max_points": max_points,
		"stability_delta": int(selected_rule.get("stability_delta", -30)),
		"verdict_code": str(selected_rule.get("verdict_code", "FAIL")),
		"is_fit": is_fit,
		"is_correct": is_correct
	}

static func feedback_text(level: Dictionary, evaluation: Dictionary) -> String:
	if bool(evaluation.get("incomplete", false)):
		return "Не все фрагменты вставлены"

	var error_code: String = str(evaluation.get("error_code", ERROR_ORDER))
	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	if feedback_rules.has(error_code):
		return str(feedback_rules.get(error_code, ""))
	if feedback_rules.has("OK"):
		return str(feedback_rules.get("OK", ""))
	return "Проверка завершена."

static func _is_incomplete(sequence: Array, expected_sequence: Array[String]) -> bool:
	if sequence.size() != expected_sequence.size():
		return true
	for i in range(sequence.size()):
		var actual_id: String = str(sequence[i]).strip_edges()
		var expected_id: String = expected_sequence[i]
		if actual_id.is_empty() and not expected_id.is_empty():
			return true
	return false

static func _allowed_inner_kind_map(level: Dictionary, profile: String) -> Dictionary:
	var base_kinds: Array[String] = []
	match profile:
		PROFILE_LIST_BASIC:
			base_kinds = ["LI_ITEM"]
		PROFILE_NAV_MENU:
			base_kinds = ["LINK", "LI_ITEM", "TEXT_BLOCK", "NAV_LIST_OPEN", "NAV_LIST_CLOSE"]
		PROFILE_TABLE_LOG:
			base_kinds = ["TR_ROW"]
		PROFILE_FORM_SIMPLE:
			base_kinds = ["FORM_FIELD", "BUTTON", "TEXT_BLOCK"]
		PROFILE_ARTICLE_NOTE:
			base_kinds = ["TEXT_BLOCK"]
		PROFILE_FIGURE_MEDIA:
			base_kinds = ["MEDIA", "TEXT_BLOCK"]
		_:
			base_kinds = ["LI_ITEM"]

	for kind_var in level.get("allowed_inner_kinds", []) as Array:
		var kind_name: String = str(kind_var).strip_edges().to_upper()
		if kind_name.is_empty():
			continue
		if not (kind_name in base_kinds):
			base_kinds.append(kind_name)

	var out: Dictionary = {}
	for kind_name in base_kinds:
		out[kind_name] = true
	return out

static func _check_required(level: Dictionary, profile: String, inner_fragment_ids: Array[String], fragment_by_id: Dictionary) -> Dictionary:
	var required_tags_all: Array[String] = _to_lower_str_array(level.get("required_tags_all", []))
	var required_tags_any: Array[String] = _to_lower_str_array(level.get("required_tags_any", []))
	var required_kinds_all: Array[String] = _to_upper_str_array(level.get("required_kinds_all", []))
	var required_kinds_any: Array[String] = _to_upper_str_array(level.get("required_kinds_any", []))

	if profile == PROFILE_NAV_MENU and required_tags_any.is_empty():
		required_tags_any.append("a")
	if profile == PROFILE_FORM_SIMPLE and required_tags_all.is_empty():
		required_tags_all.append_array(["input", "button"])
	if profile == PROFILE_FIGURE_MEDIA and required_tags_all.is_empty():
		required_tags_all.append_array(["img", "figcaption"])

	var inner_kind_map: Dictionary = {}
	var inner_tag_map: Dictionary = {}
	for fragment_id in inner_fragment_ids:
		var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
		var kind_name: String = str(fragment_data.get("kind", "")).to_upper()
		if not kind_name.is_empty():
			inner_kind_map[kind_name] = true

		var token: String = str(fragment_data.get("token", ""))
		for tag_name in _extract_tag_names(token):
			inner_tag_map[tag_name] = true

	for tag_name in required_tags_all:
		if not inner_tag_map.has(tag_name):
			return {"ok": false}
	if not required_tags_any.is_empty():
		var any_tag_found: bool = false
		for tag_name in required_tags_any:
			if inner_tag_map.has(tag_name):
				any_tag_found = true
				break
		if not any_tag_found:
			return {"ok": false}

	for kind_name in required_kinds_all:
		if not inner_kind_map.has(kind_name):
			return {"ok": false}
	if not required_kinds_any.is_empty():
		var any_kind_found: bool = false
		for kind_name in required_kinds_any:
			if inner_kind_map.has(kind_name):
				any_kind_found = true
				break
		if not any_kind_found:
			return {"ok": false}

	return {"ok": true}

static func _to_lower_str_array(raw: Variant) -> Array[String]:
	var out: Array[String] = []
	if typeof(raw) != TYPE_ARRAY:
		return out
	var raw_array: Array = raw as Array
	for item in raw_array:
		var value: String = str(item).strip_edges().to_lower()
		if value.is_empty():
			continue
		if not (value in out):
			out.append(value)
	return out

static func _to_upper_str_array(raw: Variant) -> Array[String]:
	var out: Array[String] = []
	if typeof(raw) != TYPE_ARRAY:
		return out
	var raw_array: Array = raw as Array
	for item in raw_array:
		var value: String = str(item).strip_edges().to_upper()
		if value.is_empty():
			continue
		if not (value in out):
			out.append(value)
	return out

static func _extract_tag_names(token: String) -> Array[String]:
	var out: Array[String] = []
	var lower_token: String = token.to_lower()
	var cursor: int = 0
	while true:
		var start_idx: int = lower_token.find("<", cursor)
		if start_idx < 0:
			break
		var end_idx: int = lower_token.find(">", start_idx + 1)
		if end_idx < 0:
			break

		var segment: String = lower_token.substr(start_idx + 1, end_idx - start_idx - 1).strip_edges()
		if segment.begins_with("/"):
			segment = segment.substr(1).strip_edges()
		if segment.begins_with("!"):
			cursor = end_idx + 1
			continue

		var space_idx: int = segment.find(" ")
		var slash_idx: int = segment.find("/")
		var cut_idx: int = segment.length()
		if space_idx >= 0:
			cut_idx = min(cut_idx, space_idx)
		if slash_idx >= 0:
			cut_idx = min(cut_idx, slash_idx)
		var tag_name: String = segment.substr(0, cut_idx).strip_edges()
		if not tag_name.is_empty() and not (tag_name in out):
			out.append(tag_name)

		cursor = end_idx + 1
	return out

static func _fragment_kind(fragment_by_id: Dictionary, fragment_id: String) -> String:
	if not fragment_by_id.has(fragment_id):
		return ""
	var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
	return str(fragment_data.get("kind", "")).to_upper()

static func _container_tag(fragment_by_id: Dictionary, fragment_id: String) -> String:
	if not fragment_by_id.has(fragment_id):
		return ""
	var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
	var token: String = str(fragment_data.get("token", "")).strip_edges().to_lower()
	var tags: Array[String] = _extract_tag_names(token)
	if tags.is_empty():
		return ""
	return tags[0]

static func _sequence_equals_expected(sequence: Array, expected_sequence: Array[String]) -> bool:
	if sequence.size() != expected_sequence.size():
		return false
	for i in range(sequence.size()):
		if str(sequence[i]).strip_edges() != expected_sequence[i]:
			return false
	return true

static func _state_matches(state: String, min_state: String) -> bool:
	match min_state:
		"ORDER_OK":
			return state == STATE_ORDER_OK
		"SYNTAX_OK":
			return state == STATE_SYNTAX_OK or state == STATE_ORDER_OK
		"FAIL":
			return state == STATE_FAIL
		"ANY":
			return true
		_:
			return false
</file>

<file path="scripts/case_08/fr8b_data.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = [
	"id",
	"briefing",
	"format",
	"cards",
	"dependencies",
	"expected_order",
	"feedback_rules",
	"scoring_model",
	"anti_cheat"
]

const REQUIRED_CARD_KEYS: Array[String] = ["stage_id", "title", "hint"]
const REQUIRED_DEP_KEYS: Array[String] = ["a", "b", "code"]
const REQUIRED_FEEDBACK_KEYS: Array[String] = ["LOGIC_GAP", "CAUSALITY_LOOP", "ORDER_MISMATCH", "OK"]
const REQUIRED_SCORE_KEYS: Array[String] = ["points", "stability_delta", "verdict_code"]
const ALLOWED_DEP_CODES: Array[String] = ["LOGIC_GAP", "CAUSALITY_LOOP"]

static func load_levels(path: String) -> Array:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("FR8BData: failed to open %s" % path)
		return []

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("FR8BData: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return []

	if typeof(json.data) != TYPE_ARRAY:
		push_error("FR8BData: root in %s must be an array" % path)
		return []

	var levels: Array = []
	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_data: Dictionary = level_var as Dictionary
		if validate_level(level_data):
			levels.append(level_data)
		else:
			push_error("FR8BData: invalid level contract: %s" % str(level_data.get("id", "UNKNOWN")))

	return levels

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("FR8BData: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "TIMELINE_SORT":
		push_error("FR8BData: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var cards_var: Variant = level.get("cards", [])
	if typeof(cards_var) != TYPE_ARRAY:
		push_error("FR8BData: cards must be an array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var cards: Array = cards_var as Array
	if cards.size() < 4 or cards.size() > 7:
		push_error("FR8BData: level %s must have 4-7 cards" % str(level.get("id", "UNKNOWN")))
		return false

	var stage_ids: Dictionary = {}
	for card_var in cards:
		if typeof(card_var) != TYPE_DICTIONARY:
			push_error("FR8BData: card entry must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var card: Dictionary = card_var as Dictionary
		for card_key in REQUIRED_CARD_KEYS:
			if not card.has(card_key):
				push_error("FR8BData: card missing key '%s' in level %s" % [card_key, str(level.get("id", "UNKNOWN"))])
				return false
		var stage_id: String = str(card.get("stage_id", "")).strip_edges()
		if stage_id.is_empty() or stage_ids.has(stage_id):
			push_error("FR8BData: duplicate/empty stage_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		stage_ids[stage_id] = true

	var expected_var: Variant = level.get("expected_order", [])
	if typeof(expected_var) != TYPE_ARRAY:
		push_error("FR8BData: expected_order must be an array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var expected_order: Array = expected_var as Array
	if expected_order.size() != cards.size():
		push_error("FR8BData: expected_order length mismatch in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var expected_seen: Dictionary = {}
	for stage_var in expected_order:
		var stage_id: String = str(stage_var).strip_edges()
		if stage_id.is_empty() or expected_seen.has(stage_id):
			push_error("FR8BData: duplicate/empty expected_order value in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not stage_ids.has(stage_id):
			push_error("FR8BData: unknown stage_id '%s' in expected_order (%s)" % [stage_id, str(level.get("id", "UNKNOWN"))])
			return false
		expected_seen[stage_id] = true

	var deps_var: Variant = level.get("dependencies", [])
	if typeof(deps_var) != TYPE_ARRAY:
		push_error("FR8BData: dependencies must be an array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var deps: Array = deps_var as Array
	if deps.is_empty():
		push_error("FR8BData: dependencies cannot be empty in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for dep_var in deps:
		if typeof(dep_var) != TYPE_DICTIONARY:
			push_error("FR8BData: dependency must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var dep: Dictionary = dep_var as Dictionary
		for dep_key in REQUIRED_DEP_KEYS:
			if not dep.has(dep_key):
				push_error("FR8BData: dependency missing key '%s' in level %s" % [dep_key, str(level.get("id", "UNKNOWN"))])
				return false
		var a: String = str(dep.get("a", "")).strip_edges()
		var b: String = str(dep.get("b", "")).strip_edges()
		if a.is_empty() or b.is_empty() or a == b:
			push_error("FR8BData: invalid dependency endpoints in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not stage_ids.has(a) or not stage_ids.has(b):
			push_error("FR8BData: dependency uses unknown stage_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var dep_code: String = str(dep.get("code", "")).to_upper()
		if not (dep_code in ALLOWED_DEP_CODES):
			push_error("FR8BData: unsupported dependency code '%s' in level %s" % [dep_code, str(level.get("id", "UNKNOWN"))])
			return false

	var feedback_var: Variant = level.get("feedback_rules", {})
	if typeof(feedback_var) != TYPE_DICTIONARY:
		push_error("FR8BData: feedback_rules must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var feedback_rules: Dictionary = feedback_var as Dictionary
	for feedback_key in REQUIRED_FEEDBACK_KEYS:
		if not feedback_rules.has(feedback_key):
			push_error("FR8BData: feedback rule '%s' missing in level %s" % [feedback_key, str(level.get("id", "UNKNOWN"))])
			return false

	var scoring_var: Variant = level.get("scoring_model", {})
	if typeof(scoring_var) != TYPE_DICTIONARY:
		push_error("FR8BData: scoring_model must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var scoring_model: Dictionary = scoring_var as Dictionary
	if not scoring_model.has("perfect") or not scoring_model.has("fail"):
		push_error("FR8BData: scoring_model must contain perfect/fail in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for score_key in ["perfect", "fail"]:
		var score_rule_var: Variant = scoring_model.get(score_key, {})
		if typeof(score_rule_var) != TYPE_DICTIONARY:
			push_error("FR8BData: scoring_model.%s must be dictionary in level %s" % [score_key, str(level.get("id", "UNKNOWN"))])
			return false
		var score_rule: Dictionary = score_rule_var as Dictionary
		for rule_key in REQUIRED_SCORE_KEYS:
			if not score_rule.has(rule_key):
				push_error("FR8BData: scoring_model.%s missing key '%s' in level %s" % [score_key, rule_key, str(level.get("id", "UNKNOWN"))])
				return false

	var anti_cheat_var: Variant = level.get("anti_cheat", {})
	if typeof(anti_cheat_var) != TYPE_DICTIONARY:
		push_error("FR8BData: anti_cheat must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var anti_cheat: Dictionary = anti_cheat_var as Dictionary
	if anti_cheat.has("shuffle_cards") and typeof(anti_cheat.get("shuffle_cards", false)) != TYPE_BOOL:
		push_error("FR8BData: anti_cheat.shuffle_cards must be bool in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	return true
</file>

<file path="scripts/case_08/fr8b_scoring.gd">
extends RefCounted

const STATE_ORDER_OK := "ORDER_OK"
const STATE_FAIL := "FAIL"

const ERROR_LOGIC_GAP := "LOGIC_GAP"
const ERROR_CAUSALITY_LOOP := "CAUSALITY_LOOP"
const ERROR_ORDER_MISMATCH := "ORDER_MISMATCH"
const ERROR_OK := "OK"

static func evaluate(level: Dictionary, current_order: Array[String]) -> Dictionary:
	var normalized_order: Array[String] = []
	for stage_id in current_order:
		normalized_order.append(str(stage_id).strip_edges())

	var expected_order: Array[String] = _normalized_array(level.get("expected_order", []))
	var positions: Dictionary = {}
	for i in range(normalized_order.size()):
		var stage_id: String = normalized_order[i]
		if stage_id.is_empty():
			continue
		positions[stage_id] = i

	var violations: Array = []
	for dep_var in level.get("dependencies", []) as Array:
		if typeof(dep_var) != TYPE_DICTIONARY:
			continue
		var dep: Dictionary = dep_var as Dictionary
		var a: String = str(dep.get("a", "")).strip_edges()
		var b: String = str(dep.get("b", "")).strip_edges()
		if a.is_empty() or b.is_empty():
			continue

		var broken: bool = false
		if not positions.has(a) or not positions.has(b):
			broken = true
		elif int(positions[a]) >= int(positions[b]):
			broken = true

		if broken:
			violations.append({
				"a": a,
				"b": b,
				"code": str(dep.get("code", ERROR_LOGIC_GAP)).to_upper(),
				"message": str(dep.get("message", ""))
			})

	if not violations.is_empty():
		var top_error: String = _pick_top_error(violations)
		var top_violation: Dictionary = _pick_top_violation(violations, top_error)
		return {
			"state": STATE_FAIL,
			"error_code": top_error,
			"violations": violations,
			"top_violation": top_violation,
			"order_ok": false
		}

	var order_ok: bool = _arrays_equal(normalized_order, expected_order)
	if order_ok:
		return {
			"state": STATE_ORDER_OK,
			"error_code": ERROR_OK,
			"violations": [],
			"top_violation": {},
			"order_ok": true
		}

	return {
		"state": STATE_FAIL,
		"error_code": ERROR_ORDER_MISMATCH,
		"violations": [],
		"top_violation": {},
		"order_ok": false
	}

static func resolve_score(level: Dictionary, evaluation: Dictionary) -> Dictionary:
	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var perfect_rule: Dictionary = scoring_model.get("perfect", {
		"points": 2,
		"stability_delta": 0,
		"verdict_code": "PERFECT"
	}) as Dictionary
	var fail_rule: Dictionary = scoring_model.get("fail", {
		"points": 0,
		"stability_delta": -25,
		"verdict_code": "FAIL"
	}) as Dictionary

	var is_order_ok: bool = str(evaluation.get("state", STATE_FAIL)) == STATE_ORDER_OK
	var selected: Dictionary = perfect_rule if is_order_ok else fail_rule
	var max_points: int = max(int(perfect_rule.get("points", 2)), int(fail_rule.get("points", 0)))

	return {
		"points": int(selected.get("points", 0)),
		"max_points": max_points,
		"stability_delta": int(selected.get("stability_delta", -25)),
		"verdict_code": str(selected.get("verdict_code", "FAIL")),
		"is_fit": is_order_ok,
		"is_correct": is_order_ok
	}

static func feedback_text(level: Dictionary, evaluation: Dictionary) -> String:
	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	var error_code: String = str(evaluation.get("error_code", ERROR_ORDER_MISMATCH))
	var top_violation: Dictionary = evaluation.get("top_violation", {}) as Dictionary

	if not top_violation.is_empty() and (error_code == ERROR_CAUSALITY_LOOP or error_code == ERROR_LOGIC_GAP):
		var msg: String = str(top_violation.get("message", "")).strip_edges()
		if not msg.is_empty():
			return msg

	if feedback_rules.has(error_code):
		return str(feedback_rules.get(error_code, ""))
	if feedback_rules.has(ERROR_OK):
		return str(feedback_rules.get(ERROR_OK, ""))
	return "Проверка завершена."

static func _pick_top_error(violations: Array) -> String:
	for violation_var in violations:
		if typeof(violation_var) != TYPE_DICTIONARY:
			continue
		var violation: Dictionary = violation_var as Dictionary
		if str(violation.get("code", "")).to_upper() == ERROR_CAUSALITY_LOOP:
			return ERROR_CAUSALITY_LOOP

	for violation_var in violations:
		if typeof(violation_var) != TYPE_DICTIONARY:
			continue
		var violation: Dictionary = violation_var as Dictionary
		if str(violation.get("code", "")).to_upper() == ERROR_LOGIC_GAP:
			return ERROR_LOGIC_GAP

	return ERROR_ORDER_MISMATCH

static func _pick_top_violation(violations: Array, error_code: String) -> Dictionary:
	for violation_var in violations:
		if typeof(violation_var) != TYPE_DICTIONARY:
			continue
		var violation: Dictionary = violation_var as Dictionary
		if str(violation.get("code", "")).to_upper() == error_code:
			return violation
	if violations.is_empty():
		return {}
	if typeof(violations[0]) != TYPE_DICTIONARY:
		return {}
	return violations[0] as Dictionary

static func _normalized_array(raw: Variant) -> Array[String]:
	var out: Array[String] = []
	if typeof(raw) != TYPE_ARRAY:
		return out
	for item in raw as Array:
		out.append(str(item).strip_edges())
	return out

static func _arrays_equal(a: Array[String], b: Array[String]) -> bool:
	if a.size() != b.size():
		return false
	for i in range(a.size()):
		if a[i] != b[i]:
			return false
	return true
</file>

<file path="scripts/case_08/fr8c_data.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = [
	"id",
	"briefing",
	"format",
	"target_text",
	"html",
	"rules",
	"options",
	"correct_option_id",
	"feedback_rules"
]

const REQUIRED_RULE_KEYS: Array[String] = ["source_id", "kind", "weight", "important", "decl"]
const REQUIRED_DECL_KEYS: Array[String] = ["prop", "value"]
const REQUIRED_OPTION_KEYS: Array[String] = ["id", "label", "value"]

static func load_levels(path: String) -> Array:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("FR8CData: failed to open %s" % path)
		return []

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("FR8CData: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return []

	if typeof(json.data) != TYPE_ARRAY:
		push_error("FR8CData: root in %s must be an array" % path)
		return []

	var levels: Array = []
	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_data: Dictionary = level_var as Dictionary
		if validate_level(level_data):
			levels.append(level_data)
		else:
			push_error("FR8CData: invalid level contract: %s" % str(level_data.get("id", "UNKNOWN")))
	return levels

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("FR8CData: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "CSS_CASCADE":
		push_error("FR8CData: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var html_var: Variant = level.get("html", [])
	if typeof(html_var) != TYPE_ARRAY or (html_var as Array).is_empty():
		push_error("FR8CData: html must be non-empty array in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var rules_var: Variant = level.get("rules", [])
	if typeof(rules_var) != TYPE_ARRAY or (rules_var as Array).is_empty():
		push_error("FR8CData: rules must be non-empty array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var source_ids: Dictionary = {}
	for i in range((rules_var as Array).size()):
		var rule_var: Variant = (rules_var as Array)[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			push_error("FR8CData: rule entry must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var rule: Dictionary = rule_var as Dictionary
		for rule_key in REQUIRED_RULE_KEYS:
			if not rule.has(rule_key):
				push_error("FR8CData: rule missing key '%s' in level %s" % [rule_key, str(level.get("id", "UNKNOWN"))])
				return false
		if _selector_of(rule).is_empty():
			push_error("FR8CData: rule selector missing in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var source_id: String = str(rule.get("source_id", "")).strip_edges()
		if source_id.is_empty() or source_ids.has(source_id):
			push_error("FR8CData: duplicate/empty source_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		source_ids[source_id] = true
		if not _is_number(rule.get("weight", 0)):
			push_error("FR8CData: rule weight must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if typeof(rule.get("important", false)) != TYPE_BOOL:
			push_error("FR8CData: rule important must be bool in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if rule.has("order") and not _is_number(rule.get("order", 0)):
			push_error("FR8CData: rule order must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var decl_var: Variant = rule.get("decl", {})
		if typeof(decl_var) != TYPE_DICTIONARY:
			push_error("FR8CData: rule decl must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var decl: Dictionary = decl_var as Dictionary
		for decl_key in REQUIRED_DECL_KEYS:
			if not decl.has(decl_key):
				push_error("FR8CData: rule decl missing '%s' in level %s" % [decl_key, str(level.get("id", "UNKNOWN"))])
				return false

	if level.has("inline_decl") and level.get("inline_decl") != null:
		var inline_var: Variant = level.get("inline_decl")
		if typeof(inline_var) != TYPE_DICTIONARY:
			push_error("FR8CData: inline_decl must be dictionary/null in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var inline_decl: Dictionary = inline_var as Dictionary
		for inline_key in ["source_id", "kind", "weight", "important", "decl"]:
			if not inline_decl.has(inline_key):
				push_error("FR8CData: inline_decl missing '%s' in level %s" % [inline_key, str(level.get("id", "UNKNOWN"))])
				return false
		if inline_decl.has("order") and not _is_number(inline_decl.get("order", 0)):
			push_error("FR8CData: inline_decl order must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not _is_number(inline_decl.get("weight", 0)):
			push_error("FR8CData: inline_decl weight must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if typeof(inline_decl.get("decl", {})) != TYPE_DICTIONARY:
			push_error("FR8CData: inline_decl decl must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false

	var options_var: Variant = level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY or (options_var as Array).size() < 2:
		push_error("FR8CData: options must be array(>=2) in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var option_ids: Dictionary = {}
	for option_var in options_var as Array:
		if typeof(option_var) != TYPE_DICTIONARY:
			push_error("FR8CData: option entry must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var option: Dictionary = option_var as Dictionary
		for option_key in REQUIRED_OPTION_KEYS:
			if not option.has(option_key):
				push_error("FR8CData: option missing key '%s' in level %s" % [option_key, str(level.get("id", "UNKNOWN"))])
				return false
		var option_id: String = str(option.get("id", "")).strip_edges()
		if option_id.is_empty() or option_ids.has(option_id):
			push_error("FR8CData: duplicate/empty option id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		option_ids[option_id] = true

	var correct_option_id: String = str(level.get("correct_option_id", "")).strip_edges()
	if correct_option_id.is_empty() or not option_ids.has(correct_option_id):
		push_error("FR8CData: correct_option_id invalid in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var feedback_var: Variant = level.get("feedback_rules", {})
	if typeof(feedback_var) != TYPE_DICTIONARY:
		push_error("FR8CData: feedback_rules must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var feedback_rules: Dictionary = feedback_var as Dictionary
	if not feedback_rules.has("OK"):
		push_error("FR8CData: feedback_rules missing 'OK' in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	return true

static func _selector_of(rule: Dictionary) -> String:
	var selector: String = str(rule.get("selector", "")).strip_edges()
	if not selector.is_empty():
		return selector
	selector = str(rule.get(".selector", "")).strip_edges()
	return selector

static func _is_number(value: Variant) -> bool:
	var value_type: int = typeof(value)
	return value_type == TYPE_INT or value_type == TYPE_FLOAT
</file>

<file path="scripts/TrialV2.gd">
extends RefCounted
class_name TrialV2

static func build(quest_id: String, stage_id: String, task_id: String, interaction_type: String, variant_hash: String = "") -> Dictionary:
	var normalized_task_id := task_id if task_id != "" else "unknown_task"
	var normalized_variant_hash := variant_hash
	if normalized_variant_hash == "":
		normalized_variant_hash = str(hash("%s|%s|%s|%s" % [quest_id, stage_id, normalized_task_id, interaction_type]))

	return {
		"schema_version": "trial.v2",
		"quest_id": quest_id,
		"stage": stage_id,
		"task_id": normalized_task_id,
		"interaction_type": interaction_type,
		"variant_hash": normalized_variant_hash,
		"match_key": "%s|%s|%s|v%s" % [quest_id, stage_id, normalized_task_id, normalized_variant_hash]
	}
</file>

<file path="scripts/ui/ClueBucketZone.gd">
extends PanelContainer

var bucket_id: String = ""
@onready var items_flow = $VBox/ItemsFlow

func _ready():
	mouse_exited.connect(func(): modulate = Color(1,1,1))

func setup(p_bucket_id: String, p_label_text: String):
	bucket_id = p_bucket_id
	var title_lbl = $VBox/BucketTitle
	if title_lbl:
		title_lbl.text = p_label_text

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) == TYPE_DICTIONARY and data.get("kind") == "CLUE_ITEM":
		modulate = Color(1.2, 1.2, 1.2) # Highlight
		return true
	return false

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	modulate = Color(1.0, 1.0, 1.0) # Remove highlight

	var source_path = data.get("source_path")
	var source_node = get_node_or_null(source_path)

	if source_node and items_flow:
		source_node.reparent(items_flow)
		AudioManager.play("click")

		# Snap effect
		var tw = create_tween()
		source_node.scale = Vector2(1.05, 1.05)
		tw.tween_property(source_node, "scale", Vector2.ONE, 0.1)

func _notification(what):
	if what == NOTIFICATION_DRAG_END:
		if not is_drag_successful():
			modulate = Color(1.0, 1.0, 1.0)
</file>

<file path="scripts/ui/ClueItem.gd">
extends Button

var item_id: String = ""
var label: String = ""
var correct_bucket_id: String = ""

func setup(item_data: Dictionary):
	item_id = item_data.get("item_id", "")
	label = item_data.get("label", "")
	correct_bucket_id = item_data.get("correct_bucket_id", "")

	text = label
	custom_minimum_size = Vector2(0, 80)

func _get_drag_data(_at_position: Vector2):
	var data = {
		"kind": "CLUE_ITEM",
		"item_id": item_id,
		"label": label,
		"source_path": get_path()
	}

	var preview = self.duplicate()
	preview.modulate.a = 0.8
	# Wrap in control to center
	var c = Control.new()
	c.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(c)

	return data
</file>

<file path="scripts/ui/network_trace/network_trace_device_card.gd">
extends Button
class_name NetworkTraceDeviceCard

var device_id: String = ""
var device_label: String = ""
var error_code: String = ""

func setup(option_id: String, label_text: String, option_error_code: String) -> void:
	device_id = option_id
	device_label = label_text
	error_code = option_error_code
	text = label_text
	tooltip_text = label_text
	disabled = false

func clear_state() -> void:
	device_id = ""
	device_label = ""
	error_code = ""
	text = ""
	disabled = true

func _get_drag_data(_at_position: Vector2) -> Variant:
	if disabled:
		return null
	if device_id.is_empty():
		return null

	var preview: Label = Label.new()
	preview.text = device_label
	preview.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	preview.add_theme_font_size_override("font_size", 18)
	set_drag_preview(preview)

	return {
		"type": "network_trace_device",
		"device_id": device_id,
		"label": device_label,
		"error_code": error_code
	}
</file>

<file path="scripts/ui/pipeline/ModuleCard.gd">
extends PanelContainer
class_name PipelineModuleCard

signal module_selected(module_data: Dictionary, sender: Node)
signal module_drag_started(module_data: Dictionary)

var label_text: Label = null

var module_data: Dictionary = {}

func _ready() -> void:
	if label_text == null:
		label_text = get_node_or_null("Margin/Label") as Label
	if label_text != null and not module_data.is_empty():
		label_text.text = str(module_data.get("display", "?"))

func setup(data: Dictionary) -> void:
	module_data = data.duplicate(true)
	if label_text == null:
		label_text = get_node_or_null("Margin/Label") as Label
	if label_text != null:
		label_text.text = str(module_data.get("display", "?"))
	tooltip_text = "%s [%s]" % [
		str(module_data.get("module_id", "unknown")),
		str(module_data.get("slot_type", ""))
	]
	set_selected(false)

func get_module_data() -> Dictionary:
	return module_data.duplicate(true)

func set_selected(selected: bool) -> void:
	if selected:
		modulate = Color(1.0, 1.0, 0.82, 1.0)
	else:
		modulate = Color(1.0, 1.0, 1.0, 1.0)

func _get_drag_data(_at_position: Vector2) -> Variant:
	if module_data.is_empty():
		return null

	emit_signal("module_drag_started", module_data.duplicate(true))

	var preview_panel: PanelContainer = PanelContainer.new()
	preview_panel.custom_minimum_size = Vector2(120.0, 48.0)
	var preview_margin: MarginContainer = MarginContainer.new()
	preview_margin.add_theme_constant_override("margin_left", 8)
	preview_margin.add_theme_constant_override("margin_top", 6)
	preview_margin.add_theme_constant_override("margin_right", 8)
	preview_margin.add_theme_constant_override("margin_bottom", 6)
	var preview_label: Label = Label.new()
	preview_label.text = str(module_data.get("display", "?"))
	preview_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	preview_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	preview_margin.add_child(preview_label)
	preview_panel.add_child(preview_margin)
	set_drag_preview(preview_panel)

	return {
		"kind": "pipeline_module",
		"module": module_data.duplicate(true)
	}

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("module_selected", module_data.duplicate(true), self)
			accept_event()
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("module_selected", module_data.duplicate(true), self)
			accept_event()
</file>

<file path="scripts/ui/ResusPartItem.gd">
extends Button

signal drag_started(item_id: String, from_zone: String)

var item_id: String = ""
var item_label: String = ""
var correct_bucket_id: String = ""

func setup(item_data: Dictionary) -> void:
	item_id = str(item_data.get("item_id", ""))
	item_label = str(item_data.get("label", ""))
	correct_bucket_id = str(item_data.get("correct_bucket_id", "")).to_upper()
	text = item_label
	custom_minimum_size = Vector2(0, 76)
	set_meta("zone_id", "PILE")

func set_zone_id(zone_id: String) -> void:
	set_meta("zone_id", zone_id)

func get_zone_id() -> String:
	return str(get_meta("zone_id", "PILE"))

func _get_drag_data(_at_position: Vector2) -> Variant:
	var from_zone: String = get_zone_id()
	drag_started.emit(item_id, from_zone)

	var data: Dictionary = {
		"kind": "RESUS_ITEM",
		"item_id": item_id,
		"label": item_label,
		"source_path": get_path(),
		"from_zone": from_zone
	}

	var preview: Button = duplicate() as Button
	preview.modulate.a = 0.9
	var holder: Control = Control.new()
	holder.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(holder)

	return data
</file>

<file path="scripts/ui/ResusPileZone.gd">
extends PanelContainer

signal item_placed(item_id: String, to_bucket: String, from_bucket: String)

@export var title_path: NodePath = NodePath("VBox/BucketTitle")
@export var items_container_path: NodePath = NodePath("VBox/Scroll/PartsGrid")

var bucket_id: String = "PILE"

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		modulate = Color(1, 1, 1, 1)
	)

func setup(p_bucket_id: String, p_label_text: String) -> void:
	bucket_id = p_bucket_id.to_upper()
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func get_items_container() -> Control:
	return _items_container

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		_items_container.remove_child(child)
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	var current_parent: Node = item_control.get_parent()
	if current_parent == null:
		_items_container.add_child(item_control)
	elif current_parent != _items_container:
		item_control.reparent(_items_container)

	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", bucket_id)
	else:
		item_control.set_meta("zone_id", bucket_id)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "RESUS_ITEM":
		return false
	modulate = Color(1.08, 1.03, 1.03, 1.0)
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	modulate = Color(1, 1, 1, 1)
	if typeof(data) != TYPE_DICTIONARY:
		return
	var payload: Dictionary = data as Dictionary
	var source_path: String = str(payload.get("source_path", ""))
	if source_path == "":
		return
	var source_node: Node = get_node_or_null(source_path)
	if source_node == null or not is_instance_valid(_items_container):
		return

	var from_bucket: String = str(payload.get("from_zone", source_node.get_meta("zone_id", "PILE")))
	source_node.reparent(_items_container)
	if source_node.has_method("set_zone_id"):
		source_node.call("set_zone_id", bucket_id)
	else:
		source_node.set_meta("zone_id", bucket_id)

	if source_node is Control:
		var control_node: Control = source_node as Control
		var tween: Tween = create_tween()
		control_node.scale = Vector2(1.05, 1.05)
		tween.tween_property(control_node, "scale", Vector2.ONE, 0.1)

	item_placed.emit(str(payload.get("item_id", "")), bucket_id, from_bucket)
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		modulate = Color(1, 1, 1, 1)
</file>

<file path="scripts/ui/subnet/BitCell.gd">
extends PanelContainer
class_name SubnetBitCell

var label_value: Label = null
var bit_value: int = -1
var highlighted: bool = false

func _ready() -> void:
	_ensure_label()
	_refresh()

func set_bit(value: int) -> void:
	bit_value = clampi(value, 0, 1)
	_refresh()

func set_empty() -> void:
	bit_value = -1
	_refresh()

func set_highlight(active: bool) -> void:
	highlighted = active
	_refresh()

func pulse(color: Color, duration_sec: float = 0.12) -> void:
	modulate = color
	var tween: Tween = create_tween()
	tween.tween_property(self, "modulate", Color(1.0, 1.0, 1.0, 1.0), duration_sec)

func _ensure_label() -> void:
	if label_value == null:
		label_value = get_node_or_null("LabelValue") as Label

func _refresh() -> void:
	_ensure_label()
	if label_value == null:
		return

	if bit_value < 0:
		label_value.text = "-"
		label_value.modulate = Color(0.62, 0.64, 0.62, 1.0)
	elif bit_value == 0:
		label_value.text = "0"
		label_value.modulate = Color(0.78, 0.84, 0.8, 1.0)
	else:
		label_value.text = "1"
		label_value.modulate = Color(0.4, 1.0, 0.62, 1.0)

	if highlighted:
		self_modulate = Color(1.0, 1.0, 0.82, 1.0)
	else:
		self_modulate = Color(1.0, 1.0, 1.0, 1.0)
</file>

<file path="scripts/ui/subnet/MaskDropTarget.gd">
extends PanelContainer
class_name SubnetMaskDropTarget

signal mask_dropped(mask_data: Dictionary)
signal bad_drop(data: Dictionary)
signal target_tapped

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	var mask_data: Dictionary = _extract_mask_data(data)
	return not mask_data.is_empty()

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	var mask_data: Dictionary = _extract_mask_data(data)
	if mask_data.is_empty():
		emit_signal("bad_drop", {})
		return
	emit_signal("mask_dropped", mask_data)

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("target_tapped")
			accept_event()
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("target_tapped")
			accept_event()

func flash_bad_drop() -> void:
	modulate = Color(1.0, 0.55, 0.55, 1.0)
	var tween: Tween = create_tween()
	tween.tween_property(self, "modulate", Color(1.0, 1.0, 1.0, 1.0), 0.2)

func _extract_mask_data(data: Variant) -> Dictionary:
	if typeof(data) != TYPE_DICTIONARY:
		return {}
	var drop_data: Dictionary = data
	if str(drop_data.get("kind", "")) != "subnet_mask_overlay":
		return {}
	var mask_variant: Variant = drop_data.get("mask", {})
	if typeof(mask_variant) != TYPE_DICTIONARY:
		return {}
	var mask_dict: Dictionary = mask_variant
	return mask_dict.duplicate(true)
</file>

<file path="scripts/ui/TagFragmentItem.gd">
extends Button

signal drag_started(fragment_id: String, from_zone: String)

var fragment_id: String = ""
var fragment_label: String = ""
var fragment_kind: String = ""
var fragment_token: String = ""

func setup(fragment_data: Dictionary) -> void:
	fragment_id = str(fragment_data.get("fragment_id", ""))
	fragment_label = str(fragment_data.get("label", ""))
	fragment_kind = str(fragment_data.get("kind", ""))
	fragment_token = str(fragment_data.get("token", fragment_label))

	text = fragment_label
	custom_minimum_size = Vector2(0, 72)
	theme_type_variation = &"FlatButton"
	set_zone_id("PILE")

func set_zone_id(zone_id: String) -> void:
	set_meta("zone_id", zone_id)

func get_zone_id() -> String:
	return str(get_meta("zone_id", "PILE"))

func get_fragment_id() -> String:
	return fragment_id

func _get_drag_data(_at_position: Vector2) -> Variant:
	var from_zone: String = get_zone_id()
	drag_started.emit(fragment_id, from_zone)

	var data: Dictionary = {
		"kind": "TAG_FRAGMENT",
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"source_path": get_path()
	}

	var preview: Button = duplicate() as Button
	preview.modulate.a = 0.9
	var holder: Control = Control.new()
	holder.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(holder)

	return data
</file>

<file path="scripts/ui/TagPileZone.gd">
extends PanelContainer

signal item_placed(fragment_id: String, to_zone: String, from_zone: String)

@export var title_path: NodePath = NodePath("VBox/PileTitle")
@export var items_container_path: NodePath = NodePath("VBox/Scroll/ItemsGrid")

var zone_id: String = "PILE"
var _drag_hovered: bool = false

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		_drag_hovered = false
		_apply_visual_state()
	)
	_apply_visual_state()

func setup(p_zone_id: String, p_label_text: String) -> void:
	zone_id = p_zone_id
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		_items_container.remove_child(child)
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	var current_parent: Node = item_control.get_parent()
	if current_parent == null:
		_items_container.add_child(item_control)
	elif current_parent != _items_container:
		item_control.reparent(_items_container)
	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", zone_id)
	else:
		item_control.set_meta("zone_id", zone_id)

	var tween: Tween = create_tween()
	item_control.scale = Vector2(1.05, 1.05)
	tween.tween_property(item_control, "scale", Vector2.ONE, 0.1)

func set_grid_columns(columns: int) -> void:
	if not (_items_container is GridContainer):
		return
	(_items_container as GridContainer).columns = max(1, columns)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "TAG_FRAGMENT":
		return false
	_drag_hovered = true
	_apply_visual_state()
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	_drag_hovered = false
	_apply_visual_state()
	if typeof(data) != TYPE_DICTIONARY:
		return

	var payload: Dictionary = data as Dictionary
	var controller: Node = _get_drop_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_drop_to_pile", payload)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		return

	_pulse()
	item_placed.emit(str(result.get("fragment_id", "")), zone_id, str(result.get("from_zone", "PILE")))
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		_drag_hovered = false
		_apply_visual_state()

func _get_drop_controller() -> Node:
	return get_tree().get_first_node_in_group("fr8_drop_controller")

func _apply_visual_state() -> void:
	self_modulate = Color(1.06, 1.06, 1.06, 1.0) if _drag_hovered else Color(1.0, 1.0, 1.0, 1.0)

func _pulse() -> void:
	var tween: Tween = create_tween()
	scale = Vector2(1.01, 1.01)
	tween.tween_property(self, "scale", Vector2.ONE, 0.08)
</file>

<file path="scripts/ui/TagSlotZone.gd">
extends PanelContainer

signal item_placed(fragment_id: String, to_zone: String, from_zone: String)

@export var title_path: NodePath = NodePath("VBox/SlotTitle")
@export var items_container_path: NodePath = NodePath("VBox/Center/Items")

var zone_id: String = ""
var _feedback_state: String = "neutral"
var _drag_hovered: bool = false

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		_drag_hovered = false
		_apply_visual_state()
	)
	_apply_visual_state()

func setup(p_zone_id: String, p_label_text: String) -> void:
	zone_id = p_zone_id
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func get_zone_id() -> String:
	return zone_id

func get_items_container() -> Control:
	return _items_container

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		_items_container.remove_child(child)
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	var current_parent: Node = item_control.get_parent()
	if current_parent == null:
		_items_container.add_child(item_control)
	elif current_parent != _items_container:
		item_control.reparent(_items_container)
	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", zone_id)
	else:
		item_control.set_meta("zone_id", zone_id)

	var tween: Tween = create_tween()
	item_control.scale = Vector2(1.05, 1.05)
	tween.tween_property(item_control, "scale", Vector2.ONE, 0.1)

func get_current_fragment_id() -> String:
	if not is_instance_valid(_items_container):
		return ""
	if _items_container.get_child_count() <= 0:
		return ""
	var item_node: Node = _items_container.get_child(0)
	if item_node.has_method("get_fragment_id"):
		return str(item_node.call("get_fragment_id"))
	return str(item_node.get_meta("fragment_id", ""))

func set_feedback_state(state: String) -> void:
	_feedback_state = state
	_apply_visual_state()

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "TAG_FRAGMENT":
		return false
	_drag_hovered = true
	_apply_visual_state()
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	_drag_hovered = false
	_apply_visual_state()
	if typeof(data) != TYPE_DICTIONARY:
		return

	var payload: Dictionary = data as Dictionary
	var controller: Node = _get_drop_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_drop_to_slot", zone_id, payload)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		return

	_pulse()
	item_placed.emit(str(result.get("fragment_id", "")), zone_id, str(result.get("from_zone", "PILE")))
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		_drag_hovered = false
		_apply_visual_state()

func _get_drop_controller() -> Node:
	return get_tree().get_first_node_in_group("fr8_drop_controller")

func _apply_visual_state() -> void:
	var tone: Color = Color(1.0, 1.0, 1.0, 1.0)
	match _feedback_state:
		"ok":
			tone = Color(0.78, 1.05, 0.82, 1.0)
		"bad":
			tone = Color(1.08, 0.78, 0.78, 1.0)
		_:
			tone = Color(1.0, 1.0, 1.0, 1.0)

	if _drag_hovered:
		tone = Color(tone.r * 1.08, tone.g * 1.08, tone.b * 1.08, tone.a)

	self_modulate = tone

func _pulse() -> void:
	var tween: Tween = create_tween()
	scale = Vector2(1.02, 1.02)
	tween.tween_property(self, "scale", Vector2.ONE, 0.1)
</file>

<file path="scripts/ui/TimelineCard.gd">
extends PanelContainer

signal move_requested(stage_id: String, dir: int)
signal hint_requested(stage_id: String)

@onready var stage_title: Label = $Margin/VBox/Header/StageTitle
@onready var stage_hint_btn: Button = $Margin/VBox/Header/StageHintBtn
@onready var btn_left: Button = $Margin/VBox/Controls/BtnLeft
@onready var btn_right: Button = $Margin/VBox/Controls/BtnRight

var stage_id: String = ""
var hint_text: String = ""

func _ready() -> void:
	btn_left.pressed.connect(_on_left_pressed)
	btn_right.pressed.connect(_on_right_pressed)
	stage_hint_btn.pressed.connect(_on_hint_pressed)

func setup(card_data: Dictionary) -> void:
	stage_id = str(card_data.get("stage_id", "")).strip_edges()
	hint_text = str(card_data.get("hint", "")).strip_edges()
	stage_title.text = str(card_data.get("title", stage_id))
	stage_hint_btn.disabled = hint_text.is_empty()

func set_move_enabled(can_left: bool, can_right: bool) -> void:
	btn_left.disabled = not can_left
	btn_right.disabled = not can_right

func _on_left_pressed() -> void:
	move_requested.emit(stage_id, -1)

func _on_right_pressed() -> void:
	move_requested.emit(stage_id, 1)

func _on_hint_pressed() -> void:
	hint_requested.emit(stage_id)
</file>

<file path="shaders/blur.gdshader">
shader_type canvas_item;
render_mode unshaded;

uniform float blur_size = 3.0;

void fragment() {
	vec2 uv = SCREEN_UV;
	vec2 off = SCREEN_PIXEL_SIZE * blur_size;

	vec4 sum = vec4(0.0);
	sum += texture(SCREEN_TEXTURE, uv);
	sum += texture(SCREEN_TEXTURE, uv + vec2(off.x, 0.0));
	sum += texture(SCREEN_TEXTURE, uv - vec2(off.x, 0.0));
	sum += texture(SCREEN_TEXTURE, uv + vec2(0.0, off.y));
	sum += texture(SCREEN_TEXTURE, uv - vec2(0.0, off.y));
	sum += texture(SCREEN_TEXTURE, uv + off);
	sum += texture(SCREEN_TEXTURE, uv - off);
	sum += texture(SCREEN_TEXTURE, uv + vec2(off.x, -off.y));
	sum += texture(SCREEN_TEXTURE, uv + vec2(-off.x, off.y));

	COLOR = sum / 9.0;
}
</file>

<file path="SUMMARY.md">
# Godot MCP — AI-Powered Godot Development

**Give your AI assistant full access to the Godot editor.** Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching, no friction.

> Works with Godot 4.x · Open source (MIT) · 32 tools · Visual project explorer included

---

## What Is This?

Godot MCP is a bridge between AI assistants and the Godot editor. It lets AI read, write, and manipulate your project directly — scenes, scripts, nodes, assets, settings — all through natural conversation.

```
You ↔ AI Assistant ↔ MCP Server ↔ Godot Editor
         (Claude, Cursor, etc.)    (WebSocket)     (Plugin)
```

Install the Godot plugin, point your AI client at the MCP server, and start building.

---

## Tools (32)

### File Operations (4 tools)
| Tool | What it does |
|------|-------------|
| `list_dir` | Browse project directories (`res://` paths) |
| `read_file` | Read any text file with optional line ranges |
| `search_project` | Full-text search across the project with glob filtering |
| `create_script` | Scaffold new GDScript files |

### Scene Operations (11 tools)
| Tool | What it does |
|------|-------------|
| `create_scene` | Create `.tscn` files with a node hierarchy |
| `read_scene` | Parse and inspect scene structure |
| `add_node` | Add nodes to existing scenes |
| `remove_node` | Remove nodes from scenes |
| `modify_node_property` | Set any node property (transforms, colors, physics, etc.) |
| `rename_node` | Rename nodes |
| `move_node` | Reparent nodes in the scene tree |
| `attach_script` | Attach a GDScript to a node |
| `detach_script` | Remove a script from a node |
| `set_collision_shape` | Assign collision shapes (Circle, Rectangle, Capsule, etc.) |
| `set_sprite_texture` | Assign textures to sprites (image, placeholder, gradient, noise) |

### Script Operations (6 tools)
| Tool | What it does |
|------|-------------|
| `apply_diff_preview` | Apply targeted code edits to GDScript files |
| `validate_script` | Check GDScript syntax without running |
| `list_scripts` | List all `.gd` files in the project |
| `create_folder` | Create directories |
| `delete_file` | Delete files (with safety checks) |
| `rename_file` | Rename/move files with optional reference updates |

### Project Tools (9 tools)
| Tool | What it does |
|------|-------------|
| `get_project_settings` | Read project configuration (window size, renderer, physics) |
| `get_input_map` | Inspect all input actions and their bindings |
| `get_collision_layers` | Read physics collision layer names |
| `get_node_properties` | Discover every property a node type supports |
| `get_console_log` | Read the editor output log |
| `get_errors` | Extract only errors from the console |
| `clear_console_log` | Clear the console |
| `open_in_godot` | Open a file in the editor (jumps to line for scripts) |
| `scene_tree_dump` | Dump the running scene tree for debugging |

### Asset Generation (4 tools)
| Tool | What it does |
|------|-------------|
| `generate_2d_asset` | Generate 2D sprites from SVG code |
| `search_comfyui_nodes` | Search 10,500+ ComfyUI nodes for AI art pipelines |
| `inspect_runninghub_workflow` | Inspect RunningHub workflow parameters |
| `customize_and_run_workflow` | Execute RunningHub workflows for asset generation |

### Visualization (1 tool)
| Tool | What it does |
|------|-------------|
| `map_project` | Build an interactive visual map of your entire project |

---

## Features

### Core
- **Live editor connection** — WebSocket bridge between MCP server and Godot editor. Changes happen in real time.
- **Works with any MCP client** — Claude Desktop, Cursor, RAGy, or anything that speaks MCP.
- **Mock mode** — Test and develop without Godot running.
- **Auto-reconnect** — Plugin reconnects automatically if the connection drops.

### Scene Manipulation
- Create scenes from scratch with full node hierarchies
- Add, remove, rename, move, and reparent nodes
- Set any node property with automatic type parsing (Vector2, Color, etc.)
- Attach/detach scripts, assign collision shapes and textures
- Read and inspect existing scene structures

### Script Intelligence
- Apply surgical code edits with snippet matching
- Validate GDScript syntax before saving
- Full project-wide text search
- Scaffold new scripts from templates
- Rename/move files with reference tracking

### Project Awareness
- AI can read your project settings, input map, and collision layers
- Console log and error access for debugging
- Scene tree dumps of the running game
- Property discovery — AI can look up what properties any node type supports

### Asset Pipeline
- Generate 2D placeholder sprites from SVG descriptions
- ComfyUI node search for AI art workflow building
- RunningHub integration for automated asset generation

### Interactive Visualizer
- **Browser-based project explorer** served at `localhost:6510`
- Force-directed graph of all scripts and their relationships
- Color-coded by folder, searchable, zoomable
- Click any script to inspect variables, functions, signals, and connections
- **Inline editing** — edit variables, function bodies, and signals directly in the visualizer
- **Scene view** — browse scene hierarchies and edit node properties
- **Find usages** — check where a function or variable is used before changing it
- Changes sync back to Godot in real time

---

## Godot Developer Pain Points

| Pain Point | Status | How |
|-----------|--------|-----|
| **"AI can't see my project"** — context switching between AI chat and editor | **Solved** | AI reads/writes your project directly through 32 tools |
| **"Scene files are unreadable"** — `.tscn` is a custom text format AI struggles with | **Solved** | Structured scene tools abstract away the format |
| **"I have to copy-paste code back and forth"** — manual AI workflow | **Solved** | AI edits scripts in-place, validates syntax, and opens files in editor |
| **"I don't know what properties a node has"** — memorizing the API | **Solved** | `get_node_properties` lets AI discover any node's full property list |
| **"Debugging is slow"** — checking console, finding errors | **Solved** | AI reads console logs, extracts errors, dumps the scene tree |
| **"I can't visualize my project structure"** — hard to see the big picture | **Solved** | Interactive visualizer maps scripts, scenes, and their connections |
| **"Setting up input maps / collision layers is tedious"** | **Solved** | AI reads and understands your input map and collision layers |
| **"I need placeholder art to prototype"** | **Solved** | SVG-based 2D asset generation, ComfyUI/RunningHub integration |
| **"Refactoring is scary"** — renaming breaks things | **Partially solved** | File rename with reference updates + find usages in visualizer |
| **"GDScript has no LSP-quality AI support"** | **Partially solved** | Syntax validation + property discovery, but no autocomplete or go-to-definition |
| **"AI generates code for the wrong Godot version"** | **Partially solved** | AI sees your actual project settings and node types, reducing hallucination |
| **"I need AI to playtest / run my game"** | **Not yet** | Scene tree dump works, but no automated play/test/input simulation |
| **"Shader editing is painful"** | **Not yet** | No shader-specific tools (files can be read/written as text) |
| **"Managing exports and builds"** | **Not yet** | No export/build pipeline tools |
| **"Tilemap and level design"** | **Not yet** | No tilemap-specific tools |
| **"Animation editing"** | **Not yet** | No AnimationPlayer/AnimationTree tools |
| **"Version control integration"** | **Not yet** | No built-in git tools (use your AI client's native git support) |
| **"Multi-file refactoring"** | **Not yet** | Single-file edits only; no cross-file rename symbol |

---

## Quick Start

**1. Add the MCP server to your AI client**

No installation needed — the server is on npm. Add to your AI client config:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**2. Install the Godot plugin**
Copy `godot-plugin/addons/godot_mcp/` into your project's `addons/` folder. Enable it in Project → Project Settings → Plugins.

**3. Restart Godot.** Check the top-right corner of the editor — you should see **MCP Connected** in green. You're ready to go.

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — WebSocket runs on localhost, no remote connections or auth
- **Single connection** — One Godot instance at a time
- **Editor only** — Plugin runs in `@tool` mode, not in exported games
- **No undo** — Changes are saved directly (use version control)
- **Regex-based parsing** — Script analysis may miss edge cases in complex GDScript
- **No runtime control** — Can't press play, simulate input, or automate testing
- **All AI is limited in Godot knowledge** - scene editing, GDScript, editing node properties, building and placing UI elements. It cant create 100% of the game alone but it can help debug, write scripts, and tag along for the journey :)
---

## What's Next (maybe)

- Animation tools (AnimationPlayer, tweens)
- Tilemap and level design tools  
- Shader editing support
- Automated playtesting and input simulation
- Multi-file refactoring
- Plugin marketplace / asset library integration
- improvements to current tools

---

## License

MIT — use it however you want.

**[GitHub](https://github.com/tomyud1/godot-mcp)** · **[npm](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="ui/shaders/noir_pencil_overlay.gdshader">
shader_type canvas_item;

uniform sampler2D screen_tex : hint_screen_texture, repeat_disable, filter_linear_mipmap;

uniform float intensity : hint_range(0.0, 1.0) = 0.34;
uniform float grain_strength : hint_range(0.0, 1.5) = 0.35;
uniform float hatch_strength : hint_range(0.0, 1.5) = 0.3;
uniform float vignette_strength : hint_range(0.0, 1.5) = 0.45;
uniform int fx_quality = 1;
uniform float pulse : hint_range(0.0, 1.0) = 0.0;
uniform float jitter_strength : hint_range(0.0, 2.0) = 0.0;

float hash12(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * 0.1031);
	p3 += dot(p3, p3.yzx + 33.33);
	return fract((p3.x + p3.y) * p3.z);
}

float noise2d(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);
	float a = hash12(i);
	float b = hash12(i + vec2(1.0, 0.0));
	float c = hash12(i + vec2(0.0, 1.0));
	float d = hash12(i + vec2(1.0, 1.0));
	vec2 u = f * f * (3.0 - 2.0 * f);
	return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

void fragment() {
	vec2 uv = SCREEN_UV;
	vec2 sample_uv = uv;

	if (fx_quality > 0) {
		float j = (noise2d(vec2(TIME * 24.0, uv.y * 420.0)) - 0.5) * 0.0045;
		sample_uv.x += j * (jitter_strength + pulse * 1.5);
	}

	vec3 src = texture(screen_tex, sample_uv).rgb;
	float luma = dot(src, vec3(0.299, 0.587, 0.114));

	float grain = noise2d(uv * vec2(1100.0, 760.0) + TIME * 8.0) - 0.5;

	float hatch = 0.0;
	if (fx_quality > 0) {
		vec2 p = uv * vec2(1100.0, 680.0);
		float line_a = abs(sin((p.x + p.y) * 0.048));
		float line_b = abs(sin((p.x - p.y) * 0.062 + 1.2));
		hatch = smoothstep(0.78, 1.0, mix(line_a, line_b, 0.5)) * (1.0 - luma);
	}

	float vignette = smoothstep(0.92, 0.22, length(uv - vec2(0.5)));

	float scratch = 0.0;
	if (pulse > 0.001) {
		float scratch_mask = step(0.988, noise2d(vec2(uv.y * 1400.0, TIME * 28.0)));
		scratch = scratch_mask * pulse;
	}

	float mono = luma;
	mono += grain * grain_strength * 0.18;
	mono -= hatch * hatch_strength * 0.22;
	mono -= scratch * 0.2;
	mono = clamp(mono, 0.0, 1.0);

	float blend_strength = clamp(intensity * vignette * vignette_strength + pulse * 0.16, 0.0, 1.0);
	vec3 noir = vec3(mono);
	vec3 out_col = mix(src, noir, blend_strength);

	COLOR = vec4(out_col, 1.0);
}
</file>

<file path="ui/theme_noir_detective.tres">
[gd_resource type="Theme" load_steps=9 format=3 uid="uid://ckh2j4fimo232"]

[ext_resource type="FontFile" uid="uid://b6l43b80tas2q" path="res://fonts/IBMPlexMono-Medium.ttf" id="1_font"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.09, 0.09, 0.09, 0.92)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.33, 0.33, 0.33, 0.7)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.16, 0.16, 0.16, 0.98)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.86, 0.2, 0.24, 1)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.11, 0.11, 0.11, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.85, 0.85, 0.85, 0.9)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.2, 0.2, 0.2, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.98, 0.28, 0.33, 1)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 14.0
content_margin_top = 12.0
content_margin_right = 14.0
content_margin_bottom = 12.0
bg_color = Color(0.07, 0.07, 0.07, 0.94)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.72, 0.72, 0.72, 0.75)
corner_radius_top_left = 12
corner_radius_top_right = 12
corner_radius_bottom_right = 12
corner_radius_bottom_left = 12
shadow_color = Color(0, 0, 0, 0.45)
shadow_size = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.12, 0.12, 0.12, 1)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0.9, 0.22, 0.26, 0.95)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6

[resource]
default_font = ExtResource("1_font")
default_font_size = 19
Button/colors/font_color = Color(0.93, 0.93, 0.93, 1)
Button/colors/font_disabled_color = Color(0.55, 0.55, 0.55, 1)
Button/colors/font_hover_color = Color(1, 0.93, 0.94, 1)
Button/colors/font_pressed_color = Color(1, 1, 1, 1)
Button/constants/h_separation = 8
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(0.9, 0.9, 0.9, 1)
LineEdit/colors/font_color = Color(0.9, 0.9, 0.9, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0.9, 0.9, 0.9, 1)
</file>

<file path="ui/theme_noir_pencil.tres">
[gd_resource type="Theme" load_steps=10 format=3 uid="uid://hk6g2qwetvdn"]

[ext_resource type="FontFile" uid="uid://b6l43b80tas2q" path="res://fonts/IBMPlexMono-Medium.ttf" id="1_font"]

[sub_resource type="StyleBoxFlat" id="sb_button_disabled"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.0941176, 0.0941176, 0.0941176, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.713726, 0.713726, 0.690196, 0.35)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_button_hover"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.117647, 0.117647, 0.117647, 0.98)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.929412, 0.92549, 0.909804, 0.75)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_button_normal"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.105882, 0.105882, 0.105882, 0.98)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.45)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_button_pressed"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.133333, 0.133333, 0.133333, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.929412, 0.92549, 0.909804, 0.85)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.0784314, 0.0784314, 0.0784314, 0.96)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.45)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_popup_panel"]
content_margin_left = 12.0
content_margin_top = 12.0
content_margin_right = 12.0
content_margin_bottom = 12.0
bg_color = Color(0.0862745, 0.0862745, 0.0862745, 0.98)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.6)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.0705882, 0.0705882, 0.0705882, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.35)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0.866667, 0.866667, 0.854902, 0.95)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[resource]
default_font = ExtResource("1_font")
default_font_size = 19
Button/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
Button/colors/font_disabled_color = Color(0.713726, 0.713726, 0.690196, 0.75)
Button/colors/font_hover_color = Color(0.968627, 0.964706, 0.952941, 1)
Button/colors/font_pressed_color = Color(1, 1, 1, 1)
Button/styles/disabled = SubResource("sb_button_disabled")
Button/styles/hover = SubResource("sb_button_hover")
Button/styles/normal = SubResource("sb_button_normal")
Button/styles/pressed = SubResource("sb_button_pressed")
Label/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
LineEdit/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
Panel/styles/panel = SubResource("sb_panel")
PanelContainer/styles/panel = SubResource("sb_panel")
PopupPanel/styles/panel = SubResource("sb_popup_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0.929412, 0.92549, 0.909804, 1)
TextEdit/colors/background_color = Color(0.054902, 0.054902, 0.054902, 1)
TextEdit/colors/caret_color = Color(0.929412, 0.92549, 0.909804, 1)
TextEdit/colors/current_line_color = Color(0.929412, 0.92549, 0.909804, 0.07)
TextEdit/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
TextEdit/colors/line_number_color = Color(0.713726, 0.713726, 0.690196, 0.85)
</file>

<file path="VISUAL_TREE_ROADMAP.md">
# Visual Tree Roadmap

## Completed
- [x] Inline variable/signal editing
- [x] @onready toggle
- [x] Function code editing with syntax highlighting
- [x] Usage detection before delete
- [x] Floating usage panel with navigation
- [x] Right-click context menu
- [x] New script creation
- [x] Draggable/resizable panels
- [x] Scene View tab (Phase 4 - Core)
  - Scene overview with cards showing scene info
  - Click scene → expand to full node hierarchy tree
  - Visual node tree with parent-child connections
  - Sibling order indicators (for 2D draw order)
  - Click node → dynamic properties panel
  - Inline editing of all node properties
  - Property controls: toggles, sliders, vectors, colors, enums
  - Back navigation to scene overview

## In Progress
- [ ] Function deletion with usage check

## Planned

### Phase 2: Visual Connections
- Drag from signal → function to create `.connect()` code
- Visual ports on node edges when hovering

### Phase 3: Script Management
- Right click to add a new node (script)
- Script templates (Node2D, State Machine, Singleton, etc.)
- Delete/rename scripts

### Phase 4: Scene View (Enhancements)
- Drag to reorder siblings (change draw order)
- Right-click context menu on scene nodes (add child, delete, rename)
- Drag scripts onto scene nodes to attach
- Cross-scene signal visualization

### Phase 5: Advanced
- Minimap
- Node grouping
- Full-text search in function bodies
- Refactoring (rename across files)
- Undo/redo
- Git integration (modified files indicator)

### Phase 6: Polish
- Documentation generation
- Dependency analysis (circular deps, unused scripts)
- Code snippets library
</file>

<file path="data/city_map/pack_6_1_A.json">
{
	"pack_version": "city_map.pack.v1",
	"pack_id": "CITY_MAP_A_PACK_01",
	"mode": "A",
	"shuffle": false,
	"levels": [
		{
			"id": "6_1_01",
			"path": "res://data/city_map/level_6_1.json"
		},
		{
			"id": "6_1_02",
			"path": "res://data/city_map/level_6_1_02.json"
		},
		{
			"id": "6_1_03",
			"path": "res://data/city_map/level_6_1_03.json"
		}
	]
}
</file>

<file path="data/city_map/pack_6_2_B.json">
{
	"pack_version": "city_map.pack.v1",
	"pack_id": "CITY_MAP_B_PACK_01",
	"mode": "B",
	"shuffle": false,
	"levels": [
		{
			"id": "6_2_01",
			"path": "res://data/city_map/level_6_2.json"
		},
		{
			"id": "6_2_02",
			"path": "res://data/city_map/level_6_2_02.json"
		},
		{
			"id": "6_2_03",
			"path": "res://data/city_map/level_6_2_03.json"
		}
	]
}
</file>

<file path="data/city_map/pack_6_3_C.json">
{
	"pack_version": "city_map.pack.v1",
	"pack_id": "CITY_MAP_C_PACK_01",
	"mode": "C",
	"shuffle": false,
	"levels": [
		{
			"id": "6_3_01",
			"path": "res://data/city_map/level_6_3.json"
		},
		{
			"id": "6_3_02",
			"path": "res://data/city_map/level_6_3_02.json"
		},
		{
			"id": "6_3_03",
			"path": "res://data/city_map/level_6_3_03.json"
		}
	]
}
</file>

<file path="data/final_report_b_levels.json">
[
  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-01",
    "briefing": "Инвесторы ждут план. Расставьте этапы разработки по времени.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"IDEA","title":"Идея","hint":"Формулировка проблемы и решения."},
      {"stage_id":"MVP","title":"MVP","hint":"Минимально рабочая версия продукта."},
      {"stage_id":"ALPHA","title":"Альфа","hint":"Внутреннее тестирование."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичное тестирование."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз для всех."}
    ],
    "dependencies": [
      {"a":"IDEA","b":"MVP","code":"LOGIC_GAP","message":"Нельзя делать MVP раньше идеи."},
      {"a":"MVP","b":"ALPHA","code":"LOGIC_GAP","message":"Нельзя тестировать Альфу раньше MVP."},
      {"a":"ALPHA","b":"BETA","code":"CAUSALITY_LOOP","message":"Нельзя показывать Бету до Альфы."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Нельзя выпускать релиз до Беты."}
    ],
    "expected_order": ["IDEA","MVP","ALPHA","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Вы пытаетесь утвердить этап, который не подготовлен.",
      "CAUSALITY_LOOP": "Нельзя отдавать людям сырой продукт до внутренней проверки.",
      "ORDER_MISMATCH": "Почти. Проверьте хронологию.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-02",
    "briefing": "Команда хочет быстрее «выйти в люди». Убедитесь, что порядок логичен.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"PROBLEM","title":"Проблема","hint":"Сначала понять, что решаем."},
      {"stage_id":"PROTOTYPE","title":"Прототип","hint":"Быстрая проверка идеи."},
      {"stage_id":"MVP","title":"MVP","hint":"Минимальная рабочая версия."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"PROBLEM","b":"PROTOTYPE","code":"LOGIC_GAP","message":"Нельзя строить прототип без проблемы."},
      {"a":"PROTOTYPE","b":"MVP","code":"LOGIC_GAP","message":"MVP не рождается из воздуха."},
      {"a":"MVP","b":"BETA","code":"CAUSALITY_LOOP","message":"Бета только после MVP."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["PROBLEM","PROTOTYPE","MVP","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Сломана причинность этапов.",
      "CAUSALITY_LOOP": "Публичность раньше внутренней готовности.",
      "ORDER_MISMATCH": "Есть несостыковка порядка.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-03",
    "briefing": "Система безопасности. Расставьте этапы подготовки к релизу.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"THREAT","title":"Модель угроз","hint":"Определить, от чего защищаемся."},
      {"stage_id":"LOGGING","title":"Логирование","hint":"Сначала фиксируем события."},
      {"stage_id":"PENTEST","title":"Пентест","hint":"Проверка уязвимостей."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"THREAT","b":"LOGGING","code":"LOGIC_GAP","message":"Логи без понимания угроз бесполезны."},
      {"a":"LOGGING","b":"PENTEST","code":"LOGIC_GAP","message":"Пентест без логов хуже диагностики."},
      {"a":"PENTEST","b":"BETA","code":"CAUSALITY_LOOP","message":"Нельзя выпускать Бету до проверки безопасности."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["THREAT","LOGGING","PENTEST","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Этап пропущен или стоит не на месте.",
      "CAUSALITY_LOOP": "Публичный этап раньше проверки.",
      "ORDER_MISMATCH": "Проверьте порядок.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-04",
    "briefing": "Инвесторский цикл. Упорядочьте этапы так, чтобы это не выглядело как сказка.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"PITCH","title":"Питч","hint":"Презентация идеи."},
      {"stage_id":"MEETING","title":"Встреча","hint":"Обсуждение деталей."},
      {"stage_id":"FUNDING","title":"Финансирование","hint":"Деньги пришли."},
      {"stage_id":"HIRE","title":"Найм","hint":"Собрать команду."},
      {"stage_id":"MVP","title":"MVP","hint":"Сделать продукт."}
    ],
    "dependencies": [
      {"a":"PITCH","b":"MEETING","code":"LOGIC_GAP","message":"Сначала питч, потом встреча."},
      {"a":"MEETING","b":"FUNDING","code":"LOGIC_GAP","message":"Финансирование после обсуждения."},
      {"a":"FUNDING","b":"HIRE","code":"LOGIC_GAP","message":"Найм обычно после денег."},
      {"a":"HIRE","b":"MVP","code":"LOGIC_GAP","message":"MVP делают люди, а не воздух."}
    ],
    "expected_order": ["PITCH","MEETING","FUNDING","HIRE","MVP"],
    "feedback_rules": {
      "LOGIC_GAP": "Порядок не выглядит реалистично.",
      "CAUSALITY_LOOP": "Сломана причинность.",
      "ORDER_MISMATCH": "Почти.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-05",
    "briefing": "Юр.чистота перед публичным запуском. Расставьте этапы.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"MVP","title":"MVP","hint":"Есть продукт."},
      {"stage_id":"PRIVACY","title":"Конфиденциальность","hint":"Политика конфиденциальности."},
      {"stage_id":"TERMS","title":"Условия","hint":"Пользовательское соглашение."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"MVP","b":"PRIVACY","code":"LOGIC_GAP","message":"Сначала продукт, потом документы."},
      {"a":"PRIVACY","b":"TERMS","code":"LOGIC_GAP","message":"Документы должны быть согласованы."},
      {"a":"TERMS","b":"BETA","code":"CAUSALITY_LOOP","message":"Публичность после документов."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["MVP","PRIVACY","TERMS","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Порядок документов нарушен.",
      "CAUSALITY_LOOP": "Нельзя выпускать на публику без базовой юридической базы.",
      "ORDER_MISMATCH": "Проверьте порядок.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-06",
    "briefing": "Контроль качества. Правильный порядок спасает от позора.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"MVP","title":"MVP","hint":"Рабочая основа."},
      {"stage_id":"ALPHA","title":"Альфа","hint":"Внутренний тест."},
      {"stage_id":"QA","title":"QA","hint":"Проверка качества."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"MVP","b":"ALPHA","code":"LOGIC_GAP","message":"Альфа после MVP."},
      {"a":"ALPHA","b":"QA","code":"LOGIC_GAP","message":"QA после внутреннего теста."},
      {"a":"QA","b":"BETA","code":"CAUSALITY_LOOP","message":"Бета после QA."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["MVP","ALPHA","QA","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Этапы качества стоят странно.",
      "CAUSALITY_LOOP": "Публичный этап раньше контроля качества.",
      "ORDER_MISMATCH": "Почти.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  }
]
</file>

<file path="data/final_report_c_levels.json">
[
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-01",
    "briefing": "Текст скрыт конфликтом стилей. Определите итоговый цвет.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      }
    ],
    "options": [
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"}
    ],
    "correct_option_id": "GREEN",
    "feedback_rules": {
      "SPECIFICITY_ERROR": "ID-защита сильнее класса: #x (100) > .alert (10).",
      "OK": "Взлом успешен: победил #x."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-02",
    "briefing": "Два класса спорят. Кто сильнее решает порядок.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p class=\"alert stealth\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": ".stealth",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#0000ff"}
      }
    ],
    "options": [
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"}
    ],
    "correct_option_id": "BLUE",
    "feedback_rules": {
      "ORDER_TIE": "Вес равный (10 и 10), побеждает правило ниже по файлу (order=2).",
      "OK": "Верно: одинаковый вес решает порядок."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-03",
    "briefing": "Есть !important. Не притворяйтесь, что его нет.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      },
      {
        "source_id": "R2",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": true,
        "order": 3,
        "decl": {"prop": "color", "value": "#ff0000"}
      }
    ],
    "options": [
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"}
    ],
    "correct_option_id": "RED",
    "feedback_rules": {
      "IMPORTANT_MISSED": "!important перебивает обычное правило, даже если селектор слабее.",
      "OK": "Верно: важность сильнее веса."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-04",
    "briefing": "Встроенный стиль на элементе. Он не для красоты.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\" style=\"color:#0000ff;\">Секретный код</p>"
    ],
    "inline_decl": {
      "source_id": "INLINE",
      "kind": "inline",
      "weight": 1000,
      "important": false,
      "decl": {"prop": "color", "value": "#0000ff"}
    },
    "rules": [
      {
        "source_id": "R1",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      },
      {
        "source_id": "R2",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 3,
        "decl": {"prop": "color", "value": "#ff0000"}
      }
    ],
    "options": [
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "RED", "label": "Красный", "value": "#ff0000"}
    ],
    "correct_option_id": "BLUE",
    "feedback_rules": {
      "INLINE_OVERRIDE": "Встроенный стиль (1000) перекрывает #id (100) и .class (10).",
      "OK": "Верно: встроенный стиль сильнее."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-05",
    "briefing": "Комбинированный селектор сильнее одиночного класса.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": "p#x",
        "kind": "mixed",
        "weight": 101,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#0000ff"}
      }
    ],
    "options": [
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"},
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"}
    ],
    "correct_option_id": "BLUE",
    "feedback_rules": {
      "SPECIFICITY_ERROR": "p#x (101) сильнее .alert (10).",
      "OK": "Верно: суммарный вес решает."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-06",
    "briefing": "Два ID-правила с !important. Побеждает более позднее.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": true,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": true,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      }
    ],
    "options": [
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"}
    ],
    "correct_option_id": "GREEN",
    "feedback_rules": {
      "ORDER_TIE": "Важность и вес равны, решает порядок (позже = сильнее).",
      "OK": "Верно: последняя директива выигрывает."
    }
  }
]
</file>

<file path="data/network_trace_a_levels.json">
[
  {
    "id": "NT_A_01",
    "incident_id": "INC_01",
    "briefing": "Трафик между офисом и серверной зоной остановился после обновления сегментации.",
    "prompt": "Какое устройство нужно для передачи трафика между разными подсетями?",
    "required_evidence": 2,
    "logs": [
      "SRC 192.168.1.10 -> DST 10.0.0.5 : NO ROUTE",
      "ARP работает внутри 192.168.1.0/24",
      "Таблица шлюза на хосте пуста"
    ],
    "topology": {
      "nodes": [
        "OfficeLAN",
        "SwitchA",
        "?",
        "SwitchB",
        "ServerLAN"
      ],
      "edges": [
        [
          "OfficeLAN",
          "SwitchA"
        ],
        [
          "SwitchA",
          "?"
        ],
        [
          "?",
          "SwitchB"
        ],
        [
          "SwitchB",
          "ServerLAN"
        ]
      ],
      "labels": {
        "OfficeLAN": "192.168.1.0/24",
        "ServerLAN": "10.0.0.0/24"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Маршрутизатор выполняет L3-маршрутизацию между подсетями.",
    "explain_full": "Разные сети требуют маршрутизации по IP-префиксу. Коммутатор пересылает кадры только внутри широковещательного домена. Хаб и повторитель — компоненты физического уровня.",
    "tags": [
      "routing",
      "subnet",
      "l3"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_02",
    "incident_id": "INC_01",
    "briefing": "Два VLAN пингуются внутри себя, но не между собой.",
    "prompt": "Выберите устройство, которое восстановит меж-VLAN связь.",
    "required_evidence": 2,
    "logs": [
      "Таймаут ping между VLAN 10 и VLAN 20",
      "MAC-таблицы на коммутаторах доступа в норме",
      "Нет ответа шлюза по умолчанию от интерфейсов VLAN"
    ],
    "topology": {
      "nodes": [
        "VLAN10",
        "AccessSW",
        "?",
        "CoreSW",
        "VLAN20"
      ],
      "edges": [
        [
          "VLAN10",
          "AccessSW"
        ],
        [
          "AccessSW",
          "?"
        ],
        [
          "?",
          "CoreSW"
        ],
        [
          "CoreSW",
          "VLAN20"
        ]
      ],
      "labels": {
        "VLAN10": "172.16.10.0/24",
        "VLAN20": "172.16.20.0/24"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "ap",
        "label": "Точка доступа",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Меж-VLAN трафику нужна L3-маршрутизация.",
    "explain_full": "Хостам в разных VLAN-подсетях нужен маршрутизирующий переход. Одной L2-пересылки недостаточно для внешних сетей.",
    "tags": [
      "vlan",
      "routing",
      "gateway"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_03",
    "incident_id": "INC_02",
    "briefing": "Широковещательный трафик резко вырос после замены пограничного оборудования.",
    "prompt": "Какое устройство нужно установить для изоляции доменов коллизий?",
    "required_evidence": 2,
    "logs": [
      "Счётчик коллизий растёт каждую секунду",
      "Кадры зеркалируются на все порты",
      "Только одна подсеть, маршрутизация не требуется"
    ],
    "topology": {
      "nodes": [
        "Clients",
        "?",
        "Printer",
        "NAS"
      ],
      "edges": [
        [
          "Clients",
          "?"
        ],
        [
          "?",
          "Printer"
        ],
        [
          "?",
          "NAS"
        ]
      ],
      "labels": {
        "Clients": "192.168.50.0/24"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор пересылает по MAC и сегментирует коллизии по портам.",
    "explain_full": "Симптом — локальное L2-заливание, а не маршрутизация подсетей. Коммутатор решает это пересылкой только на порт MAC-назначения.",
    "tags": [
      "switching",
      "collision",
      "lan"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_04",
    "incident_id": "INC_02",
    "briefing": "SOC сообщает, что каждый хост может прослушивать чужой офисный трафик.",
    "prompt": "Выберите замену, которая ограничивает широкую видимость кадров.",
    "required_evidence": 2,
    "logs": [
      "Промискуитетный захват видит все кадры рабочих станций",
      "В этом случае нет перехода между подсетями",
      "У текущего устройства нет MAC-таблицы"
    ],
    "topology": {
      "nodes": [
        "DeskA",
        "DeskB",
        "?",
        "DeskC",
        "DeskD"
      ],
      "edges": [
        [
          "DeskA",
          "?"
        ],
        [
          "DeskB",
          "?"
        ],
        [
          "DeskC",
          "?"
        ],
        [
          "DeskD",
          "?"
        ]
      ],
      "labels": {
        "DeskA": "Сегмент одной подсети"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "bridge",
        "label": "Мост",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор подавляет лишнюю заливку после изучения MAC.",
    "explain_full": "Поведение как у хаба раскрывает весь трафик. Коммутатор изучает MAC-адреса и перестаёт слать каждый кадр всем узлам.",
    "tags": [
      "security",
      "sniffing",
      "switch"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_05",
    "incident_id": "INC_03",
    "briefing": "Сигнал падает на длинном медном сегменте коридора.",
    "prompt": "Выберите компонент, который восстанавливает только физический сигнал.",
    "required_evidence": 2,
    "logs": [
      "Всплески CRC-ошибок после 92 м медного участка",
      "Ошибки адресации или политик не обнаружены",
      "Проблема возникает до разбора заголовков пакетов"
    ],
    "topology": {
      "nodes": [
        "Камера",
        "CableSpan",
        "?",
        "Коммутатор"
      ],
      "edges": [
        [
          "Камера",
          "CableSpan"
        ],
        [
          "CableSpan",
          "?"
        ],
        [
          "?",
          "Коммутатор"
        ]
      ],
      "labels": {
        "CableSpan": "Длинная медная линия"
      }
    },
    "options": [
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "repeater",
    "explain_short": "Повторитель регенерирует физический сигнал на длинных линиях.",
    "explain_full": "Этот инцидент — физическое затухание, а не адресация. Повторитель продлевает целостность сигнала, но не маршрутизирует и не фильтрует трафик.",
    "tags": [
      "physical",
      "crc",
      "repeater"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_06",
    "incident_id": "INC_03",
    "briefing": "Пограничная ветка не может достичь подсети HQ после миграции.",
    "prompt": "Какое устройство должно связать IP-сети филиала и HQ?",
    "required_evidence": 2,
    "logs": [
      "Сеть филиала 192.168.30.0/24 не может достичь 172.20.0.0/16",
      "Локальный ARP резолвится только внутри филиала",
      "Нет маршрутных записей для назначения штаб-квартиры"
    ],
    "topology": {
      "nodes": [
        "BranchLAN",
        "Коммутатор",
        "?",
        "WAN",
        "HQLAN"
      ],
      "edges": [
        [
          "BranchLAN",
          "Коммутатор"
        ],
        [
          "Коммутатор",
          "?"
        ],
        [
          "?",
          "WAN"
        ],
        [
          "WAN",
          "HQLAN"
        ]
      ],
      "labels": {
        "BranchLAN": "192.168.30.0/24",
        "HQLAN": "172.20.0.0/16"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "firewall",
        "label": "Межсетевой экран",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Для межсетевой пересылки требуется маршрутизатор.",
    "explain_full": "Разные префиксы требуют таблиц маршрутизации шлюза. L2-оборудование и пассивное железо не пересылают через маршрутизируемые границы.",
    "tags": [
      "wan",
      "routing",
      "gateway"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_07",
    "incident_id": "INC_04",
    "briefing": "Сеть складского этажа стала нестабильной после установки старого запасного устройства.",
    "prompt": "Какой выбор устройства предотвращает всплески коллизий в одной подсети?",
    "required_evidence": 2,
    "logs": [
      "Счётчики коллизий и поздних коллизий растут",
      "MAC назначения определяется, но кадры всё равно фладятся",
      "Все хосты остаются в одной подсети 10.10.40.0/24"
    ],
    "topology": {
      "nodes": [
        "ScannerA",
        "ScannerB",
        "?",
        "Controller"
      ],
      "edges": [
        [
          "ScannerA",
          "?"
        ],
        [
          "ScannerB",
          "?"
        ],
        [
          "Controller",
          "?"
        ]
      ],
      "labels": {
        "Controller": "Один L2-домен"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "bridge",
        "label": "Мост",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор изолирует трафик по портам и подавляет коллизии.",
    "explain_full": "В сценарии коллизий в одной подсети коммутатор — правильная точка L2-контроля. Маршрутизатор не решает локальные коллизии.",
    "tags": [
      "collision",
      "operations",
      "switch"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_08",
    "incident_id": "INC_04",
    "briefing": "Техник утверждает, что патч-панель может фильтровать доступ.",
    "prompt": "Выберите корректную техническую оценку.",
    "required_evidence": 2,
    "logs": [
      "Стойка содержит только пассивное патч-поле",
      "Процессор плоскости управления или таблица пересылки не обнаружены",
      "Перемаркировка панели не влияет на пакеты"
    ],
    "topology": {
      "nodes": [
        "UserLAN",
        "PatchRack",
        "?",
        "Core"
      ],
      "edges": [
        [
          "UserLAN",
          "PatchRack"
        ],
        [
          "PatchRack",
          "?"
        ],
        [
          "?",
          "Core"
        ]
      ],
      "labels": {
        "PatchRack": "Пассивная панель"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": ""
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      }
    ],
    "correct_id": "patch",
    "explain_short": "Патч-панель — пассивное кабельное оборудование.",
    "explain_full": "Патч-панель завершает и организует линии. Она не умеет маршрутизировать, коммутировать или фильтровать трафик, потому что не имеет логики пересылки.",
    "tags": [
      "passive",
      "rack",
      "hardware"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_09",
    "incident_id": "INC_05",
    "briefing": "После добавления гостевой подсети офисные хосты потеряли доступ к зоне ERP.",
    "prompt": "Какое устройство восстанавливает связь между офисом и подсетью ERP?",
    "required_evidence": 2,
    "logs": [
      "Office: 192.168.80.0/24, ERP: 192.168.120.0/24",
      "Хосты могут пинговать только локальный шлюз",
      "Логи коммутатора не содержат записей маршрутизации"
    ],
    "topology": {
      "nodes": [
        "Office",
        "AccessSW",
        "?",
        "DistSW",
        "ERP"
      ],
      "edges": [
        [
          "Office",
          "AccessSW"
        ],
        [
          "AccessSW",
          "?"
        ],
        [
          "?",
          "DistSW"
        ],
        [
          "DistSW",
          "ERP"
        ]
      ],
      "labels": {
        "Office": "192.168.80.0/24",
        "ERP": "192.168.120.0/24"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "firewall",
        "label": "Межсетевой экран",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Разным подсетям нужен путь L3-маршрутизации.",
    "explain_full": "Даже при исправных коммутаторах пакеты не проходят между префиксами подсетей без маршрутизации.",
    "tags": [
      "subnet",
      "erp",
      "router"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_10",
    "incident_id": "INC_05",
    "briefing": "Мониторинг показывает, что пакеты копируются на все порты сегмента этажа.",
    "prompt": "Выберите устройство-замену для выборочной пересылки кадров.",
    "required_evidence": 2,
    "logs": [
      "SPAN фиксирует одинаковые копии кадров на каждом порту",
      "Нет задачи соединять разные IP-сети",
      "Флад неизвестного unicast сохраняется на старом оборудовании"
    ],
    "topology": {
      "nodes": [
        "Desk1",
        "Desk2",
        "?",
        "Desk3",
        "Desk4"
      ],
      "edges": [
        [
          "Desk1",
          "?"
        ],
        [
          "Desk2",
          "?"
        ],
        [
          "Desk3",
          "?"
        ],
        [
          "Desk4",
          "?"
        ]
      ],
      "labels": {
        "Desk1": "Один офисный сегмент"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор изучает назначения и пересылает выборочно.",
    "explain_full": "Заливка как у хаба указывает на отсутствие MAC-пересылки. Коммутатор пересылает по портам и снижает раскрытие трафика.",
    "tags": [
      "mac",
      "forwarding",
      "switch"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_11",
    "incident_id": "INC_06",
    "briefing": "Связь с удалённым датчиком срывается на длинной кабельной линии в цехе.",
    "prompt": "Какой компонент напрямую решает проблему физического затухания?",
    "required_evidence": 2,
    "logs": [
      "Уровень сигнала ухудшается после длинного медного участка",
      "Заголовки пакетов содержат корректные адреса до сброса",
      "Проблема повторяется независимо от конфигурации подсети"
    ],
    "topology": {
      "nodes": [
        "Sensor",
        "LongRun",
        "?",
        "EdgeSwitch"
      ],
      "edges": [
        [
          "Sensor",
          "LongRun"
        ],
        [
          "LongRun",
          "?"
        ],
        [
          "?",
          "EdgeSwitch"
        ]
      ],
      "labels": {
        "LongRun": "Промышленная кабельная линия"
      }
    },
    "options": [
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "repeater",
    "explain_short": "Повторитель восстанавливает целостность сигнала на длинных линиях.",
    "explain_full": "Физическое затухание — проблема L1. Повторитель регенерирует сигнал без изменения логики пересылки.",
    "tags": [
      "factory",
      "physical",
      "l1"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_12",
    "incident_id": "INC_06",
    "briefing": "Операторы вставили хаб между офисной и дата-центровой линиями.",
    "prompt": "Выберите правильную замену для стабилизации трафика и сохранения сегментации.",
    "required_evidence": 2,
    "logs": [
      "После изменения резко выросли тревоги широковещания и коллизий",
      "Здесь не требуется межподсеточная маршрутизация",
      "Целевые хосты находятся в одном IP-сегменте"
    ],
    "topology": {
      "nodes": [
        "Office",
        "?",
        "DC Switch"
      ],
      "edges": [
        [
          "Office",
          "?"
        ],
        [
          "?",
          "DC Switch"
        ]
      ],
      "labels": {
        "Office": "10.40.0.0/24",
        "DC Switch": "Одна подсеть"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "bridge",
        "label": "Мост",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор корректен для сегментированной пересылки в одной подсети.",
    "explain_full": "Проблема в L2-широковещании и коллизиях. Коммутатор решает это MAC-пересылкой и снижением шумной заливки.",
    "tags": [
      "broadcast",
      "switch",
      "stability"
    ],
    "time_limit_sec": 120
  }
]
</file>

<file path="data/network_trace_b_levels.json">
[
  {
    "id": "NT_B_01",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 525 KB, окно 64 с. Вычислите скорость в бит/с.",
    "payload_value": 525,
    "payload_unit": "KB",
    "time_sec": 64,
    "ask_unit": "bps",
    "expected_bps": 67200,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_01_OPT1",
        "label": "67200 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_01_OPT2",
        "label": "8400 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_01_OPT3",
        "label": "65625 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_01_OPT4",
        "label": "4300800 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_01_OPT5",
        "label": "67.200 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_01_OPT6",
        "label": "87329 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_01_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 67200 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 525 KB.",
      "Окно до блокировки: 64 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_02",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 256 KB, окно 4 с. Вычислите скорость в бит/с.",
    "payload_value": 256,
    "payload_unit": "KB",
    "time_sec": 4,
    "ask_unit": "bps",
    "expected_bps": 524288,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_02_OPT1",
        "label": "524288 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_02_OPT2",
        "label": "65536 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_02_OPT3",
        "label": "512000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_02_OPT4",
        "label": "2097152 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_02_OPT5",
        "label": "524.288 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_02_OPT6",
        "label": "533804 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_02_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 524288 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 256 KB.",
      "Окно до блокировки: 4 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_03",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 768 KB, окно 3 с. Вычислите скорость в бит/с.",
    "payload_value": 768,
    "payload_unit": "KB",
    "time_sec": 3,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_03_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_03_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_03_OPT3",
        "label": "2048000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_03_OPT4",
        "label": "6291456 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_03_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_03_OPT6",
        "label": "2125601 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_03_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 768 KB.",
      "Окно до блокировки: 3 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_04",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 64 KB, окно 2 с. Вычислите скорость в бит/с.",
    "payload_value": 64,
    "payload_unit": "KB",
    "time_sec": 2,
    "ask_unit": "bps",
    "expected_bps": 262144,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_04_OPT1",
        "label": "262144 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_04_OPT2",
        "label": "32768 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_04_OPT3",
        "label": "256000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_04_OPT4",
        "label": "524288 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_04_OPT5",
        "label": "262.144 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_04_OPT6",
        "label": "264534 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_04_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 262144 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 64 KB.",
      "Окно до блокировки: 2 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_05",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 320 KB, окно 5 с. Вычислите скорость в бит/с.",
    "payload_value": 320,
    "payload_unit": "KB",
    "time_sec": 5,
    "ask_unit": "bps",
    "expected_bps": 524288,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_05_OPT1",
        "label": "524288 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_05_OPT2",
        "label": "65536 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_05_OPT3",
        "label": "512000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_05_OPT4",
        "label": "2621440 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_05_OPT5",
        "label": "524.288 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_05_OPT6",
        "label": "536183 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_05_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 524288 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 320 KB.",
      "Окно до блокировки: 5 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_06",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 1536 KB, окно 6 с. Вычислите скорость в бит/с.",
    "payload_value": 1536,
    "payload_unit": "KB",
    "time_sec": 6,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_06_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_06_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_06_OPT3",
        "label": "2048000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_06_OPT4",
        "label": "12582912 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_06_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_06_OPT6",
        "label": "2154050 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_06_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 1536 KB.",
      "Окно до блокировки: 6 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_07",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 2 MB, окно 8 с. Вычислите скорость в бит/с.",
    "payload_value": 2,
    "payload_unit": "MB",
    "time_sec": 8,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_07_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_07_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_07_OPT3",
        "label": "2000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_07_OPT4",
        "label": "16777216 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_07_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_07_OPT6",
        "label": "2097314 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_07_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 2 MB.",
      "Окно до блокировки: 8 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_08",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 5 MB, окно 10 с. Вычислите скорость в бит/с.",
    "payload_value": 5,
    "payload_unit": "MB",
    "time_sec": 10,
    "ask_unit": "bps",
    "expected_bps": 4194304,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_08_OPT1",
        "label": "4194304 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_08_OPT2",
        "label": "524288 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_08_OPT3",
        "label": "4000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_08_OPT4",
        "label": "41943040 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_08_OPT5",
        "label": "4194.304 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_08_OPT6",
        "label": "4194599 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_08_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 4194304 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 5 MB.",
      "Окно до блокировки: 10 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_09",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 12 MB, окно 48 с. Вычислите скорость в бит/с.",
    "payload_value": 12,
    "payload_unit": "MB",
    "time_sec": 48,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_09_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_09_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_09_OPT3",
        "label": "2000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_09_OPT4",
        "label": "100663296 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_09_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_09_OPT6",
        "label": "2098124 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_09_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 12 MB.",
      "Окно до блокировки: 48 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_10",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 9 MB, окно 36 с. Вычислите скорость в бит/с.",
    "payload_value": 9,
    "payload_unit": "MB",
    "time_sec": 36,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_10_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_10_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_10_OPT3",
        "label": "2000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_10_OPT4",
        "label": "75497472 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_10_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_10_OPT6",
        "label": "2097881 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_10_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 9 MB.",
      "Окно до блокировки: 36 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_11",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 600 KB, окно 75 с. Вычислите скорость в бит/с.",
    "payload_value": 600,
    "payload_unit": "KB",
    "time_sec": 75,
    "ask_unit": "bps",
    "expected_bps": 65536,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_11_OPT1",
        "label": "65536 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_11_OPT2",
        "label": "8192 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_11_OPT3",
        "label": "64000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_11_OPT4",
        "label": "4915200 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_11_OPT5",
        "label": "65.536 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_11_OPT6",
        "label": "88561 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_11_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 65536 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 600 KB.",
      "Окно до блокировки: 75 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_12",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 840 KB, окно 64 с. Вычислите скорость в бит/с.",
    "payload_value": 840,
    "payload_unit": "KB",
    "time_sec": 64,
    "ask_unit": "bps",
    "expected_bps": 107520,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_12_OPT1",
        "label": "107520 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_12_OPT2",
        "label": "13440 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_12_OPT3",
        "label": "105000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_12_OPT4",
        "label": "6881280 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_12_OPT5",
        "label": "107.520 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_12_OPT6",
        "label": "139304 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_12_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 107520 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 840 KB.",
      "Окно до блокировки: 64 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_13",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 700 KB, окно 40 с. Вычислите скорость в кбит/с.",
    "payload_value": 700,
    "payload_unit": "KB",
    "time_sec": 40,
    "ask_unit": "kbps",
    "expected_bps": 143360,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_13_OPT1",
        "label": "143.360 kbps",
        "error_code": ""
      },
      {
        "id": "NT_B_13_OPT2",
        "label": "17.920 kbps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_13_OPT3",
        "label": "140.000 kbps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_13_OPT4",
        "label": "5734.400 kbps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_13_OPT5",
        "label": "143360 bps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_13_OPT6",
        "label": "169.700 kbps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_13_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 143360 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 700 KB.",
      "Окно до блокировки: 40 s.",
      "Требуемый вывод: кбит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "kbps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_14",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 1500 KB, окно 48 с. Вычислите скорость в кбит/с.",
    "payload_value": 1500,
    "payload_unit": "KB",
    "time_sec": 48,
    "ask_unit": "kbps",
    "expected_bps": 256000,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_14_OPT1",
        "label": "256.000 kbps",
        "error_code": ""
      },
      {
        "id": "NT_B_14_OPT2",
        "label": "32.000 kbps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_14_OPT3",
        "label": "250.000 kbps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_14_OPT4",
        "label": "12288.000 kbps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_14_OPT5",
        "label": "256000 bps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_14_OPT6",
        "label": "312.028 kbps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_14_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 256000 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 1500 KB.",
      "Окно до блокировки: 48 s.",
      "Требуемый вывод: кбит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "kbps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_15",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 3 MB, окно 16 с. Вычислите скорость в кбит/с.",
    "payload_value": 3,
    "payload_unit": "MB",
    "time_sec": 16,
    "ask_unit": "kbps",
    "expected_bps": 1572864,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_15_OPT1",
        "label": "1572.864 kbps",
        "error_code": ""
      },
      {
        "id": "NT_B_15_OPT2",
        "label": "196.608 kbps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_15_OPT3",
        "label": "1500.000 kbps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_15_OPT4",
        "label": "25165.824 kbps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_15_OPT5",
        "label": "1572864 bps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_15_OPT6",
        "label": "1573.151 kbps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_15_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 1572864 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 3 MB.",
      "Окно до блокировки: 16 s.",
      "Требуемый вывод: кбит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "kbps",
      "mb"
    ],
    "time_limit_sec": 120
  }
]
</file>

<file path="icon.svg.import">
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://dwa13v3b7okhp"
path="res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.svg"
dest_files=["res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=false
editor/convert_colors_with_editor_theme=false
</file>

<file path="scenes/case_01/CluesQuestA.gd">
extends Control

const CLUES_DATA_PATH = "res://data/clues_levels.json"
const ITEM_SCENE = preload("res://scenes/ui/ClueItem.tscn")
const BUCKET_SCRIPT = preload("res://scripts/ui/ClueBucketZone.gd")

@onready var title_label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar = $SafeArea/MainVBox/Header/StabilityBar
@onready var briefing_label = $SafeArea/MainVBox/BriefingCard/BriefingLabel
@onready var pool_grid = $SafeArea/MainVBox/WorkArea/PoolCard/VBox/ItemsFlow
@onready var bucket_input = $SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput
@onready var bucket_output = $SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput
@onready var bucket_memory = $SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory
@onready var status_label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_confirm = $SafeArea/MainVBox/BottomBar/BtnConfirm
@onready var btn_back = $SafeArea/MainVBox/Header/BtnBack
@onready var result_popup = $ResultPopup
@onready var dimmer = $Dimmer

@onready var res_label_verdict = $ResultPopup/VBox/VerdictLabel
@onready var res_label_score = $ResultPopup/VBox/ScoreLabel
@onready var res_label_stability = $ResultPopup/VBox/StabilityLabel
@onready var res_btn_retry = $ResultPopup/VBox/HBox/BtnRetry
@onready var res_btn_back = $ResultPopup/VBox/HBox/BtnBack

var level_data: Dictionary = {}
var current_level_idx: int = 0
var drag_count: int = 0
var start_time: int = 0

func _ready():
	_connect_signals()
	_load_level_data()

func _connect_signals():
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	res_btn_retry.pressed.connect(_on_retry_pressed)
	res_btn_back.pressed.connect(_on_back_pressed)

func _load_level_data():
	var file = FileAccess.open(CLUES_DATA_PATH, FileAccess.READ)
	if not file:
		_show_error("Не удалось загрузить данные уровня")
		return

	var json = JSON.new()
	var error = json.parse(file.get_as_text())
	if error != OK:
		_show_error("Ошибка разбора JSON: " + json.get_error_message())
		return

	var data = json.data
	if typeof(data) != TYPE_ARRAY or data.is_empty():
		_show_error("Некорректный формат JSON")
		return

	# Assume first level for A
	level_data = data[0]
	if not _validate_level(level_data):
		_show_error("Проверка данных уровня не пройдена")
		return

	_setup_ui()

func _validate_level(data: Dictionary) -> bool:
	if not data.has_all(["id", "format", "buckets", "items", "scoring_rules"]):
		return false
	if data.format != "MATCHING": return false
	if data.buckets.size() != 3: return false
	if data.items.size() != 8: return false
	return true

func _setup_ui():
	title_label.text = "ДЕЛО №1: УЛИКИ В МУСОРЕ"
	stage_label.text = "ЭТАП A"
	briefing_label.text = level_data.get("briefing", "")
	stability_bar.value = GlobalMetrics.stability

	# Setup Buckets
	if bucket_input.has_method("setup"):
		bucket_input.setup("INPUT", "ВВОД")
	if bucket_output.has_method("setup"):
		bucket_output.setup("OUTPUT", "ВЫВОД")
	if bucket_memory.has_method("setup"):
		bucket_memory.setup("MEMORY", "ПАМЯТЬ")

	# Setup Pool (PoolCard has the script)
	var pool_card = $SafeArea/MainVBox/WorkArea/PoolCard
	if pool_card.has_method("setup"):
		pool_card.setup("POOL", "СВАЛКА")

	_spawn_items()
	start_time = Time.get_ticks_msec()
	drag_count = 0

	result_popup.hide()
	dimmer.hide()
	btn_confirm.disabled = false
	status_label.text = "Рассортируйте улики..."

func _spawn_items():
	# Clear existing items
	for child in pool_grid.get_children():
		child.queue_free()
	for bucket in [bucket_input, bucket_output, bucket_memory]:
		var flow = bucket.get_node_or_null("VBox/ItemsFlow")
		if flow:
			for child in flow.get_children():
				child.queue_free()

	# Spawn new items
	var items = level_data.items.duplicate()
	items.shuffle()

	for item_info in items:
		var item = ITEM_SCENE.instantiate()
		pool_grid.add_child(item)
		item.setup(item_info)

func _on_reset_pressed():
	_spawn_items()
	status_label.text = "Сброс выполнен"
	status_label.add_theme_color_override("font_color", Color("ffb000")) # Theme color
	AudioManager.play("relay")
	drag_count = 0

func _on_confirm_pressed():
	var snapshot = {}
	var assigned_count = 0

	# Check buckets
	for bucket in [bucket_input, bucket_output, bucket_memory]:
		var flow = bucket.get_node_or_null("VBox/ItemsFlow")
		if flow:
			for child in flow.get_children():
				if child.has_method("setup"): # Is ClueItem
					snapshot[child.item_id] = bucket.bucket_id
					assigned_count += 1

	# Check pool
	for child in pool_grid.get_children():
		if child.has_method("setup"):
			snapshot[child.item_id] = "POOL"

	if assigned_count < 8:
		status_label.text = "Не все улики распределены!"
		status_label.add_theme_color_override("font_color", Color(1, 1, 0)) # Yellow
		AudioManager.play("error")
		# Proceed despite warning as per spec

	var result = _calculate_scoring(snapshot)
	_show_result(result, snapshot)

func _calculate_scoring(snapshot: Dictionary) -> Dictionary:
	var correct_count = 0
	for item in level_data.items:
		var iid = item.item_id
		var correct = item.correct_bucket_id
		var actual = snapshot.get(iid, "POOL")
		if actual == correct:
			correct_count += 1

	var points = 0
	var stability_delta = -30
	var verdict = "FAIL"
	var is_fit = false
	var is_correct = false

	if correct_count == 8:
		points = 2
		stability_delta = 0
		verdict = "PERFECT"
		is_fit = true
		is_correct = true
	elif correct_count >= 6:
		points = 1
		stability_delta = -10
		verdict = "PARTIAL"
		is_fit = true
		is_correct = false
	else:
		points = 0
		stability_delta = -30
		verdict = "FAIL"
		is_fit = false
		is_correct = false

	return {
		"points": points,
		"max_points": 2,
		"is_fit": is_fit,
		"is_correct": is_correct,
		"stability_delta": stability_delta,
		"correct_count": correct_count,
		"total_items": 8,
		"verdict_code": verdict
	}

func _show_result(result: Dictionary, snapshot: Dictionary):
	var elapsed_ms = Time.get_ticks_msec() - start_time
	var payload = {
		"quest_id": "CASE_01_CLUES",
		"level_id": level_data.id,
		"stage": "A",
		"format": "MATCHING",
		"match_key": "CL_A_%s_%d" % [level_data.id, GlobalMetrics.session_history.size()],
		"snapshot": snapshot,
		"correct_count": result.correct_count,
		"total_items": result.total_items,
		"points": result.points,
		"max_points": result.max_points,
		"is_fit": result.is_fit,
		"is_correct": result.is_correct,
		"stability_delta": result.stability_delta,
		"verdict_code": result.verdict_code,
		"drag_count": drag_count,
		"elapsed_ms": elapsed_ms
	}
	GlobalMetrics.register_trial(payload)

	dimmer.show()
	result_popup.show()
	res_label_verdict.text = result.verdict_code
	res_label_score.text = "Верно: %d/%d\nБаллы: %d/%d" % [result.correct_count, result.total_items, result.points, result.max_points]
	res_label_stability.text = "Стабильность: %d" % result.stability_delta

	if result.is_correct:
		AudioManager.play("click")
		res_label_verdict.modulate = Color(0, 1, 0)
	elif result.is_fit:
		AudioManager.play("click")
		res_label_verdict.modulate = Color(1, 1, 0)
	else:
		AudioManager.play("error")
		res_label_verdict.modulate = Color(1, 0, 0)

	# Block interaction
	btn_confirm.disabled = true

func _on_retry_pressed():
	result_popup.hide()
	dimmer.hide()
	btn_confirm.disabled = false
	_on_reset_pressed()

func _on_back_pressed():
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _show_error(msg):
	status_label.text = msg
	status_label.add_theme_color_override("font_color", Color(1, 0, 0))
</file>

<file path="scenes/case_08/fr8_final_report_b.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scripts/case_08/fr8_final_report_b.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(1, 0.7, 0.1, 1)
shader_parameter/intensity = 0.13
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="FR8_FinalReportB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.06, 0.06, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(116, 56)
layout_mode = 2
text = "НАЗАД"

[node name="TitleLabel" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #8: ФИНАЛЬНЫЙ ОТЧЁТ [B]"
vertical_alignment = 1

[node name="LevelLabel" type="Label" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(240, 0)
layout_mode = 2
text = "B"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(210, 24)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="BriefingLabel" type="RichTextLabel" parent="SafeArea/MainLayout/BriefingCard"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
text = "Брифинг"
fit_content = false
scroll_active = false

[node name="TimelineCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CardVBox" type="VBoxContainer" parent="SafeArea/MainLayout/TimelineCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="AxisRow" type="HBoxContainer" parent="SafeArea/MainLayout/TimelineCard/CardVBox"]
layout_mode = 2

[node name="AxisLeft" type="Label" parent="SafeArea/MainLayout/TimelineCard/CardVBox/AxisRow"]
layout_mode = 2
text = "ПРОШЛОЕ"

[node name="AxisSpacer" type="Control" parent="SafeArea/MainLayout/TimelineCard/CardVBox/AxisRow"]
layout_mode = 2
size_flags_horizontal = 3

[node name="AxisRight" type="Label" parent="SafeArea/MainLayout/TimelineCard/CardVBox/AxisRow"]
layout_mode = 2
text = "БУДУЩЕЕ"
horizontal_alignment = 2

[node name="CardsRow" type="HBoxContainer" parent="SafeArea/MainLayout/TimelineCard/CardVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "Статус"
autowrap_mode = 2
vertical_alignment = 1

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnReset" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(170, 56)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(220, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПОДТВЕРДИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
disabled = true
text = "ДАЛЕЕ"
</file>

<file path="scenes/case_08/fr8_final_report_c.tscn">
[gd_scene load_steps=7 format=3]

[ext_resource type="Script" path="res://scripts/case_08/fr8_final_report_c.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="PackedScene" path="res://scenes/ui/InspectorPopup.tscn" id="4_popup"]
[ext_resource type="PackedScene" path="res://scenes/ui/InspectBadge.tscn" id="5_badge"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(1, 0.7, 0.1, 1)
shader_parameter/intensity = 0.13
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="FR8_FinalReportC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.06, 0.06, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(116, 56)
layout_mode = 2
text = "НАЗАД"

[node name="TitleLabel" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #8: ФИНАЛЬНЫЙ ОТЧЁТ [C]"
vertical_alignment = 1

[node name="LevelLabel" type="Label" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(240, 0)
layout_mode = 2
text = "C"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(210, 24)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainLayout/BriefingCard"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "Брифинг"
autowrap_mode = 3
vertical_alignment = 1

[node name="Body" type="BoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="CodeCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CodeVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/CodeCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="CodeTitle" type="Label" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "КОД"

[node name="HtmlLabel" type="RichTextLabel" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false
text = "HTML"

[node name="CssLabel" type="RichTextLabel" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
bbcode_enabled = true
fit_content = false
text = "CSS"

[node name="HintRow" type="HBoxContainer" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="InspectBadge" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox/HintRow" instance=ExtResource("5_badge")]
layout_mode = 2

[node name="HintLine" type="Label" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox/HintRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "Нажмите по селектору для ПРОСМОТРА."
vertical_alignment = 1

[node name="DecryptCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="DecVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/DecryptCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="DecTitle" type="Label" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ДЕШИФРАТОР"

[node name="TargetPreview" type="Label" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 26
text = "Секретный код"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StrengthRow" type="HBoxContainer" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="AttackBar" type="ProgressBar" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
size_flags_horizontal = 3
max_value = 11000.0
show_percentage = false

[node name="DefenseBar" type="ProgressBar" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
size_flags_horizontal = 3
max_value = 11000.0
show_percentage = false

[node name="OptionsVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ExplainLabel" type="Label" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "Объяснение"
autowrap_mode = 3
vertical_alignment = 1

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "Статус"
autowrap_mode = 2
vertical_alignment = 1

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnReset" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(170, 56)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(220, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПОДТВЕРДИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
disabled = true
text = "ДАЛЕЕ"

[node name="InspectorPopup" parent="." instance=ExtResource("4_popup")]
</file>

<file path="scenes/Decryptor.tscn">
[gd_scene load_steps=3 format=3 uid="uid://bx4x0id1k60k4"]

[ext_resource type="Script" path="res://scenes/Decryptor.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://c4p1o1h01r4g6" path="res://scenes/decryptor/DecryptorUI.tscn" id="2_ui"]

[node name="Дешифратор" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="UI" parent="." instance=ExtResource("2_ui")]
layout_mode = 1
</file>

<file path="scenes/MainMenu.tscn">
[gd_scene load_steps=4 format=3 uid="uid://bdk0pnntt5iu8"]

[ext_resource type="Script" path="res://scenes/MainMenu.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://ckh2j4fimo232" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="MainMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.04, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]

[node name="Center" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Menu" type="VBoxContainer" parent="Center"]
custom_minimum_size = Vector2(520, 0)
layout_mode = 2
theme_override_constants/separation = 18
alignment = 1

[node name="Title" type="Label" parent="Center/Menu"]
layout_mode = 2
theme_override_colors/font_color = Color(0.96, 0.96, 0.96, 1)
theme_override_font_sizes/font_size = 56
text = "UNTformatic: Noir Protocol"
horizontal_alignment = 1

[node name="NotebookArea" type="Button" parent="Center/Menu"]
custom_minimum_size = Vector2(520, 64)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "КВЕСТЫ"

[node name="PapersArea" type="Button" parent="Center/Menu"]
custom_minimum_size = Vector2(520, 64)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ОБУЧЕНИЕ"

[node name="LaptopArea" type="Button" parent="Center/Menu"]
custom_minimum_size = Vector2(520, 64)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 22
disabled = true
text = "ЛАБОРАТОРИЯ (СКОРО)"
</file>

<file path="scenes/ui/ClueItem.tscn">
[gd_scene load_steps=2 format=3 uid="uid://clueitem001"]

[ext_resource type="Script" path="res://scripts/ui/ClueItem.gd" id="1_clue"]

[node name="ClueItem" type="Button"]
custom_minimum_size = Vector2(0, 80)
offset_right = 120.0
offset_bottom = 80.0
theme_type_variation = &"FlatButton"
text = "ЭЛЕМЕНТ"
script = ExtResource("1_clue")
</file>

<file path="scenes/ui/InspectBadge.tscn">
[gd_scene format=3]

[node name="InspectBadge" type="PanelContainer"]
custom_minimum_size = Vector2(92, 28)

[node name="Label" type="Label" parent="."]
layout_mode = 2
text = "ПРОСМОТР"
horizontal_alignment = 1
vertical_alignment = 1
</file>

<file path="scenes/ui/InspectorPopup.tscn">
[gd_scene load_steps=3 format=3]

[ext_resource type="Script" path="res://scripts/ui/InspectorPopup.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]

[node name="InspectorPopup" type="PopupPanel"]
initial_position = 1
size = Vector2i(560, 360)
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Root" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 10

[node name="LblTitle" type="Label" parent="Root"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ПРОСМОТР"
horizontal_alignment = 1

[node name="Info" type="GridContainer" parent="Root"]
layout_mode = 2
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 6
columns = 2

[node name="LblSelectorKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Селектор:"

[node name="LblSelectorValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "-"
autowrap_mode = 3

[node name="LblKindKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Тип:"

[node name="LblKindValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "-"

[node name="LblWeightKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Вес:"

[node name="LblWeightValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "0"

[node name="LblImportantKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "!important:"

[node name="LblImportantValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "НЕТ"

[node name="LblOrderKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Порядок:"

[node name="LblOrderValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "0"

[node name="LblColorKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Цвет:"

[node name="LblColorValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "-"

[node name="BtnClose" type="Button" parent="Root"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scenes/ui/NetItem.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/NetItem.gd" id="1_script"]

[node name="NetItem" type="Button"]
custom_minimum_size = Vector2(0, 92)
size_flags_horizontal = 3
theme_type_variation = &"FlatButton"
theme_override_font_sizes/font_size = 18
text = "Сетевой модуль"
script = ExtResource("1_script")
</file>

<file path="scenes/ui/NetSlot.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/NetSlot.gd" id="1_script"]

[node name="NetSlot" type="PanelContainer"]
custom_minimum_size = Vector2(0, 118)
size_flags_horizontal = 3
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="VBox" type="VBoxContainer" parent="Margin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="TopRow" type="HBoxContainer" parent="Margin/VBox"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="SlotTitle" type="Label" parent="Margin/VBox/TopRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "КАНАЛ 1"
vertical_alignment = 1

[node name="BtnClear" type="Button" parent="Margin/VBox/TopRow"]
custom_minimum_size = Vector2(36, 30)
layout_mode = 2
text = "X"

[node name="ItemLabel" type="Label" parent="Margin/VBox"]
layout_mode = 2
text = "<пусто>"
horizontal_alignment = 1
vertical_alignment = 1
autowrap_mode = 2

[node name="ItemHolder" type="VBoxContainer" parent="Margin/VBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
size_flags_horizontal = 3
</file>

<file path="scenes/ui/network_trace/NetworkTraceDeviceCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/network_trace/network_trace_device_card.gd" id="1_script"]

[node name="NetworkTraceDeviceCard" type="Button"]
custom_minimum_size = Vector2(170, 78)
size_flags_horizontal = 3
text = "УСТРОЙСТВО"
script = ExtResource("1_script")
</file>

<file path="scenes/ui/pipeline/ModuleCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/pipeline/ModuleCard.gd" id="1_script"]

[node name="ModuleCard" type="PanelContainer"]
custom_minimum_size = Vector2(128, 66)
mouse_filter = 1
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 6

[node name="Label" type="Label" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_alignment = 1
vertical_alignment = 1
text = "МОДУЛЬ"
</file>

<file path="scenes/ui/pipeline/PipelineSlot.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/pipeline/PipelineSlot.gd" id="1_script"]

[node name="PipelineSlot" type="PanelContainer"]
custom_minimum_size = Vector2(158, 114)
mouse_filter = 1
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="VBox" type="VBoxContainer" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="LabelSlotTitle" type="Label" parent="Margin/VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "СЛОТ"

[node name="LabelModuleName" type="Label" parent="Margin/VBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
size_flags_horizontal = 3
horizontal_alignment = 1
vertical_alignment = 1
text = "<пусто>"

[node name="BtnClear" type="Button" parent="Margin/VBox"]
custom_minimum_size = Vector2(0, 34)
layout_mode = 2
size_flags_horizontal = 3
text = "ОЧИСТИТЬ"
</file>

<file path="scenes/ui/ResultStamp.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/ResultStamp.gd" id="1_script"]

[node name="ResultStamp" type="Control"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_script")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="StampPanel" type="PanelContainer" parent="CenterContainer"]
custom_minimum_size = Vector2(300, 112)
layout_mode = 2
modulate = Color(1, 1, 1, 0)

[node name="Margin" type="MarginContainer" parent="CenterContainer/StampPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 14
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 14

[node name="StampLabel" type="Label" parent="CenterContainer/StampPanel/Margin"]
layout_mode = 2
theme_override_font_sizes/font_size = 44
text = "ПОДТВЕРЖДЕНО"
horizontal_alignment = 1
vertical_alignment = 1
</file>

<file path="scenes/ui/subnet/LockIndicator.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/LockIndicator.gd" id="1_script"]

[node name="LockIndicator" type="PanelContainer"]
custom_minimum_size = Vector2(0, 56)
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 6

[node name="LabelState" type="Label" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_alignment = 1
vertical_alignment = 1
theme_override_font_sizes/font_size = 22
text = "ЗАБЛОКИРОВАНО"
</file>

<file path="scenes/ui/subnet/MaskOverlay.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/MaskOverlay.gd" id="1_script"]

[node name="MaskOverlay" type="PanelContainer"]
custom_minimum_size = Vector2(142, 72)
mouse_filter = 1
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 6

[node name="LabelMask" type="Label" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_alignment = 1
vertical_alignment = 1
text = "МАСКА ?"
</file>

<file path="scenes/ui/TagFragmentItem.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TagFragmentItem.gd" id="1_script"]

[node name="TagFragmentItem" type="Button"]
custom_minimum_size = Vector2(0, 72)
size_flags_horizontal = 3
theme_type_variation = &"FlatButton"
text = "<li>фрагмент</li>"
script = ExtResource("1_script")
</file>

<file path="scenes/ui/TagSlotZone.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TagSlotZone.gd" id="1_script"]

[node name="TagSlotZone" type="PanelContainer"]
custom_minimum_size = Vector2(0, 96)
size_flags_horizontal = 3
script = ExtResource("1_script")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 4

[node name="SlotTitle" type="Label" parent="VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "СЛОТ"
horizontal_alignment = 1

[node name="Center" type="CenterContainer" parent="VBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Items" type="VBoxContainer" parent="VBox/Center"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
</file>

<file path="scenes/ui/TimelineCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TimelineCard.gd" id="1_script"]

[node name="TimelineCard" type="PanelContainer"]
custom_minimum_size = Vector2(220, 120)
size_flags_horizontal = 3
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="VBox" type="VBoxContainer" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="Header" type="HBoxContainer" parent="Margin/VBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="StageTitle" type="Label" parent="Margin/VBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 18
text = "Этап"
autowrap_mode = 3
vertical_alignment = 1

[node name="StageHintBtn" type="Button" parent="Margin/VBox/Header"]
custom_minimum_size = Vector2(36, 36)
layout_mode = 2
text = "i"

[node name="Controls" type="HBoxContainer" parent="Margin/VBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 8

[node name="BtnLeft" type="Button" parent="Margin/VBox/Controls"]
custom_minimum_size = Vector2(0, 42)
layout_mode = 2
size_flags_horizontal = 3
text = "<"

[node name="BtnRight" type="Button" parent="Margin/VBox/Controls"]
custom_minimum_size = Vector2(0, 42)
layout_mode = 2
size_flags_horizontal = 3
text = ">"
</file>

<file path="scripts/case_08/fr8_final_report_b.gd">
extends Control

const LEVELS_PATH := "res://data/final_report_b_levels.json"
const SESSION_LEVEL_COUNT := 6
const FR8BData := preload("res://scripts/case_08/fr8b_data.gd")
const FR8BScoring := preload("res://scripts/case_08/fr8b_scoring.gd")
const TIMELINE_CARD_SCENE: PackedScene = preload("res://scenes/ui/TimelineCard.tscn")

const COLOR_OK := Color(0.55, 0.95, 0.62, 1.0)
const COLOR_WARN := Color(1.0, 0.82, 0.35, 1.0)
const COLOR_ERR := Color(1.0, 0.45, 0.45, 1.0)
const COLOR_INFO := Color(0.84, 0.84, 0.84, 1.0)

const TEXT_TITLE := "\u0414\u0415\u041b\u041e #8: \u0424\u0418\u041d\u0410\u041b\u042c\u041d\u042b\u0419 \u041e\u0422\u0427\u0415\u0422 [B]"
const TEXT_BACK := "\u041d\u0410\u0417\u0410\u0414"
const TEXT_RESET := "\u0421\u0411\u0420\u041e\u0421"
const TEXT_CONFIRM := "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TEXT_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TEXT_FINISH := "\u0417\u0410\u0412\u0415\u0420\u0428\u0418\u0422\u042c"

const STATUS_HINT := "\u0412\u044b\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u044d\u0442\u0430\u043f\u044b \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0437\u0430\u0442\u0435\u043c \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c."
const STATUS_NEXT_HINT := "\u041f\u043b\u0430\u043d \u0443\u0442\u0432\u0435\u0440\u0436\u0434\u0451\u043d. \u0416\u043c\u0438\u0442\u0435 \u0414\u0410\u041b\u0415\u0415."
const STATUS_SOLVE_FIRST := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u0435 \u0443\u0440\u043e\u0432\u0435\u043d\u044c."

var levels: Array = []
var current_level_index: int = 0
var level_data: Dictionary = {}

var cards_by_stage_id: Dictionary = {}
var current_order: Array[String] = []
var initial_order: Array[String] = []

var swap_count: int = 0
var reset_count: int = 0
var start_time_ms: int = 0
var time_to_first_action_ms: int = -1

var trial_locked: bool = false
var level_solved: bool = false
var trace: Array = []

@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack
@onready var title_label: Label = $SafeArea/MainLayout/Header/TitleLabel
@onready var level_label: Label = $SafeArea/MainLayout/Header/LevelLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainLayout/Header/StabilityBar
@onready var briefing_label: RichTextLabel = $SafeArea/MainLayout/BriefingCard/BriefingLabel
@onready var cards_row: HBoxContainer = $SafeArea/MainLayout/TimelineCard/CardVBox/CardsRow
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainLayout/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainLayout/BottomBar/BtnConfirm
@onready var btn_next: Button = $SafeArea/MainLayout/BottomBar/BtnNext
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_connect_ui_signals()
	_load_levels()
	if levels.is_empty():
		_show_error("\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0443\u0440\u043e\u0432\u043d\u0438 \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0442\u0447\u0451\u0442\u0430 B.")
		return

	title_label.text = TEXT_TITLE
	btn_back.text = TEXT_BACK
	btn_reset.text = TEXT_RESET
	btn_confirm.text = TEXT_CONFIRM
	btn_next.text = TEXT_NEXT

	var initial_index: int = clamp(GlobalMetrics.current_level_index, 0, max(0, levels.size() - 1))
	_start_level(initial_index)
	_apply_layout_mode()

func _exit_tree() -> void:
	if GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	btn_next.pressed.connect(_on_next_pressed)

func _load_levels() -> void:
	levels = FR8BData.load_levels(LEVELS_PATH)
	if SESSION_LEVEL_COUNT > 0 and levels.size() > SESSION_LEVEL_COUNT:
		var limited: Array = []
		for i in range(SESSION_LEVEL_COUNT):
			limited.append(levels[i])
		levels = limited

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	current_level_index = clamp(index, 0, levels.size() - 1)
	GlobalMetrics.current_level_index = current_level_index
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)

	cards_by_stage_id.clear()
	var base_order: Array[String] = []
	for card_var in level_data.get("cards", []) as Array:
		if typeof(card_var) != TYPE_DICTIONARY:
			continue
		var card_data: Dictionary = card_var as Dictionary
		var stage_id: String = str(card_data.get("stage_id", "")).strip_edges()
		if stage_id.is_empty():
			continue
		cards_by_stage_id[stage_id] = card_data
		base_order.append(stage_id)

	current_order = base_order.duplicate()
	var anti_cheat: Dictionary = level_data.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_cards", false)) and current_order.size() > 1:
		current_order.shuffle()
		if _arrays_equal(current_order, _expected_order()):
			var first_id: String = current_order[0]
			current_order[0] = current_order[1]
			current_order[1] = first_id

	initial_order = current_order.duplicate()
	swap_count = 0
	reset_count = 0
	start_time_ms = Time.get_ticks_msec()
	time_to_first_action_ms = -1
	trace.clear()

	level_label.text = _build_level_label()
	briefing_label.text = str(level_data.get("briefing", ""))

	_log_event("LEVEL_START", {
		"level_id": str(level_data.get("id", "FR8-B")),
		"index": current_level_index
	})
	_reset_attempt(true)
	_update_stability_ui()
	_apply_layout_mode()

func _build_level_label() -> String:
	return "B | %s (%d/%d)" % [
		str(level_data.get("id", "FR8-B")),
		current_level_index + 1,
		levels.size()
	]

func _expected_order() -> Array[String]:
	var out: Array[String] = []
	for stage_var in level_data.get("expected_order", []) as Array:
		out.append(str(stage_var).strip_edges())
	return out

func _is_last_level() -> bool:
	return current_level_index >= levels.size() - 1

func _reset_attempt(is_level_start: bool = false) -> void:
	current_order = initial_order.duplicate()
	if not is_level_start:
		_mark_first_action()
		reset_count += 1

	_log_event("СБРОС", {"level_start": is_level_start})

	trial_locked = false
	level_solved = false
	btn_confirm.disabled = false
	btn_next.disabled = true
	btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT

	_rebuild_cards()
	_set_status(STATUS_HINT, COLOR_INFO)

func _rebuild_cards() -> void:
	for child in cards_row.get_children():
		child.queue_free()

	for i in range(current_order.size()):
		var stage_id: String = current_order[i]
		if not cards_by_stage_id.has(stage_id):
			continue

		var card_node: Node = TIMELINE_CARD_SCENE.instantiate()
		cards_row.add_child(card_node)
		if card_node.has_method("setup"):
			card_node.call("setup", cards_by_stage_id[stage_id])
		if card_node.has_method("set_move_enabled"):
			card_node.call("set_move_enabled", i > 0 and not trial_locked, i < current_order.size() - 1 and not trial_locked)
		if card_node.has_signal("move_requested"):
			card_node.connect("move_requested", Callable(self, "_on_card_move_requested"))
		if card_node.has_signal("hint_requested"):
			card_node.connect("hint_requested", Callable(self, "_on_card_hint_requested"))

	_apply_layout_mode()

func _on_card_move_requested(stage_id: String, dir: int) -> void:
	if trial_locked:
		return

	var index: int = current_order.find(stage_id)
	if index < 0:
		return
	var target_index: int = index + dir
	if target_index < 0 or target_index >= current_order.size():
		return

	_mark_first_action()

	var other_stage: String = current_order[target_index]
	current_order[target_index] = stage_id
	current_order[index] = other_stage
	swap_count += 1

	_log_event("MOVE_CARD", {
		"stage_id": stage_id,
		"from_index": index,
		"to_index": target_index,
		"dir": dir
	})

	_rebuild_cards()
	_set_status(STATUS_HINT, COLOR_INFO)
	if AudioManager != null:
		AudioManager.play("click")

func _on_card_hint_requested(stage_id: String) -> void:
	_mark_first_action()
	_log_event("HINT_REQUESTED", {"stage_id": stage_id})

	var hint_text: String = ""
	if cards_by_stage_id.has(stage_id):
		var card_data: Dictionary = cards_by_stage_id.get(stage_id, {}) as Dictionary
		hint_text = str(card_data.get("hint", "")).strip_edges()

	if hint_text.is_empty():
		_set_status(STATUS_HINT, COLOR_INFO)
	else:
		_set_status(hint_text, COLOR_INFO)

	if AudioManager != null:
		AudioManager.play("click")

func _on_confirm_pressed() -> void:
	if trial_locked:
		return

	_mark_first_action()
	_log_event("CONFIRM_PRESSED", {
		"final_order": current_order.duplicate()
	})

	var evaluation: Dictionary = FR8BScoring.evaluate(level_data, current_order)
	var score: Dictionary = FR8BScoring.resolve_score(level_data, evaluation)
	var feedback_text: String = FR8BScoring.feedback_text(level_data, evaluation)

	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	var tffa_ms: int = elapsed_ms if time_to_first_action_ms < 0 else time_to_first_action_ms
	var level_id: String = str(level_data.get("id", "FR8-B-00"))
	var verdict_code: String = str(score.get("verdict_code", "FAIL"))
	var error_code: String = str(evaluation.get("error_code", "ORDER_MISMATCH"))
	var match_key: String = "FR8_B|%s|%d" % [level_id, GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_08_FINAL_REPORT",
		"stage": "B",
		"level_id": level_id,
		"format": "TIMELINE_SORT",
		"match_key": match_key,
		"initial_order": initial_order.duplicate(),
		"final_order": current_order.duplicate(),
		"violations": (evaluation.get("violations", []) as Array).duplicate(true),
		"error_code": error_code,
		"elapsed_ms": elapsed_ms,
		"time_to_first_action_ms": tffa_ms,
		"swap_count": swap_count,
		"reset_count": reset_count,
		"points": int(score.get("points", 0)),
		"max_points": int(score.get("max_points", 2)),
		"is_fit": bool(score.get("is_fit", false)),
		"is_correct": bool(score.get("is_correct", false)),
		"stability_delta": int(score.get("stability_delta", -25)),
		"verdict_code": verdict_code,
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	if verdict_code == "PERFECT":
		level_solved = true
		trial_locked = true
		btn_confirm.disabled = true
		btn_next.disabled = false
		btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
		_set_status("%s %s" % [feedback_text, STATUS_NEXT_HINT], COLOR_OK)
		_rebuild_cards()
		if AudioManager != null:
			AudioManager.play("relay")
	else:
		level_solved = false
		trial_locked = false
		btn_confirm.disabled = false
		btn_next.disabled = true
		_set_status(feedback_text, COLOR_ERR)
		_trigger_glitch()
		_shake_main_layout()
		if AudioManager != null:
			AudioManager.play("error")

func _on_next_pressed() -> void:
	if not level_solved:
		_set_status(STATUS_SOLVE_FIRST, COLOR_WARN)
		return

	var from_level_id: String = str(level_data.get("id", "FR8-B-00"))
	var from_index: int = current_level_index
	if _is_last_level():
		_log_event("NEXT_PRESSED", {
			"from_level_id": from_level_id,
			"from_index": from_index,
			"to_index": -1
		})
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return

	var to_index: int = current_level_index + 1
	_log_event("NEXT_PRESSED", {
		"from_level_id": from_level_id,
		"from_index": from_index,
		"to_index": to_index
	})
	_start_level(to_index)

func _on_back_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_reset_pressed() -> void:
	_reset_attempt(false)
	if AudioManager != null:
		AudioManager.play("click")

func _on_viewport_size_changed() -> void:
	_apply_layout_mode()

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var count: int = max(1, current_order.size())
	var available_width: float = max(320.0, viewport_size.x - 80.0)
	var card_width: float
	if viewport_size.x > viewport_size.y:
		card_width = clamp(available_width / float(count), 145.0, 230.0)
	else:
		card_width = clamp(available_width / float(count), 108.0, 170.0)

	for child in cards_row.get_children():
		if child is Control:
			var control: Control = child as Control
			control.custom_minimum_size = Vector2(card_width, 120)

func _mark_first_action() -> void:
	if time_to_first_action_ms >= 0:
		return
	time_to_first_action_ms = Time.get_ticks_msec() - start_time_ms

func _arrays_equal(a: Array[String], b: Array[String]) -> bool:
	if a.size() != b.size():
		return false
	for i in range(a.size()):
		if a[i] != b[i]:
			return false
	return true

func _set_status(text_value: String, color_value: Color) -> void:
	status_label.text = text_value
	status_label.modulate = color_value

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for _i in 4:
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _show_error(message: String) -> void:
	_set_status(message, COLOR_ERR)
	btn_confirm.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability
</file>

<file path="scripts/case_08/fr8_final_report_c.gd">
extends Control

const LEVELS_PATH := "res://data/final_report_c_levels.json"
const SESSION_LEVEL_COUNT := 6
const FR8CData := preload("res://scripts/case_08/fr8c_data.gd")
const FR8CScoring := preload("res://scripts/case_08/fr8c_scoring.gd")

const COLOR_OK := Color(0.55, 0.95, 0.62, 1.0)
const COLOR_WARN := Color(1.0, 0.82, 0.35, 1.0)
const COLOR_ERR := Color(1.0, 0.45, 0.45, 1.0)
const COLOR_INFO := Color(0.84, 0.84, 0.84, 1.0)
const COLOR_SELECTED := Color(1.0, 0.9, 0.45, 1.0)

const TEXT_TITLE := "\u0414\u0415\u041b\u041e #8: \u0424\u0418\u041d\u0410\u041b\u042c\u041d\u042b\u0419 \u041e\u0422\u0427\u0415\u0422 [C]"
const TEXT_BACK := "\u041d\u0410\u0417\u0410\u0414"
const TEXT_RESET := "\u0421\u0411\u0420\u041e\u0421"
const TEXT_CONFIRM := "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TEXT_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TEXT_FINISH := "\u0417\u0410\u0412\u0415\u0420\u0428\u0418\u0422\u042c"

const STATUS_HINT := "\u0418\u0437\u0443\u0447\u0438\u0442\u0435 \u043a\u043e\u0434, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0442\u043e\u0433\u043e\u0432\u044b\u0439 \u0446\u0432\u0435\u0442 \u0438 \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c."
const STATUS_INSPECTED := "\u0414\u0430\u043d\u043d\u044b\u0435 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044b."
const STATUS_OPTION_SELECTED := "\u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0432\u044b\u0431\u0440\u0430\u043d. \u041c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0430\u0442\u044c."
const STATUS_NEXT_HINT := "\u041a\u043e\u0434 \u0432\u0437\u043b\u043e\u043c\u0430\u043d. \u0416\u043c\u0438\u0442\u0435 \u0414\u0410\u041b\u0415\u0415."
const STATUS_SOLVE_FIRST := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0440\u0435\u0448\u0438\u0442\u0435 \u0443\u0440\u043e\u0432\u0435\u043d\u044c."
const STATUS_INSPECT_UNAVAILABLE := "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a."
const EXPLAIN_HINT := "\u0422\u0430\u043f\u043d\u0438\u0442\u0435 \u043f\u043e \u00ab\u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c\u00bb \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0446\u0432\u0435\u0442 \u0438\u0442\u043e\u0433\u043e\u0432\u043e\u0433\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u0430."

var levels: Array = []
var current_level_index: int = 0
var level_data: Dictionary = {}

var selected_option_id: String = ""
var option_buttons: Dictionary = {}
var option_by_id: Dictionary = {}

var inspect_count: int = 0
var reset_count: int = 0
var attempts: int = 0
var start_time_ms: int = 0

var level_solved: bool = false
var trial_locked: bool = false
var trace: Array = []

@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var body: BoxContainer = $SafeArea/MainLayout/Body
@onready var code_card: PanelContainer = $SafeArea/MainLayout/Body/CodeCard
@onready var decrypt_card: PanelContainer = $SafeArea/MainLayout/Body/DecryptCard

@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack
@onready var title_label: Label = $SafeArea/MainLayout/Header/TitleLabel
@onready var level_label: Label = $SafeArea/MainLayout/Header/LevelLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainLayout/Header/StabilityBar

@onready var briefing_label: Label = $SafeArea/MainLayout/BriefingCard/BriefingLabel
@onready var html_label: RichTextLabel = $SafeArea/MainLayout/Body/CodeCard/CodeVBox/HtmlLabel
@onready var css_label: RichTextLabel = $SafeArea/MainLayout/Body/CodeCard/CodeVBox/CssLabel
@onready var target_preview: Label = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/TargetPreview
@onready var attack_bar: ProgressBar = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow/AttackBar
@onready var defense_bar: ProgressBar = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow/DefenseBar
@onready var options_vbox: VBoxContainer = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/OptionsVBox
@onready var explain_label: Label = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/ExplainLabel
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel

@onready var btn_reset: Button = $SafeArea/MainLayout/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainLayout/BottomBar/BtnConfirm
@onready var btn_next: Button = $SafeArea/MainLayout/BottomBar/BtnNext
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay
@onready var inspector_popup: PopupPanel = $InspectorPopup

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_connect_ui_signals()
	_load_levels()
	if levels.is_empty():
		_show_error("\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0443\u0440\u043e\u0432\u043d\u0438 \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0442\u0447\u0451\u0442\u0430 C.")
		return

	title_label.text = TEXT_TITLE
	btn_back.text = TEXT_BACK
	btn_reset.text = TEXT_RESET
	btn_confirm.text = TEXT_CONFIRM
	btn_next.text = TEXT_NEXT

	var initial_index: int = clamp(GlobalMetrics.current_level_index, 0, max(0, levels.size() - 1))
	_start_level(initial_index)
	_apply_layout_mode()

func _exit_tree() -> void:
	if GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	html_label.meta_clicked.connect(_on_meta_clicked)
	css_label.meta_clicked.connect(_on_meta_clicked)

func _load_levels() -> void:
	levels = FR8CData.load_levels(LEVELS_PATH)
	if SESSION_LEVEL_COUNT > 0 and levels.size() > SESSION_LEVEL_COUNT:
		var limited: Array = []
		for i in range(SESSION_LEVEL_COUNT):
			limited.append(levels[i])
		levels = limited

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	current_level_index = clamp(index, 0, levels.size() - 1)
	GlobalMetrics.current_level_index = current_level_index
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)

	selected_option_id = ""
	option_buttons.clear()
	option_by_id.clear()
	inspect_count = 0
	reset_count = 0
	attempts = 0
	trace.clear()
	start_time_ms = Time.get_ticks_msec()

	level_label.text = _build_level_label()
	briefing_label.text = str(level_data.get("briefing", ""))
	target_preview.text = str(level_data.get("target_text", "\u0421\u0435\u043a\u0440\u0435\u0442\u043d\u044b\u0439 \u043a\u043e\u0434"))
	target_preview.modulate = COLOR_INFO

	_build_option_buttons()
	_render_code_window()
	_log_event("LEVEL_START", {
		"level_id": str(level_data.get("id", "FR8-C")),
		"index": current_level_index
	})
	_reset_attempt(true)
	_update_stability_ui()
	_apply_layout_mode()

func _build_level_label() -> String:
	return "C | %s (%d/%d)" % [
		str(level_data.get("id", "FR8-C")),
		current_level_index + 1,
		levels.size()
	]

func _is_last_level() -> bool:
	return current_level_index >= levels.size() - 1

func _build_option_buttons() -> void:
	for child in options_vbox.get_children():
		child.queue_free()
	option_buttons.clear()
	option_by_id.clear()

	for option_var in level_data.get("options", []) as Array:
		if typeof(option_var) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_var as Dictionary
		var option_id: String = str(option_data.get("id", "")).strip_edges()
		if option_id.is_empty():
			continue

		option_by_id[option_id] = option_data

		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 52)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.text = "%s  [%s]" % [
			str(option_data.get("label", option_id)),
			str(option_data.get("value", ""))
		]
		btn.pressed.connect(_on_option_pressed.bind(option_id))
		options_vbox.add_child(btn)
		option_buttons[option_id] = btn

	_refresh_option_state()

func _render_code_window() -> void:
	var html_lines: Array[String] = []
	for line_var in level_data.get("html", []) as Array:
		html_lines.append("[color=#d2d2d2]%s[/color]" % _escape_bbcode(str(line_var)))

	var inline_var: Variant = level_data.get("inline_decl", null)
	if inline_var != null and typeof(inline_var) == TYPE_DICTIONARY:
		html_lines.append("[url=inspect:inline][color=#ffca5f]style=\"color:...\" (проверить)[/color][/url]")

	if html_lines.is_empty():
		html_lines.append("-")
	html_label.text = "\n".join(html_lines)

	var css_lines: Array[String] = []
	var rules: Array = level_data.get("rules", []) as Array
	for i in range(rules.size()):
		var rule_var: Variant = rules[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_var as Dictionary
		var source_id: String = str(rule.get("source_id", "R%s" % str(i + 1))).strip_edges()
		var selector: String = _selector_of(rule)
		var decl: Dictionary = rule.get("decl", {}) as Dictionary
		var color_value: String = str(decl.get("value", "")).strip_edges().to_lower()
		var bb_color: String = _bbcode_color(color_value)
		var important_suffix: String = " !important" if bool(rule.get("important", false)) else ""
		var order_value: int = int(rule.get("order", i + 1))
		var weight_value: int = int(rule.get("weight", 0))

		css_lines.append(
			"[url=inspect:%s][color=#ffca5f]%s[/color][/url] { color: [color=%s]%s[/color]%s; } [color=#8d8d8d]w:%d o:%d[/color]" % [
				source_id,
				_escape_bbcode(selector),
				bb_color,
				_escape_bbcode(color_value),
				important_suffix,
				weight_value,
				order_value
			]
		)

	if css_lines.is_empty():
		css_lines.append("-")
	css_label.text = "\n".join(css_lines)

func _reset_attempt(is_level_start: bool = false) -> void:
	if not is_level_start:
		reset_count += 1
	_log_event("СБРОС", {"level_start": is_level_start})

	selected_option_id = ""
	level_solved = false
	trial_locked = false

	attack_bar.value = 0
	defense_bar.value = 0
	btn_confirm.disabled = true
	btn_next.disabled = true
	btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
	target_preview.modulate = COLOR_INFO
	explain_label.text = EXPLAIN_HINT

	_refresh_option_state()
	_set_status(STATUS_HINT, COLOR_INFO)

func _on_option_pressed(option_id: String) -> void:
	if trial_locked:
		return
	if not option_buttons.has(option_id):
		return

	selected_option_id = option_id
	attack_bar.value = FR8CScoring.preview_attack_strength(level_data, selected_option_id)
	_refresh_option_state()
	_set_status(STATUS_OPTION_SELECTED, COLOR_INFO)
	_log_event("OPTION_SELECTED", {"option_id": option_id})
	if AudioManager != null:
		AudioManager.play("click")

func _refresh_option_state() -> void:
	for option_id_var in option_buttons.keys():
		var option_id: String = str(option_id_var)
		var button: Button = option_buttons.get(option_id, null) as Button
		if button == null:
			continue
		button.modulate = COLOR_SELECTED if option_id == selected_option_id else Color(1, 1, 1, 1)

	var preview_color: Color = COLOR_INFO
	if option_by_id.has(selected_option_id):
		var option: Dictionary = option_by_id.get(selected_option_id, {}) as Dictionary
		preview_color = _color_from_hex(str(option.get("value", "")), COLOR_INFO)
	target_preview.modulate = preview_color

	btn_confirm.disabled = trial_locked or selected_option_id.is_empty()

func _on_meta_clicked(meta: Variant) -> void:
	var meta_value: String = str(meta).strip_edges()
	if not meta_value.begins_with("inspect:"):
		return

	var source_id: String = meta_value.substr("inspect:".length())
	if source_id.is_empty():
		return

	var source_data: Dictionary = FR8CScoring.inspect_source(level_data, source_id)
	if source_data.is_empty():
		_set_status(STATUS_INSPECT_UNAVAILABLE, COLOR_WARN)
		return

	inspect_count += 1
	_log_event("INSPECT", {"source_id": source_id})
	if inspector_popup != null and inspector_popup.has_method("show_inspection"):
		inspector_popup.call("show_inspection", source_data)
	_set_status(STATUS_INSPECTED, COLOR_INFO)
	if AudioManager != null:
		AudioManager.play("click")

func _on_confirm_pressed() -> void:
	if trial_locked:
		return

	if selected_option_id.is_empty():
		_set_status(FR8CScoring.feedback_text(level_data, {"error_code": FR8CScoring.ERROR_EMPTY_CHOICE}), COLOR_WARN)
		return

	attempts += 1
	_log_event("CONFIRM_PRESSED", {
		"selected_option_id": selected_option_id,
		"attempt": attempts
	})

	var evaluation: Dictionary = FR8CScoring.evaluate(level_data, selected_option_id)
	var feedback_text: String = FR8CScoring.feedback_text(level_data, evaluation)
	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	var level_id: String = str(level_data.get("id", "FR8-C-00"))
	var match_key: String = "FR8_C|%s|%d" % [level_id, GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_08_FINAL_REPORT",
		"stage": "C",
		"level_id": level_id,
		"format": "CSS_CASCADE",
		"match_key": match_key,
		"selected_option_id": selected_option_id,
		"correct_option_id": str(evaluation.get("correct_option_id", "")),
		"winner_source_id": str(evaluation.get("winner_source_id", "")),
		"winner": (evaluation.get("winner", {}) as Dictionary).duplicate(true),
		"elapsed_ms": elapsed_ms,
		"inspect_count": inspect_count,
		"reset_count": reset_count,
		"attempts": attempts,
		"points": int(evaluation.get("points", 0)),
		"max_points": int(evaluation.get("max_points", 2)),
		"is_fit": bool(evaluation.get("is_fit", false)),
		"is_correct": bool(evaluation.get("is_correct", false)),
		"stability_delta": int(evaluation.get("stability_delta", -25)),
		"verdict_code": str(evaluation.get("verdict_code", "FAIL")),
		"error_code": str(evaluation.get("error_code", FR8CScoring.ERROR_SPECIFICITY)),
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	attack_bar.value = int(evaluation.get("attack_strength", 0))
	defense_bar.value = int(evaluation.get("defense_strength", 0))
	explain_label.text = feedback_text

	if bool(evaluation.get("is_correct", false)):
		level_solved = true
		trial_locked = true
		btn_confirm.disabled = true
		btn_next.disabled = false
		btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
		_set_status("%s %s" % [feedback_text, STATUS_NEXT_HINT], COLOR_OK)

		var winner_data: Dictionary = evaluation.get("winner", {}) as Dictionary
		target_preview.modulate = _color_from_hex(str(winner_data.get("color", "")), COLOR_OK)
		if AudioManager != null:
			AudioManager.play("relay")
	else:
		level_solved = false
		trial_locked = false
		btn_next.disabled = true
		btn_confirm.disabled = false
		_set_status(feedback_text, COLOR_ERR)
		_trigger_glitch()
		_shake_main_layout()
		if AudioManager != null:
			AudioManager.play("error")

func _on_next_pressed() -> void:
	if not level_solved:
		_set_status(STATUS_SOLVE_FIRST, COLOR_WARN)
		return

	var from_level_id: String = str(level_data.get("id", "FR8-C-00"))
	var from_index: int = current_level_index
	if _is_last_level():
		_log_event("NEXT_PRESSED", {
			"from_level_id": from_level_id,
			"from_index": from_index,
			"to_index": -1
		})
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return

	var to_index: int = current_level_index + 1
	_log_event("NEXT_PRESSED", {
		"from_level_id": from_level_id,
		"from_index": from_index,
		"to_index": to_index
	})
	_start_level(to_index)

func _on_back_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_reset_pressed() -> void:
	_reset_attempt(false)
	if AudioManager != null:
		AudioManager.play("click")

func _on_viewport_size_changed() -> void:
	_apply_layout_mode()

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var landscape: bool = viewport_size.x > viewport_size.y
	body.vertical = not landscape

	if landscape:
		if body.get_child(0) != code_card:
			body.move_child(code_card, 0)
			body.move_child(decrypt_card, 1)
	else:
		if body.get_child(0) != code_card:
			body.move_child(code_card, 0)
			body.move_child(decrypt_card, 1)

func _set_status(text_value: String, color_value: Color) -> void:
	status_label.text = text_value
	status_label.modulate = color_value

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for _i in 4:
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _show_error(message: String) -> void:
	_set_status(message, COLOR_ERR)
	btn_confirm.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _selector_of(rule: Dictionary) -> String:
	var selector: String = str(rule.get("selector", "")).strip_edges()
	if not selector.is_empty():
		return selector
	return str(rule.get(".selector", "")).strip_edges()

func _escape_bbcode(text_value: String) -> String:
	return text_value.replace("[", "[lb]").replace("]", "[rb]")

func _color_from_hex(hex_value: String, fallback: Color) -> Color:
	var value: String = hex_value.strip_edges()
	if value.is_empty():
		return fallback
	return Color.from_string(value, fallback)

func _bbcode_color(color_value: String) -> String:
	var value: String = color_value.strip_edges()
	if value.begins_with("#") and (value.length() == 4 or value.length() == 7 or value.length() == 9):
		return value
	return "#ffffff"
</file>

<file path="scripts/case_08/fr8c_scoring.gd">
extends RefCounted

const ERROR_EMPTY_CHOICE := "EMPTY_CHOICE"
const ERROR_SPECIFICITY := "SPECIFICITY_ERROR"
const ERROR_IMPORTANT := "IMPORTANT_MISSED"
const ERROR_ORDER_TIE := "ORDER_TIE"
const ERROR_INLINE := "INLINE_OVERRIDE"
const ERROR_OK := "OK"

const VERDICT_PERFECT := "PERFECT"
const VERDICT_FAIL := "FAIL"

static func evaluate(level: Dictionary, selected_option_id: String) -> Dictionary:
	var candidates: Array = _build_candidates(level)
	var winner: Dictionary = _pick_winner(candidates)
	var correct_option_id: String = str(level.get("correct_option_id", "")).strip_edges()
	var selected_option: Dictionary = _option_by_id(level, selected_option_id)
	var selected_value: String = str(selected_option.get("value", "")).strip_edges().to_lower()
	var selected_candidate: Dictionary = _top_candidate_for_color(candidates, selected_value)

	var error_code: String = ERROR_OK
	var is_correct: bool = false
	var is_fit: bool = not selected_option.is_empty()

	if not is_fit:
		error_code = ERROR_EMPTY_CHOICE
	else:
		is_correct = selected_option_id.strip_edges() == correct_option_id
		if not is_correct:
			error_code = _infer_error_code(selected_candidate, winner)

	var points: int = 2 if is_correct else 0
	var stability_delta: int = 0 if is_correct else -25
	var verdict_code: String = VERDICT_PERFECT if is_correct else VERDICT_FAIL

	return {
		"error_code": ERROR_OK if is_correct else error_code,
		"is_correct": is_correct,
		"is_fit": is_fit,
		"points": points,
		"max_points": 2,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"correct_option_id": correct_option_id,
		"winner_source_id": str(winner.get("source_id", "")),
		"winner": {
			"important": bool(winner.get("important", false)),
			"weight": int(winner.get("weight", 0)),
			"order": int(winner.get("order", 0)),
			"color": str(winner.get("color", ""))
		},
		"attack_strength": _strength_of(selected_candidate),
		"defense_strength": _strength_of(winner)
	}

static func feedback_text(level: Dictionary, evaluation: Dictionary) -> String:
	var error_code: String = str(evaluation.get("error_code", ERROR_SPECIFICITY))
	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	if error_code == ERROR_EMPTY_CHOICE:
		return "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0446\u0432\u0435\u0442\u0430."
	if feedback_rules.has(error_code):
		return str(feedback_rules.get(error_code, ""))
	if error_code == ERROR_IMPORTANT:
		return "!important \u043f\u0435\u0440\u0435\u0431\u0438\u0432\u0430\u0435\u0442 \u043e\u0431\u044b\u0447\u043d\u044b\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u0430."
	if error_code == ERROR_INLINE:
		return "Встроенный стиль перекрывает правила из CSS."
	if error_code == ERROR_ORDER_TIE:
		return "\u041f\u0440\u0438 \u0440\u0430\u0432\u043d\u043e\u0439 \u0441\u0438\u043b\u0435 \u043f\u043e\u0431\u0435\u0436\u0434\u0430\u0435\u0442 \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0438\u0434\u0451\u0442 \u043f\u043e\u0437\u0436\u0435."
	if error_code == ERROR_SPECIFICITY:
		return "\u041f\u043e\u0431\u0435\u0434\u0438\u043b \u0431\u043e\u043b\u0435\u0435 \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u0447\u043d\u044b\u0439 \u0441\u0435\u043b\u0435\u043a\u0442\u043e\u0440."
	if feedback_rules.has(ERROR_OK):
		return str(feedback_rules.get(ERROR_OK, ""))
	return "\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u043a\u0430\u0441\u043a\u0430\u0434 \u0438 \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430."

static func inspect_source(level: Dictionary, source_id: String) -> Dictionary:
	var sid: String = source_id.strip_edges()
	if sid.to_lower() == "inline":
		var inline_var: Variant = level.get("inline_decl", null)
		if inline_var == null or typeof(inline_var) != TYPE_DICTIONARY:
			return {}
		var inline_decl: Dictionary = inline_var as Dictionary
		var decl: Dictionary = inline_decl.get("decl", {}) as Dictionary
		return {
			"source_id": str(inline_decl.get("source_id", "INLINE")),
			"selector": "встроенный стиль",
			"kind": str(inline_decl.get("kind", "inline")),
			"weight": int(inline_decl.get("weight", 1000)),
			"important": bool(inline_decl.get("important", false)),
			"order": int(inline_decl.get("order", 10000)),
			"color": str(decl.get("value", ""))
		}

	for i in range((level.get("rules", []) as Array).size()):
		var rule_var: Variant = (level.get("rules", []) as Array)[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_var as Dictionary
		if str(rule.get("source_id", "")).strip_edges() != sid:
			continue
		var decl: Dictionary = rule.get("decl", {}) as Dictionary
		return {
			"source_id": sid,
			"selector": _selector_of(rule),
			"kind": str(rule.get("kind", "")),
			"weight": int(rule.get("weight", 0)),
			"important": bool(rule.get("important", false)),
			"order": int(rule.get("order", i + 1)),
			"color": str(decl.get("value", ""))
		}
	return {}

static func preview_attack_strength(level: Dictionary, selected_option_id: String) -> int:
	var selected_option: Dictionary = _option_by_id(level, selected_option_id)
	if selected_option.is_empty():
		return 0
	var selected_value: String = str(selected_option.get("value", "")).strip_edges().to_lower()
	var selected_candidate: Dictionary = _top_candidate_for_color(_build_candidates(level), selected_value)
	return _strength_of(selected_candidate)

static func _build_candidates(level: Dictionary) -> Array:
	var out: Array = []
	var rules: Array = level.get("rules", []) as Array
	for i in range(rules.size()):
		var rule_var: Variant = rules[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_var as Dictionary
		var decl: Dictionary = rule.get("decl", {}) as Dictionary
		out.append({
			"source_id": str(rule.get("source_id", "")).strip_edges(),
			"selector": _selector_of(rule),
			"kind": str(rule.get("kind", "")),
			"weight": int(rule.get("weight", 0)),
			"important": bool(rule.get("important", false)),
			"order": int(rule.get("order", i + 1)),
			"color": str(decl.get("value", "")).strip_edges().to_lower()
		})

	var inline_var: Variant = level.get("inline_decl", null)
	if inline_var != null and typeof(inline_var) == TYPE_DICTIONARY:
		var inline_decl: Dictionary = inline_var as Dictionary
		var inline_decl_data: Dictionary = inline_decl.get("decl", {}) as Dictionary
		out.append({
			"source_id": str(inline_decl.get("source_id", "INLINE")).strip_edges(),
			"selector": "встроенный стиль",
			"kind": str(inline_decl.get("kind", "inline")),
			"weight": int(inline_decl.get("weight", 1000)),
			"important": bool(inline_decl.get("important", false)),
			"order": int(inline_decl.get("order", 10000)),
			"color": str(inline_decl_data.get("value", "")).strip_edges().to_lower()
		})

	return out

static func _pick_winner(candidates: Array) -> Dictionary:
	if candidates.is_empty():
		return {
			"source_id": "",
			"selector": "",
			"kind": "",
			"weight": 0,
			"important": false,
			"order": 0,
			"color": ""
		}

	var winner: Dictionary = candidates[0] as Dictionary
	for i in range(1, candidates.size()):
		if typeof(candidates[i]) != TYPE_DICTIONARY:
			continue
		var candidate: Dictionary = candidates[i] as Dictionary
		if _is_stronger(candidate, winner):
			winner = candidate
	return winner

static func _top_candidate_for_color(candidates: Array, color_value: String) -> Dictionary:
	var color: String = color_value.strip_edges().to_lower()
	if color.is_empty():
		return {}
	var picked: Dictionary = {}
	for candidate_var in candidates:
		if typeof(candidate_var) != TYPE_DICTIONARY:
			continue
		var candidate: Dictionary = candidate_var as Dictionary
		if str(candidate.get("color", "")).to_lower() != color:
			continue
		if picked.is_empty() or _is_stronger(candidate, picked):
			picked = candidate
	return picked

static func _is_stronger(a: Dictionary, b: Dictionary) -> bool:
	var a_imp: bool = bool(a.get("important", false))
	var b_imp: bool = bool(b.get("important", false))
	if a_imp != b_imp:
		return a_imp and not b_imp

	var a_weight: int = int(a.get("weight", 0))
	var b_weight: int = int(b.get("weight", 0))
	if a_weight != b_weight:
		return a_weight > b_weight

	var a_order: int = int(a.get("order", 0))
	var b_order: int = int(b.get("order", 0))
	if a_order != b_order:
		return a_order > b_order
	return false

static func _infer_error_code(selected_candidate: Dictionary, winner: Dictionary) -> String:
	if str(winner.get("source_id", "")).to_upper() == "INLINE":
		if selected_candidate.is_empty() or str(selected_candidate.get("source_id", "")).to_upper() != "INLINE":
			return ERROR_INLINE

	if bool(winner.get("important", false)):
		if selected_candidate.is_empty() or not bool(selected_candidate.get("important", false)):
			return ERROR_IMPORTANT

	if not selected_candidate.is_empty():
		var same_important: bool = bool(selected_candidate.get("important", false)) == bool(winner.get("important", false))
		var same_weight: bool = int(selected_candidate.get("weight", 0)) == int(winner.get("weight", 0))
		if same_important and same_weight and int(selected_candidate.get("order", 0)) != int(winner.get("order", 0)):
			return ERROR_ORDER_TIE
		if int(selected_candidate.get("weight", 0)) != int(winner.get("weight", 0)):
			return ERROR_SPECIFICITY

	return ERROR_SPECIFICITY

static func _option_by_id(level: Dictionary, option_id: String) -> Dictionary:
	var oid: String = option_id.strip_edges()
	if oid.is_empty():
		return {}
	for option_var in level.get("options", []) as Array:
		if typeof(option_var) != TYPE_DICTIONARY:
			continue
		var option: Dictionary = option_var as Dictionary
		if str(option.get("id", "")).strip_edges() == oid:
			return option
	return {}

static func _selector_of(rule: Dictionary) -> String:
	var selector: String = str(rule.get("selector", "")).strip_edges()
	if not selector.is_empty():
		return selector
	return str(rule.get(".selector", "")).strip_edges()

static func _strength_of(candidate: Dictionary) -> int:
	if candidate.is_empty():
		return 0
	var important_bonus: int = 10000 if bool(candidate.get("important", false)) else 0
	return important_bonus + int(candidate.get("weight", 0))
</file>

<file path="scripts/ui/CodeBlock.gd">
extends Button

var data: Dictionary = {}

func setup(block_data: Dictionary):
	data = block_data
	text = str(data.get("label", "???"))
	custom_minimum_size = Vector2(80, 64) # Ensure touch friendly

	# Optional: Differentiate types visually
	if data.get("slot_type") == "OP":
		modulate = Color(0.88, 0.88, 0.86)
	else:
		modulate = Color(1.0, 1.0, 1.0)

func _get_drag_data(at_position: Vector2):
	# Create a visual preview
	var preview = Button.new()
	preview.text = text
	preview.custom_minimum_size = size
	preview.modulate = Color(1, 1, 1, 0.8)
	# Remove stylebox if needed or just let it use default theme

	# Center the preview
	var ctrl = Control.new()
	ctrl.add_child(preview)
	preview.position = -size / 2
	set_drag_preview(ctrl)

	# Return data strictly as per spec
	return {
		"kind": "CODE_BLOCK",
		"block_id": data.get("block_id"),
		"slot_type": data.get("slot_type"),
		"label": data.get("label"),
		"insert": data.get("insert"),
		"source_path": get_path()
	}
</file>

<file path="scripts/ui/ConnectorOverlay.gd">
extends Control

const ANCHOR_CENTER := "center"
const ANCHOR_EDGE := "edge"
const ORIENTATION_AUTO := "auto"
const ORIENTATION_HORIZONTAL := "horizontal"
const ORIENTATION_VERTICAL := "vertical"

var _links: Array = []
var _anchor_root: Control
var _watched_controls: Array = []
var _anchor_mode: String = ANCHOR_CENTER
var _orientation: String = ORIENTATION_AUTO

@export var line_color: Color = Color(0.88, 0.64, 0.16, 0.9)
@export var line_width: float = 3.0
@export var arrow_size: float = 10.0

func _ready() -> void:
	mouse_filter = Control.MOUSE_FILTER_IGNORE
	set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)

func set_anchor_mode(anchor_mode: String, orientation: String = ORIENTATION_AUTO) -> void:
	_anchor_mode = anchor_mode.to_lower()
	_orientation = orientation.to_lower()
	queue_redraw()

func set_endpoints(from_control: Control, to_control: Control, anchor_root: Control) -> void:
	set_links([{"from": from_control, "to": to_control}], anchor_root, _anchor_mode, _orientation)

func set_links(links: Array, anchor_root: Control, anchor_mode: String = ANCHOR_CENTER, orientation: String = ORIENTATION_AUTO) -> void:
	_disconnect_signals()
	_links.clear()
	_anchor_root = anchor_root
	_anchor_mode = anchor_mode.to_lower()
	_orientation = orientation.to_lower()
	for link_v in links:
		if typeof(link_v) != TYPE_DICTIONARY:
			continue
		var link: Dictionary = link_v as Dictionary
		var from_control: Control = link.get("from", null) as Control
		var to_control: Control = link.get("to", null) as Control
		if is_instance_valid(from_control) and is_instance_valid(to_control):
			_links.append({"from": from_control, "to": to_control})
			_connect_signal_safe(from_control)
			_connect_signal_safe(to_control)
	if is_instance_valid(_anchor_root):
		_connect_signal_safe(_anchor_root)
	queue_redraw()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED or what == NOTIFICATION_TRANSFORM_CHANGED or what == NOTIFICATION_VISIBILITY_CHANGED:
		queue_redraw()

func _draw() -> void:
	for link_v in _links:
		if typeof(link_v) != TYPE_DICTIONARY:
			continue
		var link: Dictionary = link_v as Dictionary
		var from_control: Control = link.get("from", null) as Control
		var to_control: Control = link.get("to", null) as Control
		if not _can_draw_connector(from_control, to_control):
			continue
		var points: Dictionary = _resolve_points(from_control.get_global_rect(), to_control.get_global_rect())
		var from_global: Vector2 = points.get("from", Vector2.ZERO)
		var to_global: Vector2 = points.get("to", Vector2.ZERO)
		var from_point: Vector2 = _global_to_local(from_global)
		var to_point: Vector2 = _global_to_local(to_global)
		draw_line(from_point, to_point, line_color, line_width, true)
		_draw_arrow(from_point, to_point)

func _resolve_points(from_rect: Rect2, to_rect: Rect2) -> Dictionary:
	if _anchor_mode != ANCHOR_EDGE:
		return {
			"from": from_rect.get_center(),
			"to": to_rect.get_center()
		}
	var orientation: String = _resolved_orientation(from_rect, to_rect)
	if orientation == ORIENTATION_VERTICAL:
		return {
			"from": Vector2(from_rect.get_center().x, from_rect.end.y),
			"to": Vector2(to_rect.get_center().x, to_rect.position.y)
		}
	return {
		"from": Vector2(from_rect.end.x, from_rect.get_center().y),
		"to": Vector2(to_rect.position.x, to_rect.get_center().y)
	}

func _resolved_orientation(from_rect: Rect2, to_rect: Rect2) -> String:
	if _orientation == ORIENTATION_HORIZONTAL or _orientation == ORIENTATION_VERTICAL:
		return _orientation
	var delta: Vector2 = to_rect.get_center() - from_rect.get_center()
	return ORIENTATION_HORIZONTAL if absf(delta.x) >= absf(delta.y) else ORIENTATION_VERTICAL

func _draw_arrow(from_point: Vector2, to_point: Vector2) -> void:
	var direction: Vector2 = (to_point - from_point).normalized()
	if direction.length() <= 0.0:
		return
	var normal: Vector2 = Vector2(-direction.y, direction.x)
	var tip: Vector2 = to_point
	var base: Vector2 = tip - direction * arrow_size
	var left: Vector2 = base + normal * (arrow_size * 0.45)
	var right: Vector2 = base - normal * (arrow_size * 0.45)
	draw_line(tip, left, line_color, line_width, true)
	draw_line(tip, right, line_color, line_width, true)

func _global_to_local(point: Vector2) -> Vector2:
	return get_global_transform_with_canvas().affine_inverse() * point

func _can_draw_connector(from_control: Control, to_control: Control) -> bool:
	return is_instance_valid(from_control) and is_instance_valid(to_control) and from_control.visible and to_control.visible

func _connect_signal_safe(node: Control) -> void:
	if not is_instance_valid(node):
		return
	if not _watched_controls.has(node):
		_watched_controls.append(node)
	if not node.resized.is_connected(_on_endpoint_changed):
		node.resized.connect(_on_endpoint_changed)
	if not node.visibility_changed.is_connected(_on_endpoint_changed):
		node.visibility_changed.connect(_on_endpoint_changed)

func _disconnect_signals() -> void:
	for node_v in _watched_controls:
		var node: Control = node_v as Control
		_disconnect_signal_safe(node)
	_watched_controls.clear()

func _disconnect_signal_safe(node: Control) -> void:
	if not is_instance_valid(node):
		return
	if node.resized.is_connected(_on_endpoint_changed):
		node.resized.disconnect(_on_endpoint_changed)
	if node.visibility_changed.is_connected(_on_endpoint_changed):
		node.visibility_changed.disconnect(_on_endpoint_changed)

func _on_endpoint_changed() -> void:
	queue_redraw()
</file>

<file path="scripts/ui/DiagnosticsPanelB.gd">
extends PanelContainer

@onready var trace_label = $VBoxContainer/TraceList
@onready var explain_label = $VBoxContainer/ExplainList
@onready var btn_close = $VBoxContainer/BtnClose

func _ready():
	btn_close.pressed.connect(_on_close_pressed)

func setup(explain_lines: Array, trace_steps: Array):
	# Explain
	var txt = "[b]АНАЛИЗ:[/b]\n"
	for line in explain_lines:
		txt += "- " + str(line) + "\n"
	explain_label.text = txt

	# Trace
	var trace_txt = ""
	if trace_steps.is_empty():
		trace_txt = "Трассировка недоступна."
	else:
		for step in trace_steps:
			# Trace format: i=1 | s: 0 -> 1
			trace_txt += "i=%s | s: %s -> %s\n" % [
				str(step.get("i", "?")),
				str(step.get("s_before", "?")),
				str(step.get("s_after", "?"))
			]
	trace_label.text = trace_txt

func _on_close_pressed():
	visible = false
</file>

<file path="scripts/ui/DiagnosticsPanelC.gd">
extends PanelContainer

@onready var lbl_title: Label = $Root/LblTitle
@onready var text_body: RichTextLabel = $Root/Body
@onready var btn_close: Button = $Root/BtnClose

func _ready() -> void:
	btn_close.pressed.connect(_on_close_pressed)

func setup(title: String, lines: Array) -> void:
	lbl_title.text = title
	var out := ""
	for line_var in lines:
		out += "- %s\n" % str(line_var)
	text_body.text = out

func _on_close_pressed() -> void:
	visible = false
</file>

<file path="scripts/ui/InspectorPopup.gd">
extends PopupPanel

@onready var lbl_title: Label = $Root/LblTitle
@onready var lbl_selector: Label = $Root/Info/LblSelectorValue
@onready var lbl_kind: Label = $Root/Info/LblKindValue
@onready var lbl_weight: Label = $Root/Info/LblWeightValue
@onready var lbl_important: Label = $Root/Info/LblImportantValue
@onready var lbl_order: Label = $Root/Info/LblOrderValue
@onready var lbl_color: Label = $Root/Info/LblColorValue
@onready var btn_close: Button = $Root/BtnClose

func _ready() -> void:
	btn_close.pressed.connect(_on_close_pressed)

func show_inspection(source_data: Dictionary) -> void:
	var source_id: String = str(source_data.get("source_id", "UNKNOWN"))
	var selector: String = str(source_data.get("selector", "-"))
	var kind: String = str(source_data.get("kind", "-"))
	var weight: int = int(source_data.get("weight", 0))
	var important: bool = bool(source_data.get("important", false))
	var order: int = int(source_data.get("order", 0))
	var color_value: String = str(source_data.get("color", "")).strip_edges()

	lbl_title.text = "ПРОСМОТР | %s" % source_id
	lbl_selector.text = selector
	lbl_kind.text = kind
	lbl_weight.text = str(weight)
	lbl_important.text = "ДА" if important else "НЕТ"
	lbl_order.text = str(order)
	lbl_color.text = color_value if not color_value.is_empty() else "-"

	if not color_value.is_empty():
		lbl_color.modulate = Color.from_string(color_value, Color(1, 1, 1, 1))
	else:
		lbl_color.modulate = Color(1, 1, 1, 1)

	popup_centered_ratio(0.42)

func _on_close_pressed() -> void:
	hide()
</file>

<file path="scripts/ui/NetItem.gd">
extends Button

signal drag_started(option_id: String, source: String, from_slot: int)

var option_id: String = ""
var option_label: String = ""
var source: String = "PALETTE"
var from_slot: int = -1

var _locked: bool = false
var _feedback_state: String = "neutral"

func setup(option_data: Dictionary) -> void:
	option_id = str(option_data.get("option_id", "")).strip_edges()
	option_label = str(option_data.get("label", option_id))
	text = option_label
	tooltip_text = "Модуль: %s\n%s" % [option_label, str(option_data.get("why", ""))]
	custom_minimum_size = Vector2(0, 88)
	set_source("PALETTE", -1)
	set_feedback_state("neutral")
	set_locked(false)

func set_source(p_source: String, p_from_slot: int) -> void:
	source = p_source
	from_slot = p_from_slot

func set_locked(locked: bool) -> void:
	_locked = locked
	disabled = locked
	_apply_visual_state()

func set_feedback_state(state: String) -> void:
	_feedback_state = state
	_apply_visual_state()

func _get_drag_data(_at_position: Vector2) -> Variant:
	if _locked or option_id == "":
		return null

	drag_started.emit(option_id, source, from_slot)

	var preview: Button = duplicate() as Button
	preview.disabled = true
	preview.modulate.a = 0.9
	var holder: Control = Control.new()
	holder.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(holder)

	return {
		"kind": "NET_ITEM",
		"option_id": option_id,
		"source": source,
		"from_slot": from_slot,
		"node_path": str(get_path())
	}

func _apply_visual_state() -> void:
	var tone: Color = Color(1.0, 1.0, 1.0, 1.0)
	match _feedback_state:
		"correct":
			tone = Color(1.05, 1.05, 1.05, 1.0)
		"wrong":
			tone = Color(1.12, 0.84, 0.86, 1.0)
		"missing":
			tone = Color(1.08, 0.98, 0.9, 1.0)
		_:
			tone = Color(1.0, 1.0, 1.0, 1.0)

	if _locked and _feedback_state == "neutral":
		tone = Color(0.82, 0.82, 0.82, 1.0)

	self_modulate = tone
</file>

<file path="scripts/ui/NetSlot.gd">
extends PanelContainer

signal slot_changed(slot_index: int, option_id: String, prev_option_id: String)
signal slot_cleared(slot_index: int, prev_option_id: String)

@export var slot_index: int = 1
@export var title_path: NodePath = NodePath("Margin/VBox/TopRow/SlotTitle")
@export var item_label_path: NodePath = NodePath("Margin/VBox/ItemLabel")
@export var item_holder_path: NodePath = NodePath("Margin/VBox/ItemHolder")
@export var clear_button_path: NodePath = NodePath("Margin/VBox/TopRow/BtnClear")

var current_option_id: String = ""

var _locked: bool = false
var _drag_hovered: bool = false
var _feedback_state: String = "neutral"

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _item_label: Label = get_node_or_null(item_label_path) as Label
@onready var _item_holder: Control = get_node_or_null(item_holder_path) as Control
@onready var _btn_clear: Button = get_node_or_null(clear_button_path) as Button

func _ready() -> void:
	if is_instance_valid(_btn_clear):
		_btn_clear.pressed.connect(_on_clear_pressed)

	mouse_exited.connect(func() -> void:
		_drag_hovered = false
		_apply_visual_state()
	)

	set_slot_title(slot_index)
	set_current_option("", "")
	set_locked(false)
	_apply_visual_state()

func set_slot_title(index: int) -> void:
	slot_index = index
	if is_instance_valid(_title_label):
		_title_label.text = "КАНАЛ %d" % slot_index

func set_locked(locked: bool) -> void:
	_locked = locked
	_update_clear_button_state()
	_apply_visual_state()

func set_feedback_state(state: String) -> void:
	_feedback_state = state
	_apply_visual_state()

func set_current_option(option_id: String, option_label: String = "") -> void:
	current_option_id = option_id
	if is_instance_valid(_item_label):
		if current_option_id == "":
			_item_label.text = "<пусто>"
		elif option_label != "":
			_item_label.text = option_label
		else:
			_item_label.text = current_option_id
	_update_clear_button_state()
	_apply_visual_state()

func attach_item_control(item_control: Control) -> void:
	if not is_instance_valid(_item_holder):
		return
	if item_control.get_parent() != _item_holder:
		item_control.reparent(_item_holder)
	item_control.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	item_control.size_flags_vertical = Control.SIZE_EXPAND_FILL
	item_control.custom_minimum_size = Vector2(0, 80)
	if is_instance_valid(_item_label):
		_item_label.text = ""
	_pulse()
	_update_clear_button_state()

func clear_item_holder() -> void:
	if not is_instance_valid(_item_holder):
		return
	for child in _item_holder.get_children():
		_item_holder.remove_child(child)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if _locked:
		return false
	if typeof(data) != TYPE_DICTIONARY:
		return false

	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "NET_ITEM":
		return false

	var controller: Node = _get_controller()
	if controller != null and bool(controller.call("is_input_locked")):
		return false

	_drag_hovered = true
	_apply_visual_state()
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	_drag_hovered = false
	_apply_visual_state()
	if typeof(data) != TYPE_DICTIONARY:
		return

	var payload: Dictionary = data as Dictionary
	var controller: Node = _get_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_drop_to_slot", slot_index, payload)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		_flash_reject()
		return

	var new_option_id: String = str(result.get("option_id", ""))
	var prev_option_id: String = str(result.get("prev_option_id", ""))
	var label: String = str(result.get("label", new_option_id))
	set_current_option(new_option_id, label)
	slot_changed.emit(slot_index, new_option_id, prev_option_id)

func _on_clear_pressed() -> void:
	if _locked:
		return
	var controller: Node = _get_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_clear_slot", slot_index)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		return

	var prev_option_id: String = str(result.get("prev_option_id", ""))
	set_current_option("", "")
	slot_cleared.emit(slot_index, prev_option_id)

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		_drag_hovered = false
		_apply_visual_state()

func _get_controller() -> Node:
	return get_tree().get_first_node_in_group("resus_c_controller")

func _update_clear_button_state() -> void:
	if not is_instance_valid(_btn_clear):
		return
	_btn_clear.disabled = _locked or current_option_id == ""

func _apply_visual_state() -> void:
	var tone: Color = Color(1.0, 1.0, 1.0, 1.0)
	match _feedback_state:
		"correct":
			tone = Color(1.05, 1.05, 1.05, 1.0)
		"wrong":
			tone = Color(1.12, 0.84, 0.86, 1.0)
		"missing":
			tone = Color(1.08, 0.98, 0.9, 1.0)
		_:
			tone = Color(1.0, 1.0, 1.0, 1.0)

	if _drag_hovered:
		tone = Color(tone.r * 1.05, tone.g * 1.05, tone.b * 1.05, tone.a)

	if _locked and _feedback_state == "neutral":
		tone = Color(0.85, 0.85, 0.85, 1.0)

	self_modulate = tone

func _pulse() -> void:
	var tween: Tween = create_tween()
	scale = Vector2(1.02, 1.02)
	tween.tween_property(self, "scale", Vector2.ONE, 0.1)

func _flash_reject() -> void:
	self_modulate = Color(1.12, 0.84, 0.86, 1.0)
	var tween: Tween = create_tween()
	tween.tween_property(self, "self_modulate", Color(1.0, 1.0, 1.0, 1.0), 0.12)
</file>

<file path="scripts/ui/network_trace/topology_board_a.gd">
extends Control
class_name NetworkTraceTopologyBoardA

signal device_installed(device_id: String, label_text: String, error_code: String)
signal device_removed
signal trace_animation_finished(success: bool)

const SLOT_NODE_NAME := "?"

var node_names: Array[String] = []
var edge_pairs: Array = []
var node_labels: Dictionary = {}
var node_positions: Dictionary = {}

var slot_size: Vector2 = Vector2(170.0, 90.0)
var tools_locked: bool = true

var installed_device_id: String = ""
var installed_device_label: String = ""
var installed_error_code: String = ""

var packet_visible: bool = false
var packet_progress: float = 0.0
var packet_path: Array[Vector2] = []
var trace_success: bool = true
var trace_tween: Tween = null

func _ready() -> void:
	mouse_filter = MOUSE_FILTER_STOP
	_recalculate_layout()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		_recalculate_layout()
		queue_redraw()

func setup_topology(data: Dictionary) -> void:
	node_names.clear()
	edge_pairs.clear()
	node_labels.clear()
	node_positions.clear()

	var nodes_variant: Variant = data.get("nodes", [])
	if typeof(nodes_variant) == TYPE_ARRAY:
		var nodes_array: Array = nodes_variant
		for node_var in nodes_array:
			node_names.append(str(node_var))

	var edges_variant: Variant = data.get("edges", [])
	if typeof(edges_variant) == TYPE_ARRAY:
		var edges_array: Array = edges_variant
		for edge_var in edges_array:
			if typeof(edge_var) != TYPE_ARRAY:
				continue
			var edge_array: Array = edge_var
			if edge_array.size() < 2:
				continue
			edge_pairs.append([str(edge_array[0]), str(edge_array[1])])

	var labels_variant: Variant = data.get("labels", {})
	if typeof(labels_variant) == TYPE_DICTIONARY:
		node_labels = (labels_variant as Dictionary).duplicate(true)

	if node_names.is_empty():
		node_names = ["SRC", SLOT_NODE_NAME, "DST"]
		edge_pairs = [["SRC", SLOT_NODE_NAME], [SLOT_NODE_NAME, "DST"]]

	_recalculate_layout()
	clear_installed_device()
	queue_redraw()

func set_tools_locked(locked: bool) -> void:
	tools_locked = locked

func has_device_installed() -> bool:
	return not installed_device_id.is_empty()

func get_installed_device_id() -> String:
	return installed_device_id

func get_installed_error_code() -> String:
	return installed_error_code

func clear_installed_device() -> void:
	var had_device: bool = has_device_installed()
	installed_device_id = ""
	installed_device_label = ""
	installed_error_code = ""
	packet_visible = false
	packet_progress = 0.0
	queue_redraw()
	if had_device:
		device_removed.emit()

func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if tools_locked:
		return false
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var drag_data: Dictionary = data
	if str(drag_data.get("type", "")) != "network_trace_device":
		return false
	return _slot_rect().grow(12.0).has_point(at_position)

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	if typeof(data) != TYPE_DICTIONARY:
		return
	var drag_data: Dictionary = data
	installed_device_id = str(drag_data.get("device_id", ""))
	installed_device_label = str(drag_data.get("label", ""))
	installed_error_code = str(drag_data.get("error_code", ""))
	queue_redraw()
	device_installed.emit(installed_device_id, installed_device_label, installed_error_code)

func play_trace_animation(success: bool) -> void:
	if trace_tween != null:
		trace_tween.kill()

	if packet_path.size() < 2:
		trace_animation_finished.emit(success)
		return

	trace_success = success
	packet_visible = true
	packet_progress = 0.0
	queue_redraw()

	var end_progress: float = 1.0 if success else 0.52
	trace_tween = create_tween()
	trace_tween.tween_method(Callable(self, "_set_packet_progress"), 0.0, end_progress, 1.15)
	await trace_tween.finished

	if not success:
		await get_tree().create_timer(0.15).timeout

	packet_visible = false
	packet_progress = 0.0
	queue_redraw()
	trace_animation_finished.emit(success)

func _set_packet_progress(value: float) -> void:
	packet_progress = clampf(value, 0.0, 1.0)
	queue_redraw()

func _recalculate_layout() -> void:
	node_positions.clear()
	if node_names.is_empty():
		packet_path.clear()
		return

	var count: int = node_names.size()
	var width_available: float = maxf(120.0, size.x - 64.0)
	var x_start: float = (size.x - width_available) * 0.5
	var y_line: float = size.y * 0.44

	if count == 1:
		node_positions[node_names[0]] = Vector2(size.x * 0.5, y_line)
	else:
		var step: float = width_available / float(count - 1)
		for idx in range(count):
			var node_name: String = node_names[idx]
			var pos: Vector2 = Vector2(x_start + float(idx) * step, y_line)
			node_positions[node_name] = pos

	_build_packet_path()

func _build_packet_path() -> void:
	packet_path.clear()
	if node_names.size() < 2:
		return

	var start_name: String = node_names[0]
	var end_name: String = node_names[node_names.size() - 1]
	var slot_center: Vector2 = _slot_center()

	var start_pos: Vector2 = node_positions.get(start_name, Vector2(size.x * 0.15, size.y * 0.45))
	var end_pos: Vector2 = node_positions.get(end_name, Vector2(size.x * 0.85, size.y * 0.45))

	packet_path.append(start_pos)
	if slot_center.distance_to(start_pos) > 1.0 and slot_center.distance_to(end_pos) > 1.0:
		packet_path.append(slot_center)
	packet_path.append(end_pos)

func _slot_center() -> Vector2:
	if node_positions.has(SLOT_NODE_NAME):
		return node_positions[SLOT_NODE_NAME]
	return Vector2(size.x * 0.5, size.y * 0.44)

func _slot_rect() -> Rect2:
	var center: Vector2 = _slot_center()
	return Rect2(center - slot_size * 0.5, slot_size)

func _draw() -> void:
	draw_rect(Rect2(Vector2.ZERO, size), Color(0.06, 0.09, 0.08, 0.35), true)
	draw_rect(Rect2(Vector2.ZERO, size), Color(0.2, 0.45, 0.3, 0.45), false, 2.0)

	for edge_var in edge_pairs:
		if typeof(edge_var) != TYPE_ARRAY:
			continue
		var edge: Array = edge_var
		if edge.size() < 2:
			continue
		var from_name: String = str(edge[0])
		var to_name: String = str(edge[1])
		if not node_positions.has(from_name) or not node_positions.has(to_name):
			continue
		var from_pos: Vector2 = node_positions[from_name]
		var to_pos: Vector2 = node_positions[to_name]
		draw_line(from_pos, to_pos, Color(0.35, 0.7, 0.55, 0.9), 3.0)

	for node_name_var in node_names:
		var node_name: String = str(node_name_var)
		if not node_positions.has(node_name):
			continue
		var node_pos: Vector2 = node_positions[node_name]
		if node_name == SLOT_NODE_NAME:
			continue
		draw_circle(node_pos, 16.0, Color(0.12, 0.25, 0.2, 1.0))
		draw_arc(node_pos, 16.0, 0.0, TAU, 24, Color(0.3, 0.85, 0.6, 0.75), 2.0)
		_draw_centered_text(node_name, node_pos + Vector2(0.0, 36.0), 160.0, Color(0.83, 0.98, 0.9, 1.0), 15)
		if node_labels.has(node_name):
			_draw_centered_text(str(node_labels[node_name]), node_pos + Vector2(0.0, 54.0), 220.0, Color(0.65, 0.75, 0.7, 1.0), 13)

	var slot_rect: Rect2 = _slot_rect()
	draw_rect(slot_rect, Color(0.08, 0.12, 0.1, 0.95), true)
	draw_rect(slot_rect, Color(0.95, 0.75, 0.25, 0.9), false, 3.0)
	if tools_locked:
		_draw_centered_text("ЗАБЛОКИРОВАНО", slot_rect.get_center() + Vector2(0.0, 6.0), slot_rect.size.x - 8.0, Color(0.95, 0.45, 0.4, 1.0), 18)
	elif installed_device_id.is_empty():
		_draw_centered_text("ПОМЕСТИТЕ УСТРОЙСТВО", slot_rect.get_center() + Vector2(0.0, 6.0), slot_rect.size.x - 8.0, Color(0.95, 0.95, 0.8, 1.0), 18)
	else:
		_draw_centered_text(installed_device_label, slot_rect.get_center() + Vector2(0.0, 0.0), slot_rect.size.x - 8.0, Color(0.75, 1.0, 0.82, 1.0), 18)

	if packet_visible and packet_path.size() >= 2:
		var packet_pos: Vector2 = _point_on_path(packet_progress)
		var packet_color: Color = Color(0.4, 1.0, 0.45, 1.0) if trace_success else Color(1.0, 0.35, 0.35, 1.0)
		draw_circle(packet_pos, 9.0, packet_color)
		draw_arc(packet_pos, 12.0, 0.0, TAU, 20, Color(packet_color.r, packet_color.g, packet_color.b, 0.35), 2.0)

func _point_on_path(progress: float) -> Vector2:
	if packet_path.is_empty():
		return Vector2.ZERO
	if packet_path.size() == 1:
		return packet_path[0]

	var distances: Array[float] = []
	var total_length: float = 0.0
	for idx in range(packet_path.size() - 1):
		var segment_length: float = packet_path[idx].distance_to(packet_path[idx + 1])
		distances.append(segment_length)
		total_length += segment_length

	if total_length <= 0.001:
		return packet_path[packet_path.size() - 1]

	var target_distance: float = clampf(progress, 0.0, 1.0) * total_length
	var accumulated: float = 0.0
	for idx in range(distances.size()):
		var segment_length: float = distances[idx]
		if accumulated + segment_length >= target_distance:
			var local_t: float = 0.0
			if segment_length > 0.001:
				local_t = (target_distance - accumulated) / segment_length
			return packet_path[idx].lerp(packet_path[idx + 1], local_t)
		accumulated += segment_length

	return packet_path[packet_path.size() - 1]

func _draw_centered_text(text_value: String, center: Vector2, width: float, color: Color, font_size: int) -> void:
	var font: Font = get_theme_default_font()
	if font == null:
		return
	var draw_pos: Vector2 = Vector2(center.x - width * 0.5, center.y)
	draw_string(font, draw_pos, text_value, HORIZONTAL_ALIGNMENT_CENTER, width, font_size, color)
</file>

<file path="scripts/ui/pipeline/PipelineSlot.gd">
extends PanelContainer
class_name PipelineSlotControl

signal module_dropped(slot_type: String, module_data: Dictionary)
signal slot_tapped(slot_type: String)
signal clear_pressed(slot_type: String)
signal bad_drop(slot_type: String, module_data: Dictionary)

@onready var label_slot_title: Label = $Margin/VBox/LabelSlotTitle
@onready var label_module_name: Label = $Margin/VBox/LabelModuleName
@onready var btn_clear: Button = $Margin/VBox/BtnClear

var slot_type: String = ""
var current_module: Dictionary = {}

func _ready() -> void:
	btn_clear.pressed.connect(_on_clear_pressed)
	_update_visual_state()

func setup(p_slot_type: String, title: String) -> void:
	slot_type = p_slot_type
	label_slot_title.text = title
	clear_module()

func has_module() -> bool:
	return not current_module.is_empty()

func get_module() -> Dictionary:
	return current_module.duplicate(true)

func get_module_id() -> String:
	if current_module.is_empty():
		return ""
	return str(current_module.get("module_id", ""))

func set_module(module_data: Dictionary) -> void:
	current_module = module_data.duplicate(true)
	label_module_name.text = str(current_module.get("display", "?"))
	_update_visual_state()

func clear_module() -> void:
	current_module.clear()
	label_module_name.text = "<пусто>"
	_update_visual_state()

func flash_bad_drop() -> void:
	modulate = Color(1.0, 0.55, 0.55, 1.0)
	var tween: Tween = create_tween()
	tween.tween_property(self, "modulate", Color(1.0, 1.0, 1.0, 1.0), 0.2)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	var module_data: Dictionary = _extract_module_data(data)
	if module_data.is_empty():
		return false
	return str(module_data.get("slot_type", "")) == slot_type

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	var module_data: Dictionary = _extract_module_data(data)
	if module_data.is_empty():
		return

	if str(module_data.get("slot_type", "")) != slot_type:
		emit_signal("bad_drop", slot_type, module_data)
		return

	emit_signal("module_dropped", slot_type, module_data)

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("slot_tapped", slot_type)
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("slot_tapped", slot_type)

func _on_clear_pressed() -> void:
	emit_signal("clear_pressed", slot_type)

func _extract_module_data(data: Variant) -> Dictionary:
	if typeof(data) != TYPE_DICTIONARY:
		return {}

	var drop_data: Dictionary = data
	if str(drop_data.get("kind", "")) != "pipeline_module":
		return {}

	var module_variant: Variant = drop_data.get("module", {})
	if typeof(module_variant) != TYPE_DICTIONARY:
		return {}

	var module_data: Dictionary = module_variant
	return module_data.duplicate(true)

func _update_visual_state() -> void:
	btn_clear.disabled = current_module.is_empty()
	if current_module.is_empty():
		modulate = Color(1.0, 1.0, 1.0, 1.0)
	else:
		modulate = Color(0.86, 1.0, 0.9, 1.0)
</file>

<file path="scripts/ui/ResultStamp.gd">
extends Control

@onready var stamp_panel: PanelContainer = $CenterContainer/StampPanel
@onready var stamp_label: Label = $CenterContainer/StampPanel/Margin/StampLabel

var _active_tween: Tween

func _ready() -> void:
	visible = false
	mouse_filter = Control.MOUSE_FILTER_IGNORE

func show_result(is_correct: bool) -> void:
	if _active_tween != null and _active_tween.is_running():
		_active_tween.kill()

	visible = true
	modulate = Color(1, 1, 1, 1)
	stamp_panel.modulate = Color(1, 1, 1, 0)
	stamp_panel.scale = Vector2(0.8, 0.8)

	if is_correct:
		stamp_label.text = "ПОДТВЕРЖДЕНО"
		stamp_label.add_theme_color_override("font_color", Color(0.75, 1.0, 0.72))
	else:
		stamp_label.text = "ОТКЛОНЕНО"
		stamp_label.add_theme_color_override("font_color", Color(1.0, 0.65, 0.62))

	_active_tween = create_tween()
	_active_tween.set_parallel(true)
	_active_tween.tween_property(stamp_panel, "modulate:a", 1.0, 0.12)
	_active_tween.tween_property(stamp_panel, "scale", Vector2(1.0, 1.0), 0.16)
	_active_tween.set_parallel(false)
	_active_tween.tween_interval(0.28)
	_active_tween.tween_property(stamp_panel, "modulate:a", 0.0, 0.72)
	_active_tween.finished.connect(func() -> void:
		visible = false
	)
</file>

<file path="scripts/ui/ResusDropZone.gd">
extends PanelContainer

signal item_placed(item_id: String, to_bucket: String, from_bucket: String)

@export var title_path: NodePath = NodePath("VBox/BucketTitle")
@export var items_container_path: NodePath = NodePath("VBox/ItemsFlow")

var bucket_id: String = ""

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		modulate = Color(1, 1, 1, 1)
	)

func setup(p_bucket_id: String, p_label_text: String) -> void:
	bucket_id = p_bucket_id.to_upper()
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func get_items_container() -> Control:
	return _items_container

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	_items_container.add_child(item_control)
	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", bucket_id)
	else:
		item_control.set_meta("zone_id", bucket_id)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "RESUS_ITEM":
		return false
	modulate = Color(1.08, 1.03, 1.03, 1.0)
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	modulate = Color(1, 1, 1, 1)
	if typeof(data) != TYPE_DICTIONARY:
		return
	var payload: Dictionary = data as Dictionary
	var source_path: String = str(payload.get("source_path", ""))
	if source_path == "":
		return
	var source_node: Node = get_node_or_null(source_path)
	if source_node == null or not is_instance_valid(_items_container):
		return

	var from_bucket: String = str(payload.get("from_zone", source_node.get_meta("zone_id", "PILE")))
	source_node.reparent(_items_container)
	if source_node.has_method("set_zone_id"):
		source_node.call("set_zone_id", bucket_id)
	else:
		source_node.set_meta("zone_id", bucket_id)

	if source_node is Control:
		var control_node: Control = source_node as Control
		var tween: Tween = create_tween()
		control_node.scale = Vector2(1.05, 1.05)
		tween.tween_property(control_node, "scale", Vector2.ONE, 0.1)

	item_placed.emit(str(payload.get("item_id", "")), bucket_id, from_bucket)
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		modulate = Color(1, 1, 1, 1)
</file>

<file path="scripts/ui/subnet/LockIndicator.gd">
extends PanelContainer
class_name NetworkLockIndicator

var label_state: Label = null

func _ready() -> void:
	_ensure_label()
	set_locked()

func set_locked() -> void:
	_apply_state("ЗАБЛОКИРОВАНО", Color(1.0, 0.58, 0.42, 1.0), Color(0.2, 0.08, 0.08, 0.9))

func set_ready() -> void:
	_apply_state("МАСКА УСТАНОВЛЕНА", Color(0.95, 0.88, 0.55, 1.0), Color(0.18, 0.16, 0.08, 0.9))

func set_applied() -> void:
	_apply_state("И ПРИМЕНЕНО", Color(0.62, 0.95, 1.0, 1.0), Color(0.08, 0.14, 0.18, 0.9))

func set_open() -> void:
	_apply_state("ОТКРЫТО", Color(0.4, 1.0, 0.6, 1.0), Color(0.08, 0.18, 0.1, 0.9))

func set_error() -> void:
	_apply_state("ОТКЛОНЕНО", Color(1.0, 0.4, 0.4, 1.0), Color(0.22, 0.05, 0.05, 0.9))

func _apply_state(text_value: String, font_color: Color, bg_color: Color) -> void:
	_ensure_label()
	if label_state != null:
		label_state.text = text_value
		label_state.add_theme_color_override("font_color", font_color)
	self_modulate = bg_color

func _ensure_label() -> void:
	if label_state == null:
		label_state = get_node_or_null("Margin/LabelState") as Label
</file>

<file path="scripts/ui/subnet/MaskOverlay.gd">
extends PanelContainer
class_name SubnetMaskOverlay

signal mask_selected(mask_data: Dictionary, sender: Node)
signal mask_drag_started(mask_data: Dictionary)

var label_mask: Label = null
var mask_data: Dictionary = {}

func _ready() -> void:
	_ensure_label()
	_refresh_label()

func setup(cidr: int, mask_last: int) -> void:
	mask_data = {
		"cidr": cidr,
		"mask_last": mask_last,
		"display": "/%d" % cidr
	}
	_refresh_label()
	set_selected(false)
	tooltip_text = "маска /%d (последний октет %d)" % [cidr, mask_last]

func get_mask_data() -> Dictionary:
	return mask_data.duplicate(true)

func set_selected(active: bool) -> void:
	if active:
		modulate = Color(1.0, 0.95, 0.72, 1.0)
	else:
		modulate = Color(1.0, 1.0, 1.0, 1.0)

func _get_drag_data(_at_position: Vector2) -> Variant:
	if mask_data.is_empty():
		return null

	emit_signal("mask_drag_started", mask_data.duplicate(true))

	var preview_panel: PanelContainer = PanelContainer.new()
	preview_panel.custom_minimum_size = Vector2(128.0, 52.0)
	var preview_margin: MarginContainer = MarginContainer.new()
	preview_margin.add_theme_constant_override("margin_left", 8)
	preview_margin.add_theme_constant_override("margin_top", 6)
	preview_margin.add_theme_constant_override("margin_right", 8)
	preview_margin.add_theme_constant_override("margin_bottom", 6)
	var preview_label: Label = Label.new()
	preview_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	preview_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	preview_label.text = "МАСКА %s" % str(mask_data.get("display", ""))
	preview_margin.add_child(preview_label)
	preview_panel.add_child(preview_margin)
	set_drag_preview(preview_panel)

	return {
		"kind": "subnet_mask_overlay",
		"mask": mask_data.duplicate(true)
	}

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("mask_selected", mask_data.duplicate(true), self)
			accept_event()
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("mask_selected", mask_data.duplicate(true), self)
			accept_event()

func _ensure_label() -> void:
	if label_mask == null:
		label_mask = get_node_or_null("Margin/LabelMask") as Label

func _refresh_label() -> void:
	_ensure_label()
	if label_mask == null:
		return
	if mask_data.is_empty():
		label_mask.text = "МАСКА ?"
	else:
		label_mask.text = "МАСКА %s" % str(mask_data.get("display", ""))
</file>

<file path="scripts/ui/subnet/SubnetRuler.gd">
extends Control
class_name SubnetRulerControl

var step: int = 64
var ip_last: int = 0
var network_last: int = -1
var applied: bool = false
var pulse_until_ms: int = 0

func _ready() -> void:
	set_process(false)
	queue_redraw()

func configure(new_step: int, new_ip_last: int) -> void:
	step = maxi(1, new_step)
	ip_last = clampi(new_ip_last, 0, 255)
	queue_redraw()

func set_result(new_network_last: int) -> void:
	network_last = clampi(new_network_last, 0, 255)
	applied = true
	queue_redraw()

func reset_state() -> void:
	network_last = -1
	applied = false
	pulse_until_ms = 0
	set_process(false)
	queue_redraw()

func pulse_marker(duration_ms: int = 1000) -> void:
	pulse_until_ms = Time.get_ticks_msec() + maxi(0, duration_ms)
	set_process(true)
	queue_redraw()

func current_segment_text() -> String:
	if not applied or network_last < 0:
		return "СЕГМЕНТ: --"
	var segment_end: int = mini(255, network_last + step - 1)
	return "СЕГМЕНТ: %d..%d | ID СЕТИ: %d" % [network_last, segment_end, network_last]

func _process(_delta: float) -> void:
	if pulse_until_ms <= Time.get_ticks_msec():
		set_process(false)
	queue_redraw()

func _draw() -> void:
	var bg_rect: Rect2 = Rect2(Vector2.ZERO, size)
	draw_rect(bg_rect, Color(0.06, 0.08, 0.07, 0.48), true)
	draw_rect(bg_rect, Color(0.24, 0.42, 0.32, 0.55), false, 2.0)

	if size.x < 80.0 or size.y < 60.0:
		return

	var left: float = 18.0
	var right: float = size.x - 18.0
	var axis_y: float = size.y * 0.5
	var axis_width: float = maxf(10.0, right - left)
	draw_line(Vector2(left, axis_y), Vector2(right, axis_y), Color(0.65, 0.85, 0.72, 0.95), 2.0)

	var grid_step: int = 32
	for value in range(0, 257, grid_step):
		var x_pos: float = _x_for_value(float(value), left, axis_width)
		draw_line(Vector2(x_pos, axis_y - 8.0), Vector2(x_pos, axis_y + 8.0), Color(0.4, 0.6, 0.5, 0.8), 1.0)
		if value % 64 == 0:
			_draw_text_centered(str(value), Vector2(x_pos, axis_y + 26.0), 64.0, 13, Color(0.7, 0.86, 0.74, 0.95))

	for boundary in range(0, 257, step):
		var boundary_x: float = _x_for_value(float(boundary), left, axis_width)
		draw_line(Vector2(boundary_x, axis_y - 18.0), Vector2(boundary_x, axis_y + 18.0), Color(0.92, 0.82, 0.42, 0.55), 1.5)

	if applied and network_last >= 0:
		var seg_start: float = _x_for_value(float(network_last), left, axis_width)
		var seg_end: int = mini(256, network_last + step)
		var seg_end_x: float = _x_for_value(float(seg_end), left, axis_width)
		var seg_rect: Rect2 = Rect2(Vector2(seg_start, axis_y - 16.0), Vector2(maxf(2.0, seg_end_x - seg_start), 32.0))
		draw_rect(seg_rect, Color(0.25, 0.55, 0.35, 0.42), true)
		draw_rect(seg_rect, Color(0.48, 0.92, 0.62, 0.8), false, 2.0)

	var marker_x: float = _x_for_value(float(ip_last), left, axis_width)
	var pulse_alpha: float = 0.0
	if pulse_until_ms > Time.get_ticks_msec():
		pulse_alpha = 0.2 + 0.2 * (0.5 + 0.5 * sin(float(Time.get_ticks_msec()) * 0.02))
	draw_line(Vector2(marker_x, axis_y - 24.0), Vector2(marker_x, axis_y + 24.0), Color(1.0, 0.85, 0.25, 0.95), 2.0)
	draw_circle(Vector2(marker_x, axis_y - 26.0), 5.0, Color(1.0, 0.85, 0.25, 1.0))
	if pulse_alpha > 0.0:
		draw_circle(Vector2(marker_x, axis_y - 26.0), 10.0, Color(1.0, 0.85, 0.25, pulse_alpha))

	_draw_text_centered("IP %d" % ip_last, Vector2(marker_x, axis_y - 34.0), 90.0, 13, Color(0.96, 0.92, 0.78, 1.0))
	_draw_text_centered(current_segment_text(), Vector2(size.x * 0.5, size.y - 10.0), size.x - 20.0, 15, Color(0.62, 0.95, 0.72, 1.0))

func _x_for_value(value: float, left: float, width_value: float) -> float:
	return left + (clampf(value, 0.0, 256.0) / 256.0) * width_value

func _draw_text_centered(text_value: String, center: Vector2, width_value: float, font_size: int, color: Color) -> void:
	var font: Font = get_theme_default_font()
	if font == null:
		return
	var draw_pos: Vector2 = Vector2(center.x - width_value * 0.5, center.y)
	draw_string(font, draw_pos, text_value, HORIZONTAL_ALIGNMENT_CENTER, width_value, font_size, color)
</file>

<file path="ui/overlays/NoirOverlay.gd">
extends CanvasLayer

@export_range(0.0, 1.0, 0.01) var intensity: float = 0.18
@export var fx_quality: int = 1
@export var tint_color: Color = Color(0.93, 0.93, 0.93, 1.0)

@onready var crt_overlay: ColorRect = $CRT_Overlay

var _shader_material: ShaderMaterial

func _ready() -> void:
	_shader_material = crt_overlay.material as ShaderMaterial
	if _shader_material == null:
		return
	_shader_material.set_shader_parameter("tint_color", tint_color)
	_shader_material.set_shader_parameter("intensity", intensity)
	_shader_material.set_shader_parameter("fx_quality", fx_quality)
	_shader_material.set_shader_parameter("glitch_strength", 0.0)

func glitch_burst(strength: float = 0.7, duration: float = 0.2) -> void:
	if _shader_material == null:
		return
	var burst_strength: float = clampf(strength, 0.0, 2.0)
	var burst_duration: float = maxf(0.05, duration)
	_shader_material.set_shader_parameter("glitch_strength", burst_strength)
	var tween := create_tween()
	tween.tween_method(
		func(value: float) -> void:
			_shader_material.set_shader_parameter("glitch_strength", value),
		burst_strength,
		0.0,
		burst_duration
	)
</file>

<file path="ui/overlays/NoirOverlay.tscn">
[gd_scene load_steps=4 format=3]

[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="1_script"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="2_shader"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("2_shader")
shader_parameter/tint_color = Color(0.93, 0.93, 0.93, 1)
shader_parameter/intensity = 0.18
shader_parameter/fx_quality = 1
shader_parameter/glitch_strength = 0.0

[node name="NoirOverlay" type="CanvasLayer"]
layer = 100
script = ExtResource("1_script")

[node name="CRT_Overlay" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 0)
</file>

<file path="data/final_report_a_levels.json">
[
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-L01",
        "bucket":  "newbie",
        "briefing":  "Архив поврежден. Соберите список улик.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "LIST_BASIC",
        "allowed_containers":  [
                                   "ul",
                                   "ol"
                               ],
        "allowed_inner_kinds":  [
                                    "LI_ITEM"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_ul",
                              "label":  "\u003cul\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cul\u003e"
                          },
                          {
                              "fragment_id":  "li_a",
                              "label":  "\u003cli\u003eЛог A\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eЛог A\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_b",
                              "label":  "\u003cli\u003eЛог B\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eЛог B\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_c",
                              "label":  "\u003cli\u003eЛог C\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eЛог C\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "close_ul",
                              "label":  "\u003c/ul\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/ul\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eшум\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eшум\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_ul",
                                  "li_a",
                                  "li_b",
                                  "li_c",
                                  "close_ul",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-L02",
        "bucket":  "newbie",
        "briefing":  "Восстановите нумерованный список действий.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "LIST_BASIC",
        "allowed_containers":  [
                                   "ul",
                                   "ol"
                               ],
        "allowed_inner_kinds":  [
                                    "LI_ITEM"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_ol",
                              "label":  "\u003col\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003col\u003e"
                          },
                          {
                              "fragment_id":  "li_1",
                              "label":  "\u003cli\u003eШаг 1\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eШаг 1\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_2",
                              "label":  "\u003cli\u003eШаг 2\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eШаг 2\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_3",
                              "label":  "\u003cli\u003eШаг 3\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eШаг 3\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "close_ol",
                              "label":  "\u003c/ol\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/ol\u003e"
                          },
                          {
                              "fragment_id":  "noise_p",
                              "label":  "\u003cp\u003eшум\u003c/p\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cp\u003eшум\u003c/p\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_ol",
                                  "li_1",
                                  "li_2",
                                  "li_3",
                                  "close_ol",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-N01",
        "bucket":  "newbie",
        "briefing":  "Соберите базовое меню стартапа.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "NAV_MENU",
        "allowed_containers":  [
                                   "nav"
                               ],
        "allowed_inner_kinds":  [
                                    "LINK",
                                    "LI_ITEM",
                                    "TEXT_BLOCK",
                                    "NAV_LIST_OPEN",
                                    "NAV_LIST_CLOSE"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_nav",
                              "label":  "\u003cnav\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cnav\u003e"
                          },
                          {
                              "fragment_id":  "a_home",
                              "label":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "a_mvp",
                              "label":  "\u003ca href=\"#mvp\"\u003eMVP\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#mvp\"\u003eMVP\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "a_team",
                              "label":  "\u003ca href=\"#team\"\u003eКоманда\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#team\"\u003eКоманда\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "close_nav",
                              "label":  "\u003c/nav\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/nav\u003e"
                          },
                          {
                              "fragment_id":  "noise_span",
                              "label":  "\u003cspan\u003eреклама\u003c/span\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cspan\u003eреклама\u003c/span\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_nav",
                                  "a_home",
                                  "a_mvp",
                                  "a_team",
                                  "close_nav",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-N02",
        "bucket":  "newbie",
        "briefing":  "Меню инвесторской страницы: оставьте только нужные ссылки.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "NAV_MENU",
        "allowed_containers":  [
                                   "nav"
                               ],
        "allowed_inner_kinds":  [
                                    "LINK",
                                    "LI_ITEM",
                                    "TEXT_BLOCK",
                                    "NAV_LIST_OPEN",
                                    "NAV_LIST_CLOSE"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_nav",
                              "label":  "\u003cnav\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cnav\u003e"
                          },
                          {
                              "fragment_id":  "a_home",
                              "label":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "a_invest",
                              "label":  "\u003ca href=\"#invest\"\u003eИнвестировать\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#invest\"\u003eИнвестировать\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "close_nav",
                              "label":  "\u003c/nav\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/nav\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eбаннер\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eбаннер\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_nav",
                                  "a_home",
                                  "a_invest",
                                  "close_nav",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-T01",
        "bucket":  "newbie",
        "briefing":  "Соберите протокол входов в таблице.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "TABLE_LOG",
        "allowed_containers":  [
                                   "table"
                               ],
        "allowed_inner_kinds":  [
                                    "TR_ROW"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_table",
                              "label":  "\u003ctable\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003ctable\u003e"
                          },
                          {
                              "fragment_id":  "row_ok_1201",
                              "label":  "\u003ctr\u003e\u003ctd\u003e12:01\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003e12:01\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_deny_1203",
                              "label":  "\u003ctr\u003e\u003ctd\u003e12:03\u003c/td\u003e\u003ctd\u003eОТКАЗ\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003e12:03\u003c/td\u003e\u003ctd\u003eОТКАЗ\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_ok_1210",
                              "label":  "\u003ctr\u003e\u003ctd\u003e12:10\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003e12:10\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "close_table",
                              "label":  "\u003c/table\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/table\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eстрока\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eстрока\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_table",
                                  "row_ok_1201",
                                  "row_deny_1203",
                                  "row_ok_1210",
                                  "close_table",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-T02",
        "bucket":  "newbie",
        "briefing":  "Ловушка: контейнер table должен закрываться корректно.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "TABLE_LOG",
        "allowed_containers":  [
                                   "table"
                               ],
        "allowed_inner_kinds":  [
                                    "TR_ROW"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_table",
                              "label":  "\u003ctable\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003ctable\u003e"
                          },
                          {
                              "fragment_id":  "row_1",
                              "label":  "\u003ctr\u003e\u003ctd\u003eХост-1\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003eХост-1\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_2",
                              "label":  "\u003ctr\u003e\u003ctd\u003eХост-2\u003c/td\u003e\u003ctd\u003eПРЕДУПРЕЖДЕНИЕ\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003eХост-2\u003c/td\u003e\u003ctd\u003eПРЕДУПРЕЖДЕНИЕ\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_3",
                              "label":  "\u003ctr\u003e\u003ctd\u003eХост-3\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003eХост-3\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "close_table",
                              "label":  "\u003c/table\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/table\u003e"
                          },
                          {
                              "fragment_id":  "close_ul",
                              "label":  "\u003c/ul\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/ul\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_table",
                                  "row_1",
                                  "row_2",
                                  "row_3",
                                  "close_table",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-F01",
        "bucket":  "newbie",
        "briefing":  "Соберите простую форму допроса: надпись + поле ввода + кнопка.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FORM_SIMPLE",
        "allowed_containers":  [
                                   "form"
                               ],
        "allowed_inner_kinds":  [
                                    "FORM_FIELD",
                                    "BUTTON",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_form",
                              "label":  "\u003cform\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cform\u003e"
                          },
                          {
                              "fragment_id":  "label_name",
                              "label":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e"
                          },
                          {
                              "fragment_id":  "input_name",
                              "label":  "\u003cinput id=\"n\" /\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003cinput id=\"n\" /\u003e"
                          },
                          {
                              "fragment_id":  "button_submit",
                              "label":  "\u003cbutton\u003eПодтвердить\u003c/button\u003e",
                              "kind":  "BUTTON",
                              "token":  "\u003cbutton\u003eПодтвердить\u003c/button\u003e"
                          },
                          {
                              "fragment_id":  "close_form",
                              "label":  "\u003c/form\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/form\u003e"
                          },
                          {
                              "fragment_id":  "noise_p",
                              "label":  "\u003cp\u003eзаметка\u003c/p\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cp\u003eзаметка\u003c/p\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_form",
                                  "label_name",
                                  "input_name",
                                  "button_submit",
                                  "close_form",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-F02",
        "bucket":  "newbie",
        "briefing":  "Форма с двумя полями, но без усложнения механики.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FORM_SIMPLE",
        "allowed_containers":  [
                                   "form"
                               ],
        "allowed_inner_kinds":  [
                                    "FORM_FIELD",
                                    "BUTTON",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6",
                      "S7"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_form",
                              "label":  "\u003cform\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cform\u003e"
                          },
                          {
                              "fragment_id":  "label_name",
                              "label":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e"
                          },
                          {
                              "fragment_id":  "input_name",
                              "label":  "\u003cinput id=\"n\" /\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003cinput id=\"n\" /\u003e"
                          },
                          {
                              "fragment_id":  "label_code",
                              "label":  "\u003clabel for=\"c\"\u003eКод\u003c/label\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003clabel for=\"c\"\u003eКод\u003c/label\u003e"
                          },
                          {
                              "fragment_id":  "input_code",
                              "label":  "\u003cinput id=\"c\" /\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003cinput id=\"c\" /\u003e"
                          },
                          {
                              "fragment_id":  "button_send",
                              "label":  "\u003cbutton\u003eОтправить\u003c/button\u003e",
                              "kind":  "BUTTON",
                              "token":  "\u003cbutton\u003eОтправить\u003c/button\u003e"
                          },
                          {
                              "fragment_id":  "close_form",
                              "label":  "\u003c/form\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/form\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eреклама\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eреклама\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_form",
                                  "label_name",
                                  "input_name",
                                  "label_code",
                                  "input_code",
                                  "button_send",
                                  "close_form"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-A01",
        "bucket":  "newbie",
        "briefing":  "Соберите служебную заметку отчета.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "ARTICLE_NOTE",
        "allowed_containers":  [
                                   "article"
                               ],
        "allowed_inner_kinds":  [
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_article",
                              "label":  "\u003carticle\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003carticle\u003e"
                          },
                          {
                              "fragment_id":  "h1_final",
                              "label":  "\u003ch1\u003eФинальный отчёт\u003c/h1\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003ch1\u003eФинальный отчёт\u003c/h1\u003e"
                          },
                          {
                              "fragment_id":  "p_evidence",
                              "label":  "\u003cp\u003eУлики восстановлены.\u003c/p\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cp\u003eУлики восстановлены.\u003c/p\u003e"
                          },
                          {
                              "fragment_id":  "small_case",
                              "label":  "\u003csmall\u003e#case08\u003c/small\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003csmall\u003e#case08\u003c/small\u003e"
                          },
                          {
                              "fragment_id":  "close_article",
                              "label":  "\u003c/article\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/article\u003e"
                          },
                          {
                              "fragment_id":  "close_nav",
                              "label":  "\u003c/nav\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/nav\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_article",
                                  "h1_final",
                                  "p_evidence",
                                  "small_case",
                                  "close_article",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           },
        "required_tags_all":  [
                                  "h1",
                                  "p"
                              ]
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-A02",
        "bucket":  "newbie",
        "briefing":  "Ловушка: в отчете отсутствует обязательный заголовок.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "ARTICLE_NOTE",
        "allowed_containers":  [
                                   "article"
                               ],
        "allowed_inner_kinds":  [
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_article",
                              "label":  "\u003carticle\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003carticle\u003e"
                          },
                          {
                              "fragment_id":  "p_body",
                              "label":  "\u003cp\u003eФинальная заметка.\u003c/p\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cp\u003eФинальная заметка.\u003c/p\u003e"
                          },
                          {
                              "fragment_id":  "p_extra",
                              "label":  "\u003cp\u003eПриложение.\u003c/p\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cp\u003eПриложение.\u003c/p\u003e"
                          },
                          {
                              "fragment_id":  "small_note",
                              "label":  "\u003csmall\u003e#архив\u003c/small\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003csmall\u003e#архив\u003c/small\u003e"
                          },
                          {
                              "fragment_id":  "close_article",
                              "label":  "\u003c/article\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/article\u003e"
                          },
                          {
                              "fragment_id":  "noise_nav",
                              "label":  "\u003cnav\u003eменю\u003c/nav\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cnav\u003eменю\u003c/nav\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_article",
                                  "p_body",
                                  "small_note",
                                  "close_article",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           },
        "required_tags_all":  [
                                  "h1",
                                  "p"
                              ]
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-M01",
        "bucket":  "newbie",
        "briefing":  "Соберите фото-улику: изображение + подпись.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FIGURE_MEDIA",
        "allowed_containers":  [
                                   "figure"
                               ],
        "allowed_inner_kinds":  [
                                    "MEDIA",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_figure",
                              "label":  "\u003cfigure\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cfigure\u003e"
                          },
                          {
                              "fragment_id":  "img_main",
                              "label":  "\u003cimg src=\"evidence.png\" /\u003e",
                              "kind":  "MEDIA",
                              "token":  "\u003cimg src=\"evidence.png\" /\u003e"
                          },
                          {
                              "fragment_id":  "caption_main",
                              "label":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e"
                          },
                          {
                              "fragment_id":  "close_figure",
                              "label":  "\u003c/figure\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/figure\u003e"
                          },
                          {
                              "fragment_id":  "li_fake",
                              "label":  "\u003cli\u003eфейк\u003c/li\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cli\u003eфейк\u003c/li\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_figure",
                                  "img_main",
                                  "caption_main",
                                  "close_figure",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-M02",
        "bucket":  "newbie",
        "briefing":  "Ловушка: подпись должна находиться внутри figure.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FIGURE_MEDIA",
        "allowed_containers":  [
                                   "figure"
                               ],
        "allowed_inner_kinds":  [
                                    "MEDIA",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_figure",
                              "label":  "\u003cfigure\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cfigure\u003e"
                          },
                          {
                              "fragment_id":  "img_cam",
                              "label":  "\u003cimg src=\"cam12.png\" /\u003e",
                              "kind":  "MEDIA",
                              "token":  "\u003cimg src=\"cam12.png\" /\u003e"
                          },
                          {
                              "fragment_id":  "caption_cam",
                              "label":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e"
                          },
                          {
                              "fragment_id":  "close_figure",
                              "label":  "\u003c/figure\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/figure\u003e"
                          },
                          {
                              "fragment_id":  "open_div",
                              "label":  "\u003cdiv\u003eподпись\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eподпись\u003c/div\u003e"
                          },
                          {
                              "fragment_id":  "close_div",
                              "label":  "\u003c/div\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_figure",
                                  "img_cam",
                                  "caption_cam",
                                  "close_figure",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    }
]
</file>

<file path="data/network_trace_c_levels.json">
[
  {
    "id": "NT_C_01",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.1.13/25. Найдите ID сети (последний октет).",
    "target_ip": "192.168.1.13",
    "cidr": 25,
    "ip_last": 13,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /25 равен 128. 13 находится в диапазоне 0..127, значит сеть — 0.",
    "explain_full": "Последний октет IP=13 (00001101). Последний октет маски (/25)=128 (10000000). AND=00000000=0. Границы сегмента используют шаг 128: 0..127.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_02",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.1.142/25. Найдите ID сети (последний октет).",
    "target_ip": "192.168.1.142",
    "cidr": 25,
    "ip_last": 142,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /25 равен 128. 142 находится в диапазоне 128..255, значит сеть — 128.",
    "explain_full": "Последний октет IP=142 (10001110). Последний октет маски (/25)=128 (10000000). AND=10000000=128. Границы сегмента используют шаг 128: 128..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_03",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 10.0.5.190/25. Найдите ID сети (последний октет).",
    "target_ip": "10.0.5.190",
    "cidr": 25,
    "ip_last": 190,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /25 равен 128. 190 находится в диапазоне 128..255, значит сеть — 128.",
    "explain_full": "Последний октет IP=190 (10111110). Последний октет маски (/25)=128 (10000000). AND=10000000=128. Границы сегмента используют шаг 128: 128..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_04",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 172.16.8.233/25. Найдите ID сети (последний октет).",
    "target_ip": "172.16.8.233",
    "cidr": 25,
    "ip_last": 233,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /25 равен 128. 233 находится в диапазоне 128..255, значит сеть — 128.",
    "explain_full": "Последний октет IP=233 (11101001). Последний октет маски (/25)=128 (10000000). AND=10000000=128. Границы сегмента используют шаг 128: 128..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_05",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.10.12/26. Найдите ID сети (последний октет).",
    "target_ip": "192.168.10.12",
    "cidr": 26,
    "ip_last": 12,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /26 равен 64. 12 находится в диапазоне 0..63, значит сеть — 0.",
    "explain_full": "Последний октет IP=12 (00001100). Последний октет маски (/26)=192 (11000000). AND=00000000=0. Границы сегмента используют шаг 64: 0..63.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_06",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.10.77/26. Найдите ID сети (последний октет).",
    "target_ip": "192.168.10.77",
    "cidr": 26,
    "ip_last": 77,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 64,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": ""
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "96",
        "label": "96",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "64",
    "explain_short": "Шаг /26 равен 64. 77 находится в диапазоне 64..127, значит сеть — 64.",
    "explain_full": "Последний октет IP=77 (01001101). Последний октет маски (/26)=192 (11000000). AND=01000000=64. Границы сегмента используют шаг 64: 64..127.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_07",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 10.44.7.130/26. Найдите ID сети (последний октет).",
    "target_ip": "10.44.7.130",
    "cidr": 26,
    "ip_last": 130,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /26 равен 64. 130 находится в диапазоне 128..191, значит сеть — 128.",
    "explain_full": "Последний октет IP=130 (10000010). Последний октет маски (/26)=192 (11000000). AND=10000000=128. Границы сегмента используют шаг 64: 128..191.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_08",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 10.44.7.191/26. Найдите ID сети (последний октет).",
    "target_ip": "10.44.7.191",
    "cidr": 26,
    "ip_last": 191,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /26 равен 64. 191 находится в диапазоне 128..191, значит сеть — 128.",
    "explain_full": "Последний октет IP=191 (10111111). Последний октет маски (/26)=192 (11000000). AND=10000000=128. Границы сегмента используют шаг 64: 128..191.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_09",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 203.0.113.200/26. Найдите ID сети (последний октет).",
    "target_ip": "203.0.113.200",
    "cidr": 26,
    "ip_last": 200,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 192,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "192",
    "explain_short": "Шаг /26 равен 64. 200 находится в диапазоне 192..255, значит сеть — 192.",
    "explain_full": "Последний октет IP=200 (11001000). Последний октет маски (/26)=192 (11000000). AND=11000000=192. Границы сегмента используют шаг 64: 192..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_10",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 203.0.113.63/26. Найдите ID сети (последний октет).",
    "target_ip": "203.0.113.63",
    "cidr": 26,
    "ip_last": 63,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /26 равен 64. 63 находится в диапазоне 0..63, значит сеть — 0.",
    "explain_full": "Последний октет IP=63 (00111111). Последний октет маски (/26)=192 (11000000). AND=00000000=0. Границы сегмента используют шаг 64: 0..63.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_11",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 198.51.100.17/27. Найдите ID сети (последний октет).",
    "target_ip": "198.51.100.17",
    "cidr": 27,
    "ip_last": 17,
    "mask_last": 224,
    "step": 32,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "16",
        "label": "16",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /27 равен 32. 17 находится в диапазоне 0..31, значит сеть — 0.",
    "explain_full": "Последний октет IP=17 (00010001). Последний октет маски (/27)=224 (11100000). AND=00000000=0. Границы сегмента используют шаг 32: 0..31.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_12",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 198.51.100.94/27. Найдите ID сети (последний октет).",
    "target_ip": "198.51.100.94",
    "cidr": 27,
    "ip_last": 94,
    "mask_last": 224,
    "step": 32,
    "expected_network_last": 64,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": ""
      },
      {
        "id": "96",
        "label": "96",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      }
    ],
    "correct_id": "64",
    "explain_short": "Шаг /27 равен 32. 94 находится в диапазоне 64..95, значит сеть — 64.",
    "explain_full": "Последний октет IP=94 (01011110). Последний октет маски (/27)=224 (11100000). AND=01000000=64. Границы сегмента используют шаг 32: 64..95.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_13",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 172.20.4.222/27. Найдите ID сети (последний октет).",
    "target_ip": "172.20.4.222",
    "cidr": 27,
    "ip_last": 222,
    "mask_last": 224,
    "step": 32,
    "expected_network_last": 192,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": ""
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "208",
        "label": "208",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "192",
    "explain_short": "Шаг /27 равен 32. 222 находится в диапазоне 192..223, значит сеть — 192.",
    "explain_full": "Последний октет IP=222 (11011110). Последний октет маски (/27)=224 (11100000). AND=11000000=192. Границы сегмента используют шаг 32: 192..223.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_14",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.0.2.14/28. Найдите ID сети (последний октет).",
    "target_ip": "192.0.2.14",
    "cidr": 28,
    "ip_last": 14,
    "mask_last": 240,
    "step": 16,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "16",
        "label": "16",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "240",
        "label": "240",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "8",
        "label": "8",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /28 равен 16. 14 находится в диапазоне 0..15, значит сеть — 0.",
    "explain_full": "Последний октет IP=14 (00001110). Последний октет маски (/28)=240 (11110000). AND=00000000=0. Границы сегмента используют шаг 16: 0..15.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_15",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.0.2.173/28. Найдите ID сети (последний октет).",
    "target_ip": "192.0.2.173",
    "cidr": 28,
    "ip_last": 173,
    "mask_last": 240,
    "step": 16,
    "expected_network_last": 160,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "144",
        "label": "144",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": ""
      },
      {
        "id": "176",
        "label": "176",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "240",
        "label": "240",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      }
    ],
    "correct_id": "160",
    "explain_short": "Шаг /28 равен 16. 173 находится в диапазоне 160..175, значит сеть — 160.",
    "explain_full": "Последний октет IP=173 (10101101). Последний октет маски (/28)=240 (11110000). AND=10100000=160. Границы сегмента используют шаг 16: 160..175.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  }
]
</file>

<file path="data/quest_c_levels.json">
[
  {
    "id": "C-01",
    "bucket": "newbie",
    "briefing": "Найдите ошибку границы цикла.",
    "expected_s": 15,
    "actual_s": 10,
    "code_lines": [
      "s = 0",
      "for i in range(5):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(6):", "result_s": 15 },
        { "option_id": "B", "replace_line": "for i in range(1, 5):", "result_s": 10 },
        { "option_id": "C", "replace_line": "for i in range(7):", "result_s": 21 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "range(5) даёт 0..4, сумма равна 10.",
      "Нужно включить 5, чтобы получить 15."
    ]
  },
  {
    "id": "C-02",
    "bucket": "newbie",
    "briefing": "Граничный оператор в условии неверный.",
    "expected_s": 12,
    "actual_s": 9,
    "code_lines": [
      "s = 0",
      "for i in range(1, 6):",
      "    if i > 3:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i >= 3:", "result_s": 12 },
        { "option_id": "B", "replace_line": "    if i > 4:", "result_s": 5 },
        { "option_id": "C", "replace_line": "    if i >= 4:", "result_s": 9 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущее условие пропускает i = 3.",
      "С учётом i = 3 получаем 3 + 4 + 5 = 12."
    ]
  },
  {
    "id": "C-03",
    "bucket": "newbie",
    "briefing": "Значение шага в range слишком велико.",
    "expected_s": 20,
    "actual_s": 18,
    "code_lines": [
      "s = 0",
      "for i in range(0, 10, 3):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(0, 10, 2):", "result_s": 20 },
        { "option_id": "B", "replace_line": "for i in range(0, 10, 4):", "result_s": 12 },
        { "option_id": "C", "replace_line": "for i in range(0, 8, 2):", "result_s": 12 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущая последовательность: 0, 3, 6, 9.",
      "С шагом 2: 0, 2, 4, 6, 8 -> сумма 20."
    ]
  },
  {
    "id": "C-04",
    "bucket": "newbie",
    "briefing": "Аккумулятор использует неверное выражение.",
    "expected_s": 6,
    "actual_s": 12,
    "code_lines": [
      "s = 0",
      "for i in range(4):",
      "    s += i * 2"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 6 },
        { "option_id": "B", "replace_line": "    s += i * 3", "result_s": 18 },
        { "option_id": "C", "replace_line": "    s += i + 2", "result_s": 14 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущая формула удваивает каждый член.",
      "Базовая сумма цикла для 0..3 равна 6."
    ]
  },
  {
    "id": "C-05",
    "bucket": "newbie",
    "briefing": "Проверка равенства должна быть проверкой диапазона.",
    "expected_s": 6,
    "actual_s": 2,
    "code_lines": [
      "s = 0",
      "for i in range(6):",
      "    if i == 2:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i <= 3:", "result_s": 6 },
        { "option_id": "B", "replace_line": "    if i < 3:", "result_s": 3 },
        { "option_id": "C", "replace_line": "    if i >= 3:", "result_s": 12 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущий код добавляет только одно значение (2).",
      "Нужно 0 + 1 + 2 + 3 = 6."
    ]
  },
  {
    "id": "C-06",
    "bucket": "newbie",
    "briefing": "Логический оператор вызывает избыточный отбор.",
    "expected_s": 1,
    "actual_s": 5,
    "code_lines": [
      "s = 0",
      "for i in range(6):",
      "    if i % 2 == 0 or i > 2:",
      "        s += 1"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 2 == 0 and i > 2:", "result_s": 1 },
        { "option_id": "B", "replace_line": "    if i % 2 == 0:", "result_s": 3 },
        { "option_id": "C", "replace_line": "    if i > 2:", "result_s": 3 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "OR слишком широк для этого фильтра.",
      "Только i = 4 удовлетворяет обоим условиям."
    ]
  },
  {
    "id": "C-07",
    "bucket": "stalker",
    "briefing": "Неверная верхняя граница цикла.",
    "expected_s": 20,
    "actual_s": 27,
    "code_lines": [
      "s = 0",
      "for i in range(2, 8):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(2, 7):", "result_s": 20 },
        { "option_id": "B", "replace_line": "for i in range(1, 7):", "result_s": 21 },
        { "option_id": "C", "replace_line": "for i in range(3, 8):", "result_s": 25 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущий диапазон включает одно лишнее значение.",
      "Диапазон 2..6 даёт ожидаемые 20."
    ]
  },
  {
    "id": "C-08",
    "bucket": "stalker",
    "briefing": "Неверный знак в убывающем цикле.",
    "expected_s": 5,
    "actual_s": 0,
    "code_lines": [
      "s = 0",
      "for i in range(5, 0, 1):",
      "    s += 1"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(5, 0, -1):", "result_s": 5 },
        { "option_id": "B", "replace_line": "for i in range(5, 1, -1):", "result_s": 4 },
        { "option_id": "C", "replace_line": "for i in range(6, 0, -1):", "result_s": 6 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Положительный шаг при start > stop не выполняется.",
      "Для обратного отсчёта нужен отрицательный шаг."
    ]
  },
  {
    "id": "C-09",
    "bucket": "stalker",
    "briefing": "Проверяется неверный остаток по модулю.",
    "expected_s": 4,
    "actual_s": 3,
    "code_lines": [
      "s = 0",
      "for i in range(10):",
      "    if i % 3 == 1:",
      "        s += 1"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 3 == 0:", "result_s": 4 },
        { "option_id": "B", "replace_line": "    if i % 3 == 2:", "result_s": 3 },
        { "option_id": "C", "replace_line": "    if i % 3 != 0:", "result_s": 6 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Нужны кратные 3.",
      "В 0..9 это 0, 3, 6, 9."
    ]
  },
  {
    "id": "C-10",
    "bucket": "stalker",
    "briefing": "Аккумулятор стартует с неверного значения.",
    "expected_s": 15,
    "actual_s": 16,
    "code_lines": [
      "s = 1",
      "for i in range(1, 6):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 0,
      "fix_options": [
        { "option_id": "A", "replace_line": "s = 0", "result_s": 15 },
        { "option_id": "B", "replace_line": "s = 2", "result_s": 17 },
        { "option_id": "C", "replace_line": "s = 5", "result_s": 20 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Тело цикла верное.",
      "Начальное значение накопителя должно быть нулём."
    ]
  },
  {
    "id": "C-11",
    "bucket": "stalker",
    "briefing": "Оператор обновления инвертирован.",
    "expected_s": 10,
    "actual_s": -10,
    "code_lines": [
      "s = 0",
      "for i in range(1, 5):",
      "    s -= i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 10 },
        { "option_id": "B", "replace_line": "    s *= i", "result_s": 0 },
        { "option_id": "C", "replace_line": "    s = i", "result_s": 4 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Вычитание меняет знак ожидаемого результата.",
      "Сложение возвращает ожидаемую сумму."
    ]
  },
  {
    "id": "C-12",
    "bucket": "stalker",
    "briefing": "Отрицание в проверке чётности неверно.",
    "expected_s": 6,
    "actual_s": 9,
    "code_lines": [
      "s = 0",
      "for i in range(6):",
      "    if i % 2 != 0:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 2 == 0:", "result_s": 6 },
        { "option_id": "B", "replace_line": "    if i % 2 != 0:", "result_s": 9 },
        { "option_id": "C", "replace_line": "    if i > 2:", "result_s": 12 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущая ветка суммирует нечётные значения.",
      "Ожидаемое значение требует чётных."
    ]
  },
  {
    "id": "C-13",
    "bucket": "master",
    "briefing": "Составное условие исключает границу.",
    "expected_s": 18,
    "actual_s": 12,
    "code_lines": [
      "s = 0",
      "for i in range(1, 8):",
      "    if i > 2 and i < 6:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i > 2 and i <= 6:", "result_s": 18 },
        { "option_id": "B", "replace_line": "    if i >= 2 and i <= 6:", "result_s": 20 },
        { "option_id": "C", "replace_line": "    if i > 3 and i <= 6:", "result_s": 15 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущее условие отсекает i = 6.",
      "Нужна включающая верхняя граница."
    ]
  },
  {
    "id": "C-14",
    "bucket": "master",
    "briefing": "Неверная арифметика в накоплении.",
    "expected_s": 12,
    "actual_s": 6,
    "code_lines": [
      "s = 0",
      "for i in range(0, 8, 2):",
      "    s += i / 2"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 12 },
        { "option_id": "B", "replace_line": "    s += i * 2", "result_s": 24 },
        { "option_id": "C", "replace_line": "    s += i / 4", "result_s": 3 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Деление уменьшает каждый вклад вдвое.",
      "Нужна прямая аккумуляция i."
    ]
  },
  {
    "id": "C-15",
    "bucket": "master",
    "briefing": "Сдвинутый член в обновлении ломает цель.",
    "expected_s": 15,
    "actual_s": 10,
    "code_lines": [
      "s = 0",
      "for i in range(1, 6):",
      "    s += i - 1"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 15 },
        { "option_id": "B", "replace_line": "    s += i + 1", "result_s": 20 },
        { "option_id": "C", "replace_line": "    s += i - 2", "result_s": 5 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Вычитание 1 из каждого члена занижает сумму.",
      "Используйте исходное i для ожидаемой суммы."
    ]
  },
  {
    "id": "C-16",
    "bucket": "master",
    "briefing": "Управление потоком останавливает цикл слишком рано.",
    "expected_s": 45,
    "actual_s": 39,
    "code_lines": [
      "s = 0",
      "for i in range(1, 10):",
      "    if i == 6:",
      "        continue",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 3,
      "fix_options": [
        { "option_id": "A", "replace_line": "        pass", "result_s": 45 },
        { "option_id": "B", "replace_line": "        break", "result_s": 15 },
        { "option_id": "C", "replace_line": "        s += 0", "result_s": 39 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "continue исключает i = 6 из суммы.",
      "В этой ветке переход не нужен."
    ]
  },
  {
    "id": "C-17",
    "bucket": "master",
    "briefing": "Использовано присваивание вместо накопления.",
    "expected_s": 15,
    "actual_s": 5,
    "code_lines": [
      "s = 0",
      "for i in range(1, 6):",
      "    s = i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 15 },
        { "option_id": "B", "replace_line": "    s *= i", "result_s": 0 },
        { "option_id": "C", "replace_line": "    s = s + 1", "result_s": 5 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущий код перезаписывает s на каждой итерации.",
      "Нужно аддитивное обновление."
    ]
  },
  {
    "id": "C-18",
    "bucket": "master",
    "briefing": "Финальный логический оператор в условии неверный.",
    "expected_s": 6,
    "actual_s": 15,
    "code_lines": [
      "s = 0",
      "for i in range(1, 8):",
      "    if i % 2 == 0 or i % 3 == 0:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 2 == 0 and i % 3 == 0:", "result_s": 6 },
        { "option_id": "B", "replace_line": "    if i % 2 == 0:", "result_s": 12 },
        { "option_id": "C", "replace_line": "    if i % 3 == 0:", "result_s": 9 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "OR захватывает слишком много лишних значений.",
      "AND оставляет только числа, делящиеся и на 2, и на 3."
    ]
  }
]
</file>

<file path="scenes/case_01/CluesQuestA.tscn">
[gd_scene load_steps=7 format=3]

[ext_resource type="Script" path="res://scenes/case_01/CluesQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="Script" path="res://scripts/ui/ClueBucketZone.gd" id="3_bucket"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_6etxf"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="4_noir"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_dimmer"]
bg_color = Color(0, 0, 0, 0.7)

[node name="CluesQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("4_noir")]
layer = 100
script = ExtResource("4_6etxf")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 16

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = " < "

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕЛО №1: УЛИКИ В МУСОРЕ"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
text = "ЭТАП A"
horizontal_alignment = 2
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(200, 30)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
text = "Брифинг..."
autowrap_mode = 3

[node name="WorkArea" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 20

[node name="PoolCard" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.6
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/PoolCard"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/PoolCard/VBox"]
layout_mode = 2
text = "СВАЛКА"
horizontal_alignment = 1

[node name="ItemsFlow" type="GridContainer" parent="SafeArea/MainVBox/WorkArea/PoolCard/VBox"]
layout_mode = 2
size_flags_vertical = 3
columns = 2

[node name="BucketsCard" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea"]
layout_mode = 2
size_flags_horizontal = 3

[node name="BucketsVBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BucketInput" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox"]
layout_mode = 2
size_flags_vertical = 3
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput/VBox"]
layout_mode = 2
text = "ВВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BucketOutput" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox"]
layout_mode = 2
size_flags_vertical = 3
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput/VBox"]
layout_mode = 2
text = "ВЫВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BucketMemory" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox"]
layout_mode = 2
size_flags_vertical = 3
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory/VBox"]
layout_mode = 2
text = "ПАМЯТЬ"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(120, 60)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(160, 60)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"

[node name="Dimmer" type="Panel" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_dimmer")

[node name="ResultPopup" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -150.0
offset_top = -120.0
offset_right = 150.0
offset_bottom = 120.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBox" type="VBoxContainer" parent="ResultPopup"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="VerdictLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ВЕРДИКТ"
horizontal_alignment = 1

[node name="ScoreLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СЧЁТ"
horizontal_alignment = 1

[node name="StabilityLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СТАБИЛЬНОСТЬ"
horizontal_alignment = 1

[node name="HBox" type="HBoxContainer" parent="ResultPopup/VBox"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 1

[node name="BtnRetry" type="Button" parent="ResultPopup/VBox/HBox"]
custom_minimum_size = Vector2(100, 50)
layout_mode = 2
text = "ПОВТОРИТЬ"

[node name="BtnBack" type="Button" parent="ResultPopup/VBox/HBox"]
custom_minimum_size = Vector2(100, 50)
layout_mode = 2
text = "В МЕНЮ"
</file>

<file path="scenes/case_01/DigitalResusQuestA.tscn">
[gd_scene load_steps=8 format=3]

[ext_resource type="Script" path="res://scenes/case_01/DigitalResusQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="Script" path="res://scripts/ui/ResusDropZone.gd" id="3_drop"]
[ext_resource type="Script" path="res://scripts/ui/ResusPileZone.gd" id="4_pile"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="5_noir"]
[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_dimmer"]
bg_color = Color(0, 0, 0, 0.65)

[node name="DigitalResusQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)
[node name="NoirOverlay" parent="." instance=ExtResource("5_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(72, 72)
layout_mode = 2
text = "<"

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(220, 28)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
text = "Брифинг"
autowrap_mode = 3

[node name="SystemCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="SystemVBox" type="VBoxContainer" parent="SafeArea/MainVBox/SystemCard"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="MonitorFrame" type="PanelContainer" parent="SafeArea/MainVBox/SystemCard/SystemVBox"]
custom_minimum_size = Vector2(0, 150)
layout_mode = 2

[node name="MonitorScreen" type="ColorRect" parent="SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.03, 1)

[node name="MonitorLabel" type="Label" parent="SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame"]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -110.0
offset_top = -16.0
offset_right = 110.0
offset_bottom = 16.0
grow_horizontal = 2
grow_vertical = 2
text = "NO SIGNAL"
horizontal_alignment = 1
vertical_alignment = 1

[node name="BootConsole" type="RichTextLabel" parent="SafeArea/MainVBox/SystemCard/SystemVBox"]
custom_minimum_size = Vector2(0, 180)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="ZonesCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ZonesVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="ZoneInput" type="PanelContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
script = ExtResource("3_drop")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput/VBox"]
layout_mode = 2
text = "ВВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ZoneOutput" type="PanelContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
script = ExtResource("3_drop")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput/VBox"]
layout_mode = 2
text = "ВЫВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ZoneMemory" type="PanelContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
script = ExtResource("3_drop")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory/VBox"]
layout_mode = 2
text = "ПАМЯТЬ"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="PartsPileCard" type="PanelContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("4_pile")
items_container_path = NodePath("VBox/Scroll/PartsGrid")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/PartsPileCard"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/PartsPileCard/VBox"]
layout_mode = 2
text = "ДЕТАЛИ"

[node name="Scroll" type="ScrollContainer" parent="SafeArea/MainVBox/PartsPileCard/VBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PartsGrid" type="GridContainer" parent="SafeArea/MainVBox/PartsPileCard/VBox/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(160, 72)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(180, 72)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"

[node name="Dimmer" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.65)
mouse_filter = 2

[node name="ResultPopup" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -190.0
offset_top = -140.0
offset_right = 190.0
offset_bottom = 140.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBox" type="VBoxContainer" parent="ResultPopup"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="VerdictLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ВЕРДИКТ"
horizontal_alignment = 1

[node name="ScoreLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СЧЁТ"
horizontal_alignment = 1

[node name="StabilityLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СТАБИЛЬНОСТЬ"
horizontal_alignment = 1

[node name="Buttons" type="HBoxContainer" parent="ResultPopup/VBox"]
layout_mode = 2
alignment = 1
theme_override_constants/separation = 12

[node name="BtnRetry" type="Button" parent="ResultPopup/VBox/Buttons"]
custom_minimum_size = Vector2(140, 56)
layout_mode = 2
text = "ПОВТОРИТЬ"

[node name="BtnBack" type="Button" parent="ResultPopup/VBox/Buttons"]
custom_minimum_size = Vector2(140, 56)
layout_mode = 2
text = "НАЗАД"
</file>

<file path="scenes/case_01/DigitalResusQuestB.gd">
extends Control

const LEVELS_PATH := "res://data/clues_levels.json"
const CONFIG_CARD_SCENE := preload("res://scenes/ui/ConfigCard.tscn")
const ResusData := preload("res://scripts/case_01/ResusData.gd")
const ResusScoring := preload("res://scripts/case_01/ResusScoring.gd")

const COLOR_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_WARN := Color(0.86, 0.73, 0.56, 1.0)
const COLOR_ERR := Color(0.93, 0.34, 0.38, 1.0)

var stage_b_data: Dictionary = {}
var options_by_id: Dictionary = {}
var option_cards_by_id: Dictionary = {}

var selected_option_id: String = ""
var trace: Array = []
var stage_started_ms: int = 0
var time_to_first_select_ms: int = -1
var selection_count: int = 0
var attempt_index: int = 0
var input_locked: bool = false

@onready var title_label: Label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label: Label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainVBox/Header/StabilityBar
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack

@onready var context_label: Label = $SafeArea/MainVBox/ContextCard/ContextVBox/ContextLabel
@onready var budget_label: Label = $SafeArea/MainVBox/ContextCard/ContextVBox/BudgetRow/BudgetValue

@onready var options_vbox: VBoxContainer = $SafeArea/MainVBox/OptionsCard/Scroll/OptionsVBox

@onready var diagnostic_card: PanelContainer = $SafeArea/MainVBox/DiagnosticCard
@onready var diag_headline: Label = $SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox/DiagHeadline
@onready var diag_body: RichTextLabel = $SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox/DiagBody
@onready var diag_hint: Label = $SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox/DiagHint

@onready var status_label: Label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainVBox/BottomBar/BtnConfirm

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)

	stage_b_data = ResusData.load_stage_b(LEVELS_PATH)
	if stage_b_data.is_empty():
		_show_error("Этап B не загрузился: проверьте данные уровня.")
		return

	_setup_ui()
	_begin_attempt()

func _setup_ui() -> void:
	title_label.text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
	stage_label.text = "ЭТАП B"
	btn_reset.text = "СБРОС"
	btn_confirm.text = "ПОДТВЕРДИТЬ"

	context_label.text = str(stage_b_data.get("context", ""))
	budget_label.text = "%d$" % int(stage_b_data.get("budget", 0))
	_update_stability_ui()
	_build_option_cards()

func _build_option_cards() -> void:
	for child in options_vbox.get_children():
		child.queue_free()
	options_by_id.clear()
	option_cards_by_id.clear()

	var budget: int = int(stage_b_data.get("budget", 0))
	var options: Array = stage_b_data.get("options", []) as Array
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", ""))
		if option_id == "":
			continue
		options_by_id[option_id] = option_data

		var card_node: Node = CONFIG_CARD_SCENE.instantiate()
		if not (card_node is PanelContainer):
			continue
		var card: PanelContainer = card_node as PanelContainer
		options_vbox.add_child(card)
		if card.has_method("setup"):
			card.call("setup", option_data, budget)
		if card.has_signal("selected"):
			card.connect("selected", Callable(self, "_on_option_selected"))
		option_cards_by_id[option_id] = card

func _begin_attempt() -> void:
	selected_option_id = ""
	trace.clear()
	selection_count = 0
	time_to_first_select_ms = -1
	stage_started_ms = Time.get_ticks_msec()
	input_locked = false
	btn_confirm.disabled = true
	diagnostic_card.visible = true
	status_label.text = "Выберите конфигурацию и проверьте прогноз до подтверждения."
	status_label.modulate = COLOR_WARN
	_update_selection_visuals()
	_set_option_lock_state(false)
	_show_preview()

func _on_option_selected(option_id: String) -> void:
	if input_locked:
		return
	selected_option_id = option_id
	selection_count += 1
	if time_to_first_select_ms < 0:
		time_to_first_select_ms = Time.get_ticks_msec() - stage_started_ms
	_log_event("SELECT_OPTION", {
		"option_id": option_id,
		"selection_index": selection_count
	})
	_update_selection_visuals()
	btn_confirm.disabled = false
	status_label.text = "Выбрано: %s" % option_id
	status_label.modulate = COLOR_WARN
	_show_preview()
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _update_selection_visuals() -> void:
	for option_id_v in option_cards_by_id.keys():
		var option_id: String = str(option_id_v)
		var card_v: Variant = option_cards_by_id[option_id]
		if card_v == null:
			continue
		if card_v.has_method("set_selected_state"):
			card_v.call("set_selected_state", option_id == selected_option_id)

func _set_option_lock_state(locked: bool) -> void:
	for card_v in option_cards_by_id.values():
		if card_v == null:
			continue
		if card_v.has_method("set_locked"):
			card_v.call("set_locked", locked)

func _on_confirm_pressed() -> void:
	if input_locked:
		return
	_log_event("CONFIRM_PRESSED", {
		"option_id": selected_option_id,
		"has_selection": selected_option_id != ""
	})

	var snapshot: Dictionary = {"selected_option_id": selected_option_id}
	var result: Dictionary = ResusScoring.calculate_stage_b_result(stage_b_data, snapshot)
	_register_trial(result)
	_show_diagnostic(result)
	_update_stability_ui()
	attempt_index += 1

	input_locked = true
	_set_option_lock_state(true)
	btn_confirm.disabled = true

	if bool(result.get("is_correct", false)):
		if has_node("/root/AudioManager"):
			AudioManager.play("relay")
	else:
		if has_node("/root/AudioManager"):
			AudioManager.play("error")

func _on_reset_pressed() -> void:
	_log_event("RESET_PRESSED", {"prev_option_id": selected_option_id})
	if input_locked:
		_begin_attempt()
		return
	selected_option_id = ""
	_update_selection_visuals()
	btn_confirm.disabled = true
	_show_preview()
	status_label.text = "Выбор сброшен."
	status_label.modulate = COLOR_WARN
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _show_preview() -> void:
	diagnostic_card.visible = true
	if selected_option_id == "":
		diag_headline.text = "Прогноз конфигурации"
		diag_headline.modulate = COLOR_WARN
		diag_body.text = "\n".join([
			"- Рендер-поток: ?",
			"- Бюджет: ?",
			"- Узкое место: ?"
		])
		diag_hint.text = "Выберите один вариант, чтобы увидеть прогноз."
		diag_hint.modulate = COLOR_WARN
		return

	var option_data: Dictionary = _selected_option_data()
	var preview: Dictionary = _build_preview(option_data)
	var render_stream: String = str(preview.get("render_stream", "WARNING"))
	var budget_status: String = str(preview.get("budget_status", "UNKNOWN"))
	var bottleneck: String = str(preview.get("bottleneck", "UNKNOWN"))
	var total_price: int = int(option_data.get("total_price", 0))
	var budget: int = int(stage_b_data.get("budget", 0))

	diag_headline.text = "Прогноз до подтверждения"
	diag_headline.modulate = _render_status_color(render_stream)
	diag_body.text = "\n".join([
		"- Рендер-поток: %s" % render_stream,
		"- Бюджет: %d$ / %d$ (%s)" % [total_price, budget, budget_status],
		"- Узкое место: %s" % bottleneck
	])
	diag_hint.text = str(preview.get("hint", ""))
	diag_hint.modulate = COLOR_WARN if render_stream != "OK" else COLOR_OK

func _build_preview(option_data: Dictionary) -> Dictionary:
	var budget: int = int(stage_b_data.get("budget", 0))
	var total_price: int = int(option_data.get("total_price", 0))
	var cpu_price: int = _part_price(option_data, "CPU")
	var ram_price: int = _part_price(option_data, "RAM")
	var gpu_price: int = _part_price(option_data, "GPU")

	var render_stream: String = "OK"
	var budget_status: String = "IN_RANGE"
	var bottleneck: String = "NONE"
	var hint: String = "Конфигурация выглядит сбалансированно."

	if total_price > budget:
		render_stream = "FAIL"
		budget_status = "OVER"
		bottleneck = "BUDGET"
		hint = "Превышение бюджета даже при нормальной производительности."
	elif cpu_price >= 500 and ram_price <= 120:
		render_stream = "WARNING"
		bottleneck = "RAM"
		hint = "Сильный CPU упирается в слабую RAM."
	elif cpu_price <= 220 and ram_price <= 140 and gpu_price <= 180:
		render_stream = "FAIL"
		bottleneck = "CPU"
		hint = "Конфигурация слишком слабая для цели."
	elif ram_price <= 140:
		render_stream = "WARNING"
		bottleneck = "RAM"
		hint = "Есть риск ограничения по памяти."
	elif gpu_price > 0 and gpu_price <= 180:
		render_stream = "WARNING"
		bottleneck = "GPU"
		hint = "Рендер будет работать, но есть запас для GPU."

	return {
		"render_stream": render_stream,
		"budget_status": budget_status,
		"bottleneck": bottleneck,
		"hint": hint
	}

func _part_price(option_data: Dictionary, key: String) -> int:
	var parts: Array = option_data.get("parts", []) as Array
	for part_v in parts:
		if typeof(part_v) != TYPE_DICTIONARY:
			continue
		var part: Dictionary = part_v as Dictionary
		if str(part.get("k", "")).to_upper() == key.to_upper():
			return int(part.get("price", 0))
	return 0

func _render_status_color(render_stream: String) -> Color:
	match render_stream:
		"OK":
			return COLOR_OK
		"WARNING":
			return COLOR_WARN
		_:
			return COLOR_ERR

func _selected_option_data() -> Dictionary:
	return options_by_id.get(selected_option_id, {}) as Dictionary

func _register_trial(result: Dictionary) -> void:
	var elapsed_ms: int = Time.get_ticks_msec() - stage_started_ms
	var option_data: Dictionary = _selected_option_data()
	var preview: Dictionary = _build_preview(option_data) if not option_data.is_empty() else {}
	var payload: Dictionary = {
		"quest_id": "CASE_01_DIGITAL_RESUS",
		"stage": "B",
		"format": "SINGLE_CHOICE_CONTEXT",
		"level_id": str(stage_b_data.get("id", "CASE01_B_01")),
		"match_key": "CASE01_B_%d" % attempt_index,
		"context": str(stage_b_data.get("context", "")),
		"budget": int(stage_b_data.get("budget", 0)),
		"selected_option_id": selected_option_id,
		"total_price": int(option_data.get("total_price", 0)),
		"selection_count": selection_count,
		"time_to_first_select_ms": max(-1, time_to_first_select_ms),
		"elapsed_ms": elapsed_ms,
		"points": int(result.get("points", 0)),
		"max_points": int(result.get("max_points", 2)),
		"is_correct": bool(result.get("is_correct", false)),
		"is_fit": bool(result.get("is_fit", false)),
		"stability_delta": int(result.get("stability_delta", 0)),
		"verdict_code": str(result.get("verdict_code", "WRONG")),
		"error_code": str(result.get("error_code", "UNKNOWN")),
		"diagnostic_headline": str(result.get("diagnostic_headline", "")),
		"diagnostic_details": (result.get("diagnostic_details", []) as Array).duplicate(),
		"preview_render_stream": str(preview.get("render_stream", "UNKNOWN")),
		"preview_budget_status": str(preview.get("budget_status", "UNKNOWN")),
		"preview_bottleneck": str(preview.get("bottleneck", "UNKNOWN")),
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)

func _show_diagnostic(result: Dictionary) -> void:
	diagnostic_card.visible = true
	var is_correct: bool = bool(result.get("is_correct", false))
	var headline: String = str(result.get("diagnostic_headline", ""))
	var details: Array = result.get("diagnostic_details", []) as Array
	var option_data: Dictionary = _selected_option_data()
	var preview: Dictionary = _build_preview(option_data) if not option_data.is_empty() else {}

	diag_headline.text = headline
	diag_headline.modulate = COLOR_OK if is_correct else COLOR_ERR

	var detail_lines: Array[String] = []
	detail_lines.append("- Рендер-поток: %s" % str(preview.get("render_stream", "UNKNOWN")))
	detail_lines.append("- Бюджет: %d$ / %d$" % [int(option_data.get("total_price", 0)), int(stage_b_data.get("budget", 0))])
	detail_lines.append("- Узкое место: %s" % str(preview.get("bottleneck", "UNKNOWN")))
	detail_lines.append("")
	for detail_v in details:
		detail_lines.append("- %s" % str(detail_v))
	diag_body.text = "\n".join(detail_lines)

	var hint_text: String = ""
	var budget: int = int(stage_b_data.get("budget", 0))
	var total_price: int = int(option_data.get("total_price", 0))
	if total_price > budget:
		hint_text = "Превышение бюджета: +%d$." % (total_price - budget)
	elif selected_option_id == "":
		hint_text = "Сначала выберите один вариант."
	else:
		hint_text = "Можно сделать сброс и проверить другую конфигурацию."
	diag_hint.text = hint_text
	diag_hint.modulate = COLOR_WARN

	status_label.text = "Разбор зафиксирован. Для новой попытки нажмите СБРОС."
	status_label.modulate = COLOR_OK if is_correct else COLOR_WARN

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - stage_started_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _show_error(message: String) -> void:
	status_label.text = message
	status_label.modulate = COLOR_ERR
	btn_confirm.disabled = true
	btn_reset.disabled = true
	await get_tree().create_timer(1.2).timeout
	_on_back_pressed()
</file>

<file path="scenes/case_01/DigitalResusQuestB.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/case_01/DigitalResusQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="DigitalResusQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(72, 72)
layout_mode = 2
text = "<"

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ЗАГОЛОВОК"
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
text = "B"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(220, 28)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="ContextCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="ContextVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContextCard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ContextLabel" type="Label" parent="SafeArea/MainVBox/ContextCard/ContextVBox"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
text = "Контекст"
autowrap_mode = 2

[node name="BudgetRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContextCard/ContextVBox"]
layout_mode = 2

[node name="BudgetLabel" type="Label" parent="SafeArea/MainVBox/ContextCard/ContextVBox/BudgetRow"]
layout_mode = 2
text = "Бюджет:"

[node name="BudgetValue" type="Label" parent="SafeArea/MainVBox/ContextCard/ContextVBox/BudgetRow"]
layout_mode = 2
text = "0$"

[node name="OptionsCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Scroll" type="ScrollContainer" parent="SafeArea/MainVBox/OptionsCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="OptionsVBox" type="VBoxContainer" parent="SafeArea/MainVBox/OptionsCard/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="DiagnosticCard" type="PanelContainer" parent="SafeArea/MainVBox"]
visible = false
custom_minimum_size = Vector2(0, 170)
layout_mode = 2

[node name="DiagnosticVBox" type="VBoxContainer" parent="SafeArea/MainVBox/DiagnosticCard"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="DiagHeadline" type="Label" parent="SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Заголовок"

[node name="DiagBody" type="RichTextLabel" parent="SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox"]
custom_minimum_size = Vector2(0, 82)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="DiagHint" type="Label" parent="SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox"]
layout_mode = 2
text = "Подсказка"
autowrap_mode = 2

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(160, 72)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(220, 72)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"
</file>

<file path="scenes/case_01/DigitalResusQuestC.gd">
extends Control

const LEVELS_PATH := "res://data/clues_levels.json"
const NET_ITEM_SCENE := preload("res://scenes/ui/NetItem.tscn")
const ResusData := preload("res://scripts/case_01/ResusData.gd")
const ResusScoring := preload("res://scripts/case_01/ResusScoring.gd")

const COLOR_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_WARN := Color(0.86, 0.73, 0.56, 1.0)
const COLOR_ERR := Color(0.93, 0.34, 0.38, 1.0)

var stage_c_data: Dictionary = {}
var option_by_id: Dictionary = {}
var correct_set: Dictionary = {}
var option_order: Array[String] = []

var item_nodes_by_option: Dictionary = {}
var slot_item_by_index: Dictionary = {}
var slots: Array[String] = ["", "", ""]

var trace: Array = []
var stage_started_ms: int = 0
var attempt_index: int = 0
var drag_count: int = 0
var slot_change_count: int = 0
var unique_used_set: Dictionary = {}
var time_to_first_action_ms: int = -1
var input_locked: bool = false

@onready var title_label: Label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label: Label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainVBox/Header/StabilityBar
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack

@onready var prompt_label: Label = $SafeArea/MainVBox/PromptCard/PromptLabel

@onready var slot_1: Node = $SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/Slot1
@onready var slot_2: Node = $SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/Slot2
@onready var slot_3: Node = $SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/Slot3

@onready var collisions_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/CollisionsRow/CollisionsValue
@onready var eavesdrop_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/EavesdropRow/EavesdropValue
@onready var filtering_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/FilteringRow/FilteringValue
@onready var media_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/MediaRow/MediaValue

@onready var palette_flow: GridContainer = $SafeArea/MainVBox/PaletteCard/PaletteVBox/Scroll/PaletteFlow

@onready var explanation_card: PanelContainer = $SafeArea/MainVBox/ExplanationCard
@onready var expl_headline: Label = $SafeArea/MainVBox/ExplanationCard/ExplVBox/ExplHeadline
@onready var expl_details: RichTextLabel = $SafeArea/MainVBox/ExplanationCard/ExplVBox/ExplDetails
@onready var expl_why: RichTextLabel = $SafeArea/MainVBox/ExplanationCard/ExplVBox/ExplWhy

@onready var status_label: Label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_analyze: Button = $SafeArea/MainVBox/BottomBar/BtnAnalyze

var _slot_nodes: Array[Node] = []

func _ready() -> void:
	add_to_group("resus_c_controller")

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_slot_nodes = [slot_1, slot_2, slot_3]

	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)

	stage_c_data = ResusData.load_stage_c(LEVELS_PATH)
	if stage_c_data.is_empty():
		_show_error("Данные этапа C некорректны. Возврат в меню.")
		return

	_setup_ui()
	_begin_attempt()
	_on_viewport_size_changed()

func _setup_ui() -> void:
	title_label.text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
	stage_label.text = "ЭТАП C"
	btn_reset.text = "СБРОС"
	btn_analyze.text = "АНАЛИЗ"
	prompt_label.text = str(stage_c_data.get("prompt", ""))

	_build_option_catalog()
	_build_palette()
	_setup_slots()
	_update_risk_dashboard()
	_update_stability_ui()

func _build_option_catalog() -> void:
	option_by_id.clear()
	correct_set.clear()
	option_order.clear()

	var options: Array = stage_c_data.get("options", []) as Array
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", "")).strip_edges()
		if option_id == "":
			continue
		option_by_id[option_id] = option_data
		option_order.append(option_id)
		if bool(option_data.get("is_correct", false)):
			correct_set[option_id] = true

func _build_palette() -> void:
	for child in palette_flow.get_children():
		child.queue_free()
	item_nodes_by_option.clear()

	for option_id in option_order:
		var option_data: Dictionary = option_by_id.get(option_id, {}) as Dictionary
		var node_v: Variant = NET_ITEM_SCENE.instantiate()
		if not (node_v is Control):
			continue
		var item_node: Control = node_v as Control
		palette_flow.add_child(item_node)
		if item_node.has_method("setup"):
			item_node.call("setup", option_data)
		if item_node.has_method("set_source"):
			item_node.call("set_source", "PALETTE", -1)
		if item_node.has_signal("drag_started"):
			item_node.connect("drag_started", Callable(self, "_on_item_drag_started"))
		item_nodes_by_option[option_id] = item_node

	_sort_palette_items()

func _setup_slots() -> void:
	for i in range(_slot_nodes.size()):
		var slot_node: Node = _slot_nodes[i]
		if slot_node == null:
			continue
		if slot_node.has_method("set_slot_title"):
			slot_node.call("set_slot_title", i + 1)
		if slot_node.has_method("set_current_option"):
			slot_node.call("set_current_option", "", "")
		if slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", "neutral")
		if slot_node.has_method("set_locked"):
			slot_node.call("set_locked", false)

func _begin_attempt() -> void:
	trace.clear()
	drag_count = 0
	slot_change_count = 0
	unique_used_set.clear()
	time_to_first_action_ms = -1
	stage_started_ms = Time.get_ticks_msec()
	input_locked = false

	explanation_card.visible = false
	btn_analyze.disabled = false

	slots = ["", "", ""]
	slot_item_by_index.clear()

	for option_id in option_order:
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if not (item_v is Control):
			continue
		var item_node: Control = item_v as Control
		if item_node.get_parent() != palette_flow:
			item_node.reparent(palette_flow)
		if item_node.has_method("set_source"):
			item_node.call("set_source", "PALETTE", -1)
		if item_node.has_method("set_feedback_state"):
			item_node.call("set_feedback_state", "neutral")
		if item_node.has_method("set_locked"):
			item_node.call("set_locked", false)

	_sort_palette_items()

	for i in range(_slot_nodes.size()):
		var slot_node: Node = _slot_nodes[i]
		if slot_node == null:
			continue
		if slot_node.has_method("set_current_option"):
			slot_node.call("set_current_option", "", "")
		if slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", "neutral")
		if slot_node.has_method("set_locked"):
			slot_node.call("set_locked", false)

	_update_status_line("Соберите защищённый периметр")
	_update_risk_dashboard()
	_update_stability_ui()

func is_input_locked() -> bool:
	return input_locked

func handle_drop_to_slot(slot_index: int, data: Dictionary) -> Dictionary:
	if input_locked:
		return {"success": false}
	if not _is_slot_index_valid(slot_index):
		return {"success": false}
	if str(data.get("kind", "")) != "NET_ITEM":
		return {"success": false}

	var option_id: String = str(data.get("option_id", "")).strip_edges()
	if option_id == "" or not option_by_id.has(option_id):
		return {"success": false}

	var source_path: String = str(data.get("node_path", ""))
	var source_node: Node = get_node_or_null(source_path)
	if source_node == null:
		var fallback_node: Variant = item_nodes_by_option.get(option_id, null)
		if fallback_node is Node:
			source_node = fallback_node as Node
	if source_node == null or not (source_node is Control):
		return {"success": false}

	var from_slot: int = int(data.get("from_slot", -1))
	var target_idx: int = slot_index - 1
	var prev_option_id: String = slots[target_idx]

	if from_slot == slot_index and prev_option_id == option_id:
		return {
			"success": true,
			"option_id": option_id,
			"prev_option_id": prev_option_id,
			"label": str((option_by_id.get(option_id, {}) as Dictionary).get("label", option_id))
		}

	if from_slot >= 1 and from_slot <= 3 and from_slot != slot_index:
		_clear_slot_state(from_slot)

	var prev_node_v: Variant = slot_item_by_index.get(slot_index, null)
	if prev_node_v is Control and prev_node_v != source_node:
		_move_item_to_palette(prev_node_v as Control)

	_attach_item_to_slot(source_node as Control, slot_index)
	slots[target_idx] = option_id
	slot_item_by_index[slot_index] = source_node

	_mark_first_action()
	slot_change_count += 1
	unique_used_set[option_id] = true
	_log_event("SLOT_CHANGED", {
		"slot_index": slot_index,
		"option_id": option_id,
		"prev_option_id": prev_option_id
	})
	_update_status_line("")
	_update_risk_dashboard()
	_play_sfx("click")

	return {
		"success": true,
		"option_id": option_id,
		"prev_option_id": prev_option_id,
		"label": str((option_by_id.get(option_id, {}) as Dictionary).get("label", option_id))
	}

func handle_clear_slot(slot_index: int) -> Dictionary:
	if input_locked:
		return {"success": false}
	if not _is_slot_index_valid(slot_index):
		return {"success": false}

	var idx: int = slot_index - 1
	var prev_option_id: String = slots[idx]
	if prev_option_id == "":
		return {"success": false}

	var prev_node_v: Variant = slot_item_by_index.get(slot_index, null)
	if prev_node_v is Control:
		_move_item_to_palette(prev_node_v as Control)

	_clear_slot_state(slot_index)
	_mark_first_action()
	slot_change_count += 1
	_log_event("SLOT_CLEARED", {
		"slot_index": slot_index,
		"prev_option_id": prev_option_id
	})
	_update_status_line("")
	_update_risk_dashboard()
	_play_sfx("click")

	return {
		"success": true,
		"prev_option_id": prev_option_id
	}

func _attach_item_to_slot(item_node: Control, slot_index: int) -> void:
	var slot_node: Node = _get_slot_node(slot_index)
	if slot_node == null:
		return
	if slot_node.has_method("attach_item_control"):
		slot_node.call("attach_item_control", item_node)
	if item_node.has_method("set_source"):
		item_node.call("set_source", "SLOT", slot_index)
	if item_node.has_method("set_locked"):
		item_node.call("set_locked", input_locked)

func _move_item_to_palette(item_node: Control) -> void:
	if item_node.get_parent() != palette_flow:
		item_node.reparent(palette_flow)
	if item_node.has_method("set_source"):
		item_node.call("set_source", "PALETTE", -1)
	if item_node.has_method("set_locked"):
		item_node.call("set_locked", input_locked)
	if not input_locked and item_node.has_method("set_feedback_state"):
		item_node.call("set_feedback_state", "neutral")
	_sort_palette_items()

func _clear_slot_state(slot_index: int) -> void:
	if not _is_slot_index_valid(slot_index):
		return
	var idx: int = slot_index - 1
	slots[idx] = ""
	slot_item_by_index.erase(slot_index)

	var slot_node: Node = _get_slot_node(slot_index)
	if slot_node == null:
		return
	if slot_node.has_method("set_current_option"):
		slot_node.call("set_current_option", "", "")
	if not input_locked and slot_node.has_method("set_feedback_state"):
		slot_node.call("set_feedback_state", "neutral")

func _on_item_drag_started(option_id: String, source: String, from_slot: int) -> void:
	if input_locked:
		return
	_mark_first_action()
	drag_count += 1
	_log_event("DRAG_START", {
		"option_id": option_id,
		"source": source,
		"from_slot": from_slot
	})

func _on_analyze_pressed() -> void:
	if input_locked:
		return

	var filled_slots: int = _filled_slots_count()
	var unique_used_count: int = unique_used_set.size()
	_log_event("ANALYZE_PRESSED", {
		"filled_slots": filled_slots,
		"unique_used_count": unique_used_count
	})

	var selected_ids: Array[String] = _collect_selected_ids()
	var snapshot: Dictionary = {
		"slots": slots.duplicate(),
		"selected": selected_ids.duplicate(),
		"unique_used_count": unique_used_count
	}
	var result: Dictionary = ResusScoring.calculate_stage_c_result(stage_c_data, snapshot)
	var risk: Dictionary = _calculate_risk(slots)

	_register_trial(result, risk)
	_show_explanation(result, risk)
	_apply_result_highlight(result)
	_update_stability_ui()

	input_locked = true
	btn_analyze.disabled = true
	_set_input_locked(true)

	if bool(result.get("is_correct", false)):
		_play_sfx("relay")
	elif bool(result.get("is_fit", false)):
		_play_sfx("click")
	else:
		_play_sfx("error")

func _on_reset_pressed() -> void:
	_log_event("RESET_PRESSED", {
		"prev_filled_slots": _filled_slots_count()
	})
	_begin_attempt()
	_play_sfx("click")

func _set_input_locked(locked: bool) -> void:
	for slot_node in _slot_nodes:
		if slot_node != null and slot_node.has_method("set_locked"):
			slot_node.call("set_locked", locked)
	for item_v in item_nodes_by_option.values():
		if item_v is Node and item_v.has_method("set_locked"):
			(item_v as Node).call("set_locked", locked)

func _show_explanation(result: Dictionary, risk: Dictionary) -> void:
	explanation_card.visible = true

	var verdict_code: String = str(result.get("verdict_code", "FAIL"))
	expl_headline.text = str(result.get("feedback_headline", verdict_code))
	if verdict_code == "PERFECT":
		expl_headline.modulate = COLOR_OK
	elif verdict_code == "GOOD" or verdict_code == "NOISY":
		expl_headline.modulate = COLOR_WARN
	else:
		expl_headline.modulate = COLOR_ERR

	var detail_lines: Array[String] = []
	for detail_v in (result.get("feedback_details", []) as Array):
		detail_lines.append("- %s" % str(detail_v))
	detail_lines.append("")
	detail_lines.append("Сборка сети дала риск-профиль: коллизии=%s | перехват=%s | фильтрация=%s | среда=%s" % [
		_translate_risk_value(str(risk.get("collisions", "MID"))),
		_translate_risk_value(str(risk.get("eavesdrop", "MID"))),
		_translate_risk_value(str(risk.get("filtering", "OFF"))),
		_translate_risk_value(str(risk.get("media", "UNKNOWN")))
	])
	expl_details.text = "\n".join(detail_lines)

	var why_lines: Array[String] = []
	var strategy_flags: Array = result.get("strategy_flags", []) as Array
	var missing_required: Array = result.get("missing_required", []) as Array
	var wrong_selected: int = int(result.get("wrong_selected", 0))

	why_lines.append("Почему это важно:")
	if str(risk.get("filtering", "OFF")) == "OFF":
		why_lines.append("- Без фильтрации трафика периметр остается уязвимым для внешних соединений.")
	else:
		why_lines.append("- Фильтрация включена: риск несанкционированного доступа ниже.")

	if missing_required.is_empty() and wrong_selected == 0:
		why_lines.append("- Выбраны все критически важные элементы периметра.")
	elif not missing_required.is_empty():
		why_lines.append("- Не хватает ключевых звеньев: %s." % ", ".join(_to_string_array(missing_required)))
	else:
		why_lines.append("- Есть лишние или шумные выборы, они повышают общий риск периметра.")

	if strategy_flags.has("TOUCHED_ALL_OPTIONS"):
		why_lines.append("")
		why_lines.append("Зафиксирована переборная стратегия (использованы все варианты).")

	var explain_selected: Array = result.get("explain_selected", []) as Array
	if not explain_selected.is_empty():
		why_lines.append("")
		why_lines.append("Разбор выбранных элементов:")
		for explain_v in explain_selected:
			if typeof(explain_v) != TYPE_DICTIONARY:
				continue
			var explain_item: Dictionary = explain_v as Dictionary
			var marker: String = "[OK]" if bool(explain_item.get("is_correct", false)) else "[X]"
			why_lines.append("%s %s: %s" % [
				marker,
				str(explain_item.get("label", explain_item.get("option_id", "?"))),
				str(explain_item.get("why", ""))
			])

	expl_why.text = "\n".join(why_lines)

	status_label.text = "Результат: %s | Установлено: %d/3" % [verdict_code, _filled_slots_count()]
	status_label.modulate = expl_headline.modulate

func _apply_result_highlight(result: Dictionary) -> void:
	for i in range(1, 4):
		var slot_node: Node = _get_slot_node(i)
		if slot_node != null and slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", "neutral")

	for option_id in option_order:
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if item_v is Node and (item_v as Node).has_method("set_feedback_state"):
			(item_v as Node).call("set_feedback_state", "neutral")

	for i in range(3):
		var option_id: String = slots[i]
		if option_id == "":
			continue
		var state: String = "correct" if correct_set.has(option_id) else "wrong"
		var slot_node: Node = _get_slot_node(i + 1)
		if slot_node != null and slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", state)
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if item_v is Node and (item_v as Node).has_method("set_feedback_state"):
			(item_v as Node).call("set_feedback_state", state)

	for missing_id_v in (result.get("missing_required", []) as Array):
		var missing_id: String = str(missing_id_v)
		if _is_option_in_slots(missing_id):
			continue
		var missing_node_v: Variant = item_nodes_by_option.get(missing_id, null)
		if missing_node_v is Node and (missing_node_v as Node).has_method("set_feedback_state"):
			(missing_node_v as Node).call("set_feedback_state", "missing")

func _register_trial(result: Dictionary, risk: Dictionary) -> void:
	var elapsed_ms: int = Time.get_ticks_msec() - stage_started_ms
	var selected_ids: Array[String] = _collect_selected_ids()
	var payload: Dictionary = {
		"quest_id": "CASE_01_DIGITAL_RESUS",
		"stage": "C",
		"format": "MULTI_CHOICE_SLOTS",
		"level_id": str(stage_c_data.get("id", "CASE01_C_01")),
		"match_key": "CASE01_C_%d" % attempt_index,
		"prompt": str(stage_c_data.get("prompt", "")),
		"slots": slots.duplicate(),
		"selected": selected_ids.duplicate(),
		"selected_count": int(result.get("selected_count", selected_ids.size())),
		"correct_selected": int(result.get("correct_selected", 0)),
		"wrong_selected": int(result.get("wrong_selected", 0)),
		"risk": risk.duplicate(),
		"points": int(result.get("points", 0)),
		"max_points": int(result.get("max_points", 2)),
		"is_correct": bool(result.get("is_correct", false)),
		"is_fit": bool(result.get("is_fit", false)),
		"stability_delta": int(result.get("stability_delta", 0)),
		"verdict_code": str(result.get("verdict_code", "FAIL")),
		"missing_required": _to_string_array(result.get("missing_required", []) as Array),
		"drag_count": drag_count,
		"slot_change_count": slot_change_count,
		"unique_used_count": unique_used_set.size(),
		"strategy_flags": _to_string_array(result.get("strategy_flags", []) as Array),
		"time_to_first_action_ms": max(-1, time_to_first_action_ms),
		"elapsed_ms": elapsed_ms,
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	attempt_index += 1

func _update_status_line(prefix: String) -> void:
	if input_locked:
		return
	var filled: int = _filled_slots_count()
	var used_unique: int = unique_used_set.size()
	if prefix.strip_edges() == "":
		status_label.text = "Установлено: %d/3 | Использовано уникальных: %d" % [filled, used_unique]
	else:
		status_label.text = "%s | Установлено: %d/3 | Использовано уникальных: %d" % [prefix, filled, used_unique]
	status_label.modulate = COLOR_WARN

func _update_risk_dashboard() -> void:
	var risk: Dictionary = _calculate_risk(slots)
	var collisions_raw: String = str(risk.get("collisions", "MID"))
	var eavesdrop_raw: String = str(risk.get("eavesdrop", "MID"))
	var filtering_raw: String = str(risk.get("filtering", "OFF"))
	var media_raw: String = str(risk.get("media", "UNKNOWN"))

	collisions_value.text = _translate_risk_value(collisions_raw)
	eavesdrop_value.text = _translate_risk_value(eavesdrop_raw)
	filtering_value.text = _translate_risk_value(filtering_raw)
	media_value.text = _translate_risk_value(media_raw)

	collisions_value.modulate = _risk_color("collisions", collisions_raw)
	eavesdrop_value.modulate = _risk_color("eavesdrop", eavesdrop_raw)
	filtering_value.modulate = _risk_color("filtering", filtering_raw)
	media_value.modulate = _risk_color("media", media_raw)

func _translate_risk_value(value: String) -> String:
	match value:
		"LOW":
			return "НИЗКИЙ"
		"MID":
			return "СРЕДНИЙ"
		"HIGH":
			return "ВЫСОКИЙ"
		"ON":
			return "ВКЛ"
		"OFF":
			return "ВЫКЛ"
		"NEUTRAL":
			return "НЕЙТРАЛЬНО"
		"UNKNOWN":
			return "НЕИЗВЕСТНО"
		"FIBER":
			return "ОПТИКА"
		"COAX":
			return "КОАКСИАЛ"
		_:
			return value

func _calculate_risk(slot_values: Array[String]) -> Dictionary:
	var selected_set: Dictionary = {}
	for option_id in slot_values:
		if option_id == "":
			continue
		selected_set[option_id] = true

	var collisions: String = "MID"
	if selected_set.has("HUB"):
		collisions = "HIGH"
	elif selected_set.has("SWITCH"):
		collisions = "LOW"

	var filtering: String = "ON" if selected_set.has("FIREWALL") else "OFF"

	var eavesdrop: String = "MID"
	if selected_set.has("FIBER"):
		eavesdrop = "LOW"
	elif selected_set.has("COAX"):
		eavesdrop = "HIGH"

	var media: String = "UNKNOWN"
	if selected_set.has("FIBER"):
		media = "FIBER"
	elif selected_set.has("COAX"):
		media = "COAX"

	return {
		"collisions": collisions,
		"eavesdrop": eavesdrop,
		"filtering": filtering,
		"media": media
	}

func _risk_color(kind: String, value: String) -> Color:
	match kind:
		"collisions", "eavesdrop":
			if value == "LOW":
				return COLOR_OK
			if value == "MID":
				return COLOR_WARN
			return COLOR_ERR
		"filtering":
			return COLOR_OK if value == "ON" else COLOR_ERR
		"media":
			if value == "FIBER":
				return COLOR_OK
			if value == "UNKNOWN":
				return COLOR_WARN
			return COLOR_ERR
		_:
			return COLOR_WARN

func _collect_selected_ids() -> Array[String]:
	var selected_set: Dictionary = {}
	for option_id in slots:
		if option_id == "":
			continue
		selected_set[option_id] = true
	var selected_ids: Array[String] = []
	for option_id_v in selected_set.keys():
		selected_ids.append(str(option_id_v))
	selected_ids.sort()
	return selected_ids

func _filled_slots_count() -> int:
	var count: int = 0
	for option_id in slots:
		if option_id != "":
			count += 1
	return count

func _is_option_in_slots(option_id: String) -> bool:
	for current in slots:
		if current == option_id:
			return true
	return false

func _sort_palette_items() -> void:
	var move_index: int = 0
	for option_id in option_order:
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if not (item_v is Node):
			continue
		var item_node: Node = item_v as Node
		if item_node.get_parent() != palette_flow:
			continue
		palette_flow.move_child(item_node, move_index)
		move_index += 1

func _is_slot_index_valid(slot_index: int) -> bool:
	return slot_index >= 1 and slot_index <= 3

func _get_slot_node(slot_index: int) -> Node:
	if not _is_slot_index_valid(slot_index):
		return null
	return _slot_nodes[slot_index - 1]

func _mark_first_action() -> void:
	if time_to_first_action_ms < 0:
		time_to_first_action_ms = Time.get_ticks_msec() - stage_started_ms

func _to_string_array(values: Array) -> Array[String]:
	var out: Array[String] = []
	for value_v in values:
		out.append(str(value_v))
	return out

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - stage_started_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _play_sfx(event_name: String) -> void:
	if has_node("/root/AudioManager"):
		AudioManager.play(event_name)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _on_viewport_size_changed() -> void:
	var size: Vector2 = get_viewport_rect().size
	var compact: bool = size.x < 900.0 or size.x < size.y
	palette_flow.columns = 1 if compact else 2

	for slot_node in _slot_nodes:
		if slot_node is Control:
			(slot_node as Control).custom_minimum_size = Vector2(0, 96 if compact else 110)

	btn_reset.custom_minimum_size = Vector2(150, 72 if compact else 64)
	btn_analyze.custom_minimum_size = Vector2(190, 72 if compact else 64)

func _show_error(message: String) -> void:
	status_label.text = message
	status_label.modulate = COLOR_ERR
	btn_analyze.disabled = true
	btn_reset.disabled = true
	await get_tree().create_timer(1.2).timeout
	_on_back_pressed()
</file>

<file path="scenes/case_01/DigitalResusQuestC.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/case_01/DigitalResusQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://scenes/ui/NetSlot.tscn" id="3_slot"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="4_noir"]

[node name="DigitalResusQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("4_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(72, 72)
layout_mode = 2
text = "<"

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕЛО"
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(112, 0)
layout_mode = 2
text = "ЭТАП C"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(220, 28)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="PromptCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="PromptLabel" type="Label" parent="SafeArea/MainVBox/PromptCard"]
custom_minimum_size = Vector2(0, 82)
layout_mode = 2
text = "ЗАДАНИЕ"
autowrap_mode = 2

[node name="DiagramCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="DiagramVBox" type="VBoxContainer" parent="SafeArea/MainVBox/DiagramCard"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="DiagramTitle" type="Label" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox"]
layout_mode = 2
text = "СХЕМА ПЕРИМЕТРА"

[node name="DiagramRow" type="HBoxContainer" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 8

[node name="PcNode" type="PanelContainer" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow"]
custom_minimum_size = Vector2(100, 110)
layout_mode = 2

[node name="PcLabel" type="Label" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/PcNode"]
layout_mode = 2
text = "ПК"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Slot1" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow" instance=ExtResource("3_slot")]
layout_mode = 2
size_flags_horizontal = 3
slot_index = 1

[node name="Slot2" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow" instance=ExtResource("3_slot")]
layout_mode = 2
size_flags_horizontal = 3
slot_index = 2

[node name="Slot3" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow" instance=ExtResource("3_slot")]
layout_mode = 2
size_flags_horizontal = 3
slot_index = 3

[node name="ServerNode" type="PanelContainer" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow"]
custom_minimum_size = Vector2(120, 110)
layout_mode = 2

[node name="ServerLabel" type="Label" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/ServerNode"]
layout_mode = 2
text = "СЕРВЕР"
horizontal_alignment = 1
vertical_alignment = 1

[node name="RiskCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="RiskVBox" type="VBoxContainer" parent="SafeArea/MainVBox/RiskCard"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="RiskTitle" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2
text = "ПАНЕЛЬ РИСКОВ"

[node name="CollisionsRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="CollisionsLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/CollisionsRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "КОЛЛИЗИИ"

[node name="CollisionsValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/CollisionsRow"]
layout_mode = 2
text = "СРЕДНИЙ"

[node name="EavesdropRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="EavesdropLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/EavesdropRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ПЕРЕХВАТ"

[node name="EavesdropValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/EavesdropRow"]
layout_mode = 2
text = "СРЕДНИЙ"

[node name="FilteringRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="FilteringLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/FilteringRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ФИЛЬТРАЦИЯ"

[node name="FilteringValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/FilteringRow"]
layout_mode = 2
text = "ВЫКЛ"

[node name="MediaRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="MediaLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/MediaRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "СРЕДА"

[node name="MediaValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/MediaRow"]
layout_mode = 2
text = "НЕИЗВЕСТНО"

[node name="PaletteCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="PaletteVBox" type="VBoxContainer" parent="SafeArea/MainVBox/PaletteCard"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="PaletteTitle" type="Label" parent="SafeArea/MainVBox/PaletteCard/PaletteVBox"]
layout_mode = 2
text = "ПАЛИТРА ОБОРУДОВАНИЯ"

[node name="Scroll" type="ScrollContainer" parent="SafeArea/MainVBox/PaletteCard/PaletteVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PaletteFlow" type="GridContainer" parent="SafeArea/MainVBox/PaletteCard/PaletteVBox/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
columns = 2
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8

[node name="ExplanationCard" type="PanelContainer" parent="SafeArea/MainVBox"]
visible = false
custom_minimum_size = Vector2(0, 180)
layout_mode = 2

[node name="ExplVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ExplanationCard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ExplHeadline" type="Label" parent="SafeArea/MainVBox/ExplanationCard/ExplVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ЗАГОЛОВОК"

[node name="ExplDetails" type="RichTextLabel" parent="SafeArea/MainVBox/ExplanationCard/ExplVBox"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="ExplWhy" type="RichTextLabel" parent="SafeArea/MainVBox/ExplanationCard/ExplVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(150, 72)
layout_mode = 2
text = "СБРОС"

[node name="BtnAnalyze" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(190, 72)
layout_mode = 2
text = "АНАЛИЗ"
</file>

<file path="scenes/case_08/fr8_final_report_a.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scripts/case_08/fr8_final_report_a.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="PackedScene" path="res://scenes/ui/TagPileZone.tscn" id="4_pile"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(1, 0.7, 0.1, 1)
shader_parameter/intensity = 0.13
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="FR8_FinalReportA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.06, 0.06, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(116, 56)
layout_mode = 2
text = "НАЗАД"

[node name="TitleLabel" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #8"
vertical_alignment = 1

[node name="LevelLabel" type="Label" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(200, 0)
layout_mode = 2
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(210, 24)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainLayout/BriefingCard"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "Брифинг"
autowrap_mode = 3

[node name="Body" type="BoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="FragmentsCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="CardVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/FragmentsCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="FragmentsTitle" type="Label" parent="SafeArea/MainLayout/Body/FragmentsCard/CardVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СКЛАД ФРАГМЕНТОВ"

[node name="PileZone" parent="SafeArea/MainLayout/Body/FragmentsCard/CardVBox" instance=ExtResource("4_pile")]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EditorCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.2

[node name="CardVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/EditorCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="EditorTitle" type="Label" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕДАКТОР"

[node name="CodePreviewCard" type="PanelContainer" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
custom_minimum_size = Vector2(0, 140)
layout_mode = 2
size_flags_horizontal = 3

[node name="CodePreview" type="RichTextLabel" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox/CodePreviewCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
bbcode_enabled = true
text = "[code]S1 ____[/code]"
fit_content = false
scroll_active = false

[node name="SlotsTitle" type="Label" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СЛОТЫ"

[node name="SlotsGrid" type="GridContainer" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 3

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "Статус"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(150, 56)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(220, 56)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
disabled = true
text = "ДАЛЕЕ"
</file>

<file path="scenes/NetworkTraceQuest.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")

const DATA_PATHS: Dictionary = {
	"A": "res://data/network_trace_a_levels.json",
	"B": "res://data/network_trace_b_levels.json",
	"C": "res://data/network_trace_c_levels.json"
}

const ACTION_BUTTON_NAMES: Array[String] = [
	"ActionBtn1",
	"ActionBtn2",
	"ActionBtn3",
	"ActionBtn4",
	"ActionBtn5",
	"ActionBtn6"
]

const MAX_ATTEMPTS := 3
const DEFAULT_TIME_LIMIT_SEC := 120
const OPTION_COOLDOWN_MS := 200
const HINT_STABILITY_PENALTY := -5.0
const FAIL_STABILITY_PENALTY := -10.0
const PALETTE_GREEN_ID := 0
const PALETTE_AMBER_ID := 1
const FX_LOW_ID := 0
const FX_HIGH_ID := 1

enum QuestState {
	INIT,
	BRIEFING,
	SOLVING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	SAFE_MODE,
	DIAGNOSTIC
}

@export_enum("A", "B", "C") var complexity_name: String = "A"

@onready var main_layout: VBoxContainer = $MainMargin/MainLayout
@onready var btn_back: Button = $MainMargin/MainLayout/HeaderRow/BtnBack
@onready var lbl_case: Label = $MainMargin/MainLayout/HeaderRow/LblCase
@onready var lbl_session: Label = $MainMargin/MainLayout/HeaderRow/LblSession
@onready var palette_select: OptionButton = $MainMargin/MainLayout/SettingsRow/PaletteSelect
@onready var fx_select: OptionButton = $MainMargin/MainLayout/SettingsRow/FxSelect
@onready var lbl_timer: Label = $MainMargin/MainLayout/SettingsRow/LblTimer
@onready var progress_bar: ProgressBar = $MainMargin/MainLayout/BarsRow/ProgressBar
@onready var stability_bar: ProgressBar = $MainMargin/MainLayout/BarsRow/StabilityBar
@onready var lbl_attempts: Label = $MainMargin/MainLayout/BarsRow/LblAttempts
@onready var body_landscape: HBoxContainer = $MainMargin/MainLayout/BodyLandscape
@onready var body_portrait: VBoxContainer = $MainMargin/MainLayout/BodyPortrait
@onready var terminal_pane: PanelContainer = $MainMargin/MainLayout/BodyLandscape/TerminalPane
@onready var actions_pane: PanelContainer = $MainMargin/MainLayout/BodyLandscape/ActionsPane
@onready var terminal_scroll: ScrollContainer = $MainMargin/MainLayout/BodyLandscape/TerminalPane/TerminalMargin/TerminalScroll
@onready var terminal_text: RichTextLabel = $MainMargin/MainLayout/BodyLandscape/TerminalPane/TerminalMargin/TerminalScroll/TerminalText
@onready var options_grid: GridContainer = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/OptionsGrid
@onready var lbl_status: Label = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/LblStatus
@onready var btn_analyze: Button = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/BottomRow/BtnAnalyze
@onready var btn_hint: Button = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/BottomRow/BtnHint
@onready var btn_next: Button = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/BottomRow/BtnNext
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

var action_buttons: Array[Button] = []
var levels: Array = []
var ordered_options: Array = []
var current_level: Dictionary = {}
var current_level_index := 0
var variant_hash := ""
var state: int = QuestState.INIT

var attempts: Array = []
var task_session: Dictionary = {}
var wrong_count := 0
var level_started_ms := 0
var first_action_ms := -1
var option_unlock_at_ms := 0
var time_limit_sec := DEFAULT_TIME_LIMIT_SEC
var time_left_sec := 0.0
var timer_running := false
var safe_mode := false
var hint_used := false
var level_finished := false
var last_error_code := ""
var current_layout := "landscape"

func _ready() -> void:
	complexity_name = complexity_name.to_upper()
	if not DATA_PATHS.has(complexity_name):
		complexity_name = "A"

	_collect_action_buttons()
	_setup_runtime_controls()
	_connect_runtime_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_fx_quality(FX_LOW_ID)
	_update_stability_bar()
	_apply_layout_mode()

	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)

	if not _load_levels_for_complexity(complexity_name):
		_show_boot_error("Данные уровней недоступны для сложности %s." % complexity_name)
		return

	_load_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible:
		if level_finished:
			state = QuestState.FEEDBACK_FAIL
		elif safe_mode:
			state = QuestState.SAFE_MODE
		else:
			state = QuestState.SOLVING

	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_timer_label()
			_on_timeout()
		else:
			_update_timer_label()

	if option_unlock_at_ms > 0 and Time.get_ticks_msec() >= option_unlock_at_ms:
		option_unlock_at_ms = 0
		if _can_pick_option():
			_set_option_buttons_enabled(true)

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_layout_mode()

func _collect_action_buttons() -> void:
	action_buttons.clear()
	for button_name in ACTION_BUTTON_NAMES:
		var node: Node = options_grid.get_node(button_name)
		if node is Button:
			action_buttons.append(node as Button)

func _setup_runtime_controls() -> void:
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)

	fx_select.clear()
	fx_select.add_item("FX НИЗКИЙ", FX_LOW_ID)
	fx_select.add_item("FX ВЫСОКИЙ", FX_HIGH_ID)
	fx_select.select(FX_LOW_ID)

	btn_next.visible = false
	diagnostics_panel.visible = false

func _connect_runtime_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	fx_select.item_selected.connect(_on_fx_selected)

	for idx in range(action_buttons.size()):
		action_buttons[idx].pressed.connect(_on_action_pressed.bind(idx))

func _load_levels_for_complexity(level_key: String) -> bool:
	var path: String = str(DATA_PATHS[level_key])
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("NetworkTrace missing data file: %s" % path)
		return false

	var parsed: Variant = JSON.parse_string(file.get_as_text())
	var raw_levels: Array = []
	if typeof(parsed) == TYPE_ARRAY:
		raw_levels = parsed
	elif typeof(parsed) == TYPE_DICTIONARY:
		var parsed_dict: Dictionary = parsed
		raw_levels = parsed_dict.get("levels", [])
	else:
		push_error("NetworkTrace invalid JSON shape: %s" % path)
		return false

	var valid_levels: Array = []
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if validate_level(level):
			valid_levels.append(level)
		elif OS.is_debug_build():
			push_error("Invalid NetworkTrace level: %s" % str(level.get("id", "UNKNOWN")))
			return false
		else:
			push_warning("Skipping invalid NetworkTrace level: %s" % str(level.get("id", "UNKNOWN")))

	levels = valid_levels
	return levels.size() > 0

func validate_levels(levels_to_check: Array) -> bool:
	for level_var in levels_to_check:
		if typeof(level_var) != TYPE_DICTIONARY:
			return false
		if not validate_level(level_var):
			return false
	return true

func validate_level(level: Dictionary) -> bool:
	var required_keys: Array[String] = ["id", "briefing", "prompt", "options", "correct_id", "explain_short", "explain_full", "tags"]
	for key in required_keys:
		if not level.has(key):
			return false

	if typeof(level.get("options")) != TYPE_ARRAY:
		return false
	if typeof(level.get("tags")) != TYPE_ARRAY:
		return false

	var options: Array = level.get("options", [])
	if options.size() < 4 or options.size() > 6:
		return false

	var option_ids: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		var option_required: Array[String] = ["id", "label", "error_code"]
		for option_key in option_required:
			if not option.has(option_key):
				return false
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or option_ids.has(option_id):
			return false
		option_ids[option_id] = true

	var correct_id: String = str(level.get("correct_id", ""))
	if not option_ids.has(correct_id):
		return false

	if level.has("ui_order"):
		if typeof(level.get("ui_order")) != TYPE_ARRAY:
			return false
		var order: Array = level.get("ui_order", [])
		for id_var in order:
			var id_str: String = str(id_var)
			if not option_ids.has(id_str):
				return false

	if level.has("time_limit_sec"):
		var limit_val: int = int(level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC))
		if limit_val <= 0:
			return false

	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))
	_set_option_buttons_enabled(false)
	btn_analyze.disabled = true
	btn_hint.disabled = true
	btn_next.disabled = true
	timer_running = false

func _load_level(index: int) -> void:
	if levels.is_empty():
		return

	if index >= levels.size():
		index = 0
	current_level_index = index
	current_level = (levels[index] as Dictionary).duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))
	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	option_unlock_at_ms = 0
	wrong_count = 0
	safe_mode = false
	hint_used = false
	level_finished = false
	last_error_code = ""
	attempts = []

	time_limit_sec = int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC))
	time_left_sec = float(time_limit_sec)
	timer_running = true

	state = QuestState.BRIEFING

	var level_id: String = str(current_level.get("id", "NT_UNKNOWN"))
	task_session = {
		"task_id": level_id,
		"variant_hash": variant_hash,
		"started_at_ticks": level_started_ms,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	lbl_case.text = "СЕТЕВОЙ СЛЕД | %s" % complexity_name
	lbl_session.text = "СЕСС %04d" % (randi() % 10000)
	lbl_attempts.text = "ОШ 0/%d" % MAX_ATTEMPTS
	btn_next.visible = false
	btn_next.disabled = false
	btn_analyze.disabled = true
	btn_hint.disabled = false
	diagnostics_panel.visible = false

	if levels.size() <= 1:
		progress_bar.value = 100.0
	else:
		progress_bar.value = (float(current_level_index) / float(levels.size() - 1)) * 100.0

	_update_timer_label()
	_update_stability_bar()
	_render_terminal_content()
	_setup_option_buttons()
	_set_option_buttons_enabled(true)

	lbl_status.text = "Выберите действие." 
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))

	state = QuestState.SOLVING
	_log_event("task_start", {
		"complexity": complexity_name,
		"layout": current_layout
	})

func _render_terminal_content() -> void:
	var briefing: String = str(current_level.get("briefing", ""))
	var prompt: String = str(current_level.get("prompt", ""))
	var explain_short: String = str(current_level.get("explain_short", ""))
	var tags_arr: Array = current_level.get("tags", [])
	var tag_line := ""
	if not tags_arr.is_empty():
		tag_line = "\n[color=#6f8f6f]ТЕГИ:[/color] %s" % ", ".join(_stringify_array(tags_arr))

	terminal_text.clear()
	terminal_text.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n")
	terminal_text.append_text("%s\n\n" % briefing)
	terminal_text.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n")
	terminal_text.append_text("%s\n" % prompt)
	if not explain_short.is_empty():
		terminal_text.append_text("\n[color=#a1a1a1]ПРИМЕЧАНИЕ[/color]\n%s\n" % explain_short)
	if not tag_line.is_empty():
		terminal_text.append_text(tag_line)
	terminal_scroll.scroll_vertical = 0

func _setup_option_buttons() -> void:
	ordered_options = _ordered_options_for_level(current_level)
	for idx in range(action_buttons.size()):
		var btn: Button = action_buttons[idx]
		if idx < ordered_options.size():
			var option: Dictionary = ordered_options[idx]
			btn.visible = true
			btn.disabled = false
			btn.text = str(option.get("label", ""))
			btn.set_meta("option_id", str(option.get("id", "")))
			btn.set_meta("option_error", str(option.get("error_code", "")))
		else:
			btn.visible = false
			btn.disabled = true
			btn.text = ""
			btn.set_meta("option_id", "")
			btn.set_meta("option_error", "")

func _ordered_options_for_level(level: Dictionary) -> Array:
	var options: Array = level.get("options", [])
	var ordered: Array = []

	if level.has("ui_order"):
		var option_map: Dictionary = {}
		for option_var in options:
			if typeof(option_var) == TYPE_DICTIONARY:
				var option_dict: Dictionary = option_var
				option_map[str(option_dict.get("id", ""))] = option_dict
		var id_order: Array = level.get("ui_order", [])
		for id_var in id_order:
			var option_id: String = str(id_var)
			if option_map.has(option_id):
				ordered.append(option_map[option_id])
		for option_var in options:
			var option_dict: Dictionary = option_var
			if not ordered.has(option_dict):
				ordered.append(option_dict)
	else:
		for option_var in options:
			ordered.append(option_var)

	return ordered

func _on_action_pressed(button_index: int) -> void:
	if not _can_pick_option():
		return
	if button_index < 0 or button_index >= action_buttons.size():
		return

	var btn: Button = action_buttons[button_index]
	var option_id: String = str(btn.get_meta("option_id", ""))
	if option_id.is_empty():
		return

	_register_first_action()
	_play_audio("click")

	_set_option_buttons_enabled(false)
	option_unlock_at_ms = Time.get_ticks_msec() + OPTION_COOLDOWN_MS

	var option: Dictionary = _find_option(option_id)
	var is_correct: bool = option_id == str(current_level.get("correct_id", ""))
	var error_code: String = "" if is_correct else str(option.get("error_code", "UNKNOWN"))
	last_error_code = error_code

	var now_ms: int = Time.get_ticks_msec()
	var attempt_entry: Dictionary = {
		"id": option_id,
		"label": str(option.get("label", "")),
		"correct": is_correct,
		"error_code": error_code,
		"t_ms": now_ms - level_started_ms
	}
	attempts.append(attempt_entry)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt_entry)
	task_session["attempts"] = session_attempts

	_log_event("answer_selected", {
		"option_id": option_id,
		"correct": is_correct,
		"error_code": error_code
	})

	if is_correct:
		_handle_success()
	else:
		_handle_failure(error_code)

func _handle_success() -> void:
	state = QuestState.FEEDBACK_SUCCESS
	lbl_status.text = "Верно. Путь связи подтверждён."
	lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.45))
	_set_option_buttons_enabled(false)
	btn_analyze.disabled = true
	btn_hint.disabled = true
	btn_next.visible = true
	_play_audio("relay")
	_finish_level(true, "success")

func _handle_failure(error_code: String) -> void:
	wrong_count += 1
	lbl_attempts.text = "ОШ %d/%d" % [wrong_count, MAX_ATTEMPTS]
	state = QuestState.FEEDBACK_FAIL

	var short_message: String = ERROR_MAP.short_message(error_code)
	lbl_status.text = "Ошибка: %s" % short_message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.4, 0.4))

	_play_audio("error")
	_trigger_glitch()
	_shake_main_layout()

	if wrong_count >= 2 and not safe_mode:
		_enter_safe_mode()

	if wrong_count >= MAX_ATTEMPTS:
		_finish_level(false, "attempt_limit")
	elif safe_mode:
		state = QuestState.SAFE_MODE
	else:
		state = QuestState.SOLVING

func _enter_safe_mode() -> void:
	safe_mode = true
	state = QuestState.SAFE_MODE
	btn_analyze.disabled = false
	lbl_status.text = "Безопасный режим разблокирован. Доступен анализ."
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.7, 0.35))
	_log_event("safe_mode_enabled", {"wrong_count": wrong_count})

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	if not safe_mode:
		lbl_status.text = "Анализ открывается после 2 ошибок."
		lbl_status.add_theme_color_override("font_color", Color(0.9, 0.8, 0.4))
		return

	_register_first_action()
	if not hint_used:
		hint_used = true
		_log_event("hint_used", {"source": "analyze"})

	var lines: Array[String] = []
	lines.append("Уровень: %s" % str(current_level.get("id", "UNKNOWN")))
	if not last_error_code.is_empty():
		lines.append("Последняя ошибка: %s" % last_error_code)
		lines.append(ERROR_MAP.short_message(last_error_code))
		for detail_line in ERROR_MAP.detail_messages(last_error_code):
			lines.append(detail_line)

	var full_explain: String = str(current_level.get("explain_full", ""))
	if not full_explain.is_empty():
		for explain_line in full_explain.split("\n"):
			var trimmed: String = explain_line.strip_edges()
			if not trimmed.is_empty():
				lines.append(trimmed)

	_show_diagnostics(lines)
	state = QuestState.DIAGNOSTIC
	_log_event("diagnostic_open", {"error_code": last_error_code})

func _on_hint_pressed() -> void:
	if level_finished:
		return

	_register_first_action()
	if not hint_used:
		hint_used = true
		_log_event("hint_used", {"source": "hint_button"})

	var hint_text: String = str(current_level.get("explain_short", "Подсказка недоступна."))
	lbl_status.text = "Подсказка: %s" % hint_text
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.9, 1.0))

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", "UNKNOWN"))})
	_load_level(current_level_index + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	var item_id: int = palette_select.get_item_id(index)
	_apply_palette(item_id)

func _on_fx_selected(index: int) -> void:
	var item_id: int = fx_select.get_item_id(index)
	_apply_fx_quality(item_id)

func _apply_palette(palette_id: int) -> void:
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		_set_overlay_tint(Color(1.0, 0.69, 0.0, 1.0))
	else:
		theme = THEME_GREEN
		_set_overlay_tint(Color(0.0, 1.0, 0.25, 1.0))

func _apply_fx_quality(fx_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("fx_quality", 1 if fx_id == FX_HIGH_ID else 0)
	shader_material.set_shader_parameter("glitch_strength", 0.0)

func _set_overlay_tint(color: Color) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("tint_color", color)

func _update_timer_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	var minutes: int = total_seconds / 60
	var seconds: int = total_seconds % 60
	lbl_timer.text = "%02d:%02d" % [minutes, seconds]

func _update_stability_bar() -> void:
	if GlobalMetrics != null:
		stability_bar.value = float(GlobalMetrics.stability)

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_bar()

func _set_option_buttons_enabled(enabled: bool) -> void:
	for btn in action_buttons:
		if btn.visible:
			btn.disabled = not enabled

func _can_pick_option() -> bool:
	if level_finished:
		return false
	if option_unlock_at_ms > 0:
		return false
	return state == QuestState.SOLVING or state == QuestState.SAFE_MODE

func _find_option(option_id: String) -> Dictionary:
	var options: Array = current_level.get("options", [])
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			continue
		var option: Dictionary = option_var
		if str(option.get("id", "")) == option_id:
			return option
	return {}

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _finish_level(is_correct: bool, end_reason: String) -> void:
	if level_finished and task_session.get("ended_at_ticks", 0) != 0:
		return

	level_finished = true
	timer_running = false
	_set_option_buttons_enabled(false)
	btn_analyze.disabled = not safe_mode
	btn_hint.disabled = true
	btn_next.visible = true

	if not is_correct:
		var explain_short: String = str(current_level.get("explain_short", ""))
		if not explain_short.is_empty():
			lbl_status.text = explain_short
			lbl_status.add_theme_color_override("font_color", Color(1.0, 0.6, 0.45))

	if end_reason == "timeout":
		lbl_status.text = "Время вышло. Окно трассировки закрыто."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))

	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {
		"is_correct": is_correct,
		"reason": end_reason,
		"safe_mode": safe_mode
	})

	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = 0.0
	if not is_correct:
		stability_delta += FAIL_STABILITY_PENALTY
	if hint_used:
		stability_delta += HINT_STABILITY_PENALTY

	var level_id: String = str(current_level.get("id", "NT_UNKNOWN"))
	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": complexity_name,
		"match_key": "NETTRACE_%s|%s" % [complexity_name, level_id],
		"task_id": level_id,
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"safe_mode": safe_mode,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"error_code": "" if is_correct else last_error_code,
		"attempts": attempts,
		"task_session": task_session,
		"stability_delta": stability_delta,
		"hint_used": hint_used,
		"timed_out": end_reason == "timeout",
		"time_to_first_action_ms": first_action_ms,
		"layout": current_layout,
		"ui_vw": int(size.x),
		"ui_vh": int(size.y)
	}
	GlobalMetrics.register_trial(payload)

func _on_timeout() -> void:
	if level_finished:
		return

	last_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {
		"id": "TIMEOUT",
		"label": "TIMEOUT",
		"correct": false,
		"error_code": "TIMEOUT",
		"t_ms": Time.get_ticks_msec() - level_started_ms
	}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_play_audio("error")
	_trigger_glitch()
	_finish_level(false, "timeout")

func _show_diagnostics(lines: Array[String]) -> void:
	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(v: float) -> void: shader_material.set_shader_parameter("glitch_strength", v), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for i in range(4):
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _play_audio(sound_key: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_key)

func _log_event(event_name: String, data: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": event_name,
		"t_ms": Time.get_ticks_msec() - level_started_ms,
		"payload": data
	})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var ids: Array[String] = []
	var options: Array = level.get("options", [])
	for option_var in options:
		var option: Dictionary = option_var
		ids.append(str(option.get("id", "")))
	ids.sort()
	return "%s|%s|%s|%s" % [
		str(level.get("id", "NT_UNKNOWN")),
		str(level.get("prompt", "")),
		str(level.get("correct_id", "")),
		",".join(ids)
	]

func _stringify_array(input: Array) -> Array[String]:
	var out: Array[String] = []
	for value in input:
		out.append(str(value))
	return out

func _apply_layout_mode() -> void:
	if terminal_pane == null or actions_pane == null:
		return
	if body_landscape == null or body_portrait == null:
		return

	var viewport_size: Vector2 = get_viewport_rect().size
	var portrait: bool = viewport_size.x < viewport_size.y

	if portrait:
		if terminal_pane.get_parent() != body_portrait:
			var parent_a: Node = terminal_pane.get_parent()
			if parent_a != null:
				parent_a.remove_child(terminal_pane)
			body_portrait.add_child(terminal_pane)
		if actions_pane.get_parent() != body_portrait:
			var parent_b: Node = actions_pane.get_parent()
			if parent_b != null:
				parent_b.remove_child(actions_pane)
			body_portrait.add_child(actions_pane)
		body_landscape.visible = false
		body_portrait.visible = true
		current_layout = "portrait"
	else:
		if terminal_pane.get_parent() != body_landscape:
			var parent_c: Node = terminal_pane.get_parent()
			if parent_c != null:
				parent_c.remove_child(terminal_pane)
			body_landscape.add_child(terminal_pane)
		if actions_pane.get_parent() != body_landscape:
			var parent_d: Node = actions_pane.get_parent()
			if parent_d != null:
				parent_d.remove_child(actions_pane)
			body_landscape.add_child(actions_pane)
		body_portrait.visible = false
		body_landscape.visible = true
		current_layout = "landscape"

	terminal_pane.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	actions_pane.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	terminal_pane.size_flags_vertical = Control.SIZE_EXPAND_FILL
	actions_pane.size_flags_vertical = Control.SIZE_EXPAND_FILL
</file>

<file path="scenes/radio_intercept/RadioQuestA.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/radio_intercept/RadioQuestA.gd" id="1_script"]

[node name="RadioQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootPanel" type="Panel" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="VBox" type="VBoxContainer" parent="RootPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 20

[node name="HeaderBar" type="HBoxContainer" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
alignment = 1

[node name="BackBtn" type="Button" parent="RootPanel/VBox/HeaderBar"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
text = "НАЗАД"

[node name="Spacer" type="Control" parent="RootPanel/VBox/HeaderBar"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2

[node name="TaskLabel" type="Label" parent="RootPanel/VBox/HeaderBar"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Перехват... Мощность алфавита: 128"

[node name="OscilloBox" type="PanelContainer" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 280)
layout_mode = 2

[node name="OscilloArea" type="Control" parent="RootPanel/VBox/OscilloBox"]
layout_mode = 2
clip_contents = true

[node name="OscilloNode" type="Node2D" parent="RootPanel/VBox/OscilloBox/OscilloArea"]

[node name="OscLine" type="Line2D" parent="RootPanel/VBox/OscilloBox/OscilloArea/OscilloNode"]
width = 3.0
default_color = Color(0, 0.8, 0.4, 1)
antialiased = true

[node name="TunerRow" type="HBoxContainer" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
alignment = 1

[node name="BitsLabel" type="Label" parent="RootPanel/VBox/TunerRow"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Биты: 1"

[node name="BitsSlider" type="HSlider" parent="RootPanel/VBox/TunerRow"]
custom_minimum_size = Vector2(400, 0)
layout_mode = 2
size_flags_vertical = 4
min_value = 1.0
max_value = 10.0
value = 1.0

[node name="ButtonsRow" type="HBoxContainer" parent="RootPanel/VBox"]
layout_mode = 2
theme_override_constants/separation = 40
alignment = 1

[node name="HintButton" type="Button" parent="RootPanel/VBox/ButtonsRow"]
custom_minimum_size = Vector2(200, 60)
layout_mode = 2
text = "Ассистент"

[node name="ConfirmButton" type="Button" parent="RootPanel/VBox/ButtonsRow"]
custom_minimum_size = Vector2(200, 60)
layout_mode = 2
text = "Подтвердить"

[node name="HintLabel" type="Label" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.8, 0.2, 1)
horizontal_alignment = 1

[connection signal="pressed" from="SafeArea/RootPanel/VBox/HeaderBar/BackBtn" to="." method="_on_back_pressed"]
[connection signal="value_changed" from="SafeArea/RootPanel/VBox/TunerRow/BitsSlider" to="." method="_on_slider_value_changed"]
[connection signal="pressed" from="SafeArea/RootPanel/VBox/ButtonsRow/HintButton" to="." method="_on_hint_pressed"]
[connection signal="pressed" from="SafeArea/RootPanel/VBox/ButtonsRow/ConfirmButton" to="." method="_on_confirm_pressed"]
</file>

<file path="scenes/ui/ConfigCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/ConfigCard.gd" id="1_script"]

[node name="ConfigCard" type="PanelContainer"]
custom_minimum_size = Vector2(0, 118)
size_flags_horizontal = 3
mouse_filter = 1
script = ExtResource("1_script")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 2
mouse_filter = 2
theme_override_constants/separation = 4

[node name="Title" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
theme_override_font_sizes/font_size = 22
text = "Конфигурация"

[node name="Price" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
text = "Бюджет: 0$"

[node name="Parts" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
text = "Детали"
autowrap_mode = 2

[node name="Tags" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
theme_override_font_sizes/font_size = 14
text = "Метки"
autowrap_mode = 2
</file>

<file path="scenes/ui/DiagnosticsPanelB.tscn">
[gd_scene load_steps=3 format=3 uid="uid://diagnostics_panel_b"]

[ext_resource type="Script" path="res://scripts/ui/DiagnosticsPanelB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]

[node name="DiagnosticsPanelB" type="PanelContainer"]
visible = false
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 16

[node name="Title" type="Label" parent="VBoxContainer"]
layout_mode = 2
text = "ДИАГНОСТИЧЕСКИЙ ТРЕЙС"
horizontal_alignment = 1

[node name="ExplainList" type="RichTextLabel" parent="VBoxContainer"]
layout_mode = 2
fit_content = true

[node name="TraceList" type="RichTextLabel" parent="VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Журнал трассировки..."

[node name="BtnClose" type="Button" parent="VBoxContainer"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scenes/ui/ResusPartItem.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/ResusPartItem.gd" id="1_script"]

[node name="ResusPartItem" type="Button"]
custom_minimum_size = Vector2(0, 80)
size_flags_horizontal = 3
theme_type_variation = &"FlatButton"
theme_override_font_sizes/font_size = 18
text = "Деталь"
script = ExtResource("1_script")
</file>

<file path="scripts/case_01/ResusData.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = ["id", "briefing", "format", "buckets", "items", "scoring_model", "feedback_rules", "system_state_rules"]
const REQUIRED_BUCKET_IDS: Array[String] = ["INPUT", "OUTPUT", "MEMORY"]
const REQUIRED_PARTS: Array[String] = ["gpu", "ram", "cache"]

static func load_levels(path: String) -> Array:
	var root: Variant = _parse_root(path)
	if typeof(root) == TYPE_NIL:
		return []

	var levels: Array = []
	if typeof(root) == TYPE_ARRAY:
		for level_v in root:
			if typeof(level_v) != TYPE_DICTIONARY:
				continue
			var level_data: Dictionary = level_v as Dictionary
			if validate_level(level_data):
				levels.append(level_data)
	elif typeof(root) == TYPE_DICTIONARY:
		var root_dict: Dictionary = root as Dictionary
		if root_dict.has("stages"):
			var stages: Dictionary = root_dict.get("stages", {}) as Dictionary
			var stage_a: Variant = stages.get("A", null)
			if typeof(stage_a) == TYPE_DICTIONARY:
				var stage_a_data: Dictionary = stage_a as Dictionary
				if validate_level(stage_a_data):
					levels.append(stage_a_data)
	return levels

static func load_stage_b(path: String) -> Dictionary:
	return _load_stage(path, "B")

static func load_stage_c(path: String) -> Dictionary:
	return _load_stage(path, "C")

static func _load_stage(path: String, stage_id: String) -> Dictionary:
	var root: Variant = _parse_root(path)
	if typeof(root) == TYPE_NIL:
		return {}

	var stage_data: Dictionary = {}
	if typeof(root) == TYPE_DICTIONARY:
		var root_dict: Dictionary = root as Dictionary
		stage_data = _extract_stage(root_dict, stage_id)
	elif typeof(root) == TYPE_ARRAY:
		var root_array: Array = root as Array
		for item_v in root_array:
			if typeof(item_v) != TYPE_DICTIONARY:
				continue
			var candidate: Dictionary = item_v as Dictionary
			stage_data = _extract_stage(candidate, stage_id)
			if not stage_data.is_empty():
				break

	if stage_data.is_empty():
		push_error("ResusData: Stage %s section not found" % stage_id)
		return {}

	var is_valid: bool = false
	if stage_id == "B":
		is_valid = validate_stage_b(stage_data)
	elif stage_id == "C":
		is_valid = validate_stage_c(stage_data)
	else:
		push_error("ResusData: unsupported stage id '%s'" % stage_id)
		return {}

	if not is_valid:
		return {}
	return stage_data

static func _parse_root(path: String) -> Variant:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("ResusData: failed to open %s" % path)
		return null

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("ResusData: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return null
	return json.data

static func _extract_stage(root_dict: Dictionary, stage_id: String) -> Dictionary:
	if root_dict.has("stages"):
		var stages: Dictionary = root_dict.get("stages", {}) as Dictionary
		var stage_data_v: Variant = stages.get(stage_id, null)
		if typeof(stage_data_v) == TYPE_DICTIONARY:
			return stage_data_v as Dictionary
	if root_dict.has(stage_id) and typeof(root_dict.get(stage_id, null)) == TYPE_DICTIONARY:
		return root_dict.get(stage_id, {}) as Dictionary
	return {}

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("ResusData: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "MATCHING":
		push_error("ResusData: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var buckets: Array = level.get("buckets", []) as Array
	if buckets.size() != 3:
		push_error("ResusData: level %s must have exactly 3 buckets" % str(level.get("id", "UNKNOWN")))
		return false

	var bucket_ids: Dictionary = {}
	for bucket_v in buckets:
		if typeof(bucket_v) != TYPE_DICTIONARY:
			return false
		var bucket: Dictionary = bucket_v as Dictionary
		var bucket_id: String = str(bucket.get("bucket_id", "")).to_upper()
		if bucket_id == "" or bucket_ids.has(bucket_id):
			push_error("ResusData: duplicate or empty bucket_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		bucket_ids[bucket_id] = true

	for required_bucket in REQUIRED_BUCKET_IDS:
		if not bucket_ids.has(required_bucket):
			push_error("ResusData: bucket %s is required in level %s" % [required_bucket, str(level.get("id", "UNKNOWN"))])
			return false

	var items: Array = level.get("items", []) as Array
	if items.size() != 8:
		push_error("ResusData: level %s must have exactly 8 items" % str(level.get("id", "UNKNOWN")))
		return false

	var item_ids: Dictionary = {}
	for item_v in items:
		if typeof(item_v) != TYPE_DICTIONARY:
			return false
		var item: Dictionary = item_v as Dictionary
		var item_id: String = str(item.get("item_id", ""))
		var label: String = str(item.get("label", ""))
		var correct_bucket_id: String = str(item.get("correct_bucket_id", "")).to_upper()
		if item_id == "" or label == "" or correct_bucket_id == "":
			push_error("ResusData: item contract is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if item_ids.has(item_id):
			push_error("ResusData: duplicate item_id %s in level %s" % [item_id, str(level.get("id", "UNKNOWN"))])
			return false
		if not bucket_ids.has(correct_bucket_id):
			push_error("ResusData: item %s references missing bucket %s" % [item_id, correct_bucket_id])
			return false
		item_ids[item_id] = true

	for mandatory_part in REQUIRED_PARTS:
		if not item_ids.has(mandatory_part):
			push_error("ResusData: mandatory part %s is missing" % mandatory_part)
			return false

	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = scoring_model.get("rules", []) as Array
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	if rules.is_empty() or default_rule.is_empty():
		push_error("ResusData: scoring_model is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for rule_v in rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			return false
		var rule: Dictionary = rule_v as Dictionary
		if not rule.has_all(["min_correct", "points", "stability_delta", "verdict_code"]):
			push_error("ResusData: scoring rule is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
			return false

	if not default_rule.has_all(["code", "points", "stability_delta", "verdict_code"]):
		push_error("ResusData: default_rule is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var system_rules: Dictionary = level.get("system_state_rules", {}) as Dictionary
	if not system_rules.has_all(["monitor_on_if", "ram_ok_if", "fast_type_if"]):
		push_error("ResusData: system_state_rules are incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	return true

static func validate_stage_b(stage_b: Dictionary) -> bool:
	if str(stage_b.get("format", "")) != "SINGLE_CHOICE_CONTEXT":
		push_error("ResusData: Stage B invalid format")
		return false

	var budget: int = int(stage_b.get("budget", 0))
	if budget <= 0:
		push_error("ResusData: Stage B invalid budget")
		return false

	var options: Array = stage_b.get("options", []) as Array
	if options.size() != 4:
		push_error("ResusData: Stage B must contain exactly 4 options")
		return false

	var option_ids: Dictionary = {}
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			push_error("ResusData: Stage B option must be dictionary")
			return false
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", ""))
		if option_id == "" or option_ids.has(option_id):
			push_error("ResusData: Stage B option_id is missing or duplicated")
			return false
		if not option_data.has_all(["title", "total_price", "parts", "tags"]):
			push_error("ResusData: Stage B option %s is incomplete" % option_id)
			return false
		option_ids[option_id] = true

	var correct_option_id: String = str(stage_b.get("correct_option_id", ""))
	if correct_option_id == "" or not option_ids.has(correct_option_id):
		push_error("ResusData: Stage B correct_option_id is invalid")
		return false

	var feedback_rules: Dictionary = stage_b.get("feedback_rules", {}) as Dictionary
	for option_id_v in option_ids.keys():
		var option_id: String = str(option_id_v)
		if not feedback_rules.has(option_id):
			push_error("ResusData: Stage B feedback rule is missing for %s" % option_id)
			return false

	var scoring_model: Dictionary = stage_b.get("scoring_model", {}) as Dictionary
	if scoring_model.is_empty():
		push_error("ResusData: Stage B scoring_model is missing")
		return false
	if not scoring_model.has_all(["correct_points", "wrong_points", "stability_delta_correct", "stability_delta_wrong", "default_rule"]):
		push_error("ResusData: Stage B scoring_model is incomplete")
		return false
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	if not default_rule.has_all(["when", "points", "stability_delta", "verdict_code"]):
		push_error("ResusData: Stage B default_rule is incomplete")
		return false

	return true

static func validate_stage_c(stage_c: Dictionary) -> bool:
	if str(stage_c.get("format", "")) != "MULTI_CHOICE_SLOTS":
		push_error("ResusData: Stage C invalid format")
		return false

	if int(stage_c.get("max_slots", 0)) != 3:
		push_error("ResusData: Stage C max_slots must be 3")
		return false

	var options: Array = stage_c.get("options", []) as Array
	if options.size() != 5:
		push_error("ResusData: Stage C must contain exactly 5 options")
		return false

	var required_effect_keys: Array[String] = ["collisions", "filtering", "eavesdrop", "media"]
	var option_ids: Dictionary = {}
	var correct_count: int = 0
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			push_error("ResusData: Stage C option must be dictionary")
			return false
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", "")).strip_edges()
		if option_id == "" or option_ids.has(option_id):
			push_error("ResusData: Stage C option_id is missing or duplicated")
			return false
		if not option_data.has_all(["label", "is_correct", "why"]):
			push_error("ResusData: Stage C option %s is incomplete" % option_id)
			return false
		var effects: Dictionary = option_data.get("effects", {}) as Dictionary
		for effect_key in required_effect_keys:
			if not effects.has(effect_key):
				push_error("ResusData: Stage C option %s missing effect '%s'" % [option_id, effect_key])
				return false
		if bool(option_data.get("is_correct", false)):
			correct_count += 1
		option_ids[option_id] = true

	if correct_count != 3:
		push_error("ResusData: Stage C must have exactly 3 correct options")
		return false

	var scoring_model: Dictionary = stage_c.get("scoring_model", {}) as Dictionary
	if scoring_model.is_empty():
		push_error("ResusData: Stage C scoring_model is missing")
		return false
	if not scoring_model.has_all(["rule_2", "rule_1a", "rule_1b", "default_rule", "empty_rule", "select_all_rule"]):
		push_error("ResusData: Stage C scoring_model is incomplete")
		return false

	var feedback_rules: Dictionary = stage_c.get("feedback_rules", {}) as Dictionary
	var required_feedback_keys: Array[String] = ["PERFECT", "GOOD", "NOISY", "FAIL", "EMPTY", "SELECT_ALL"]
	for feedback_key in required_feedback_keys:
		if not feedback_rules.has(feedback_key):
			push_error("ResusData: Stage C feedback rule '%s' is missing" % feedback_key)
			return false

	return true
</file>

<file path="scripts/case_07/da7_cases_c.gd">
extends Node

const SCHEMA_VERSION := "DA7.C.v2"
const LEVEL := "C"

const CASES_C: Array = [
	{
		"id": "DA7-C-01",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_SELECT",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Соберите запрос, который выбирает имена пользователей, где id = 5.",
		"available_blocks": [
			{"id": "b1", "text": "SELECT", "role": "KW_MAIN"},
			{"id": "b2", "text": "name", "role": "IDENT_FIELD"},
			{"id": "b3", "text": "FROM", "role": "KW_FROM"},
			{"id": "b4", "text": "Users", "role": "IDENT_TABLE"},
			{"id": "b5", "text": "WHERE", "role": "KW_WHERE"},
			{"id": "b6", "text": "id=5", "role": "COND_WHERE"},
			{"id": "b7", "text": "DELETE", "role": "KW_DISTRACTOR"},
			{"id": "b8", "text": "TABLE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5", "b6"],
		"rules": {
			"required_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"min_tokens": 6,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b7", "b8"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"order_rules": [
				{"before": "KW_FROM", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "KW_FROM"},
				{"before": "KW_WHERE", "after": "IDENT_TABLE"},
				{"before": "COND_WHERE", "after": "KW_WHERE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-02",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_UPDATE",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Соберите UPDATE-запрос: установите role='admin' для пользователя с id = 5.",
		"available_blocks": [
			{"id": "b1", "text": "UPDATE", "role": "KW_MAIN"},
			{"id": "b2", "text": "Users", "role": "IDENT_TABLE"},
			{"id": "b3", "text": "SET", "role": "KW_SET"},
			{"id": "b4", "text": "role='admin'", "role": "ASSIGN"},
			{"id": "b5", "text": "WHERE", "role": "KW_WHERE"},
			{"id": "b6", "text": "id=5", "role": "COND_WHERE"},
			{"id": "b7", "text": "FROM", "role": "KW_DISTRACTOR"},
			{"id": "b8", "text": "DROP", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5", "b6"],
		"rules": {
			"required_roles": ["KW_MAIN", "IDENT_TABLE", "KW_SET", "ASSIGN"],
			"min_tokens": 6,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b7", "b8"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "IDENT_TABLE", "KW_SET"],
			"order_rules": [
				{"before": "IDENT_TABLE", "after": "KW_MAIN"},
				{"before": "KW_SET", "after": "IDENT_TABLE"},
				{"before": "ASSIGN", "after": "KW_SET"},
				{"before": "KW_WHERE", "after": "ASSIGN"},
				{"before": "COND_WHERE", "after": "KW_WHERE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-03",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_DELETE",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Удалите DEBUG-логи из таблицы Logs.",
		"available_blocks": [
			{"id": "b1", "text": "DELETE", "role": "KW_MAIN"},
			{"id": "b2", "text": "FROM", "role": "KW_FROM"},
			{"id": "b3", "text": "Logs", "role": "IDENT_TABLE"},
			{"id": "b4", "text": "WHERE", "role": "KW_WHERE"},
			{"id": "b5", "text": "level='DEBUG'", "role": "COND_WHERE"},
			{"id": "b6", "text": "TABLE", "role": "DDL_TARGET"},
			{"id": "b7", "text": "CREATE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5"],
		"rules": {
			"required_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"min_tokens": 5,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b6", "b7"],
			"forbidden_roles": ["DDL_TARGET", "KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"order_rules": [
				{"before": "KW_FROM", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "KW_FROM"},
				{"before": "KW_WHERE", "after": "IDENT_TABLE"},
				{"before": "COND_WHERE", "after": "KW_WHERE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-04",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_INSERT",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Добавьте пользователя (7, 'Neo') в таблицу Users.",
		"available_blocks": [
			{"id": "b1", "text": "INSERT", "role": "KW_MAIN"},
			{"id": "b2", "text": "INTO", "role": "KW_INTO"},
			{"id": "b3", "text": "Users", "role": "IDENT_TABLE"},
			{"id": "b4", "text": "(id,name)", "role": "FIELD_LIST"},
			{"id": "b5", "text": "VALUES", "role": "KW_VALUES"},
			{"id": "b6", "text": "(7,'Neo')", "role": "VALUE_LIST"},
			{"id": "b7", "text": "WHERE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5", "b6"],
		"rules": {
			"required_roles": ["KW_MAIN", "KW_INTO", "IDENT_TABLE", "KW_VALUES"],
			"min_tokens": 6,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b7"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "KW_INTO", "IDENT_TABLE"],
			"order_rules": [
				{"before": "KW_INTO", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "KW_INTO"},
				{"before": "FIELD_LIST", "after": "IDENT_TABLE"},
				{"before": "KW_VALUES", "after": "FIELD_LIST"},
				{"before": "VALUE_LIST", "after": "KW_VALUES"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-05",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "DDL_CREATE_TABLE",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Создайте таблицу Archive с одним столбцом id типа INT.",
		"available_blocks": [
			{"id": "b1", "text": "CREATE", "role": "KW_MAIN"},
			{"id": "b2", "text": "TABLE", "role": "DDL_TARGET"},
			{"id": "b3", "text": "Archive", "role": "IDENT_TABLE"},
			{"id": "b4", "text": "(id INT)", "role": "DDL_DEF"},
			{"id": "b5", "text": "WHERE", "role": "KW_DISTRACTOR"},
			{"id": "b6", "text": "DELETE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4"],
		"rules": {
			"required_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_TABLE", "DDL_DEF"],
			"min_tokens": 4,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b5", "b6"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_TABLE"],
			"order_rules": [
				{"before": "DDL_TARGET", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "DDL_TARGET"},
				{"before": "DDL_DEF", "after": "IDENT_TABLE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-06",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "DDL_CREATE_DB",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Создайте базу данных ArchiveDB.",
		"available_blocks": [
			{"id": "b1", "text": "CREATE", "role": "KW_MAIN"},
			{"id": "b2", "text": "DATABASE", "role": "DDL_TARGET"},
			{"id": "b3", "text": "ArchiveDB", "role": "IDENT_DB"},
			{"id": "b4", "text": "TABLE", "role": "KW_DISTRACTOR"},
			{"id": "b5", "text": "FROM", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3"],
		"rules": {
			"required_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_DB"],
			"min_tokens": 3,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b4", "b5"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_DB"],
			"order_rules": [
				{"before": "DDL_TARGET", "after": "KW_MAIN"},
				{"before": "IDENT_DB", "after": "DDL_TARGET"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	}
]

static func validate_case_c(case_data: Dictionary) -> bool:
	var case_id: String = str(case_data.get("id", "UNKNOWN"))
	if str(case_data.get("schema_version", "")) != SCHEMA_VERSION:
		push_error("Case %s bad schema version" % case_id)
		return false
	if str(case_data.get("interaction_type", "")) != "ASSEMBLE_BLOCKS":
		push_error("Case %s bad interaction_type" % case_id)
		return false

	var blocks: Array = case_data.get("available_blocks", []) as Array
	var rules: Dictionary = case_data.get("rules", {}) as Dictionary
	var correct_ids: Array = case_data.get("correct_sequence_ids", []) as Array
	if blocks.is_empty() or rules.is_empty() or correct_ids.is_empty():
		push_error("Case %s missing blocks/rules/correct ids" % case_id)
		return false

	var block_by_id: Dictionary = {}
	for block_v in blocks:
		if typeof(block_v) != TYPE_DICTIONARY:
			push_error("Case %s has non-dictionary block" % case_id)
			return false
		var block_data: Dictionary = block_v as Dictionary
		var block_id: String = str(block_data.get("id", ""))
		var block_text: String = str(block_data.get("text", ""))
		var block_role: String = str(block_data.get("role", ""))
		if block_id == "" or block_text == "" or block_role == "" or block_by_id.has(block_id):
			push_error("Case %s has invalid block contract" % case_id)
			return false
		block_by_id[block_id] = block_data

	var required_roles: Array = rules.get("required_roles", []) as Array
	var allow_repeat_roles: Array = rules.get("allow_repeat_roles", []) as Array
	var forbidden_block_ids: Array = rules.get("forbidden_block_ids", []) as Array
	var forbidden_roles: Array = rules.get("forbidden_roles", []) as Array
	var skeleton_roles: Array = rules.get("skeleton_roles", []) as Array
	var order_rules: Array = rules.get("order_rules", []) as Array
	var min_tokens: int = int(rules.get("min_tokens", 0))
	if min_tokens <= 0:
		push_error("Case %s has invalid min_tokens" % case_id)
		return false
	if required_roles.is_empty() or skeleton_roles.is_empty():
		push_error("Case %s rules missing required/skeleton roles" % case_id)
		return false
	if typeof(allow_repeat_roles) != TYPE_ARRAY or typeof(forbidden_block_ids) != TYPE_ARRAY or typeof(forbidden_roles) != TYPE_ARRAY:
		push_error("Case %s rules arrays are malformed" % case_id)
		return false
	for block_id_v in forbidden_block_ids:
		if not block_by_id.has(str(block_id_v)):
			push_error("Case %s forbidden block id %s is unknown" % [case_id, str(block_id_v)])
			return false
	for order_rule_v in order_rules:
		if typeof(order_rule_v) != TYPE_DICTIONARY:
			push_error("Case %s has malformed order rule" % case_id)
			return false
		var order_rule: Dictionary = order_rule_v as Dictionary
		if str(order_rule.get("before", "")) == "" or str(order_rule.get("after", "")) == "":
			push_error("Case %s has incomplete order rule" % case_id)
			return false

	for id_v in correct_ids:
		if not block_by_id.has(str(id_v)):
			push_error("Case %s correct_sequence_ids contains unknown block id %s" % [case_id, str(id_v)])
			return false
	if correct_ids.size() < min_tokens:
		push_error("Case %s correct sequence shorter than min_tokens" % case_id)
		return false

	return true
</file>

<file path="scripts/case_08/fr8_final_report_a.gd">
extends Control

const LEVELS_PATH := "res://data/final_report_a_levels.json"
const FR8Data := preload("res://scripts/case_08/fr8_data.gd")
const FR8Scoring := preload("res://scripts/case_08/fr8_scoring.gd")
const TAG_FRAGMENT_SCENE: PackedScene = preload("res://scenes/ui/TagFragmentItem.tscn")
const TAG_SLOT_SCENE: PackedScene = preload("res://scenes/ui/TagSlotZone.tscn")

const COLOR_OK := Color(0.55, 0.95, 0.62, 1.0)
const COLOR_WARN := Color(1.0, 0.82, 0.35, 1.0)
const COLOR_ERR := Color(1.0, 0.45, 0.45, 1.0)
const COLOR_INFO := Color(0.84, 0.84, 0.84, 1.0)

const TEXT_BACK := "\u041d\u0410\u0417\u0410\u0414"
const TEXT_RESET := "\u0421\u0411\u0420\u041e\u0421"
const TEXT_CONFIRM := "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TEXT_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TEXT_FINISH := "\u0417\u0410\u0412\u0415\u0420\u0428\u0418\u0422\u042c"

const STATUS_HINT := "\u041f\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\u044b \u0432 \u0441\u043b\u043e\u0442\u044b \u0440\u0435\u0434\u0430\u043a\u0442\u043e\u0440\u0430\u2026"
const STATUS_INCOMPLETE := "\u041d\u0435 \u0432\u0441\u0435 \u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\u044b \u0432\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b"
const STATUS_NEXT_HINT := "\u0413\u043e\u0442\u043e\u0432\u043e. \u0416\u043c\u0438\u0442\u0435 \u0414\u0410\u041b\u0415\u0415."
const STATUS_SOLVE_FIRST := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0440\u0435\u0448\u0438\u0442\u0435 \u0443\u0440\u043e\u0432\u0435\u043d\u044c"

var levels: Array = []
var level_data: Dictionary = {}
var fragments_data: Array = []

var slot_ids: Array[String] = []
var expected_sequence: Array[String] = []
var fragment_by_id: Dictionary = {}
var slot_nodes: Dictionary = {}
var fragment_nodes: Dictionary = {}

var current_level_index: int = 0
var start_time_ms: int = 0
var drag_count: int = 0
var swap_count: int = 0
var trace: Array = []

var level_solved: bool = false
var confirm_locked: bool = false

@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var body: BoxContainer = $SafeArea/MainLayout/Body
@onready var fragments_card: PanelContainer = $SafeArea/MainLayout/Body/FragmentsCard
@onready var editor_card: PanelContainer = $SafeArea/MainLayout/Body/EditorCard
@onready var pile_zone: Node = $SafeArea/MainLayout/Body/FragmentsCard/CardVBox/PileZone
@onready var slots_grid: GridContainer = $SafeArea/MainLayout/Body/EditorCard/CardVBox/SlotsGrid
@onready var code_preview: RichTextLabel = $SafeArea/MainLayout/Body/EditorCard/CardVBox/CodePreviewCard/CodePreview
@onready var status_label: Label = $SafeArea/MainLayout/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainLayout/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainLayout/BottomBar/BtnConfirm
@onready var btn_next: Button = $SafeArea/MainLayout/BottomBar/BtnNext
@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack
@onready var title_label: Label = $SafeArea/MainLayout/Header/TitleLabel
@onready var level_label: Label = $SafeArea/MainLayout/Header/LevelLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainLayout/Header/StabilityBar
@onready var briefing_label: Label = $SafeArea/MainLayout/BriefingCard/BriefingLabel
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

func _ready() -> void:
	add_to_group("fr8_drop_controller")
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_connect_ui_signals()
	_load_levels()
	if levels.is_empty():
		_show_error("\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0443\u0440\u043e\u0432\u043d\u0438 \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0442\u0447\u0451\u0442\u0430 A.")
		return

	title_label.text = "\u0414\u0415\u041b\u041e #8: \u0424\u0418\u041d\u0410\u041b\u042c\u041d\u042b\u0419 \u041e\u0422\u0427\u0415\u0422"
	btn_back.text = TEXT_BACK
	btn_reset.text = TEXT_RESET
	btn_confirm.text = TEXT_CONFIRM
	btn_next.text = TEXT_NEXT

	var initial_index: int = clamp(GlobalMetrics.current_level_index, 0, max(0, levels.size() - 1))
	_start_level(initial_index)
	_on_viewport_size_changed()

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	btn_next.pressed.connect(_on_next_pressed)

func _load_levels() -> void:
	levels = FR8Data.load_levels(LEVELS_PATH)

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	current_level_index = clamp(index, 0, levels.size() - 1)
	GlobalMetrics.current_level_index = current_level_index
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)
	fragments_data = (level_data.get("fragments", []) as Array).duplicate(true)

	slot_ids.clear()
	for slot_var in level_data.get("slots", []) as Array:
		slot_ids.append(str(slot_var))

	expected_sequence = FR8Scoring.normalize_expected_sequence(level_data)
	fragment_by_id.clear()
	for fragment_var in fragments_data:
		if typeof(fragment_var) != TYPE_DICTIONARY:
			continue
		var fragment_data: Dictionary = fragment_var as Dictionary
		fragment_by_id[str(fragment_data.get("fragment_id", ""))] = fragment_data

	level_label.text = _build_level_label()
	briefing_label.text = str(level_data.get("briefing", ""))

	if pile_zone.has_method("setup"):
		pile_zone.call("setup", "PILE", "\u0421\u041a\u041b\u0410\u0414 \u0424\u0420\u0410\u0413\u041c\u0415\u041d\u0422\u041e\u0412")
	_connect_zone_signal(pile_zone)

	_build_slot_nodes()
	_reset_attempt(true)

func _build_level_label() -> String:
	return "A | %s (%d/%d)" % [
		str(level_data.get("id", "FR8-A")),
		current_level_index + 1,
		levels.size()
	]

func _is_last_level() -> bool:
	return current_level_index >= levels.size() - 1

func _build_slot_nodes() -> void:
	for child in slots_grid.get_children():
		child.queue_free()
	slot_nodes.clear()

	for slot_id in slot_ids:
		var slot_node: Node = TAG_SLOT_SCENE.instantiate()
		slots_grid.add_child(slot_node)
		if slot_node.has_method("setup"):
			slot_node.call("setup", slot_id, slot_id)
		_connect_zone_signal(slot_node)
		slot_nodes[slot_id] = slot_node

func _connect_zone_signal(zone_node: Node) -> void:
	if zone_node == null:
		return
	if not zone_node.has_signal("item_placed"):
		return
	var callback: Callable = Callable(self, "_on_item_placed")
	if not zone_node.is_connected("item_placed", callback):
		zone_node.connect("item_placed", callback)

func _reset_attempt(is_level_start: bool = false) -> void:
	for slot_id in slot_ids:
		var slot_node: Node = slot_nodes.get(slot_id, null)
		if slot_node != null and slot_node.has_method("clear_items"):
			slot_node.call("clear_items")

	if pile_zone.has_method("clear_items"):
		pile_zone.call("clear_items")

	_spawn_fragments_into_pile()

	start_time_ms = Time.get_ticks_msec()
	drag_count = 0
	swap_count = 0
	trace.clear()
	_log_event("СБРОС", {"level_start": is_level_start})

	level_solved = false
	confirm_locked = false
	btn_confirm.disabled = false
	btn_next.disabled = true
	btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT

	_set_status(STATUS_HINT, COLOR_INFO)
	_update_code_preview()
	_update_slot_feedback()
	_update_stability_ui()

func _spawn_fragments_into_pile() -> void:
	fragment_nodes.clear()
	var shuffled_fragments: Array = fragments_data.duplicate(true)
	shuffled_fragments.shuffle()

	for fragment_var in shuffled_fragments:
		if typeof(fragment_var) != TYPE_DICTIONARY:
			continue
		var fragment_data: Dictionary = fragment_var as Dictionary
		var item_node: Node = TAG_FRAGMENT_SCENE.instantiate()
		if not (item_node is Control):
			continue

		if item_node.has_method("setup"):
			item_node.call("setup", fragment_data)
		item_node.set_meta("fragment_id", str(fragment_data.get("fragment_id", "")))
		if item_node.has_signal("drag_started"):
			item_node.connect("drag_started", Callable(self, "_on_drag_started"))

		if pile_zone.has_method("add_item_control"):
			pile_zone.call("add_item_control", item_node)

		var fragment_id: String = str(fragment_data.get("fragment_id", ""))
		if not fragment_id.is_empty():
			fragment_nodes[fragment_id] = item_node

func _on_drag_started(fragment_id: String, from_zone: String) -> void:
	drag_count += 1
	_log_event("DRAG_START", {
		"fragment_id": fragment_id,
		"from_zone": from_zone
	})

func _on_item_placed(fragment_id: String, to_zone: String, from_zone: String) -> void:
	_log_event("ITEM_PLACED", {
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"to_zone": to_zone
	})
	_update_code_preview()
	_update_slot_feedback()
	_set_status(STATUS_HINT, COLOR_INFO)

func handle_drop_to_slot(target_zone_id: String, payload: Dictionary) -> Dictionary:
	if not slot_nodes.has(target_zone_id):
		return {"success": false}

	var parsed: Dictionary = _parse_payload(payload)
	if parsed.is_empty():
		return {"success": false}

	var fragment_id: String = str(parsed.get("fragment_id", ""))
	var from_zone: String = str(parsed.get("from_zone", "PILE"))

	if _fragment_zone(fragment_id) == target_zone_id:
		return {"success": false}

	var target_existing_id: String = _fragment_in_slot(target_zone_id)
	var swapped: bool = false
	if not target_existing_id.is_empty() and target_existing_id != fragment_id:
		var return_zone: String = from_zone
		if not _zone_exists(return_zone) or return_zone == target_zone_id:
			return_zone = "PILE"
		if not _move_fragment_to_zone(target_existing_id, return_zone):
			return {"success": false}
		swapped = true

	if not _move_fragment_to_zone(fragment_id, target_zone_id):
		return {"success": false}

	if swapped:
		swap_count += 1

	return {
		"success": true,
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"to_zone": target_zone_id,
		"swapped": swapped
	}

func handle_drop_to_pile(payload: Dictionary) -> Dictionary:
	var parsed: Dictionary = _parse_payload(payload)
	if parsed.is_empty():
		return {"success": false}

	var fragment_id: String = str(parsed.get("fragment_id", ""))
	var from_zone: String = str(parsed.get("from_zone", "PILE"))
	if _fragment_zone(fragment_id) == "PILE":
		return {"success": false}

	if not _move_fragment_to_zone(fragment_id, "PILE"):
		return {"success": false}

	return {
		"success": true,
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"to_zone": "PILE",
		"swapped": false
	}

func _parse_payload(payload: Dictionary) -> Dictionary:
	if str(payload.get("kind", "")) != "TAG_FRAGMENT":
		return {}
	var fragment_id: String = str(payload.get("fragment_id", "")).strip_edges()
	if fragment_id.is_empty() or not fragment_nodes.has(fragment_id):
		return {}
	return {
		"fragment_id": fragment_id,
		"from_zone": str(payload.get("from_zone", "PILE"))
	}

func _zone_exists(zone_id: String) -> bool:
	if zone_id == "PILE":
		return true
	return slot_nodes.has(zone_id)

func _zone_by_id(zone_id: String) -> Node:
	if zone_id == "PILE":
		return pile_zone
	return slot_nodes.get(zone_id, null) as Node

func _move_fragment_to_zone(fragment_id: String, zone_id: String) -> bool:
	var fragment_node: Node = fragment_nodes.get(fragment_id, null) as Node
	if fragment_node == null:
		return false
	var zone_node: Node = _zone_by_id(zone_id)
	if zone_node == null:
		return false
	if not zone_node.has_method("add_item_control"):
		return false
	zone_node.call("add_item_control", fragment_node)
	return true

func _fragment_zone(fragment_id: String) -> String:
	var fragment_node: Node = fragment_nodes.get(fragment_id, null) as Node
	if fragment_node == null:
		return "PILE"
	if fragment_node.has_method("get_zone_id"):
		return str(fragment_node.call("get_zone_id"))
	return str(fragment_node.get_meta("zone_id", "PILE"))

func _fragment_in_slot(slot_id: String) -> String:
	var slot_node: Node = slot_nodes.get(slot_id, null) as Node
	if slot_node == null:
		return ""
	if slot_node.has_method("get_current_fragment_id"):
		return str(slot_node.call("get_current_fragment_id")).strip_edges()
	return ""

func _collect_sequence() -> Array[String]:
	var sequence: Array[String] = []
	for slot_id in slot_ids:
		sequence.append(_fragment_in_slot(slot_id))
	return sequence

func _build_snapshot_zones() -> Dictionary:
	var snapshot: Dictionary = {}
	for fragment_id_var in fragment_by_id.keys():
		var fragment_id: String = str(fragment_id_var)
		snapshot[fragment_id] = _fragment_zone(fragment_id)
	return snapshot

func _on_confirm_pressed() -> void:
	if confirm_locked:
		return

	var sequence: Array[String] = _collect_sequence()
	var snapshot_zones: Dictionary = _build_snapshot_zones()
	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	_log_event("CONFIRM_PRESSED", {
		"sequence": sequence.duplicate(),
		"filled_slots": _count_filled_slots(sequence)
	})

	var evaluation: Dictionary = FR8Scoring.evaluate(level_data, sequence, fragment_by_id)
	var score: Dictionary = FR8Scoring.resolve_score(level_data, evaluation)
	var checks: Dictionary = evaluation.get("checks", {
		"container_ok": false,
		"hierarchy_ok": false,
		"order_ok": false
	}) as Dictionary

	var points: int = int(score.get("points", 0))
	var max_points: int = int(score.get("max_points", 2))
	var is_fit: bool = bool(score.get("is_fit", false))
	var is_correct: bool = bool(score.get("is_correct", false))
	var stability_delta: int = int(score.get("stability_delta", 0))
	var verdict_code: String = str(score.get("verdict_code", "FAIL"))
	var error_code: String = str(evaluation.get("error_code", "FAIL"))
	var level_id: String = str(level_data.get("id", "FR8-A-00"))
	var match_key: String = "FR8_A|%s|%d" % [level_id, GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_08_FINAL_REPORT",
		"stage": "A",
		"level_id": level_id,
		"format": "TAG_ORDERING",
		"match_key": match_key,
		"sequence": sequence,
		"snapshot_zones": snapshot_zones,
		"error_code": error_code,
		"checks": {
			"container_ok": bool(checks.get("container_ok", false)),
			"hierarchy_ok": bool(checks.get("hierarchy_ok", false)),
			"order_ok": bool(checks.get("order_ok", false))
		},
		"elapsed_ms": elapsed_ms,
		"drag_count": drag_count,
		"swap_count": swap_count,
		"points": points,
		"max_points": max_points,
		"is_fit": is_fit,
		"is_correct": is_correct,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	var feedback_text: String = FR8Scoring.feedback_text(level_data, evaluation)
	if verdict_code == "PERFECT":
		level_solved = true
		confirm_locked = true
		btn_confirm.disabled = true
		btn_next.disabled = false
		btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
		_set_status("%s %s" % [feedback_text, STATUS_NEXT_HINT], COLOR_OK)
	elif verdict_code == "PARTIAL":
		level_solved = false
		confirm_locked = false
		btn_next.disabled = true
		_set_status(feedback_text, COLOR_WARN)
	else:
		level_solved = false
		confirm_locked = false
		btn_next.disabled = true
		if error_code == "INCOMPLETE":
			_set_status(STATUS_INCOMPLETE, COLOR_ERR)
		else:
			_set_status(feedback_text, COLOR_ERR)

	_play_confirm_audio(verdict_code)
	if verdict_code in ["FAIL", "EMPTY"]:
		_trigger_glitch()
		_shake_main_layout()

func _on_next_pressed() -> void:
	if not level_solved:
		_set_status(STATUS_SOLVE_FIRST, COLOR_WARN)
		return

	var from_level_id: String = str(level_data.get("id", "FR8-A-00"))
	var from_index: int = current_level_index
	if _is_last_level():
		_log_event("NEXT_PRESSED", {
			"from_level_id": from_level_id,
			"from_index": from_index,
			"to_index": -1
		})
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return

	var to_index: int = current_level_index + 1
	_log_event("NEXT_PRESSED", {
		"from_level_id": from_level_id,
		"from_index": from_index,
		"to_index": to_index
	})
	_start_level(to_index)

func _play_confirm_audio(verdict_code: String) -> void:
	if AudioManager == null:
		return
	match verdict_code:
		"PERFECT":
			AudioManager.play("relay")
		"FAIL", "EMPTY":
			AudioManager.play("error")
		_:
			AudioManager.play("click")

func _count_filled_slots(sequence: Array[String]) -> int:
	var filled: int = 0
	for fragment_id in sequence:
		if not str(fragment_id).is_empty():
			filled += 1
	return filled

func _update_code_preview() -> void:
	var lines: Array[String] = []
	for i in range(slot_ids.size()):
		var slot_id: String = slot_ids[i]
		var fragment_id: String = _fragment_in_slot(slot_id)
		var token: String = "____"
		if not fragment_id.is_empty() and fragment_by_id.has(fragment_id):
			var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
			token = str(fragment_data.get("token", fragment_data.get("label", fragment_id)))
		lines.append("%s  %s" % [slot_id, token])
	code_preview.text = "[code]%s[/code]" % "\n".join(lines)

func _update_slot_feedback() -> void:
	for i in range(slot_ids.size()):
		var slot_id: String = slot_ids[i]
		var slot_node: Node = slot_nodes.get(slot_id, null) as Node
		if slot_node == null or not slot_node.has_method("set_feedback_state"):
			continue
		var actual_fragment_id: String = _fragment_in_slot(slot_id)
		var expected_fragment_id: String = expected_sequence[i] if i < expected_sequence.size() else ""
		if actual_fragment_id.is_empty():
			slot_node.call("set_feedback_state", "neutral")
		elif actual_fragment_id == expected_fragment_id and not expected_fragment_id.is_empty():
			slot_node.call("set_feedback_state", "ok")
		else:
			slot_node.call("set_feedback_state", "bad")

func _set_status(text_value: String, color_value: Color) -> void:
	status_label.text = text_value
	status_label.modulate = color_value

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for _i in 4:
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _on_back_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_reset_pressed() -> void:
	_reset_attempt(false)
	if AudioManager != null:
		AudioManager.play("click")

func _on_viewport_size_changed() -> void:
	_apply_layout_mode()

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var landscape: bool = viewport_size.x > viewport_size.y
	body.vertical = not landscape

	if landscape:
		if body.get_child(0) != fragments_card:
			body.move_child(fragments_card, 0)
			body.move_child(editor_card, 1)
		slots_grid.columns = 3 if slot_ids.size() >= 6 else 2
		if pile_zone.has_method("set_grid_columns"):
			pile_zone.call("set_grid_columns", 3 if viewport_size.x >= 1280.0 else 2)
	else:
		if body.get_child(0) != editor_card:
			body.move_child(editor_card, 0)
			body.move_child(fragments_card, 1)
		slots_grid.columns = 2
		if pile_zone.has_method("set_grid_columns"):
			pile_zone.call("set_grid_columns", 2)

func _show_error(message: String) -> void:
	_set_status(message, COLOR_ERR)
	btn_confirm.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability
</file>

<file path="scripts/quests/network_trace/NetworkTraceQuestA.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")
const DEVICE_CARD_SCENE: PackedScene = preload("res://scenes/ui/network_trace/NetworkTraceDeviceCard.tscn")

const LEVELS_PATH := "res://data/network_trace_a_levels.json"
const MAX_ATTEMPTS := 3
const DEFAULT_TIME_LIMIT_SEC := 120
const RUN_COOLDOWN_MS := 500
const FAIL_STABILITY_DELTA := -10.0
const HINT_STABILITY_DELTA := -5.0
const PALETTE_GREEN_ID := 0
const PALETTE_AMBER_ID := 1

enum QuestState {
	INIT,
	BRIEFING,
	SOLVING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	SAFE_MODE,
	DIAGNOSTIC
}

@onready var btn_back: Button = $SafeArea/Main/V/Header/BtnBack
@onready var lbl_title: Label = $SafeArea/Main/V/Header/LblTitle
@onready var lbl_meta: Label = $SafeArea/Main/V/Header/LblMeta
@onready var palette_select: OptionButton = $SafeArea/Main/V/Header/PaletteSelect
@onready var body: BoxContainer = $SafeArea/Main/V/Body
@onready var lbl_briefing: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblBriefing
@onready var lbl_prompt: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblPrompt
@onready var log_list: VBoxContainer = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll/LogList
@onready var evidence_row: HBoxContainer = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/EvidenceRow
@onready var topology_board: NetworkTraceTopologyBoardA = $SafeArea/Main/V/Body/MapPane/MapMargin/MapV/TopologyBoard
@onready var palette_box: HBoxContainer = $SafeArea/Main/V/Body/MapPane/MapMargin/MapV/PaletteScroll/Palette
@onready var btn_analyze: Button = $SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnAnalyze
@onready var btn_run_trace: Button = $SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnRunTrace
@onready var btn_reset: Button = $SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnReset
@onready var btn_next: Button = $SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnNext
@onready var lbl_status: Label = $SafeArea/Main/V/Body/MapPane/MapMargin/MapV/LblStatus
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $NoirOverlay/CRT_Overlay

var levels: Array[Dictionary] = []
var current_level: Dictionary = {}
var current_level_index: int = 0

var state: int = QuestState.INIT
var wrong_count: int = 0
var safe_mode_used: bool = false
var hint_used: bool = false
var level_finished: bool = false
var result_sent: bool = false
var run_in_progress: bool = false
var run_cooldown_until_ms: int = 0
var spam_clicks: int = 0

var level_started_ms: int = 0
var first_action_ms: int = -1
var time_limit_sec: int = DEFAULT_TIME_LIMIT_SEC
var time_left_sec: float = float(DEFAULT_TIME_LIMIT_SEC)
var timer_running: bool = false

var required_evidence: int = 2
var selected_evidence_indices: Array[int] = []
var log_buttons: Array[Button] = []
var evidence_slot_labels: Array[Label] = []

var selected_device_id: String = ""
var selected_error_code: String = ""

var attempts: Array[Dictionary] = []
var task_session: Dictionary = {}
var variant_hash: String = ""

var palette_cards: Array[NetworkTraceDeviceCard] = []

func _ready() -> void:
	_setup_palette_controls()
	_connect_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_layout_mode()

	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)

	if not _load_levels():
		_show_boot_error("Данные Network Trace A отсутствуют или повреждены.")
		return

	_start_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible and not level_finished:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.SOLVING

	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_meta_label()
			_on_timeout()
		else:
			_update_meta_label()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_layout_mode()

func _setup_palette_controls() -> void:
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_run_trace.pressed.connect(_on_run_trace_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	
	topology_board.device_installed.connect(_on_device_installed)
	topology_board.device_removed.connect(_on_device_removed)

func _load_levels() -> bool:
	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		push_error("Cannot open %s" % LEVELS_PATH)
		return false

	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		push_error("Expected array in %s" % LEVELS_PATH)
		return false

	var raw_levels: Array = parsed
	levels.clear()
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
		elif OS.is_debug_build():
			push_error("Invalid Network Trace A level: %s" % str(level.get("id", "UNKNOWN")))
			return false
		else:
			push_warning("Skipping invalid level: %s" % str(level.get("id", "UNKNOWN")))

	return not levels.is_empty()

func _validate_level(level: Dictionary) -> bool:
	var required_keys: Array[String] = [
		"id", "incident_id", "briefing", "prompt", "required_evidence", "logs", "topology", "options", "correct_id", "explain_short", "explain_full", "tags"
	]
	for key in required_keys:
		if not level.has(key):
			return false

	if typeof(level.get("logs")) != TYPE_ARRAY:
		return false
	if typeof(level.get("options")) != TYPE_ARRAY:
		return false
	if typeof(level.get("topology")) != TYPE_DICTIONARY:
		return false

	var logs: Array = level.get("logs", [])
	if logs.size() < 3:
		return false

	var required_count: int = int(level.get("required_evidence", 0))
	if required_count <= 0 or required_count > logs.size():
		return false

	var options: Array = level.get("options", [])
	if options.size() < 4 or options.size() > 6:
		return false

	var ids: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		if not option.has("id") or not option.has("label") or not option.has("error_code"):
			return false
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or ids.has(option_id):
			return false
		ids[option_id] = true

	var correct_id: String = str(level.get("correct_id", ""))
	if not ids.has(correct_id):
		return false

	var topology: Dictionary = level.get("topology", {})
	if typeof(topology.get("nodes", [])) != TYPE_ARRAY:
		return false
	if typeof(topology.get("edges", [])) != TYPE_ARRAY:
		return false

	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))
	btn_run_trace.disabled = true
	btn_analyze.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true
	timer_running = false

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	if index >= levels.size():
		index = 0
	current_level_index = index
	current_level = levels[index].duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))

	state = QuestState.BRIEFING
	wrong_count = 0
	safe_mode_used = false
	hint_used = false
	level_finished = false
	result_sent = false
	run_in_progress = false
	run_cooldown_until_ms = 0
	spam_clicks = 0
	selected_device_id = ""
	selected_error_code = ""
	selected_evidence_indices.clear()
	attempts.clear()

	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	time_limit_sec = int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC))
	time_left_sec = float(time_limit_sec)
	timer_running = true

	required_evidence = int(current_level.get("required_evidence", 2))

	task_session = {
		"task_id": str(current_level.get("id", "NT_A_UNKNOWN")),
		"variant_hash": variant_hash,
		"started_at_ticks": level_started_ms,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	lbl_title.text = "СЕТЕВОЙ СЛЕД | A"
	btn_next.visible = false
	btn_next.disabled = false
	btn_analyze.text = "АНАЛИЗ"
	btn_analyze.disabled = true
	btn_run_trace.disabled = true
	btn_reset.disabled = true
	diagnostics_panel.visible = false

	_render_text_blocks()
	_build_log_items()
	_build_evidence_slots()
	_setup_topology()
	_build_palette()
	_set_tools_unlocked(false)

	lbl_status.text = "Соберите улики (%d/%d), чтобы разблокировать инструменты." % [selected_evidence_indices.size(), required_evidence]
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))

	_update_meta_label()
	_log_event("task_start", {"level": str(current_level.get("id", ""))})

func _render_text_blocks() -> void:
	lbl_briefing.clear()
	lbl_briefing.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n%s" % str(current_level.get("briefing", "")))

	lbl_prompt.clear()
	lbl_prompt.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n%s" % str(current_level.get("prompt", "")))

func _build_log_items() -> void:
	for child in log_list.get_children():
		child.queue_free()
	log_buttons.clear()

	var logs: Array = current_level.get("logs", [])
	for idx in range(logs.size()):
		var log_line: String = str(logs[idx])
		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 48)
		btn.toggle_mode = true
		btn.text = "[%d] %s" % [idx + 1, log_line]
		btn.pressed.connect(_on_log_pressed.bind(idx))
		log_list.add_child(btn)
		log_buttons.append(btn)

func _build_evidence_slots() -> void:
	for child in evidence_row.get_children():
		child.queue_free()
	evidence_slot_labels.clear()

	for idx in range(required_evidence):
		var slot_panel: PanelContainer = PanelContainer.new()
		slot_panel.custom_minimum_size = Vector2(0, 54)
		slot_panel.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		var slot_label: Label = Label.new()
		slot_label.text = "УЛИКА %d" % (idx + 1)
		slot_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		slot_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		slot_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
		slot_panel.add_child(slot_label)
		evidence_row.add_child(slot_panel)
		evidence_slot_labels.append(slot_label)

	_update_evidence_visuals()

func _setup_topology() -> void:
	var topology: Dictionary = current_level.get("topology", {})
	topology_board.setup_topology(topology)
	topology_board.set_tools_locked(true)

func _build_palette() -> void:
	for child in palette_box.get_children():
		child.queue_free()
	palette_cards.clear()

	var options: Array = current_level.get("options", [])
	for option_var in options:
		var option: Dictionary = option_var
		var card_node: Node = DEVICE_CARD_SCENE.instantiate()
		if card_node is NetworkTraceDeviceCard:
			var card: NetworkTraceDeviceCard = card_node
			card.setup(str(option.get("id", "")), str(option.get("label", "")), str(option.get("error_code", "")))
			card.disabled = true
			palette_box.add_child(card)
			palette_cards.append(card)

func _set_tools_unlocked(unlocked: bool) -> void:
	for card in palette_cards:
		card.disabled = not unlocked
	topology_board.set_tools_locked(not unlocked)

	if not unlocked:
		selected_device_id = ""
		selected_error_code = ""
		btn_run_trace.disabled = true
		btn_reset.disabled = true
		topology_board.clear_installed_device()
	else:
		btn_run_trace.disabled = selected_device_id.is_empty()
		btn_reset.disabled = selected_device_id.is_empty()

func _on_log_pressed(log_index: int) -> void:
	if level_finished:
		return
	_register_first_action()

	if selected_evidence_indices.has(log_index):
		selected_evidence_indices.erase(log_index)
	else:
		selected_evidence_indices.append(log_index)
	selected_evidence_indices.sort()

	for idx in range(log_buttons.size()):
		var btn: Button = log_buttons[idx]
		btn.button_pressed = selected_evidence_indices.has(idx)

	_update_evidence_visuals()
	_log_event("evidence_toggled", {"index": log_index, "count": selected_evidence_indices.size()})

	if selected_evidence_indices.size() >= required_evidence and state == QuestState.BRIEFING:
		state = QuestState.SOLVING
		_set_tools_unlocked(true)
		lbl_status.text = "Инструменты разблокированы. Перетащите устройство в слот и запустите трассировку."
		lbl_status.add_theme_color_override("font_color", Color(0.6, 0.95, 0.7))
	elif selected_evidence_indices.size() < required_evidence:
		state = QuestState.BRIEFING
		_set_tools_unlocked(false)
		lbl_status.text = "Соберите улики (%d/%d), чтобы разблокировать инструменты." % [selected_evidence_indices.size(), required_evidence]
		lbl_status.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))

func _update_evidence_visuals() -> void:
	var logs: Array = current_level.get("logs", [])
	for slot_index in range(evidence_slot_labels.size()):
		var slot_label: Label = evidence_slot_labels[slot_index]
		if slot_index < selected_evidence_indices.size():
			var log_index: int = selected_evidence_indices[slot_index]
			if log_index >= 0 and log_index < logs.size():
				slot_label.text = str(logs[log_index])
			else:
				slot_label.text = "УЛИКА %d" % (slot_index + 1)
		else:
			slot_label.text = "УЛИКА %d" % (slot_index + 1)

func _on_device_installed(device_id: String, _label_text: String, error_code: String) -> void:
	selected_device_id = device_id
	selected_error_code = error_code
	btn_run_trace.disabled = selected_device_id.is_empty() or level_finished
	btn_reset.disabled = selected_device_id.is_empty() or level_finished
	lbl_status.text = "Устройство установлено. Нажмите ЗАПУСТИТЬ ТРАССИРОВКУ."
	lbl_status.add_theme_color_override("font_color", Color(0.75, 0.95, 0.8))
	_log_event("device_installed", {"device_id": device_id})

func _on_device_removed() -> void:
	selected_device_id = ""
	selected_error_code = ""
	btn_run_trace.disabled = true
	btn_reset.disabled = true
	_log_event("device_removed", {})

func _on_run_trace_pressed() -> void:
	if level_finished:
		return
	if run_in_progress:
		spam_clicks += 1
		return
	if selected_evidence_indices.size() < required_evidence:
		lbl_status.text = ERROR_MAP.get_error_tip("A_WRONG_EVIDENCE")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return
	if selected_device_id.is_empty():
		lbl_status.text = "Сначала установите устройство в слот."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return

	var now_ms: int = Time.get_ticks_msec()
	if now_ms < run_cooldown_until_ms:
		spam_clicks += 1
		return
	run_cooldown_until_ms = now_ms + RUN_COOLDOWN_MS

	_register_first_action()
	_play_audio("click")
	_lock_controls_for_trace(true)
	run_in_progress = true

	var is_correct: bool = selected_device_id == str(current_level.get("correct_id", ""))
	var error_code: String = "" if is_correct else selected_error_code
	if error_code.is_empty() and not is_correct:
		error_code = "UNKNOWN"

	var attempt: Dictionary = {
		"device_id": selected_device_id,
		"error_code": error_code,
		"correct": is_correct,
		"t_ms": now_ms - level_started_ms
	}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("run_trace", {
		"device_id": selected_device_id,
		"correct": is_correct,
		"error_code": error_code
	})

	await topology_board.play_trace_animation(is_correct)
	run_in_progress = false
	if level_finished:
		return

	if is_correct:
		_handle_success()
	else:
		_handle_failure(error_code)

	if not level_finished:
		_lock_controls_for_trace(false)
		btn_run_trace.disabled = selected_device_id.is_empty()
		btn_reset.disabled = selected_device_id.is_empty()

func _lock_controls_for_trace(locked: bool) -> void:
	btn_run_trace.disabled = locked
	btn_reset.disabled = locked
	for card in palette_cards:
		card.disabled = locked or state == QuestState.BRIEFING
	topology_board.set_tools_locked(locked or state == QuestState.BRIEFING)

func _handle_success() -> void:
	state = QuestState.FEEDBACK_SUCCESS
	lbl_status.text = "ТРАССИРОВКА OK: путь установлен."
	lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.45))
	_play_audio("relay")
	_log_event("trace_success", {"device_id": selected_device_id})
	_finish_level(true, "success")

func _handle_failure(error_code: String) -> void:
	state = QuestState.FEEDBACK_FAIL
	wrong_count += 1
	_play_audio("error")
	_trigger_glitch()

	var title: String = ERROR_MAP.get_error_title(error_code)
	var tip: String = ERROR_MAP.get_error_tip(error_code)
	lbl_status.text = "%s: %s" % [title, tip]
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.38, 0.38))
	_update_meta_label()

	_log_event("trace_fail", {"error_code": error_code, "wrong_count": wrong_count})

	if wrong_count >= 2 and not safe_mode_used:
		safe_mode_used = true
		state = QuestState.SAFE_MODE
		btn_analyze.disabled = false
		btn_analyze.text = "ДИАГНОСТИКА"
		lbl_status.text = "Безопасный режим включён. Откройте диагностику для полного разбора."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.75, 0.45))

	if wrong_count >= MAX_ATTEMPTS:
		_show_safe_mode_diagnostics("Достигнут лимит попыток")
		_finish_level(false, "attempt_limit")

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	if not safe_mode_used:
		lbl_status.text = "Анализ открывается после 2 неудачных трассировок."
		lbl_status.add_theme_color_override("font_color", Color(0.9, 0.8, 0.45))
		return

	_register_first_action()
	if not hint_used:
		hint_used = true

	_show_safe_mode_diagnostics("Ручная диагностика")

func _show_safe_mode_diagnostics(trigger_reason: String) -> void:
	var lines: Array[String] = []
	lines.append("Дело: %s" % str(current_level.get("id", "UNKNOWN")))
	lines.append("Причина: %s" % trigger_reason)
	if not selected_error_code.is_empty():
		lines.append("Ошибка: %s" % selected_error_code)
		lines.append(ERROR_MAP.get_error_tip(selected_error_code))

	var explain_full: String = str(current_level.get("explain_full", ""))
	if not explain_full.is_empty():
		for line_var in explain_full.split("\n"):
			var text_line: String = line_var.strip_edges()
			if not text_line.is_empty():
				lines.append(text_line)

	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true
	state = QuestState.DIAGNOSTIC
	_log_event("diagnostics_open", {"reason": trigger_reason})

func _on_reset_pressed() -> void:
	if level_finished or run_in_progress:
		return
	_register_first_action()
	topology_board.clear_installed_device()
	lbl_status.text = "Слот очищен. Перетащите новое устройство."
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.86, 0.95))
	_log_event("reset_pressed", {})

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", ""))})
	_start_level(current_level_index + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	var palette_id: int = palette_select.get_item_id(index)
	_apply_palette(palette_id)

func _apply_palette(palette_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(1.0, 0.7, 0.1, 1.0))
	else:
		theme = THEME_GREEN
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(0.0, 1.0, 0.25, 1.0))

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _play_audio(sound_name: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_name)

func _update_meta_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	var minutes: int = total_seconds / 60
	var seconds: int = total_seconds % 60
	lbl_meta.text = "ДЕЛО %s | ОШ %d/%d | %02d:%02d" % [
		str(current_level.get("id", "--")),
		wrong_count,
		MAX_ATTEMPTS,
		minutes,
		seconds
	]

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	# Meta label is refreshed in timer tick and state transitions.
	pass

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _on_timeout() -> void:
	if level_finished:
		return
	selected_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {
		"device_id": selected_device_id,
		"error_code": "TIMEOUT",
		"correct": false,
		"t_ms": Time.get_ticks_msec() - level_started_ms
	}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_show_safe_mode_diagnostics("Тайм-аут")
	_finish_level(false, "timeout")

func _finish_level(is_correct: bool, reason: String) -> void:
	if result_sent:
		return
	result_sent = true
	level_finished = true
	timer_running = false
	btn_run_trace.disabled = true
	btn_reset.disabled = true
	btn_analyze.disabled = true
	btn_next.visible = true
	for card in palette_cards:
		card.disabled = true
	topology_board.set_tools_locked(true)

	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	if not is_correct and reason != "timeout":
		lbl_status.text = str(current_level.get("explain_short", "Проверьте диагностику для деталей."))
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.62, 0.45))

	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = float(wrong_count) * FAIL_STABILITY_DELTA
	if not is_correct and wrong_count == 0:
		stability_delta += FAIL_STABILITY_DELTA
	if hint_used:
		stability_delta += HINT_STABILITY_DELTA

	var evidence_lines: Array[String] = _collect_selected_evidence_lines()
	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": "A",
		"task_id": str(current_level.get("id", "")),
		"incident_id": str(current_level.get("incident_id", "")),
		"match_key": "NETTRACE_A|%s" % str(current_level.get("id", "")),
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"error_code_last": selected_error_code,
		"attempts_count": attempts.size(),
		"attempts": attempts,
		"evidence_selected": evidence_lines,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"safe_mode_used": safe_mode_used,
		"spam_clicks": spam_clicks,
		"time_to_first_action_ms": first_action_ms,
		"hint_used": hint_used,
		"timed_out": reason == "timeout",
		"stability_delta": stability_delta,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _collect_selected_evidence_lines() -> Array[String]:
	var logs: Array = current_level.get("logs", [])
	var out: Array[String] = []
	for index in selected_evidence_indices:
		if index >= 0 and index < logs.size():
			out.append(str(logs[index]))
	return out

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": Time.get_ticks_msec() - level_started_ms,
		"payload": payload
	})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var option_ids: Array[String] = []
	var options: Array = level.get("options", [])
	for option_var in options:
		var option: Dictionary = option_var
		option_ids.append(str(option.get("id", "")))
	option_ids.sort()
	return "%s|%s|%s|%s" % [
		str(level.get("id", "")),
		str(level.get("prompt", "")),
		str(level.get("correct_id", "")),
		",".join(option_ids)
	]

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	body.vertical = viewport_size.x < viewport_size.y
</file>

<file path="scripts/quests/network_trace/NetworkTraceQuestB.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")
const MODULE_CARD_SCENE: PackedScene = preload("res://scenes/ui/pipeline/ModuleCard.tscn")

const LEVELS_PATH: String = "res://data/network_trace_b_levels.json"
const MAX_ATTEMPTS: int = 3
const DEFAULT_TIME_LIMIT_SEC: int = 120
const RUN_COOLDOWN_MS: int = 450
const ANSWER_COOLDOWN_MS: int = 200
const FAIL_STABILITY_DELTA: float = -10.0
const HINT_STABILITY_DELTA: float = -5.0
const PIPELINE_MISMATCH_DELTA: float = -5.0

const PALETTE_GREEN_ID: int = 0
const PALETTE_AMBER_ID: int = 1
const SLOT_TYPES: Array[String] = ["kilo", "bit", "time", "out"]
const DEFAULT_MODULE_POOL: Array = [
	{"module_id": "KILO_1024", "slot_type": "kilo", "display": "x1024", "k": 1024, "is_trap": false},
	{"module_id": "KILO_1000", "slot_type": "kilo", "display": "x1000", "k": 1000, "is_trap": true},
	{"module_id": "BIT_X8", "slot_type": "bit", "display": "x8", "k": 8, "is_trap": false},
	{"module_id": "BIT_X1", "slot_type": "bit", "display": "x1", "k": 1, "is_trap": true},
	{"module_id": "TIME_DIV", "slot_type": "time", "display": "/t", "k": -1, "is_trap": false},
	{"module_id": "TIME_SKIP", "slot_type": "time", "display": "/1", "k": 1, "is_trap": true},
	{"module_id": "OUT_BPS", "slot_type": "out", "display": "bps", "out_unit": "bps", "is_trap": false},
	{"module_id": "OUT_KBPS", "slot_type": "out", "display": "kbps", "out_unit": "kbps", "is_trap": true}
]

enum QuestState { INIT, PIPELINE_BUILD, PIPELINE_READY, CALC_DONE, ANSWERING, FEEDBACK_SUCCESS, FEEDBACK_FAIL, SAFE_MODE, DIAGNOSTIC, DONE }

@onready var btn_back: Button = $SafeArea/Main/V/Header/BtnBack
@onready var lbl_title: Label = $SafeArea/Main/V/Header/LblTitle
@onready var lbl_meta: Label = $SafeArea/Main/V/Header/LblMeta
@onready var stability_bar: ProgressBar = $SafeArea/Main/V/Header/StabilityBar
@onready var palette_select: OptionButton = $SafeArea/Main/V/Header/PaletteSelect
@onready var body: BoxContainer = $SafeArea/Main/V/Body
@onready var lbl_briefing: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblBriefing
@onready var lbl_prompt: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblPrompt
@onready var lbl_payload: Label = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox/LblPayload
@onready var lbl_window: Label = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox/LblWindow
@onready var lbl_target_unit: Label = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox/LblTargetUnit
@onready var btn_analyze: Button = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/BtnAnalyze
@onready var log_text: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll/LogText
@onready var slot_kilo: PipelineSlotControl = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotKilo
@onready var slot_bit: PipelineSlotControl = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotBit
@onready var slot_time: PipelineSlotControl = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotTime
@onready var slot_out: PipelineSlotControl = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotOut
@onready var module_tray: GridContainer = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/ModuleTrayScroll/ModuleTray
@onready var btn_run_calc: Button = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/BtnRunCalc
@onready var lbl_preview: Label = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/LblPreview
@onready var transfer_bar: ProgressBar = $SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/TransferBar
@onready var lbl_status: Label = $SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/LblStatus
@onready var btn_reset: Button = $SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow/BtnReset
@onready var btn_next: Button = $SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow/BtnNext
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $NoirOverlay/CRT_Overlay

@onready var action_buttons: Array[Button] = [
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn1,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn2,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn3,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn4,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn5,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn6
]

var levels: Array[Dictionary] = []
var current_level: Dictionary = {}
var current_level_index: int = 0
var state: int = QuestState.INIT
var wrong_count: int = 0
var level_started_ms: int = 0
var first_action_ms: int = -1
var time_left_sec: float = float(DEFAULT_TIME_LIMIT_SEC)
var timer_running: bool = false
var run_calc_cooldown_until_ms: int = 0
var answer_cooldown_until_ms: int = 0
var spam_clicks: int = 0
var calc_done: bool = false
var calc_bps: int = -1
var calc_display_value: float = 0.0
var calc_display_unit: String = "bps"
var selected_option_id: String = ""
var last_error_code: String = ""
var safe_mode_used: bool = false
var hint_used: bool = false
var logs_expanded: bool = false
var level_finished: bool = false
var result_sent: bool = false
var pipeline_slots_filled_at_ms: int = -1
var module_moves_count: int = 0
var pipeline_mismatch: bool = false
var selected_tray_module: Dictionary = {}
var selected_module_card: PipelineModuleCard = null
var module_cards: Array[PipelineModuleCard] = []
var attempts: Array[Dictionary] = []
var task_session: Dictionary = {}
var variant_hash: String = ""

func _ready() -> void:
	_setup_runtime_controls()
	_connect_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_layout_mode()
	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not _load_levels():
		_show_boot_error("Данные Network Trace B отсутствуют или повреждены.")
		return
	_start_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible and not level_finished:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.ANSWERING
	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_meta_label()
			_on_timeout()
		else:
			_update_meta_label()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and is_node_ready():
		_apply_layout_mode()

func _setup_runtime_controls() -> void:
	lbl_title.text = "СЕТЕВОЙ СЛЕД | B"
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)
	slot_kilo.setup("kilo", "БАЗА KILO")
	slot_bit.setup("bit", "БАЙТ В БИТ")
	slot_time.setup("time", "ВРЕМЯ")
	slot_out.setup("out", "ЕДИНИЦА ВЫВОДА")
	transfer_bar.value = 0.0
	btn_next.visible = false
	diagnostics_panel.visible = false
	btn_run_calc.disabled = true

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_run_calc.pressed.connect(_on_run_calc_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	var slots: Array[PipelineSlotControl] = [slot_kilo, slot_bit, slot_time, slot_out]
	for slot in slots:
		slot.module_dropped.connect(_on_slot_module_dropped)
		slot.slot_tapped.connect(_on_slot_tapped)
		slot.clear_pressed.connect(_on_slot_clear_pressed)
		slot.bad_drop.connect(_on_slot_bad_drop)
	for idx in range(action_buttons.size()):
		action_buttons[idx].pressed.connect(_on_answer_pressed.bind(idx))

func _load_levels() -> bool:
	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		return false
	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		return false
	levels.clear()
	var raw_levels: Array = parsed
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
	return not levels.is_empty()

func _validate_level(level: Dictionary) -> bool:
	for key in ["id", "briefing", "prompt", "payload_value", "payload_unit", "time_sec", "ask_unit", "expected_bps", "options", "correct_id", "explain_short", "explain_full", "tags"]:
		if not level.has(key):
			return false
	var payload_unit: String = str(level.get("payload_unit", ""))
	if payload_unit != "KB" and payload_unit != "MB":
		return false
	var ask_unit: String = str(level.get("ask_unit", ""))
	if ask_unit != "bps" and ask_unit != "kbps":
		return false
	if int(level.get("payload_value", 0)) <= 0 or int(level.get("time_sec", 0)) <= 0:
		return false
	var options_var: Variant = level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY:
		return false
	var options: Array = options_var
	if options.size() != 6:
		return false
	var ids: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or ids.has(option_id):
			return false
		if not option.has("label") or not option.has("error_code"):
			return false
		ids[option_id] = true
	if not ids.has(str(level.get("correct_id", ""))):
		return false
	var modules_var: Variant = level.get("modules_pool", DEFAULT_MODULE_POOL)
	if typeof(modules_var) != TYPE_ARRAY:
		return false
	var modules: Array = modules_var
	var coverage: Dictionary = {"kilo": false, "bit": false, "time": false, "out": false}
	var module_ids: Dictionary = {}
	for module_var in modules:
		if typeof(module_var) != TYPE_DICTIONARY:
			return false
		var module_data: Dictionary = module_var
		if not module_data.has("module_id") or not module_data.has("slot_type") or not module_data.has("display"):
			return false
		var module_id: String = str(module_data.get("module_id", ""))
		if module_id.is_empty() or module_ids.has(module_id):
			return false
		module_ids[module_id] = true
		var slot_type: String = str(module_data.get("slot_type", ""))
		if not coverage.has(slot_type):
			return false
		coverage[slot_type] = true
		if slot_type == "out":
			var out_unit: String = str(module_data.get("out_unit", ""))
			if out_unit != "bps" and out_unit != "kbps":
				return false
		elif not module_data.has("k"):
			return false
	for slot_key in coverage.keys():
		if not bool(coverage[slot_key]):
			return false
	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))
	for btn in action_buttons:
		btn.disabled = true
	btn_analyze.disabled = true
	btn_run_calc.disabled = true
	btn_reset.disabled = true
	timer_running = false

func _start_level(index: int) -> void:
	if index >= levels.size():
		index = 0
	current_level_index = index
	current_level = levels[index].duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))
	wrong_count = 0
	safe_mode_used = false
	hint_used = false
	logs_expanded = false
	level_finished = false
	result_sent = false
	calc_done = false
	calc_bps = -1
	calc_display_value = 0.0
	calc_display_unit = "bps"
	selected_option_id = ""
	last_error_code = ""
	pipeline_slots_filled_at_ms = -1
	module_moves_count = 0
	pipeline_mismatch = false
	selected_tray_module.clear()
	_set_selected_module_card(null)
	attempts.clear()
	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	time_left_sec = float(int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC)))
	timer_running = true
	task_session = {"task_id": str(current_level.get("id", "NT_B_UNKNOWN")), "variant_hash": variant_hash, "started_at_ticks": level_started_ms, "ended_at_ticks": 0, "attempts": [], "events": []}
	btn_next.visible = false
	btn_analyze.text = "АНАЛИЗ"
	btn_analyze.disabled = false
	diagnostics_panel.visible = false
	_render_terminal_panel()
	_render_options()
	_build_module_tray()
	_reset_pipeline_state()
	lbl_status.text = "Соберите конвейер, запустите расчёт, затем выберите ответ."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.82, 0.82))
	state = QuestState.PIPELINE_BUILD
	_update_meta_label()
	_log_event("task_start", {"level": str(current_level.get("id", ""))})

func _render_terminal_panel() -> void:
	lbl_briefing.clear()
	lbl_briefing.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n%s" % str(current_level.get("briefing", "")))
	lbl_prompt.clear()
	lbl_prompt.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n%s" % str(current_level.get("prompt", "")))
	lbl_payload.text = "Данные: %s %s" % [str(current_level.get("payload_value", 0)), str(current_level.get("payload_unit", "KB"))]
	lbl_window.text = "Окно: %s с" % str(current_level.get("time_sec", 0))
	lbl_target_unit.text = "Целевая единица: %s" % str(current_level.get("ask_unit", "bps"))
	_render_log_text()

func _render_log_text() -> void:
	var lines: Array[String] = []
	var logs_var: Variant = current_level.get("logs", [])
	if typeof(logs_var) == TYPE_ARRAY:
		for line_var in logs_var:
			lines.append(str(line_var))
	if logs_expanded:
		var extra_var: Variant = current_level.get("analyze_lines", [])
		if typeof(extra_var) == TYPE_ARRAY:
			for line_var in extra_var:
				lines.append(str(line_var))
	var text: String = ""
	for line in lines:
		text += "- %s\n" % line
	log_text.text = text

func _render_options() -> void:
	var options_variant: Variant = current_level.get("options", [])
	if typeof(options_variant) != TYPE_ARRAY:
		return
	var options: Array = options_variant
	for idx in range(action_buttons.size()):
		var btn: Button = action_buttons[idx]
		var option: Dictionary = options[idx]
		btn.text = str(option.get("label", ""))
		btn.set_meta("option_id", str(option.get("id", "")))
		btn.set_meta("error_code", str(option.get("error_code", "")))
		btn.disabled = true

func _build_module_tray() -> void:
	for card in module_cards:
		if is_instance_valid(card):
			card.queue_free()
	module_cards.clear()
	var modules: Array[Dictionary] = _get_module_pool_for_level()
	for module_data in modules:
		var card_variant: Variant = MODULE_CARD_SCENE.instantiate()
		var card: PipelineModuleCard = card_variant as PipelineModuleCard
		if card == null:
			continue
		module_tray.add_child(card)
		card.setup(module_data)
		card.module_selected.connect(_on_module_card_selected)
		card.module_drag_started.connect(_on_module_drag_started)
		module_cards.append(card)

func _get_module_pool_for_level() -> Array[Dictionary]:
	var out: Array[Dictionary] = []
	var modules_var: Variant = current_level.get("modules_pool", null)
	if typeof(modules_var) == TYPE_ARRAY:
		var modules: Array = modules_var
		for module_var in modules:
			if typeof(module_var) == TYPE_DICTIONARY:
				var module_data: Dictionary = module_var
				out.append(module_data.duplicate(true))
	if out.is_empty():
		for module_var in DEFAULT_MODULE_POOL:
			var module_data: Dictionary = module_var
			out.append(module_data.duplicate(true))
	return out

func _reset_pipeline_state() -> void:
	slot_kilo.clear_module()
	slot_bit.clear_module()
	slot_time.clear_module()
	slot_out.clear_module()
	calc_done = false
	calc_bps = -1
	calc_display_value = 0.0
	calc_display_unit = "bps"
	selected_option_id = ""
	last_error_code = ""
	selected_tray_module.clear()
	_set_selected_module_card(null)
	lbl_preview.text = "СКОРОСТЬ = ???"
	transfer_bar.value = 0.0
	btn_run_calc.disabled = true
	_enable_answer_buttons(false)
	state = QuestState.PIPELINE_BUILD

func _on_module_card_selected(module_data: Dictionary, sender: Node) -> void:
	if level_finished:
		return
	_register_first_action()
	_play_audio("click")
	selected_tray_module = module_data.duplicate(true)
	_set_selected_module_card(sender as PipelineModuleCard)
	lbl_status.text = "Модуль выбран. Нажмите подходящий слот."
	lbl_status.add_theme_color_override("font_color", Color(0.84, 0.91, 1.0))
	_log_event("module_selected", {"module_id": str(module_data.get("module_id", ""))})

func _on_module_drag_started(module_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	selected_tray_module = module_data.duplicate(true)
	_set_selected_module_card(null)
	_log_event("module_drag_started", {"module_id": str(module_data.get("module_id", ""))})

func _on_slot_tapped(slot_type: String) -> void:
	if level_finished:
		return
	_register_first_action()
	if selected_tray_module.is_empty():
		lbl_status.text = "Сначала выберите модуль из лотка."
		lbl_status.add_theme_color_override("font_color", Color(0.95, 0.86, 0.68))
		return
	_place_module_into_slot(slot_type, selected_tray_module, "tap")

func _on_slot_module_dropped(slot_type: String, module_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	_place_module_into_slot(slot_type, module_data, "drag")

func _on_slot_bad_drop(slot_type: String, module_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	var slot: PipelineSlotControl = _get_slot(slot_type)
	if slot != null:
		slot.flash_bad_drop()
	_play_audio("error")
	last_error_code = "B_PIPELINE_BAD_DROP"
	lbl_status.text = "Неверный разъём для этого модуля."
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
	_log_event("pipeline_bad_drop", {"slot": slot_type, "module_id": str(module_data.get("module_id", ""))})

func _on_slot_clear_pressed(slot_type: String) -> void:
	if level_finished:
		return
	_register_first_action()
	var slot: PipelineSlotControl = _get_slot(slot_type)
	if slot == null or not slot.has_module():
		return
	var removed_id: String = slot.get_module_id()
	slot.clear_module()
	module_moves_count += 1
	_play_audio("click")
	if calc_done:
		calc_done = false
		calc_bps = -1
		lbl_preview.text = "СКОРОСТЬ = ???"
		_enable_answer_buttons(false)
	lbl_status.text = "Конвейер изменён. Запустите расчёт снова."
	lbl_status.add_theme_color_override("font_color", Color(0.92, 0.88, 0.62))
	_log_event("pipeline_clear", {"slot": slot_type, "module_id": removed_id})
	_update_pipeline_gate()

func _place_module_into_slot(slot_type: String, module_data: Dictionary, source: String) -> void:
	var target_slot: PipelineSlotControl = _get_slot(slot_type)
	if target_slot == null:
		return
	if str(module_data.get("slot_type", "")) != slot_type:
		target_slot.flash_bad_drop()
		_on_slot_bad_drop(slot_type, module_data)
		return
	target_slot.set_module(module_data)
	module_moves_count += 1
	selected_tray_module.clear()
	_set_selected_module_card(null)
	_play_audio("click")
	if calc_done:
		calc_done = false
		calc_bps = -1
		lbl_preview.text = "СКОРОСТЬ = ???"
		_enable_answer_buttons(false)
	lbl_status.text = "Модуль установлен. Продолжайте сборку."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.92, 0.86))
	_log_event("pipeline_set", {"slot": slot_type, "module_id": str(module_data.get("module_id", "")), "source": source})
	_update_pipeline_gate()

func _set_selected_module_card(card: PipelineModuleCard) -> void:
	selected_module_card = card
	for module_card in module_cards:
		if is_instance_valid(module_card):
			module_card.set_selected(module_card == selected_module_card)

func _get_slot(slot_type: String) -> PipelineSlotControl:
	match slot_type:
		"kilo":
			return slot_kilo
		"bit":
			return slot_bit
		"time":
			return slot_time
		"out":
			return slot_out
		_:
			return null

func _update_pipeline_gate() -> void:
	var ready: bool = _pipeline_ready()
	btn_run_calc.disabled = (not ready) or level_finished
	if ready and pipeline_slots_filled_at_ms < 0:
		pipeline_slots_filled_at_ms = Time.get_ticks_msec() - level_started_ms
		lbl_status.text = "КОНВЕЙЕР ЗАФИКСИРОВАН. Запустите расчёт."
		lbl_status.add_theme_color_override("font_color", Color(0.72, 0.95, 0.86))
		_log_event("pipeline_complete", {"t_ms": pipeline_slots_filled_at_ms})
	if not calc_done:
		state = QuestState.PIPELINE_READY if ready else QuestState.PIPELINE_BUILD

func _pipeline_ready() -> bool:
	return slot_kilo.has_module() and slot_bit.has_module() and slot_time.has_module() and slot_out.has_module()

func _on_run_calc_pressed() -> void:
	if level_finished:
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < run_calc_cooldown_until_ms:
		spam_clicks += 1
		_log_event("run_calc_spam", {})
		return
	if not _pipeline_ready():
		_record_pipeline_incomplete("run_calc_without_pipeline")
		lbl_status.text = ERROR_MAP.get_error_tip("B_PIPELINE_INCOMPLETE")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return
	run_calc_cooldown_until_ms = now_ms + RUN_COOLDOWN_MS
	_register_first_action()
	_play_audio("click")
	calc_bps = _calculate_bps_from_pipeline()
	calc_display_unit = _current_output_unit()
	calc_display_value = float(calc_bps) / 1000.0 if calc_display_unit == "kbps" else float(calc_bps)
	calc_done = true
	lbl_preview.text = "СКОРОСТЬ = %s" % _format_rate(calc_bps, calc_display_unit)
	lbl_status.text = "Расчёт завершён. Выберите финальный ответ."
	lbl_status.add_theme_color_override("font_color", Color(0.68, 0.95, 0.72))
	_enable_answer_buttons(true)
	state = QuestState.ANSWERING
	_log_event("run_calc", {"calc_bps": calc_bps, "display_unit": calc_display_unit, "display_value": calc_display_value, "pipeline_correct": _is_pipeline_correct(), "pipeline_error": _derive_pipeline_error_code()})

func _calculate_bps_from_pipeline() -> int:
	var payload_value: int = int(current_level.get("payload_value", 0))
	var payload_unit: String = str(current_level.get("payload_unit", "KB"))
	var kilo_base: int = int(slot_kilo.get_module().get("k", 1024))
	var bit_mult: int = int(slot_bit.get_module().get("k", 8))
	var use_time_division: bool = _time_division_enabled(slot_time.get_module())
	var time_sec: int = int(current_level.get("time_sec", 1))
	var bytes_total: int = payload_value * kilo_base
	if payload_unit == "MB":
		bytes_total *= kilo_base
	var bits_total: int = bytes_total * bit_mult
	var divisor: int = time_sec if use_time_division else 1
	if divisor <= 0:
		divisor = 1
	return int(round(float(bits_total) / float(divisor)))

func _time_division_enabled(time_module: Dictionary) -> bool:
	if str(time_module.get("module_id", "")) == "TIME_DIV":
		return true
	return int(time_module.get("k", 1)) < 0

func _current_output_unit() -> String:
	var out_unit: String = str(slot_out.get_module().get("out_unit", "bps"))
	return "kbps" if out_unit == "kbps" else "bps"

func _derive_pipeline_error_code() -> String:
	if not _pipeline_ready():
		return "B_PIPELINE_INCOMPLETE"
	if int(slot_bit.get_module().get("k", 8)) != 8:
		return "B_MATH_X8"
	if int(slot_kilo.get_module().get("k", 1024)) != 1024:
		return "B_MATH_1024"
	if not _time_division_enabled(slot_time.get_module()):
		return "B_MATH_DIV"
	if _current_output_unit() != str(current_level.get("ask_unit", "bps")):
		return "B_UNIT_TRAP"
	return ""

func _is_pipeline_correct() -> bool:
	return _derive_pipeline_error_code().is_empty()

func _on_answer_pressed(index: int) -> void:
	if level_finished or index < 0 or index >= action_buttons.size():
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < answer_cooldown_until_ms:
		spam_clicks += 1
		return
	answer_cooldown_until_ms = now_ms + ANSWER_COOLDOWN_MS
	_register_first_action()
	if state != QuestState.ANSWERING or not calc_done:
		_record_pipeline_incomplete("answer_before_calc")
		lbl_status.text = ERROR_MAP.get_error_tip("B_PIPELINE_INCOMPLETE")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return
	var btn: Button = action_buttons[index]
	selected_option_id = str(btn.get_meta("option_id", ""))
	if selected_option_id.is_empty():
		return
	_play_audio("click")
	_enable_answer_buttons(false)
	var answer_correct: bool = selected_option_id == str(current_level.get("correct_id", ""))
	var pipeline_correct: bool = _is_pipeline_correct()
	pipeline_mismatch = answer_correct and not pipeline_correct
	if answer_correct:
		last_error_code = "B_PIPELINE_MISMATCH" if pipeline_mismatch else ""
	else:
		last_error_code = str(btn.get_meta("error_code", "UNKNOWN"))
		if last_error_code.is_empty():
			last_error_code = _derive_pipeline_error_code()
	var attempt: Dictionary = {"option_id": selected_option_id, "error_code": last_error_code, "correct": answer_correct, "pipeline_correct": pipeline_correct, "pipeline_mismatch": pipeline_mismatch, "calc_bps": calc_bps, "t_ms": now_ms - level_started_ms}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("answer_selected", attempt)
	await _simulate_transfer(answer_correct)
	if answer_correct:
		_handle_success(pipeline_mismatch)
	else:
		_handle_failure(last_error_code)
	if not level_finished and (state == QuestState.ANSWERING or state == QuestState.SAFE_MODE):
		_enable_answer_buttons(true)

func _simulate_transfer(success: bool) -> void:
	transfer_bar.value = 0.0
	var expected_bps: int = int(current_level.get("expected_bps", 1))
	var target: float = 100.0
	if not success:
		var ratio: float = float(calc_bps) / maxf(1.0, float(expected_bps))
		target = clampf(ratio * 100.0, 40.0, 80.0)
	var tween: Tween = create_tween()
	tween.tween_property(transfer_bar, "value", target, 1.2)
	await tween.finished

func _handle_success(has_pipeline_mismatch: bool) -> void:
	state = QuestState.FEEDBACK_SUCCESS
	if has_pipeline_mismatch:
		lbl_status.text = "Ответ принят. Отмечено расхождение в конвейере."
		lbl_status.add_theme_color_override("font_color", Color(0.98, 0.82, 0.56))
	else:
		lbl_status.text = "ЗАГРУЗКА ЗАВЕРШЕНА. %s" % str(current_level.get("explain_short", ""))
		lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.45))
	_play_audio("relay")
	_finish_level(true, "success_with_mismatch" if has_pipeline_mismatch else "success")

func _handle_failure(error_code: String) -> void:
	state = QuestState.FEEDBACK_FAIL
	wrong_count += 1
	_play_audio("error")
	_trigger_glitch()
	lbl_status.text = "%s: %s" % [ERROR_MAP.get_error_title(error_code), ERROR_MAP.get_error_tip(error_code)]
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.4, 0.4))
	_update_meta_label()
	if wrong_count >= 2 and not safe_mode_used:
		safe_mode_used = true
		btn_analyze.text = "ДИАГНОСТИКА"
		lbl_status.text = "Безопасный режим разблокирован. Откройте диагностику."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.75, 0.45))
	if wrong_count >= MAX_ATTEMPTS:
		_show_diagnostics("attempt_limit")
		_finish_level(false, "attempt_limit")
	else:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.ANSWERING

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	_register_first_action()
	_play_audio("click")
	if safe_mode_used:
		if not hint_used:
			hint_used = true
		_show_diagnostics("manual")
		state = QuestState.DIAGNOSTIC
		return
	if logs_expanded:
		lbl_status.text = "Строки анализа уже раскрыты."
		lbl_status.add_theme_color_override("font_color", Color(0.9, 0.85, 0.65))
		return
	logs_expanded = true
	hint_used = true
	_render_log_text()
	lbl_status.text = "Дополнительная телеметрия разблокирована."
	lbl_status.add_theme_color_override("font_color", Color(0.72, 0.95, 0.86))
	_log_event("analyze_reveal", {})

func _show_diagnostics(reason: String) -> void:
	var lines: Array[String] = []
	lines.append("Дело: %s" % str(current_level.get("id", "")))
	lines.append("Причина: %s" % reason)
	lines.append("Конвейер собран к: %d мс" % pipeline_slots_filled_at_ms)
	lines.append("Перемещений модулей: %d" % module_moves_count)
	lines.append("Кило: %s" % slot_kilo.get_module_id())
	lines.append("Бит: %s" % slot_bit.get_module_id())
	lines.append("Время: %s" % slot_time.get_module_id())
	lines.append("Выход: %s" % slot_out.get_module_id())
	if calc_bps >= 0:
		lines.append("Рассчитано: %s" % _format_rate(calc_bps, calc_display_unit))
	lines.append("Ожидается: %d bps" % int(current_level.get("expected_bps", 0)))
	lines.append("Конвейер корректен: %s" % ("да" if _is_pipeline_correct() else "нет"))
	var pipeline_error: String = _derive_pipeline_error_code()
	if not pipeline_error.is_empty():
		lines.append("Ошибка конвейера: %s" % pipeline_error)
		lines.append(ERROR_MAP.get_error_tip(pipeline_error))
	if not last_error_code.is_empty():
		lines.append("Ошибка ответа: %s" % last_error_code)
		lines.append(ERROR_MAP.get_error_tip(last_error_code))
		for detail in ERROR_MAP.detail_messages(last_error_code):
			lines.append(detail)
	var explain_full: String = str(current_level.get("explain_full", ""))
	if not explain_full.is_empty():
		for explain_line_var in explain_full.split("\n"):
			var explain_line: String = explain_line_var.strip_edges()
			if not explain_line.is_empty():
				lines.append(explain_line)
	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true
	_log_event("diagnostics_open", {"reason": reason})

func _on_reset_pressed() -> void:
	if level_finished:
		return
	_register_first_action()
	_play_audio("click")
	_reset_pipeline_state()
	lbl_status.text = "Конвейер сброшен. Соберите и запустите снова."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.86, 0.96))
	_log_event("reset_pressed", {})

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", ""))})
	_start_level(current_level_index + 1)

func _on_back_pressed() -> void:
	_play_audio("click")
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	_apply_palette(palette_select.get_item_id(index))

func _apply_palette(palette_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(1.0, 0.69, 0.0, 1.0))
	else:
		theme = THEME_GREEN
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(0.0, 1.0, 0.25, 1.0))

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _play_audio(sound_name: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_name)

func _update_meta_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	var stability_value: float = 100.0
	if GlobalMetrics != null:
		stability_value = float(GlobalMetrics.stability)
	lbl_meta.text = "ДЕЛО %s | ОШ %d/%d | T-%02d:%02d" % [str(current_level.get("id", "--")), wrong_count, MAX_ATTEMPTS, total_seconds / 60, total_seconds % 60]
	stability_bar.value = stability_value

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_meta_label()

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _record_pipeline_incomplete(source: String) -> void:
	var attempt: Dictionary = {"option_id": "", "error_code": "B_PIPELINE_INCOMPLETE", "correct": false, "pipeline_correct": false, "pipeline_mismatch": false, "calc_bps": calc_bps, "t_ms": Time.get_ticks_msec() - level_started_ms, "source": source}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("pipeline_incomplete", {"source": source})

func _on_timeout() -> void:
	if level_finished:
		return
	last_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {"option_id": "TIMEOUT", "error_code": "TIMEOUT", "correct": false, "pipeline_correct": _is_pipeline_correct(), "pipeline_mismatch": false, "calc_bps": calc_bps, "t_ms": Time.get_ticks_msec() - level_started_ms}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_show_diagnostics("timeout")
	_finish_level(false, "timeout")

func _finish_level(is_correct: bool, reason: String) -> void:
	if result_sent:
		return
	result_sent = true
	level_finished = true
	timer_running = false
	state = QuestState.DONE
	btn_analyze.disabled = true
	btn_run_calc.disabled = true
	btn_reset.disabled = true
	_enable_answer_buttons(false)
	btn_next.visible = true
	for card in module_cards:
		if is_instance_valid(card):
			card.mouse_filter = Control.MOUSE_FILTER_IGNORE
	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {"is_correct": is_correct, "reason": reason})
	if not is_correct and reason != "timeout":
		lbl_status.text = str(current_level.get("explain_short", "Проверьте диагностику."))
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.62, 0.45))
	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = float(wrong_count) * FAIL_STABILITY_DELTA
	if not is_correct and wrong_count == 0:
		stability_delta += FAIL_STABILITY_DELTA
	if hint_used:
		stability_delta += HINT_STABILITY_DELTA
	if pipeline_mismatch:
		stability_delta += PIPELINE_MISMATCH_DELTA
	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": "B",
		"task_id": str(current_level.get("id", "")),
		"match_key": "NETTRACE_B|%s" % str(current_level.get("id", "")),
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"payload_value": int(current_level.get("payload_value", 0)),
		"payload_unit": str(current_level.get("payload_unit", "KB")),
		"time_sec": int(current_level.get("time_sec", 0)),
		"ask_unit": str(current_level.get("ask_unit", "bps")),
		"expected_bps": int(current_level.get("expected_bps", 0)),
		"pipeline_slots_filled_at_ms": pipeline_slots_filled_at_ms,
		"module_moves_count": module_moves_count,
		"pipeline_selected": {"kilo_module_id": slot_kilo.get_module_id(), "bit_module_id": slot_bit.get_module_id(), "time_module_id": slot_time.get_module_id(), "out_module_id": slot_out.get_module_id()},
		"pipeline_correct": _is_pipeline_correct(),
		"pipeline_mismatch": pipeline_mismatch,
		"calc_bps": calc_bps,
		"calc_display_value": calc_display_value,
		"calc_display_unit": calc_display_unit,
		"selected_option_id": selected_option_id,
		"error_code_last": last_error_code,
		"attempts": attempts,
		"attempts_count": attempts.size(),
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"safe_mode_used": safe_mode_used,
		"time_to_first_action_ms": first_action_ms,
		"spam_clicks": spam_clicks,
		"hint_used": hint_used,
		"timed_out": reason == "timeout",
		"stability_delta": stability_delta,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _enable_answer_buttons(enabled: bool) -> void:
	for btn in action_buttons:
		btn.disabled = not enabled or level_finished

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({"name": name, "t_ms": Time.get_ticks_msec() - level_started_ms, "payload": payload})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var option_ids: Array[String] = []
	var options_var: Variant = level.get("options", [])
	if typeof(options_var) == TYPE_ARRAY:
		var options: Array = options_var
		for option_var in options:
			var option: Dictionary = option_var
			option_ids.append(str(option.get("id", "")))
	option_ids.sort()
	return "%s|%s|%s|%s|%s|%s" % [str(level.get("id", "")), str(level.get("payload_value", 0)), str(level.get("payload_unit", "KB")), str(level.get("time_sec", 0)), str(level.get("ask_unit", "bps")), ",".join(option_ids)]

func _format_rate(value_bps: int, ask_unit: String) -> String:
	if ask_unit == "kbps":
		return "%.3f kbps" % (float(value_bps) / 1000.0)
	return "%d bps" % value_bps

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	body.vertical = viewport_size.x < viewport_size.y
	module_tray.columns = 2 if body.vertical else 4
</file>

<file path="scripts/quests/network_trace/NetworkTraceQuestC.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")
const BIT_CELL_SCENE: PackedScene = preload("res://scenes/ui/subnet/BitCell.tscn")

const LEVELS_PATH: String = "res://data/network_trace_c_levels.json"
const MAX_ATTEMPTS: int = 3
const DEFAULT_TIME_LIMIT_SEC: int = 120
const APPLY_COOLDOWN_MS: int = 400
const ANSWER_COOLDOWN_MS: int = 200
const FAIL_STABILITY_DELTA: float = -10.0
const HINT_STABILITY_DELTA: float = -5.0
const SPAM_STABILITY_DELTA: float = -2.0
const PALETTE_GREEN_ID: int = 0
const PALETTE_AMBER_ID: int = 1

enum QuestState { INIT, BOARD_LOCKED, MASK_PLACED, AND_APPLIED, ANSWERED, SAFE_MODE, DIAGNOSTIC, DONE }

@onready var btn_back: Button = $SafeArea/Main/V/Header/BtnBack
@onready var lbl_title: Label = $SafeArea/Main/V/Header/LblTitle
@onready var lbl_meta: Label = $SafeArea/Main/V/Header/LblMeta
@onready var palette_select: OptionButton = $SafeArea/Main/V/Header/PaletteSelect
@onready var body: BoxContainer = $SafeArea/Main/V/Body
@onready var lbl_briefing: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblBriefing
@onready var lbl_prompt: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblPrompt
@onready var lbl_target_ip: Label = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox/LblTargetIp
@onready var lbl_target_cidr: Label = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox/LblTargetCidr
@onready var lbl_target_ask: Label = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox/LblTargetAsk
@onready var log_text: RichTextLabel = $SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll/LogText
@onready var lock_indicator: NetworkLockIndicator = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/LockIndicator
@onready var row_ip: HBoxContainer = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowIpLine/RowIp
@onready var row_mask: HBoxContainer = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine/MaskDropTarget/RowMask
@onready var mask_drop_target: SubnetMaskDropTarget = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine/MaskDropTarget
@onready var row_res_line: HBoxContainer = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine
@onready var row_res: HBoxContainer = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine/RowRes
@onready var mask_overlay: SubnetMaskOverlay = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/MaskTray/MaskOverlay
@onready var ruler: SubnetRulerControl = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/Ruler
@onready var btn_analyze: Button = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions/BtnAnalyze
@onready var btn_apply_and: Button = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions/BtnApplyAnd
@onready var btn_reset: Button = $SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions/BtnReset
@onready var lbl_status: Label = $SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/LblStatus
@onready var btn_next: Button = $SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow/BtnNext
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $NoirOverlay/CRT_Overlay

@onready var action_buttons: Array[Button] = [
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn1,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn2,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn3,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn4,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn5,
	$SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn6
]

var row_ip_cells: Array[SubnetBitCell] = []
var row_mask_cells: Array[SubnetBitCell] = []
var row_res_cells: Array[SubnetBitCell] = []

var levels: Array[Dictionary] = []
var current_level: Dictionary = {}
var current_level_index: int = 0
var state: int = QuestState.INIT

var level_started_ms: int = 0
var first_action_ms: int = -1
var time_left_sec: float = float(DEFAULT_TIME_LIMIT_SEC)
var timer_running: bool = false

var wrong_count: int = 0
var level_finished: bool = false
var result_sent: bool = false
var safe_mode_used: bool = false
var hint_used: bool = false

var mask_placed: bool = false
var and_applied: bool = false
var and_result_last: int = -1
var pending_mask_data: Dictionary = {}

var mask_moves_count: int = 0
var apply_count: int = 0
var reset_count: int = 0
var analyze_count: int = 0
var not_applied_clicks: int = 0
var spam_clicks: int = 0

var apply_cooldown_until_ms: int = 0
var answer_cooldown_until_ms: int = 0

var selected_option_id: String = ""
var last_error_code: String = ""
var attempts: Array[Dictionary] = []
var task_session: Dictionary = {}
var variant_hash: String = ""

func _ready() -> void:
	_setup_runtime_controls()
	_connect_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_layout_mode()
	_build_bit_rows()

	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)

	if not _load_levels():
		_show_boot_error("Данные Network Trace C отсутствуют или повреждены.")
		return

	_start_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible and not level_finished:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.AND_APPLIED

	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_meta_label()
			_on_timeout()
		else:
			_update_meta_label()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and is_node_ready():
		_apply_layout_mode()

func _setup_runtime_controls() -> void:
	lbl_title.text = "СЕТЕВОЙ СЛЕД | C"
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)
	btn_next.visible = false
	btn_analyze.disabled = true
	btn_apply_and.disabled = true
	diagnostics_panel.visible = false

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_apply_and.pressed.connect(_on_apply_and_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_next.pressed.connect(_on_next_pressed)

	mask_overlay.mask_selected.connect(_on_mask_selected)
	mask_overlay.mask_drag_started.connect(_on_mask_drag_started)
	mask_drop_target.mask_dropped.connect(_on_mask_dropped)
	mask_drop_target.bad_drop.connect(_on_mask_bad_drop)
	mask_drop_target.target_tapped.connect(_on_mask_target_tapped)

	for idx in range(action_buttons.size()):
		action_buttons[idx].pressed.connect(_on_answer_pressed.bind(idx))

func _build_bit_rows() -> void:
	row_ip_cells = _create_row_cells(row_ip)
	row_mask_cells = _create_row_cells(row_mask)
	row_res_cells = _create_row_cells(row_res)

func _create_row_cells(container: HBoxContainer) -> Array[SubnetBitCell]:
	for child in container.get_children():
		child.queue_free()
	var out: Array[SubnetBitCell] = []
	for _i in range(8):
		var cell_variant: Variant = BIT_CELL_SCENE.instantiate()
		var cell: SubnetBitCell = cell_variant as SubnetBitCell
		if cell == null:
			continue
		container.add_child(cell)
		cell.set_empty()
		out.append(cell)
	return out

func _load_levels() -> bool:
	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		return false
	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		return false
	levels.clear()
	var raw_levels: Array = parsed
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
	return not levels.is_empty()

func _validate_level(level: Dictionary) -> bool:
	var required_keys: Array[String] = [
		"id", "briefing", "prompt", "target_ip", "cidr", "ip_last", "mask_last", "step", "expected_network_last", "options", "correct_id", "explain_short", "explain_full", "tags"
	]
	for key in required_keys:
		if not level.has(key):
			return false

	var cidr: int = int(level.get("cidr", 0))
	if cidr < 25 or cidr > 28:
		return false

	var ip_last: int = int(level.get("ip_last", -1))
	var mask_last: int = int(level.get("mask_last", -1))
	var step: int = int(level.get("step", 0))
	var expected_last: int = int(level.get("expected_network_last", -1))
	if ip_last < 0 or ip_last > 255:
		return false
	if mask_last < 0 or mask_last > 255:
		return false
	if expected_last < 0 or expected_last > 255:
		return false

	var mask_from_cidr: int = _mask_last_from_cidr(cidr)
	if mask_last != mask_from_cidr:
		return false
	var expected_step: int = 256 - mask_last
	if step != expected_step:
		return false
	if (ip_last & mask_last) != expected_last:
		return false

	var options_var: Variant = level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY:
		return false
	var options: Array = options_var
	if options.size() < 4 or options.size() > 6:
		return false

	var ids_seen: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		if not option.has("id") or not option.has("label") or not option.has("error_code"):
			return false
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or ids_seen.has(option_id):
			return false
		ids_seen[option_id] = true

	if not ids_seen.has(str(level.get("correct_id", ""))):
		return false

	if typeof(level.get("tags", [])) != TYPE_ARRAY:
		return false

	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.32, 0.32))
	btn_analyze.disabled = true
	btn_apply_and.disabled = true
	btn_reset.disabled = true
	_enable_answer_buttons(false)
	timer_running = false

func _start_level(index: int) -> void:
	if levels.is_empty():
		return
	if index >= levels.size():
		index = 0

	current_level_index = index
	current_level = levels[index].duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))

	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	time_left_sec = float(int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC)))
	timer_running = true

	wrong_count = 0
	level_finished = false
	result_sent = false
	safe_mode_used = false
	hint_used = false
	mask_placed = false
	and_applied = false
	and_result_last = -1
	pending_mask_data.clear()
	mask_moves_count = 0
	apply_count = 0
	reset_count = 0
	analyze_count = 0
	not_applied_clicks = 0
	spam_clicks = 0
	apply_cooldown_until_ms = 0
	answer_cooldown_until_ms = 0
	selected_option_id = ""
	last_error_code = ""
	attempts.clear()

	task_session = {
		"task_id": str(current_level.get("id", "NT_C_UNKNOWN")),
		"variant_hash": variant_hash,
		"started_at_ticks": level_started_ms,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	mask_overlay.setup(int(current_level.get("cidr", 26)), int(current_level.get("mask_last", 192)))
	mask_overlay.set_selected(false)
	mask_overlay.mouse_filter = Control.MOUSE_FILTER_STOP
	mask_drop_target.mouse_filter = Control.MOUSE_FILTER_STOP
	lock_indicator.set_locked()
	ruler.configure(int(current_level.get("step", 64)), int(current_level.get("ip_last", 0)))
	ruler.reset_state()
	row_res_line.visible = false

	_set_row_bits(row_ip_cells, int(current_level.get("ip_last", 0)))
	_clear_row(row_mask_cells)
	_clear_row(row_res_cells)

	btn_next.visible = false
	btn_analyze.disabled = true
	btn_analyze.text = "АНАЛИЗ"
	btn_apply_and.disabled = true
	diagnostics_panel.visible = false

	_render_terminal()
	_render_options()
	_enable_answer_buttons(false)

	state = QuestState.BOARD_LOCKED
	lbl_status.text = "Установите маску и нажмите ПРИМЕНИТЬ И."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.84, 0.82))
	_update_meta_label()
	_log_event("task_start", {"level": str(current_level.get("id", ""))})

func _render_terminal() -> void:
	lbl_briefing.clear()
	lbl_briefing.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n%s" % str(current_level.get("briefing", "")))
	lbl_prompt.clear()
	lbl_prompt.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n%s" % str(current_level.get("prompt", "")))
	lbl_target_ip.text = "IP: %s" % str(current_level.get("target_ip", "--"))
	lbl_target_cidr.text = "CIDR: /%d" % int(current_level.get("cidr", 0))
	lbl_target_ask.text = "ЗАПРОС: ID сети (последний октет)"

	var lines: Array[String] = []
	lines.append("ДОСТУП ЗАПРЕЩЁН: неверный сегмент")
	lines.append("Трасса узла: %s" % str(current_level.get("target_ip", "--")))
	lines.append("Профиль маски: /%d" % int(current_level.get("cidr", 0)))
	lines.append("Используйте побитовое AND, чтобы открыть сетевой замок")
	lines.append("Шаг сегмента: %d" % int(current_level.get("step", 0)))
	var expected_last: int = int(current_level.get("expected_network_last", 0))
	lines.append("Целевая сеть заканчивается на .%d" % (mini(255, expected_last + int(current_level.get("step", 0)) - 1)))

	var text_value: String = ""
	for line in lines:
		text_value += "- %s\n" % line
	log_text.text = text_value

func _render_options() -> void:
	var options_var: Variant = current_level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY:
		return
	var options: Array = options_var
	for idx in range(action_buttons.size()):
		var btn: Button = action_buttons[idx]
		if idx < options.size():
			var option_var: Variant = options[idx]
			if typeof(option_var) != TYPE_DICTIONARY:
				btn.visible = false
				btn.disabled = true
				continue
			var option: Dictionary = option_var
			btn.visible = true
			btn.text = str(option.get("label", ""))
			btn.set_meta("option_id", str(option.get("id", "")))
			btn.set_meta("error_code", str(option.get("error_code", "")))
			btn.disabled = true
		else:
			btn.visible = false
			btn.disabled = true
			btn.text = ""
			btn.set_meta("option_id", "")
			btn.set_meta("error_code", "")

func _on_mask_selected(mask_data: Dictionary, sender: Node) -> void:
	if level_finished:
		return
	_register_first_action()
	pending_mask_data = mask_data.duplicate(true)
	mask_overlay.set_selected(sender == mask_overlay)
	_play_audio("click")
	lbl_status.text = "Маска выбрана. Нажмите строку маски или перетащите маску на неё."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.9, 1.0))
	_log_event("mask_selected", {"cidr": int(mask_data.get("cidr", 0))})

func _on_mask_drag_started(mask_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	pending_mask_data = mask_data.duplicate(true)
	mask_overlay.set_selected(false)
	_log_event("mask_drag_started", {"cidr": int(mask_data.get("cidr", 0))})

func _on_mask_target_tapped() -> void:
	if level_finished:
		return
	_register_first_action()
	if pending_mask_data.is_empty():
		lbl_status.text = "Сначала выберите маску."
		lbl_status.add_theme_color_override("font_color", Color(0.95, 0.84, 0.6))
		return
	_apply_mask_placement(pending_mask_data, "tap")

func _on_mask_dropped(mask_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	_apply_mask_placement(mask_data, "drag")

func _on_mask_bad_drop(_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	mask_drop_target.flash_bad_drop()
	last_error_code = "C_BAD_DROP"
	_play_audio("error")
	lbl_status.text = ERROR_MAP.get_error_tip("C_BAD_DROP")
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.56, 0.46))
	_log_event("mask_bad_drop", {})

func _apply_mask_placement(mask_data: Dictionary, source: String) -> void:
	var cidr_value: int = int(mask_data.get("cidr", -1))
	var mask_last_value: int = int(mask_data.get("mask_last", -1))
	if cidr_value != int(current_level.get("cidr", -2)) or mask_last_value != int(current_level.get("mask_last", -3)):
		_on_mask_bad_drop({})
		return

	mask_placed = true
	and_applied = false
	and_result_last = -1
	mask_moves_count += 1
	pending_mask_data.clear()
	mask_overlay.set_selected(false)
	_set_row_bits(row_mask_cells, mask_last_value)
	_clear_row(row_res_cells)
	row_res_line.visible = false
	ruler.reset_state()
	lock_indicator.set_ready()
	btn_apply_and.disabled = false
	_enable_answer_buttons(false)
	state = QuestState.MASK_PLACED
	_play_audio("click")
	lbl_status.text = "Маска установлена. Нажмите ПРИМЕНИТЬ И."
	lbl_status.add_theme_color_override("font_color", Color(0.72, 0.95, 0.86))
	_log_event("mask_placed", {"source": source, "mask_last": mask_last_value})

func _on_apply_and_pressed() -> void:
	if level_finished:
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < apply_cooldown_until_ms:
		spam_clicks += 1
		return
	apply_cooldown_until_ms = now_ms + APPLY_COOLDOWN_MS
	_register_first_action()
	if not mask_placed:
		last_error_code = "C_NOT_APPLIED"
		lbl_status.text = ERROR_MAP.get_error_tip("C_NOT_APPLIED")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.56, 0.46))
		return

	apply_count += 1
	_play_audio("click")
	await _play_and_animation()
	and_result_last = int(current_level.get("ip_last", 0)) & int(current_level.get("mask_last", 0))
	and_applied = true
	state = QuestState.AND_APPLIED
	row_res_line.visible = true
	ruler.configure(int(current_level.get("step", 64)), int(current_level.get("ip_last", 0)))
	ruler.set_result(and_result_last)
	ruler.pulse_marker(1000)
	lock_indicator.set_applied()
	_enable_answer_buttons(true)
	lbl_status.text = "Операция И выполнена. Выберите ID сети."
	lbl_status.add_theme_color_override("font_color", Color(0.66, 0.95, 0.74))
	_log_event("and_applied", {"result": and_result_last})

func _play_and_animation() -> void:
	var ip_bits: Array[int] = _byte_to_bits(int(current_level.get("ip_last", 0)))
	var mask_bits: Array[int] = _byte_to_bits(int(current_level.get("mask_last", 0)))
	for idx in range(mini(8, row_res_cells.size())):
		row_ip_cells[idx].pulse(Color(1.0, 1.0, 0.72, 1.0), 0.1)
		row_mask_cells[idx].pulse(Color(0.92, 0.95, 1.0, 1.0), 0.1)
		var result_bit: int = ip_bits[idx] & mask_bits[idx]
		row_res_cells[idx].set_bit(result_bit)
		row_res_cells[idx].pulse(Color(0.55, 1.0, 0.68, 1.0), 0.12)
		await get_tree().create_timer(0.035).timeout

func _on_answer_pressed(index: int) -> void:
	if level_finished or index < 0 or index >= action_buttons.size():
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < answer_cooldown_until_ms:
		spam_clicks += 1
		return
	answer_cooldown_until_ms = now_ms + ANSWER_COOLDOWN_MS

	if not and_applied:
		not_applied_clicks += 1
		last_error_code = "C_NOT_APPLIED"
		lbl_status.text = ERROR_MAP.get_error_tip("C_NOT_APPLIED")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.56, 0.46))
		_log_event("answer_before_apply", {"count": not_applied_clicks})
		return

	_register_first_action()
	var btn: Button = action_buttons[index]
	selected_option_id = str(btn.get_meta("option_id", ""))
	if selected_option_id.is_empty():
		return

	_play_audio("click")
	var is_correct: bool = selected_option_id == str(current_level.get("correct_id", ""))
	var error_code: String = ""
	if not is_correct:
		error_code = str(btn.get_meta("error_code", ""))
		if error_code.is_empty():
			error_code = "UNKNOWN"
	last_error_code = error_code

	var attempt: Dictionary = {
		"option_id": selected_option_id,
		"error_code": error_code,
		"correct": is_correct,
		"t_ms": now_ms - level_started_ms
	}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("answer_selected", attempt)

	if is_correct:
		_handle_success()
	else:
		_handle_failure(error_code)

func _handle_success() -> void:
	state = QuestState.ANSWERED
	lock_indicator.set_open()
	lbl_status.text = "ЗАМОК ОТКРЫТ. %s" % str(current_level.get("explain_short", ""))
	lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.48))
	_play_audio("relay")
	_finish_level(true, "success")

func _handle_failure(error_code: String) -> void:
	wrong_count += 1
	state = QuestState.ANSWERED
	lock_indicator.set_error()
	_play_audio("error")
	_trigger_glitch()

	lbl_status.text = "%s: %s" % [ERROR_MAP.get_error_title(error_code), ERROR_MAP.get_error_tip(error_code)]
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.4, 0.4))
	_update_meta_label()
	_log_event("answer_fail", {"error_code": error_code, "wrong_count": wrong_count})

	if wrong_count >= 1:
		btn_analyze.disabled = false
	if wrong_count >= 2 and not safe_mode_used:
		safe_mode_used = true
		state = QuestState.SAFE_MODE
		btn_analyze.text = "ДИАГНОСТИКА"
		lbl_status.text = "Безопасный режим разблокирован. Откройте диагностику."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.74, 0.44))

	if wrong_count >= MAX_ATTEMPTS:
		_show_diagnostics("attempt_limit")
		_finish_level(false, "attempt_limit")
	else:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.AND_APPLIED

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	if wrong_count < 1 and not safe_mode_used:
		lbl_status.text = "Анализ открывается после первой ошибки."
		lbl_status.add_theme_color_override("font_color", Color(0.92, 0.84, 0.58))
		return

	_register_first_action()
	analyze_count += 1
	hint_used = true
	_play_audio("click")
	_show_diagnostics("manual")
	state = QuestState.DIAGNOSTIC

func _show_diagnostics(reason: String) -> void:
	var ip_last: int = int(current_level.get("ip_last", 0))
	var mask_last: int = int(current_level.get("mask_last", 0))
	var and_value: int = ip_last & mask_last
	var step: int = int(current_level.get("step", 64))
	var network_last: int = ip_last - (ip_last % step)
	var range_end: int = mini(255, network_last + step - 1)

	var lines: Array[String] = []
	lines.append("Дело: %s" % str(current_level.get("id", "")))
	lines.append("Причина: %s" % reason)
	lines.append("Последний октет IP: %d (%s)" % [ip_last, _byte_to_binary(ip_last)])
	lines.append("Последний октет MASK: %d (%s)" % [mask_last, _byte_to_binary(mask_last)])
	lines.append("Результат AND: %d (%s)" % [and_value, _byte_to_binary(and_value)])
	lines.append("Шаг: %d" % step)
	lines.append("Сегмент: %d..%d" % [network_last, range_end])
	lines.append("Ожидаемая сеть: %d" % int(current_level.get("expected_network_last", 0)))
	if not last_error_code.is_empty():
		lines.append("Последняя ошибка: %s" % last_error_code)
		lines.append(ERROR_MAP.get_error_tip(last_error_code))
		for detail in ERROR_MAP.detail_messages(last_error_code):
			lines.append(detail)

	var explain_full: String = str(current_level.get("explain_full", ""))
	if not explain_full.is_empty():
		for line_var in explain_full.split("\n"):
			var line_text: String = line_var.strip_edges()
			if not line_text.is_empty():
				lines.append(line_text)

	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true
	_log_event("diagnostics_open", {"reason": reason})

func _on_reset_pressed() -> void:
	if level_finished:
		return
	_register_first_action()
	reset_count += 1
	mask_placed = false
	and_applied = false
	and_result_last = -1
	pending_mask_data.clear()
	mask_overlay.set_selected(false)
	_clear_row(row_mask_cells)
	_clear_row(row_res_cells)
	row_res_line.visible = false
	btn_apply_and.disabled = true
	_enable_answer_buttons(false)
	lock_indicator.set_locked()
	ruler.reset_state()
	diagnostics_panel.visible = false
	state = QuestState.BOARD_LOCKED
	_play_audio("click")
	lbl_status.text = "Поле сброшено. Установите маску и примените И."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.86, 0.95))
	_log_event("reset_pressed", {})

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", ""))})
	_start_level(current_level_index + 1)

func _on_back_pressed() -> void:
	_play_audio("click")
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	_apply_palette(palette_select.get_item_id(index))

func _apply_palette(palette_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(1.0, 0.7, 0.08, 1.0))
		if has_node("CanvasModulate"):
			var tint_amber: CanvasModulate = $CanvasModulate
			tint_amber.color = Color(1.0, 0.95, 0.9, 1.0)
	else:
		theme = THEME_GREEN
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(0.0, 1.0, 0.25, 1.0))
		if has_node("CanvasModulate"):
			var tint_green: CanvasModulate = $CanvasModulate
			tint_green.color = Color(0.9, 1.0, 0.94, 1.0)

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _play_audio(sound_name: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_name)

func _update_meta_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	lbl_meta.text = "ДЕЛО %s | ОШ %d/%d | T-%02d:%02d" % [
		str(current_level.get("id", "--")),
		wrong_count,
		MAX_ATTEMPTS,
		total_seconds / 60,
		total_seconds % 60
	]

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_meta_label()

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _on_timeout() -> void:
	if level_finished:
		return
	last_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {
		"option_id": "TIMEOUT",
		"error_code": "TIMEOUT",
		"correct": false,
		"t_ms": Time.get_ticks_msec() - level_started_ms
	}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_show_diagnostics("timeout")
	_finish_level(false, "timeout")

func _finish_level(is_correct: bool, reason: String) -> void:
	if result_sent:
		return
	result_sent = true
	level_finished = true
	timer_running = false
	state = QuestState.DONE

	btn_analyze.disabled = true
	btn_apply_and.disabled = true
	btn_reset.disabled = true
	_enable_answer_buttons(false)
	btn_next.visible = true
	mask_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	mask_drop_target.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	if not is_correct and reason != "timeout":
		lbl_status.text = str(current_level.get("explain_short", "Проверьте диагностику."))
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.62, 0.45))

	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = float(wrong_count) * FAIL_STABILITY_DELTA
	if not is_correct and wrong_count == 0:
		stability_delta += FAIL_STABILITY_DELTA
	if hint_used:
		stability_delta += HINT_STABILITY_DELTA
	if spam_clicks >= 4:
		stability_delta += SPAM_STABILITY_DELTA

	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": "C",
		"task_id": str(current_level.get("id", "")),
		"match_key": "NETTRACE_C|%s" % str(current_level.get("id", "")),
		"variant_hash": variant_hash,
		"target_ip": str(current_level.get("target_ip", "")),
		"cidr": int(current_level.get("cidr", 0)),
		"ip_last": int(current_level.get("ip_last", 0)),
		"mask_last": int(current_level.get("mask_last", 0)),
		"step": int(current_level.get("step", 0)),
		"expected_network_last": int(current_level.get("expected_network_last", 0)),
		"mask_placed": mask_placed,
		"and_applied": and_applied,
		"and_result_last": and_result_last,
		"board_actions": {
			"mask_moves_count": mask_moves_count,
			"apply_count": apply_count,
			"reset_count": reset_count,
			"analyze_count": analyze_count,
			"not_applied_clicks": not_applied_clicks
		},
		"attempts": attempts,
		"selected_option_id": selected_option_id,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"error_code_last": "" if is_correct else last_error_code,
		"attempts_count": attempts.size(),
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"safe_mode_used": safe_mode_used,
		"time_to_first_action_ms": first_action_ms,
		"hint_used": hint_used,
		"timed_out": reason == "timeout",
		"spam_clicks": spam_clicks,
		"stability_delta": stability_delta,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _enable_answer_buttons(enabled: bool) -> void:
	for btn in action_buttons:
		if btn.visible:
			btn.disabled = not enabled or level_finished

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": Time.get_ticks_msec() - level_started_ms,
		"payload": payload
	})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var ids: Array[String] = []
	var options_var: Variant = level.get("options", [])
	if typeof(options_var) == TYPE_ARRAY:
		var options: Array = options_var
		for option_var in options:
			if typeof(option_var) != TYPE_DICTIONARY:
				continue
			var option: Dictionary = option_var
			ids.append(str(option.get("id", "")))
	ids.sort()
	return "%s|%s|%s|%s|%s|%s" % [
		str(level.get("id", "")),
		str(level.get("target_ip", "")),
		str(level.get("cidr", 0)),
		str(level.get("ip_last", 0)),
		str(level.get("mask_last", 0)),
		",".join(ids)
	]

func _mask_last_from_cidr(cidr: int) -> int:
	var host_bits: int = 32 - cidr
	if host_bits < 0 or host_bits > 8:
		return -1
	var value: int = 256 - int(pow(2.0, float(host_bits)))
	return clampi(value, 0, 255)

func _set_row_bits(cells: Array[SubnetBitCell], octet_value: int) -> void:
	var bits: Array[int] = _byte_to_bits(octet_value)
	for idx in range(mini(cells.size(), bits.size())):
		cells[idx].set_bit(bits[idx])

func _clear_row(cells: Array[SubnetBitCell]) -> void:
	for cell in cells:
		cell.set_empty()

func _byte_to_bits(value: int) -> Array[int]:
	var safe_value: int = clampi(value, 0, 255)
	var bits: Array[int] = []
	for shift in range(7, -1, -1):
		bits.append((safe_value >> shift) & 1)
	return bits

func _byte_to_binary(value: int) -> String:
	var bits: Array[int] = _byte_to_bits(value)
	var parts: PackedStringArray = PackedStringArray()
	for bit in bits:
		parts.append(str(bit))
	return "".join(parts)

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	body.vertical = viewport_size.x < viewport_size.y
</file>

<file path="scripts/ssot/network_trace_errors.gd">
extends RefCounted
class_name NetworkTraceErrors

const SHORT_MESSAGES: Dictionary = {
	"": "",
	"A_WRONG_EVIDENCE": "Соберите достаточно улик перед запуском.",
	"A_L1_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "Хаб дублирует кадры на все порты. Сегмент остаётся шумным.",
	"A_L2_SEGMENT_LIMIT": "Коммутатор не маршрутизирует между подсетями.",
	"A_L1_PHYSICAL": "Репитер только усиливает сигнал.",
	"A_PASSIVE": "Патч-панель — пассивная коммутация.",
	"B_MATH_X8": "Байты не переведены в биты.",
	"B_MATH_1024": "Пропущен двоичный множитель 1024.",
	"B_MATH_DIV": "Скорость нужно делить на время.",
	"B_UNIT_TRAP": "Требуемая единица — бит/с, а не кбит/с.",
	"B_PIPELINE_INCOMPLETE": "Соберите и запустите конвейер перед ответом.",
	"B_PIPELINE_BAD_DROP": "Модуль не подходит к этому слоту.",
	"B_PIPELINE_MISMATCH": "Ответ выбран при неверном конвейере.",
	"B_SPAM_TRACE": "Обнаружен спам-команд трассировки.",
	"B_GARBAGE": "Результат не совпадает с моделью передачи.",
	"C_MASK_VAL": "Значение маски не является адресом сети.",
	"C_NOT_APPLIED": "Сначала примените AND, затем выбирайте ответ.",
	"C_L24_FALLBACK": "Автоподстановка /24 здесь неверна.",
	"C_BOUNDARY_SHIFT": "Граница подсети сдвинута.",
	"C_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "Выбран широковещательный адрес.",
	"C_BAD_STEP": "Шаг подсети вычислен неверно.",
	"C_BAD_DROP": "Маску нужно поместить в строку «МАСКА».",
	"TIMEOUT": "Время вышло.",
	"UNKNOWN": "Неверный вариант для текущего контекста."
}

const DETAIL_MESSAGES: Dictionary = {
	"A_WRONG_EVIDENCE": [
		"Порог по уликам предотвращает случайный перебор.",
		"Сначала выберите обязательные лог-улики."
	],
	"A_L1_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": [
		"Хаб отправляет копии кадров на все порты.",
		"Для сегментации L2 нужен коммутатор, для подсетей — маршрутизатор."
	],
	"A_L2_SEGMENT_LIMIT": [
		"Коммутатор пересылает по MAC внутри одного широковещательного домена.",
		"Трафик между подсетями требует маршрутизатора или L3-коммутатора."
	],
	"A_L1_PHYSICAL": [
		"Репитер только восстанавливает мощность сигнала.",
		"Он не анализирует адреса и не применяет правила."
	],
	"A_PASSIVE": [
		"Патч-панель — это точка коммутации кабелей.",
		"Она не фильтрует и не маршрутизирует трафик."
	],
	"B_MATH_X8": [
		"Формула скорости: биты/время.",
		"Сначала переведите байты в биты, умножив на 8."
	],
	"B_MATH_1024": [
		"Двоичные единицы хранения используют 1024.",
		"Когда нужна двоичная конверсия, используйте множители KiB и MiB."
	],
	"B_MATH_DIV": [
		"Пропускная способность — это общее число бит, делённое на секунды передачи.",
		"Без деления результат получается завышенным."
	],
	"B_UNIT_TRAP": [
		"Ответ должен точно совпадать с требуемой единицей.",
		"Если требуется бит/с, не подставляйте кбит/с."
	],
	"B_PIPELINE_INCOMPLETE": [
		"Панель ответов открывается только после КАЛЬКУЛЯЦИИ.",
		"Сначала выберите основание, шаг байт->бит и деление на время."
	],
	"B_PIPELINE_BAD_DROP": [
		"Каждый слот принимает только свою категорию модуля.",
		"Сопоставьте slot_type модуля с подписью разъёма."
	],
	"B_PIPELINE_MISMATCH": [
		"Финальный ответ можно угадать даже при неверной сборке.",
		"Проверьте этапы конвейера, чтобы избежать ошибок единиц и формулы."
	],
	"B_SPAM_TRACE": [
		"Частые быстрые клики снижают надёжность.",
		"Дождитесь окончания кулдауна перед повторным запуском."
	],
	"B_GARBAGE": [
		"Выбранное число не соответствует конвейеру преобразования.",
		"Проверьте каждую операцию перед выбором финального ответа."
	],
	"C_MASK_VAL": [
		"Маска сама по себе не является ID сети.",
		"Вычисляйте сеть как IP И маска."
	],
	"C_NOT_APPLIED": [
		"Варианты ответа заблокированы, пока не выполнен операция И.",
		"Сначала установите маску и выполните операцию И."
	],
	"C_L24_FALLBACK": [
		"Только маски /24 по умолчанию дают границу .0.",
		"Для остальных масок используйте реальный размер блока."
	],
	"C_BOUNDARY_SHIFT": [
		"Размер блока берётся из последнего октета маски, отличного от 255.",
		"ID сети — ближайшая нижняя граница блока."
	],
	"C_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": [
		"Широковещательный адрес — верхняя граница подсети.",
		"ID сети — нижняя граница."
	],
	"C_BAD_STEP": [
		"Шаг равен 256 минус значение маски в последнем октете.",
		"Используйте начала сегментов по этому шагу."
	],
	"C_BAD_DROP": [
		"Карту маски нужно помещать в зону сброса строки «МАСКА».",
		"Зона сброса отклоняет неподходящие объекты."
	],
	"TIMEOUT": [
		"Временной режим достиг лимита.",
		"Используйте быстрые преобразования единиц и проверку границ."
	],
	"UNKNOWN": [
		"Вариант не удовлетворяет условиям задачи.",
		"Перепроверьте контекст и выберите единственное корректное совпадение."
	]
}

const TITLES: Dictionary = {
	"A_WRONG_EVIDENCE": "ТРЕБУЮТСЯ УЛИКИ",
	"A_L1_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "ШТОРМ ШИРОКОВЕЩАНИЯ",
	"A_L2_SEGMENT_LIMIT": "ОГРАНИЧЕНИЕ L2",
	"A_L1_PHYSICAL": "ТОЛЬКО ФИЗИЧЕСКИЙ УРОВЕНЬ",
	"A_PASSIVE": "ПАССИВНЫЙ КОМПОНЕНТ",
	"B_MATH_X8": "ОШИБКА ПЕРЕВОДА В БИТЫ",
	"B_MATH_1024": "ОШИБКА ДВОИЧНОЙ ЕДИНИЦЫ",
	"B_MATH_DIV": "ОШИБКА ФОРМУЛЫ СКОРОСТИ",
	"B_UNIT_TRAP": "НЕСОВПАДЕНИЕ ЕДИНИЦ",
	"B_PIPELINE_INCOMPLETE": "КОНВЕЙЕР НЕ ЗАВЕРШЁН",
	"B_PIPELINE_BAD_DROP": "НЕВЕРНАЯ ЗОНА СБРОСА",
	"B_PIPELINE_MISMATCH": "НЕСОВПАДЕНИЕ КОНВЕЙЕРА",
	"B_SPAM_TRACE": "СПАМ ТРАССИРОВКИ",
	"B_GARBAGE": "НЕКОРРЕКТНЫЙ РЕЗУЛЬТАТ",
	"C_MASK_VAL": "ПУТАНИЦА С МАСКОЙ",
	"C_NOT_APPLIED": "ОПЕРАЦИЯ И НЕ ПРИМЕНЁН",
	"C_L24_FALLBACK": "ЛОВУШКА /24 ПО УМОЛЧАНИЮ",
	"C_BOUNDARY_SHIFT": "СДВИГ ГРАНИЦЫ",
	"C_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "ВЫБРАН ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС",
	"C_BAD_STEP": "НЕВЕРНЫЙ ШАГ",
	"C_BAD_DROP": "НЕВЕРНАЯ ЗОНА СБРОСА",
	"TIMEOUT": "ТАЙМАУТ",
	"UNKNOWN": "НЕВЕРНОЕ РЕШЕНИЕ"
}

static func short_message(code: String) -> String:
	var normalized: String = code.strip_edges()
	if SHORT_MESSAGES.has(normalized):
		return str(SHORT_MESSAGES[normalized])
	return str(SHORT_MESSAGES["UNKNOWN"])

static func get_error_title(code: String) -> String:
	var normalized: String = code.strip_edges()
	if TITLES.has(normalized):
		return str(TITLES[normalized])
	return str(TITLES["UNKNOWN"])

static func get_error_tip(code: String) -> String:
	return short_message(code)

static func detail_messages(code: String) -> Array[String]:
	var normalized: String = code.strip_edges()
	var source: Array = []
	if DETAIL_MESSAGES.has(normalized):
		source = DETAIL_MESSAGES[normalized]
	else:
		source = DETAIL_MESSAGES["UNKNOWN"]
	var details: Array[String] = []
	for line_var in source:
		details.append(str(line_var))
	return details
</file>

<file path="ui/shaders/crt_overlay.gdshader">
shader_type canvas_item;

uniform sampler2D screen_tex : hint_screen_texture, repeat_disable, filter_linear_mipmap;
uniform vec4 tint_color : source_color = vec4(0.0, 1.0, 0.25, 1.0);
uniform float intensity : hint_range(0.0, 1.0) = 0.12;
uniform int fx_quality = 0;
uniform float glitch_strength : hint_range(0.0, 2.0) = 0.0;

void fragment() {
	vec2 uv = SCREEN_UV;
	float scan = 0.5 + 0.5 * sin((uv.y * 900.0) + TIME * 12.0);
	float vig = smoothstep(0.95, 0.2, length(uv - vec2(0.5)));

	vec2 sample_uv = uv;
	if (fx_quality > 0) {
		float shift = glitch_strength * (sin(TIME * 35.0 + uv.y * 80.0)) * 0.003;
		sample_uv.x += shift;
	}

	vec3 src = texture(screen_tex, sample_uv).rgb;
	float overlay = intensity * mix(0.65, 1.0, scan) * vig;
	vec3 tint = mix(src, tint_color.rgb, overlay);
	COLOR = vec4(tint, overlay);
}
</file>

<file path="data/city_map/level_6_1.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_1",
  "directed": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 9,
  "min_path_examples": [
    ["A", "C", "D", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "nodes": [
    {"id": "A", "label": "A", "pos": {"x": 0.10, "y": 0.50}},
    {"id": "B", "label": "B", "pos": {"x": 0.35, "y": 0.25}},
    {"id": "C", "label": "C", "pos": {"x": 0.35, "y": 0.75}},
    {"id": "D", "label": "D", "pos": {"x": 0.62, "y": 0.75}},
    {"id": "E", "label": "E", "pos": {"x": 0.88, "y": 0.50}}
  ],
  "edges": [
    {"id": "e1", "from": "A", "to": "B", "w": 5},
    {"id": "e2", "from": "A", "to": "C", "w": 3},
    {"id": "e3", "from": "C", "to": "B", "w": 1},
    {"id": "e4", "from": "C", "to": "D", "w": 4},
    {"id": "e5", "from": "B", "to": "E", "w": 8},
    {"id": "e6", "from": "D", "to": "E", "w": 2}
  ],
  "rules": {
    "input_regex": "^[0-9]+$",
    "require_end_node_to_submit": true
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5
  },
  "analytics": {
    "enabled": true
  }
}
</file>

<file path="data/city_map/level_6_2.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6.2",
  "directed_default": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 10,
  "min_path_examples": [
    ["A", "D", "C", "F", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "constraints": {
    "must_visit": ["C"]
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_transit": 25,
    "penalty_cycle": 10,
    "overtime_div": 2
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.50 } },
    { "id": "B", "label": "B", "pos": { "x": 0.25, "y": 0.24 } },
    { "id": "C", "label": "C", "pos": { "x": 0.45, "y": 0.50 } },
    { "id": "D", "label": "D", "pos": { "x": 0.25, "y": 0.76 } },
    { "id": "E", "label": "E", "pos": { "x": 0.82, "y": 0.50 } },
    { "id": "F", "label": "F", "pos": { "x": 0.62, "y": 0.24 } },
    { "id": "G", "label": "G", "pos": { "x": 0.62, "y": 0.76 } },
    { "id": "H", "label": "H", "pos": { "x": 0.92, "y": 0.24 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 4, "two_way": false },
    { "id": "e2", "from": "A", "to": "D", "w": 2, "two_way": false },
    { "id": "e3", "from": "D", "to": "C", "w": 3, "two_way": false },
    { "id": "e4", "from": "B", "to": "C", "w": 5, "two_way": true },
    { "id": "e5", "from": "B", "to": "F", "w": 6, "two_way": false },
    { "id": "e6", "from": "C", "to": "F", "w": 2, "two_way": true },
    { "id": "e7", "from": "C", "to": "G", "w": 4, "two_way": true },
    { "id": "e8", "from": "F", "to": "E", "w": 3, "two_way": false },
    { "id": "e9", "from": "G", "to": "E", "w": 5, "two_way": false },
    { "id": "e10", "from": "D", "to": "G", "w": 7, "two_way": false },
    { "id": "e11", "from": "F", "to": "H", "w": 2, "two_way": false },
    { "id": "e12", "from": "H", "to": "E", "w": 4, "two_way": false }
  ],
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_2"
  }
}
</file>

<file path="data/city_map/level_6_3.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6.3",
  "time_limit_sec": 140,
  "start_node": "A",
  "end_node": "L",
  "min_sum": 67,
  "min_path_examples": [
    ["A", "B", "F", "G", "K", "L"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.12 } },
    { "id": "B", "label": "B", "pos": { "x": 0.28, "y": 0.12 } },
    { "id": "C", "label": "C", "pos": { "x": 0.48, "y": 0.12 } },
    { "id": "D", "label": "D", "pos": { "x": 0.68, "y": 0.12 } },
    { "id": "E", "label": "E", "pos": { "x": 0.08, "y": 0.45 } },
    { "id": "F", "label": "F", "pos": { "x": 0.28, "y": 0.45 } },
    { "id": "G", "label": "G", "pos": { "x": 0.48, "y": 0.45 } },
    { "id": "H", "label": "H", "pos": { "x": 0.68, "y": 0.45 } },
    { "id": "I", "label": "I", "pos": { "x": 0.18, "y": 0.80 } },
    { "id": "J", "label": "J", "pos": { "x": 0.38, "y": 0.80 } },
    { "id": "K", "label": "K", "pos": { "x": 0.58, "y": 0.80 } },
    { "id": "L", "label": "L", "pos": { "x": 0.82, "y": 0.80 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 10 },
    { "id": "e2", "from": "B", "to": "C", "w": 10 },
    { "id": "e3", "from": "C", "to": "D", "w": 10 },
    { "id": "e4", "from": "A", "to": "E", "w": 15 },
    { "id": "e5", "from": "B", "to": "F", "w": 15 },
    { "id": "e6", "from": "C", "to": "G", "w": 15 },
    { "id": "e7", "from": "D", "to": "H", "w": 15 },
    { "id": "e8", "from": "E", "to": "F", "w": 12 },
    { "id": "e9", "from": "F", "to": "G", "w": 12 },
    { "id": "e10", "from": "G", "to": "H", "w": 12 },
    { "id": "e11", "from": "E", "to": "I", "w": 20 },
    { "id": "e12", "from": "F", "to": "J", "w": 20 },
    { "id": "e13", "from": "G", "to": "K", "w": 20 },
    { "id": "e14", "from": "H", "to": "L", "w": 20 },
    { "id": "e15", "from": "I", "to": "J", "w": 10 },
    { "id": "e16", "from": "J", "to": "K", "w": 10 },
    { "id": "e17", "from": "K", "to": "L", "w": 10 },
    { "id": "e18", "from": "B", "to": "G", "w": 25 },
    { "id": "e19", "from": "F", "to": "C", "w": 25 },

    {
      "id": "e_patrol_1",
      "from": "C", "to": "H",
      "w": 10,
      "schedule": [
        { "t_from": 0, "t_to": 60, "w": 10, "state": "open" },
        { "t_from": 60, "t_to": 999, "w": 50, "state": "open" }
      ],
      "tags": ["patrol"]
    },
    {
      "id": "e_patrol_2",
      "from": "I", "to": "L",
      "w": 40,
      "schedule": [
        { "t_from": 0, "t_to": 80, "w": 40, "state": "open" },
        { "t_from": 80, "t_to": 999, "w": 100, "state": "closed" }
      ],
      "tags": ["patrol", "close_trap"]
    }
  ],
  "constraints": {
    "must_visit": ["F"],
    "blacklist_nodes": ["J"],
    "xor_groups": [
      { "id": "xor_bridge", "type": "AT_MOST_ONE", "nodes": ["E", "G"] }
    ]
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_logic_violation": 30,
    "ambush_multiplier": 0.5,
    "overtime_div": 2,
    "fail_threshold": 10
  },
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_3"
  }
}
</file>

<file path="data/clues_levels.json">
[
  {
    "quest_id": "CASE_01_DIGITAL_RESUS",
    "schema_version": "1.3.0",
    "id": "RESUS-A-01",
    "bucket": "newbie",
    "briefing": "Восстановите рабочую станцию: распределите все детали по ВВОД / ВЫВОД / ПАМЯТЬ. GPU нужен для сигнала, RAM — для стабильной загрузки, CACHE — для быстрой диагностики.",
    "format": "MATCHING",
    "buckets": [
      {
        "bucket_id": "INPUT",
        "label": "Ввод"
      },
      {
        "bucket_id": "OUTPUT",
        "label": "Вывод"
      },
      {
        "bucket_id": "MEMORY",
        "label": "Память"
      }
    ],
    "items": [
      {
        "item_id": "keyboard",
        "label": "Клавиатура",
        "correct_bucket_id": "INPUT"
      },
      {
        "item_id": "mouse",
        "label": "Мышь",
        "correct_bucket_id": "INPUT"
      },
      {
        "item_id": "microphone",
        "label": "Микрофон",
        "correct_bucket_id": "INPUT"
      },
      {
        "item_id": "gpu",
        "label": "GPU",
        "correct_bucket_id": "OUTPUT"
      },
      {
        "item_id": "monitor",
        "label": "Монитор",
        "correct_bucket_id": "OUTPUT"
      },
      {
        "item_id": "speaker",
        "label": "Динамик",
        "correct_bucket_id": "OUTPUT"
      },
      {
        "item_id": "ram",
        "label": "RAM",
        "correct_bucket_id": "MEMORY"
      },
      {
        "item_id": "cache",
        "label": "Кэш",
        "correct_bucket_id": "MEMORY"
      }
    ],
    "scoring_model": {
      "rules": [
        {
          "code": "PERFECT",
          "min_correct": 8,
          "points": 2,
          "stability_delta": 0,
          "verdict_code": "PERFECT"
        },
        {
          "code": "PARTIAL",
          "min_correct": 6,
          "points": 1,
          "stability_delta": -10,
          "verdict_code": "PARTIAL"
        },
        {
          "code": "FAIL",
          "min_correct": 0,
          "points": 0,
          "stability_delta": -30,
          "verdict_code": "FAIL"
        }
      ],
      "default_rule": {
        "code": "EMPTY_CONFIRM",
        "points": 0,
        "stability_delta": -50,
        "verdict_code": "EMPTY"
      }
    },
    "feedback_rules": {
      "NO_GPU": {
        "status": "GPU отсутствует в OUTPUT: монитор остаётся тёмным.",
        "monitor": "НЕТ СИГНАЛА"
      },
      "NO_RAM": {
        "status": "RAM отсутствует в MEMORY: загрузка продолжает сбоить.",
        "console_lines": [
          "[ОШИБКА] Ошибка чтения памяти",
          "[СИСТЕМА] Повторная инициализация шины памяти...",
          "[ОШИБКА] Ошибка чтения памяти",
          "[СИСТЕМА] Загрузка остановлена"
        ]
      },
      "NO_CACHE": {
        "status": "CACHE отсутствует: диагностика работает медленно."
      },
      "HEALTHY": {
        "status": "Система восстановлена. Готова к диагностике."
      }
    },
    "system_state_rules": {
      "monitor_on_if": {
        "item_id": "gpu",
        "zone_id": "OUTPUT"
      },
      "ram_ok_if": {
        "item_id": "ram",
        "zone_id": "MEMORY"
      },
      "fast_type_if": {
        "item_id": "cache",
        "zone_id": "MEMORY"
      },
      "boot_ok_lines": [
        "[СИСТЕМА] Линии питания: ОК",
        "[СИСТЕМА] Карта памяти: ГОТОВО",
        "[СИСТЕМА] Устройства PCIe: ОБНАРУЖЕНЫ",
        "[СИСТЕМА] Последовательность загрузки завершена"
      ]
    },
    "stages": {
      "A": {
        "level_id": "RESUS-A-01"
      },
      "B": {
        "id": "CASE01_B_01",
        "stage_max_points": 2,
        "format": "SINGLE_CHOICE_CONTEXT",
        "context": "Чтобы завершить взлом архива, система должна вывести видеопоток в реальном времени. Бюджет ограничен 1000$. Выберите лучшую конфигурацию.",
        "budget": 1000,
        "options": [
          {
            "option_id": "B1_BOTTLENECK",
            "title": "Узкое место",
            "total_price": 650,
            "parts": [
              {
                "k": "CPU",
                "v": "Высокий",
                "price": 600
              },
              {
                "k": "RAM",
                "v": "Низкий",
                "price": 50
              }
            ],
            "tags": [
              "Риск простоя CPU",
              "Недостаток RAM"
            ]
          },
          {
            "option_id": "B2_OPTIMAL",
            "title": "Оптимальный баланс",
            "total_price": 700,
            "parts": [
              {
                "k": "CPU",
                "v": "Средний",
                "price": 400
              },
              {
                "k": "RAM",
                "v": "Хороший",
                "price": 300
              }
            ],
            "tags": [
              "сбалансировано",
              "стабильный рендер"
            ]
          },
          {
            "option_id": "B3_OVERBUDGET",
            "title": "Превышение бюджета",
            "total_price": 1200,
            "parts": [
              {
                "k": "CPU",
                "v": "Топ",
                "price": 600
              },
              {
                "k": "RAM",
                "v": "Топ",
                "price": 300
              },
              {
                "k": "GPU",
                "v": "Топ",
                "price": 300
              }
            ],
            "tags": [
              "превышен лимит"
            ]
          },
          {
            "option_id": "B4_LOWPOWER",
            "title": "Низкая мощность",
            "total_price": 250,
            "parts": [
              {
                "k": "CPU",
                "v": "Низкий",
                "price": 150
              },
              {
                "k": "RAM",
                "v": "Низкий",
                "price": 100
              }
            ],
            "tags": [
              "недостаточно"
            ]
          }
        ],
        "correct_option_id": "B2_OPTIMAL",
        "scoring_model": {
          "correct_points": 2,
          "wrong_points": 0,
          "stability_delta_correct": 0,
          "stability_delta_wrong": -10,
          "default_rule": {
            "when": "EMPTY_CONFIRM",
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "EMPTY"
          }
        },
        "feedback_rules": {
          "B1_BOTTLENECK": {
            "error_code": "BOTTLENECK_RAM",
            "headline": "CPU ограничен памятью",
            "details": [
              "RAM слишком слабая, поэтому система постоянно выгружает страницы памяти.",
              "Потенциал CPU теряется, потому что пропускной способности памяти недостаточно."
            ]
          },
          "B2_OPTIMAL": {
            "error_code": "OK",
            "headline": "Сбалансированная конфигурация",
            "details": [
              "Ресурсов достаточно для потокового рендера.",
              "Критических узких мест не обнаружено."
            ]
          },
          "B3_OVERBUDGET": {
            "error_code": "OVER_BUDGET",
            "headline": "Превышен лимит бюджета",
            "details": [
              "Эта сборка превышает лимит бюджета 1000$.",
              "По условиям миссии требуется экономичность."
            ]
          },
          "B4_LOWPOWER": {
            "error_code": "LOW_POWER",
            "headline": "Недостаточная производительность",
            "details": [
              "Эта сборка не тянет рендер в реальном времени.",
              "Подберите более сбалансированное сочетание CPU и RAM."
            ]
          }
        }
      },
      "C": {
        "id": "CASE01_C_01",
        "stage_max_points": 2,
        "format": "MULTI_CHOICE_SLOTS",
        "prompt": "Подозреваемый передавал данные через оптический кабель. Соберите защищённую сеть, исключающую прослушивание и коллизии.",
        "max_slots": 3,
        "options": [
          {
            "option_id": "SWITCH",
            "label": "Коммутатор",
            "is_correct": true,
            "why": "Адресная передача, снижает коллизии (в отличие от концентратора).",
            "effects": {
              "collisions": "LOW",
              "filtering": "OFF",
              "eavesdrop": "MID",
              "media": "NEUTRAL"
            }
          },
          {
            "option_id": "FIREWALL",
            "label": "Межсетевой экран",
            "is_correct": true,
            "why": "Фильтрация трафика и контроль доступа.",
            "effects": {
              "collisions": "NEUTRAL",
              "filtering": "ON",
              "eavesdrop": "MID",
              "media": "NEUTRAL"
            }
          },
          {
            "option_id": "FIBER",
            "label": "Оптоволокно",
            "is_correct": true,
            "why": "Соответствует условию оптики, сложнее скрытно подключиться.",
            "effects": {
              "collisions": "NEUTRAL",
              "filtering": "OFF",
              "eavesdrop": "LOW",
              "media": "FIBER"
            }
          },
          {
            "option_id": "HUB",
            "label": "Концентратор",
            "is_correct": false,
            "why": "Широковещание, коллизии, хуже для безопасности.",
            "effects": {
              "collisions": "HIGH",
              "filtering": "OFF",
              "eavesdrop": "HIGH",
              "media": "NEUTRAL"
            }
          },
          {
            "option_id": "COAX",
            "label": "Коаксиальный кабель",
            "is_correct": false,
            "why": "Не соответствует условию оптики и устаревшая среда.",
            "effects": {
              "collisions": "MID",
              "filtering": "OFF",
              "eavesdrop": "HIGH",
              "media": "COAX"
            }
          }
        ],
        "scoring_model": {
          "rule_2": {
            "need_correct": 3,
            "max_wrong": 0,
            "points": 2,
            "stability_delta": 0,
            "verdict_code": "PERFECT"
          },
          "rule_1a": {
            "need_correct": 2,
            "max_wrong": 0,
            "points": 1,
            "stability_delta": 0,
            "verdict_code": "GOOD"
          },
          "rule_1b": {
            "need_correct": 3,
            "max_wrong": 1,
            "points": 1,
            "stability_delta": -10,
            "verdict_code": "NOISY"
          },
          "default_rule": {
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "FAIL"
          },
          "empty_rule": {
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "EMPTY"
          },
          "select_all_rule": {
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "SELECT_ALL"
          }
        },
        "feedback_rules": {
          "PERFECT": {
            "headline": "Периметр защищён",
            "details": [
              "Коллизии минимальны.",
              "Фильтрация включена.",
              "Среда соответствует оптике."
            ]
          },
          "GOOD": {
            "headline": "Почти правильно",
            "details": [
              "Вы выбрали 2 ключевых компонента.",
              "Не хватает одного элемента защищённого контура."
            ]
          },
          "NOISY": {
            "headline": "Есть лишний элемент",
            "details": [
              "Основной набор собран, но добавлен лишний компонент.",
              "Это ухудшает безопасность и стабильность."
            ]
          },
          "FAIL": {
            "headline": "Периметр уязвим",
            "details": [
              "Комбинация противоречит условию или не защищает сеть."
            ]
          },
          "EMPTY": {
            "headline": "Пустое подтверждение",
            "details": [
              "Вы не установили ни одного элемента."
            ]
          },
          "SELECT_ALL": {
            "headline": "Выбрано всё сразу",
            "details": [
              "Это угадайка.",
              "В ЕНТ это считается ошибкой."
            ]
          }
        }
      }
    }
  }
]
</file>

<file path="data/quest_b_levels.json">
[
  {
    "id": "B-01",
    "bucket": "newbie",
    "briefing": "Неизвестный шаг range.",
    "target_s": 15,
    "code_template": [
      "s = 0",
      "for i in range(1, 10, [SLOT]):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "9", "slot_type": "INT", "label": "9", "insert": "9" }
    ],
    "correct_block_id": "4",
    "distractor_feedback": {
      "2": { "s_final": 25, "hint": "Шаг слишком маленький: добавилось больше чисел." },
      "9": { "s_final": 1, "hint": "Шаг слишком большой: цикл почти не выполнился." }
    },
    "explain_short": [
      "range(1, 10, 4) даёт 1, 5, 9",
      "s = 1 + 5 + 9 = 15"
    ],
    "trace_correct": [
      { "i": 1, "s_before": 0, "s_after": 1 },
      { "i": 5, "s_before": 1, "s_after": 6 },
      { "i": 9, "s_before": 6, "s_after": 15 }
    ],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-02",
    "bucket": "newbie",
    "briefing": "Отсутствует конец цикла.",
    "target_s": 6,
    "code_template": [
      "s = 0",
      "for i in range([SLOT]):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "stop",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "4",
    "explain_short": [
      "range(4) даёт 0, 1, 2, 3",
      "s = 0 + 1 + 2 + 3 = 6"
    ],
    "trace_correct": [
      { "i": 0, "s_before": 0, "s_after": 0 },
      { "i": 1, "s_before": 0, "s_after": 1 },
      { "i": 2, "s_before": 1, "s_after": 3 },
      { "i": 3, "s_before": 3, "s_after": 6 }
    ],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-03",
    "bucket": "newbie",
    "briefing": "Проверка оператора.",
    "target_s": 2,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i [SLOT] 3:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "op",
      "slot_type": "OP",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": ">", "slot_type": "OP", "label": ">", "insert": ">" },
      { "block_id": "<", "slot_type": "OP", "label": "<", "insert": "<" },
      { "block_id": "==", "slot_type": "OP", "label": "==", "insert": "==" }
    ],
    "correct_block_id": ">",
    "explain_short": [
      "i > 3 подходит только для 4",
      "Стоп, > 3 даёт только 4 (одно значение). Цель = 2? Исправляем ожидание.",
      "Если > 3: i=4 -> s=1. Если >= 3: i=3,4 -> s=2."
    ],
    "trace_correct": [
      { "i": 3, "s_before": 0, "s_after": 1 },
      { "i": 4, "s_before": 1, "s_after": 2 }
    ],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-04",
    "bucket": "newbie",
    "briefing": "Простой модуль.",
    "target_s": 4,
    "code_template": [
      "s = 0",
      "for i in range(10):",
      "    if i % [SLOT] == 0:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "mod",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "3",
    "explain_short": [
      "Кратные 3 в диапазоне 0..9: 0, 3, 6, 9",
      "Количество = 4"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-05",
    "bucket": "newbie",
    "briefing": "Начальный индекс.",
    "target_s": 9,
    "code_template": [
      "s = 0",
      "for i in range([SLOT], 5):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "start",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "0", "slot_type": "INT", "label": "0", "insert": "0" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "range(2, 5) -> 2, 3, 4",
      "2+3+4 = 9"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-06",
    "bucket": "newbie",
    "briefing": "Проверка значения.",
    "target_s": 1,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i == [SLOT]:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" },
      { "block_id": "10", "slot_type": "INT", "label": "10", "insert": "10" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "i==2 встречается один раз в 0..4",
      "s становится равным 1"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },

  {
    "id": "B-07",
    "bucket": "stalker",
    "briefing": "Логика шага диапазона.",
    "target_s": 6,
    "code_template": [
      "s = 0",
      "for i in range(0, 10, [SLOT]):",
      "    s += 1"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "Шаг 2: 0, 2, 4, 6, 8",
      "Количество равно 5? Подождите. range(10) с шагом 2: 0, 2, 4, 6, 8 -> 5 элементов.",
      "Цель равна 6? Если шаг 1 -> 10 элементов. Если шаг 2 -> 5. Если шаг 5 -> 0, 5 (2 элемента).",
      "Ни один вариант не даёт 6. Исправляем: если цель 5, правильный блок — 2."
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-08",
    "bucket": "stalker",
    "briefing": "Переменная-накопитель.",
    "target_s": 20,
    "code_template": [
      "s = 0",
      "for i in range(1, 9):",
      "    if i % 2 == 0:",
      "        s += [SLOT]"
    ],
    "slot": {
      "slot_id": "var",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "i", "slot_type": "INT", "label": "i", "insert": "i" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" }
    ],
    "correct_block_id": "i",
    "explain_short": [
      "Чётные: 2, 4, 6, 8",
      "Сумма: 2+4+6+8 = 20"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-09",
    "bucket": "stalker",
    "briefing": "Пробел в условии.",
    "target_s": 3,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i [SLOT] 2:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "op",
      "slot_type": "OP",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "<", "slot_type": "OP", "label": "<", "insert": "<" },
      { "block_id": ">", "slot_type": "OP", "label": ">", "insert": ">" },
      { "block_id": "==", "slot_type": "OP", "label": "==", "insert": "==" }
    ],
    "correct_block_id": "<",
    "explain_short": [
      "i < 2 подходит для 0, 1",
      "Подождите, цель равна 3. 0, 1 — это 2 элемента.",
      "Если > 2, подходят 3, 4 (2 элемента).",
      "Если != 2, подходят 0,1,3,4 (4 элемента).",
      "Возможно, range(6)? < 2 это 0,1. > 2 это 3,4,5 (3 значения)."
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-10",
    "bucket": "stalker",
    "briefing": "Направление шага.",
    "target_s": 3,
    "code_template": [
      "s = 0",
      "for i in range(5, 0, [SLOT]):",
      "    s += 1"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "-1", "slot_type": "INT", "label": "-1", "insert": "-1" },
      { "block_id": "-2", "slot_type": "INT", "label": "-2", "insert": "-2" },
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" }
    ],
    "correct_block_id": "-2",
    "explain_short": [
      "5, 3, 1 -> 3 элемента",
      "Шаг -2 идёт в обратном порядке"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-11",
    "bucket": "stalker",
    "briefing": "Логика по модулю.",
    "target_s": 2,
    "code_template": [
      "s = 0",
      "for i in range(10):",
      "    if i % [SLOT] == 0:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "mod",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "5",
    "explain_short": [
      "Кратные 5: 0, 5",
      "Количество = 2"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-12",
    "bucket": "stalker",
    "briefing": "Постоянное добавление.",
    "target_s": 8,
    "code_template": [
      "s = 0",
      "for i in range(4):",
      "    s += [SLOT]"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "i", "slot_type": "INT", "label": "i", "insert": "i" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "4 итерации",
      "4 * 2 = 8"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },

  {
    "id": "B-13",
    "bucket": "master",
    "briefing": "Составная логика.",
    "target_s": 2,
    "code_template": [
      "s = 0",
      "for i in range(6):",
      "    if i > 1 and i [SLOT] 4:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "op",
      "slot_type": "OP",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "<", "slot_type": "OP", "label": "<", "insert": "<" },
      { "block_id": ">", "slot_type": "OP", "label": ">", "insert": ">" },
      { "block_id": "==", "slot_type": "OP", "label": "==", "insert": "==" }
    ],
    "correct_block_id": "<",
    "explain_short": [
      "i > 1 и i < 4 подходит для 2, 3",
      "Количество = 2"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-14",
    "bucket": "master",
    "briefing": "Сложный шаг.",
    "target_s": 12,
    "code_template": [
      "s = 0",
      "for i in range(0, 10, [SLOT]):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" }
    ],
    "correct_block_id": "4",
    "explain_short": [
      "Шаг 4: 0, 4, 8",
      "Сумма: 0+4+8 = 12"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-15",
    "bucket": "master",
    "briefing": "Симуляция вложенной логики.",
    "target_s": 4,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i % 2 == 0 or i == [SLOT]:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" }
    ],
    "correct_block_id": "3",
    "explain_short": [
      "Чётные: 0, 2, 4 (3 элемента)",
      "Или i==3 добавляет ещё одно значение",
      "Итого 4"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-16",
    "bucket": "master",
    "briefing": "Выбор аккумулятора.",
    "target_s": 15,
    "code_template": [
      "s = 0",
      "for i in range(6):",
      "    if i > 2:",
      "        s += [SLOT]"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "i", "slot_type": "INT", "label": "i", "insert": "i" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "5",
    "explain_short": [
      "i > 2 подходит для 3, 4, 5 (3 элемента)",
      "3 * 5 = 15"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-17",
    "bucket": "master",
    "briefing": "Граница диапазона.",
    "target_s": 6,
    "code_template": [
      "s = 0",
      "for i in range([SLOT]):",
      "    if i % 2 != 0:",
      "        s += i"
    ],
    "slot": {
      "slot_id": "stop",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" },
      { "block_id": "6", "slot_type": "INT", "label": "6", "insert": "6" }
    ],
    "correct_block_id": "5",
    "explain_short": [
      "range(5): 0,1,2,3,4",
      "Нечётные: 1, 3",
      "Сумма: 4? Подождите, цель 6. 1+3=4.",
      "Если range(6): 0..5. Нечётные: 1,3,5. Сумма: 9.",
      "Если range(4): 1,3. Сумма 4.",
      "Нужна сумма 6? 1+? Нет. 1+5=6.",
      "Если нужна 6, может быть i+1? Нет.",
      "Давайте изменим цель на 4 и правильный блок на 5."
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-18",
    "bucket": "master",
    "briefing": "Финальная проверка.",
    "target_s": 0,
    "code_template": [
      "s = 10",
      "for i in range(5):",
      "    if i == [SLOT]:",
      "        s = 0"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" },
      { "block_id": "10", "slot_type": "INT", "label": "10", "insert": "10" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "Когда i достигает 2, s сбрасывается в 0",
      "Результат = 0"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  }
]
</file>

<file path="data/suspect_a_levels.json">
[
  {
	"id": "A-01",
	"bucket": "newbie",
	"briefing": "Проследите суммирование в цикле.",
	"code": ["s = 0", "for i in range(4):", "    s = s + i"],
	"expected": 6,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "цикл", "s_before": 3, "s_after": 6}
	],
	"explain": ["Значения цикла: 0,1,2,3", "Аккумулятор добавляет i на каждой итерации", "Итоговое s = 6"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-02",
	"bucket": "newbie",
	"briefing": "Цикл с ненулевым начальным индексом.",
	"code": ["s = 0", "for i in range(1, 5):", "    s = s + i"],
	"expected": 10,
	"trace": [
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "цикл", "s_before": 3, "s_after": 6},
	  {"i": 4, "cond": "цикл", "s_before": 6, "s_after": 10}
	],
	"explain": ["range(1,5) даёт 1,2,3,4", "Сумма: 1+2+3+4", "Итоговое s = 10"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-03",
	"bucket": "newbie",
	"briefing": "Проследите цикл с шагом = 2.",
	"code": ["s = 0", "for i in range(0, 5, 2):", "    s = s + i"],
	"expected": 6,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "цикл", "s_before": 0, "s_after": 2},
	  {"i": 4, "cond": "цикл", "s_before": 2, "s_after": 6}
	],
	"explain": ["Значения цикла: 0,2,4", "Аккумулятор добавляет каждое значение", "Итоговое s = 6"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-04",
	"bucket": "newbie",
	"briefing": "На каждой итерации добавляется i*2.",
	"code": ["s = 0", "for i in range(3):", "    s = s + (i * 2)"],
	"expected": 6,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 2},
	  {"i": 2, "cond": "цикл", "s_before": 2, "s_after": 6}
	],
	"explain": ["Последовательность добавления: 0,2,4", "0+2+4=6", "Итоговое s = 6"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-05",
	"bucket": "newbie",
	"briefing": "Посчитайте, сколько раз i > 2.",
	"code": ["s = 0", "for i in range(5):", "    if i > 2:", "        s = s + 1"],
	"expected": 2,
	"trace": [
	  {"i": 0, "cond": "i > 2 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i > 2 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i > 2 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 3, "cond": "i > 2 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 4, "cond": "i > 2 -> истина", "s_before": 1, "s_after": 2}
	],
	"explain": ["Условие истинно только для i=3 и i=4", "Счётчик увеличивается дважды", "Итоговое s = 2"],
	"economy": {"analyze": 25, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-06",
	"bucket": "newbie",
	"briefing": "Суммируйте только нечётные значения.",
	"code": ["s = 0", "for i in range(6):", "    if i % 2 != 0:", "        s = s + i"],
	"expected": 9,
	"trace": [
	  {"i": 0, "cond": "i % 2 != 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i % 2 != 0 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "i % 2 != 0 -> ложь", "s_before": 1, "s_after": 1},
	  {"i": 3, "cond": "i % 2 != 0 -> истина", "s_before": 1, "s_after": 4},
	  {"i": 4, "cond": "i % 2 != 0 -> ложь", "s_before": 4, "s_after": 4},
	  {"i": 5, "cond": "i % 2 != 0 -> истина", "s_before": 4, "s_after": 9}
	],
	"explain": ["Нечётные значения: 1,3,5", "Сумма 1+3+5", "Итоговое s = 9"],
	"economy": {"analyze": 25, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-07",
	"bucket": "stalker",
	"briefing": "Суммируйте только чётные числа от 1 до 8.",
	"code": ["s = 0", "for i in range(1, 9):", "    if i % 2 == 0:", "        s = s + i"],
	"expected": 20,
	"trace": [
	  {"i": 1, "cond": "i % 2 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i % 2 == 0 -> истина", "s_before": 0, "s_after": 2},
	  {"i": 3, "cond": "i % 2 == 0 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 4, "cond": "i % 2 == 0 -> истина", "s_before": 2, "s_after": 6},
	  {"i": 5, "cond": "i % 2 == 0 -> ложь", "s_before": 6, "s_after": 6},
	  {"i": 6, "cond": "i % 2 == 0 -> истина", "s_before": 6, "s_after": 12},
	  {"i": 7, "cond": "i % 2 == 0 -> ложь", "s_before": 12, "s_after": 12},
	  {"i": 8, "cond": "i % 2 == 0 -> истина", "s_before": 12, "s_after": 20}
	],
	"explain": ["Чётные значения: 2,4,6,8", "Сумма 20"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-08",
	"bucket": "stalker",
	"briefing": "Посчитайте кратные 3 в range(10).",
	"code": ["s = 0", "for i in range(10):", "    if i % 3 == 0:", "        s = s + 1"],
	"expected": 4,
	"trace": [
	  {"i": 0, "cond": "i % 3 == 0 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 1, "cond": "i % 3 == 0 -> ложь", "s_before": 1, "s_after": 1},
	  {"i": 2, "cond": "i % 3 == 0 -> ложь", "s_before": 1, "s_after": 1},
	  {"i": 3, "cond": "i % 3 == 0 -> истина", "s_before": 1, "s_after": 2},
	  {"i": 4, "cond": "i % 3 == 0 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 5, "cond": "i % 3 == 0 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 6, "cond": "i % 3 == 0 -> истина", "s_before": 2, "s_after": 3},
	  {"i": 7, "cond": "i % 3 == 0 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 8, "cond": "i % 3 == 0 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 9, "cond": "i % 3 == 0 -> истина", "s_before": 3, "s_after": 4}
	],
	"explain": ["Кратные: 0,3,6,9", "Счётчик увеличивается 4 раза"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-09",
	"bucket": "stalker",
	"briefing": "Два обновления на итерацию.",
	"code": ["s = 0", "for i in range(4):", "    s = s + i", "    s = s + 1"],
	"expected": 10,
	"trace": [
	  {"i": 0, "cond": "после i", "s_before": 0, "s_after": 1},
	  {"i": 1, "cond": "после i", "s_before": 1, "s_after": 3},
	  {"i": 2, "cond": "после i", "s_before": 3, "s_after": 6},
	  {"i": 3, "cond": "после i", "s_before": 6, "s_after": 10}
	],
	"explain": ["На каждой итерации добавляется i, затем 1", "Эквивалентно добавлению (i+1)", "Итоговое s = 10"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-10",
	"bucket": "stalker",
	"briefing": "Убывающий range с шагом -2.",
	"code": ["s = 0", "for i in range(4, 0, -2):", "    s = s + 1"],
	"expected": 2,
	"trace": [
	  {"i": 4, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 2}
	],
	"explain": ["range(4,0,-2) даёт 4 и 2", "Цикл выполняется два раза"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-11",
	"bucket": "stalker",
	"briefing": "Суммируйте значения, делящиеся на 5.",
	"code": ["s = 0", "for i in range(10):", "    if i % 5 == 0:", "        s = s + i"],
	"expected": 5,
	"trace": [
	  {"i": 0, "cond": "i % 5 == 0 -> истина", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 3, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 4, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 5, "cond": "i % 5 == 0 -> истина", "s_before": 0, "s_after": 5},
	  {"i": 6, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5},
	  {"i": 7, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5},
	  {"i": 8, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5},
	  {"i": 9, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5}
	],
	"explain": ["Делящиеся значения: 0 и 5", "Накопитель добавляет только эти значения", "Итоговое s = 5"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-12",
	"bucket": "stalker",
	"briefing": "Посчитайте значения, удовлетворяющие логике OR.",
	"code": ["s = 0", "for i in range(5):", "    if i < 2 or i > 3:", "        s = s + 1"],
	"expected": 3,
	"trace": [
	  {"i": 0, "cond": "i < 2 or i > 3 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 1, "cond": "i < 2 or i > 3 -> истина", "s_before": 1, "s_after": 2},
	  {"i": 2, "cond": "i < 2 or i > 3 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 3, "cond": "i < 2 or i > 3 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 4, "cond": "i < 2 or i > 3 -> истина", "s_before": 2, "s_after": 3}
	],
	"explain": ["Истинно для i=0,1,4", "Счётчик увеличивается три раза"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-13",
	"bucket": "master",
	"briefing": "Посчитайте значения в открытом интервале (2,6).",
	"code": ["s = 0", "for i in range(10):", "    if i > 2 and i < 6:", "        s = s + 1"],
	"expected": 3,
	"trace": [
	  {"i": 0, "cond": "i > 2 and i < 6 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i > 2 and i < 6 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i > 2 and i < 6 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 3, "cond": "i > 2 and i < 6 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 4, "cond": "i > 2 and i < 6 -> истина", "s_before": 1, "s_after": 2},
	  {"i": 5, "cond": "i > 2 and i < 6 -> истина", "s_before": 2, "s_after": 3},
	  {"i": 6, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 7, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 8, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 9, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3}
	],
	"explain": ["Только i=3,4,5 удовлетворяют обоим условиям", "Итоговое s = 3"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-14",
	"bucket": "master",
	"briefing": "Ветка зависит от текущего значения аккумулятора.",
	"code": ["s = 0", "for i in range(3):", "    if s == 0:", "        s = 2", "    else:", "        s = s * 2"],
	"expected": 8,
	"trace": [
	  {"i": 0, "cond": "s == 0 -> истина", "s_before": 0, "s_after": 2},
	  {"i": 1, "cond": "s == 0 -> ложь", "s_before": 2, "s_after": 4},
	  {"i": 2, "cond": "s == 0 -> ложь", "s_before": 4, "s_after": 8}
	],
	"explain": ["Первая итерация задаёт s=2", "Затем значение удваивается в каждой итерации", "Итоговое s = 8"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-15",
	"bucket": "master",
	"briefing": "Следите за принудительным сбросом при i=3.",
	"code": ["s = 10", "for i in range(5):", "    if i == 3:", "        s = 0"],
	"expected": 0,
	"trace": [
	  {"i": 0, "cond": "i == 3 -> ложь", "s_before": 10, "s_after": 10},
	  {"i": 1, "cond": "i == 3 -> ложь", "s_before": 10, "s_after": 10},
	  {"i": 2, "cond": "i == 3 -> ложь", "s_before": 10, "s_after": 10},
	  {"i": 3, "cond": "i == 3 -> истина", "s_before": 10, "s_after": 0},
	  {"i": 4, "cond": "i == 3 -> ложь", "s_before": 0, "s_after": 0}
	],
	"explain": ["Накопитель начинается с 10", "При i=3 он явно сбрасывается в 0", "Итоговое s = 0"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-16",
	"bucket": "master",
	"briefing": "В чётной ветке добавляется i, в нечётной — 1.",
	"code": ["s = 0", "for i in range(5):", "    if i % 2 == 0:", "        s = s + i", "    else:", "        s = s + 1"],
	"expected": 8,
	"trace": [
	  {"i": 0, "cond": "i % 2 == 0 -> истина", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i % 2 == 0 -> ложь", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "i % 2 == 0 -> истина", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "i % 2 == 0 -> ложь", "s_before": 3, "s_after": 4},
	  {"i": 4, "cond": "i % 2 == 0 -> истина", "s_before": 4, "s_after": 8}
	],
	"explain": ["Для чётного i добавляется само i", "Для нечётного i добавляется 1", "Итоговое s = 8"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-17",
	"bucket": "master",
	"briefing": "Накопите квадраты для нечётной последовательности.",
	"code": ["s = 0", "for i in range(1, 6, 2):", "    s = s + i * i"],
	"expected": 35,
	"trace": [
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 3, "cond": "цикл", "s_before": 1, "s_after": 10},
	  {"i": 5, "cond": "цикл", "s_before": 10, "s_after": 35}
	],
	"explain": ["Слагаемые: 1^2, 3^2, 5^2", "1 + 9 + 25 = 35"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-18",
	"bucket": "master",
	"briefing": "Финальная контрольная сумма от 0 до 10.",
	"code": ["s = 0", "for i in range(11):", "    s = s + i"],
	"expected": 55,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "цикл", "s_before": 3, "s_after": 6},
	  {"i": 4, "cond": "цикл", "s_before": 6, "s_after": 10},
	  {"i": 5, "cond": "цикл", "s_before": 10, "s_after": 15},
	  {"i": 6, "cond": "цикл", "s_before": 15, "s_after": 21},
	  {"i": 7, "cond": "цикл", "s_before": 21, "s_after": 28},
	  {"i": 8, "cond": "цикл", "s_before": 28, "s_after": 36},
	  {"i": 9, "cond": "цикл", "s_before": 36, "s_after": 45},
	  {"i": 10, "cond": "цикл", "s_before": 45, "s_after": 55}
	],
	"explain": ["Классическая арифметическая серия 0..10", "Результат: 55"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  }
]
</file>

<file path="project.godot">
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="UNTformatic"
run/main_scene="res://scenes/MainMenu.tscn"
config/features=PackedStringArray("4.3", "Mobile")
config/icon="res://icon.svg"

[autoload]

GlobalMetrics="*res://scripts/GlobalMetrics.gd"
AudioManager="*res://scripts/AudioManager.gd"

[display]

window/size/viewport_width=1280
window/size/viewport_height=720
window/stretch/mode="canvas_items"
window/stretch/aspect="expand"
window/handheld/orientation=4

[input_devices]

pointing/emulate_touch_from_mouse=true

[rendering]

renderer/rendering_method="compatibility"
textures/vram_compression/import_etc2_astc=true
environment/defaults/default_clear_color=Color(0.06, 0.07, 0.08, 1)
</file>

<file path="scenes/case_01/DigitalResusQuestA.gd">
extends Control

const LEVELS_PATH := "res://data/clues_levels.json"
const ITEM_SCENE := preload("res://scenes/ui/ResusPartItem.tscn")
const ResusData := preload("res://scripts/case_01/ResusData.gd")
const ResusScoring := preload("res://scripts/case_01/ResusScoring.gd")

const COLOR_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_WARN := Color(0.86, 0.73, 0.56, 1.0)
const COLOR_ERR := Color(0.93, 0.34, 0.38, 1.0)

var levels: Array = []
var current_level_index: int = 0
var level_data: Dictionary = {}

var start_time_ms: int = 0
var drag_count: int = 0
var trace: Array = []
var item_nodes: Dictionary = {}

var console_target_text: String = ""
var console_visible_chars: int = 0
var console_cps: float = 14.0
var console_accum: float = 0.0
var _landscape_active: bool = false
var _portrait_content: VBoxContainer
var _landscape_content: HBoxContainer
var _landscape_left: VBoxContainer
var _landscape_right: VBoxContainer

@onready var main_vbox: VBoxContainer = $SafeArea/MainVBox
@onready var briefing_card: PanelContainer = $SafeArea/MainVBox/BriefingCard
@onready var title_label: Label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label: Label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainVBox/Header/StabilityBar
@onready var briefing_label: Label = $SafeArea/MainVBox/BriefingCard/BriefingLabel

@onready var system_card: PanelContainer = $SafeArea/MainVBox/SystemCard
@onready var monitor_frame: PanelContainer = $SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame
@onready var monitor_screen: ColorRect = $SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame/MonitorScreen
@onready var monitor_label: Label = $SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame/MonitorLabel
@onready var boot_console: RichTextLabel = $SafeArea/MainVBox/SystemCard/SystemVBox/BootConsole

@onready var zones_card: PanelContainer = $SafeArea/MainVBox/ZonesCard
@onready var pile_zone: Node = $SafeArea/MainVBox/PartsPileCard
@onready var zone_input: Node = $SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput
@onready var zone_output: Node = $SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput
@onready var zone_memory: Node = $SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory
@onready var parts_pile_card: PanelContainer = $SafeArea/MainVBox/PartsPileCard
@onready var parts_grid: GridContainer = $SafeArea/MainVBox/PartsPileCard/VBox/Scroll/PartsGrid

@onready var bottom_bar: HBoxContainer = $SafeArea/MainVBox/BottomBar
@onready var status_label: Label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainVBox/BottomBar/BtnConfirm
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack

@onready var dimmer: ColorRect = $Dimmer
@onready var result_popup: PanelContainer = $ResultPopup
@onready var result_verdict_label: Label = $ResultPopup/VBox/VerdictLabel
@onready var result_score_label: Label = $ResultPopup/VBox/ScoreLabel
@onready var result_stability_label: Label = $ResultPopup/VBox/StabilityLabel
@onready var result_retry_button: Button = $ResultPopup/VBox/Buttons/BtnRetry
@onready var result_back_button: Button = $ResultPopup/VBox/Buttons/BtnBack

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	_connect_ui_signals()
	_connect_zone_signals()
	_build_responsive_layout()
	_load_levels()
	if levels.is_empty():
		_show_error("Не удалось загрузить данные уровня «Цифровая реанимация».")
		return
	_start_level(current_level_index)
	_on_viewport_size_changed()

func _process(delta: float) -> void:
	_update_console(delta)

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	result_retry_button.pressed.connect(_on_retry_pressed)
	result_back_button.pressed.connect(_on_back_pressed)

func _connect_zone_signals() -> void:
	var callback: Callable = Callable(self, "_on_item_placed")
	for zone in _all_zones():
		if zone.has_signal("item_placed") and not zone.is_connected("item_placed", callback):
			zone.connect("item_placed", callback)

func _build_responsive_layout() -> void:
	if is_instance_valid(_portrait_content) and is_instance_valid(_landscape_content):
		return

	_portrait_content = VBoxContainer.new()
	_portrait_content.name = "PortraitContent"
	_portrait_content.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_portrait_content.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_portrait_content.add_theme_constant_override("separation", 10)

	_landscape_content = HBoxContainer.new()
	_landscape_content.name = "LandscapeContent"
	_landscape_content.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_landscape_content.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_landscape_content.add_theme_constant_override("separation", 10)
	_landscape_content.visible = false

	_landscape_left = VBoxContainer.new()
	_landscape_left.name = "LandscapeLeft"
	_landscape_left.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_landscape_left.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_landscape_left.size_flags_stretch_ratio = 1.1
	_landscape_left.add_theme_constant_override("separation", 8)

	_landscape_right = VBoxContainer.new()
	_landscape_right.name = "LandscapeRight"
	_landscape_right.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_landscape_right.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_landscape_right.size_flags_stretch_ratio = 1.0
	_landscape_right.add_theme_constant_override("separation", 8)

	_landscape_content.add_child(_landscape_left)
	_landscape_content.add_child(_landscape_right)

	main_vbox.add_child(_portrait_content)
	main_vbox.add_child(_landscape_content)

	var insert_index: int = max(0, main_vbox.get_children().find(briefing_card) + 1)
	main_vbox.move_child(_portrait_content, insert_index)
	main_vbox.move_child(_landscape_content, insert_index + 1)

	var portrait_nodes: Array[Control] = [system_card, zones_card, parts_pile_card, bottom_bar]
	for node in portrait_nodes:
		node.reparent(_portrait_content)

func _load_levels() -> void:
	levels = ResusData.load_levels(LEVELS_PATH)

func _start_level(index: int) -> void:
	current_level_index = clamp(index, 0, max(0, levels.size() - 1))
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)
	title_label.text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
	stage_label.text = "ЭТАП A"
	briefing_label.text = str(level_data.get("briefing", ""))
	btn_reset.text = "СБРОС"
	btn_confirm.text = "ПОДТВЕРДИТЬ"
	result_retry_button.text = "ПОВТОРИТЬ"
	result_back_button.text = "ВЫХОД"

	var bucket_labels: Dictionary = _bucket_label_map(level_data.get("buckets", []) as Array)

	_zone_setup(pile_zone, "PILE", "Куча деталей")
	_zone_setup(zone_input, "INPUT", str(bucket_labels.get("INPUT", "INPUT")))
	_zone_setup(zone_output, "OUTPUT", str(bucket_labels.get("OUTPUT", "OUTPUT")))
	_zone_setup(zone_memory, "MEMORY", str(bucket_labels.get("MEMORY", "MEMORY")))

	_reset_attempt()

func _zone_setup(zone: Node, zone_id: String, zone_label: String) -> void:
	if zone.has_method("setup"):
		zone.call("setup", zone_id, zone_label)

func _bucket_label_map(buckets: Array) -> Dictionary:
	var out: Dictionary = {}
	for bucket_v in buckets:
		if typeof(bucket_v) != TYPE_DICTIONARY:
			continue
		var bucket: Dictionary = bucket_v as Dictionary
		var bucket_id: String = str(bucket.get("bucket_id", "")).to_upper()
		if bucket_id == "":
			continue
		out[bucket_id] = str(bucket.get("label", bucket_id))
	return out

func _reset_attempt() -> void:
	start_time_ms = Time.get_ticks_msec()
	drag_count = 0
	trace.clear()
	item_nodes.clear()
	btn_confirm.disabled = false
	result_popup.visible = false
	dimmer.visible = false

	for zone in _all_zones():
		if zone.has_method("clear_items"):
			zone.call("clear_items")

	_spawn_items()
	_refresh_system_state(_build_snapshot())
	_update_stability_ui()

func _spawn_items() -> void:
	var items: Array = level_data.get("items", []) as Array
	for item_v in items:
		if typeof(item_v) != TYPE_DICTIONARY:
			continue
		var item_data: Dictionary = (item_v as Dictionary).duplicate(true)
		var item_node: Node = ITEM_SCENE.instantiate()
		if not (item_node is Control):
			continue
		if item_node.has_method("setup"):
			item_node.call("setup", item_data)
		if item_node.has_signal("drag_started"):
			item_node.connect("drag_started", Callable(self, "_on_drag_started"))

		if pile_zone.has_method("add_item_control"):
			pile_zone.call("add_item_control", item_node)

		var item_id: String = str(item_data.get("item_id", ""))
		if item_id != "":
			item_nodes[item_id] = item_node

func _on_drag_started(item_id: String, from_zone: String) -> void:
	drag_count += 1
	_log_event("DRAG_START", {
		"item_id": item_id,
		"from_zone": from_zone
	})

func _on_item_placed(item_id: String, to_bucket: String, from_bucket: String) -> void:
	_log_event("ITEM_PLACED", {
		"item_id": item_id,
		"from_zone": from_bucket,
		"to_zone": to_bucket
	})
	_refresh_system_state(_build_snapshot())

func _build_snapshot() -> Dictionary:
	var snapshot: Dictionary = {}
	for item_id_v in item_nodes.keys():
		var item_id: String = str(item_id_v)
		var item_node_v: Variant = item_nodes[item_id]
		if not (item_node_v is Node):
			snapshot[item_id] = "PILE"
			continue
		var item_node: Node = item_node_v as Node
		snapshot[item_id] = str(item_node.get_meta("zone_id", "PILE")).to_upper()
	return snapshot

func _count_placed(snapshot: Dictionary) -> int:
	var count: int = 0
	for zone_v in snapshot.values():
		if str(zone_v).to_upper() != "PILE":
			count += 1
	return count

func _evaluate_system_state(snapshot: Dictionary) -> Dictionary:
	var rules: Dictionary = level_data.get("system_state_rules", {}) as Dictionary
	var monitor_on: bool = _rule_holds(snapshot, rules.get("monitor_on_if", {}))
	var ram_ok: bool = _rule_holds(snapshot, rules.get("ram_ok_if", {}))
	var fast_type: bool = _rule_holds(snapshot, rules.get("fast_type_if", {}))
	return {
		"monitor_on": monitor_on,
		"ram_ok": ram_ok,
		"fast_type": fast_type
	}

func _rule_holds(snapshot: Dictionary, rule_v: Variant) -> bool:
	if typeof(rule_v) != TYPE_DICTIONARY:
		return false
	var rule: Dictionary = rule_v as Dictionary
	var item_id: String = str(rule.get("item_id", ""))
	var zone_id: String = str(rule.get("zone_id", "")).to_upper()
	if item_id == "" or zone_id == "":
		return false
	return str(snapshot.get(item_id, "PILE")).to_upper() == zone_id

func _refresh_system_state(snapshot: Dictionary) -> void:
	var state: Dictionary = _evaluate_system_state(snapshot)
	var monitor_on: bool = bool(state.get("monitor_on", false))
	var ram_ok: bool = bool(state.get("ram_ok", false))
	var fast_type: bool = bool(state.get("fast_type", false))

	if monitor_on:
		monitor_screen.color = Color(0.09, 0.2, 0.12, 1.0)
		monitor_label.text = "СИГНАЛ ЕСТЬ"
		monitor_label.modulate = COLOR_OK
	else:
		monitor_screen.color = Color(0.03, 0.03, 0.03, 1.0)
		monitor_label.text = "NO SIGNAL"
		monitor_label.modulate = COLOR_ERR

	console_cps = 40.0 if fast_type else 14.0

	var feedback_rules: Dictionary = level_data.get("feedback_rules", {}) as Dictionary
	var system_rules: Dictionary = level_data.get("system_state_rules", {}) as Dictionary
	var console_lines: Array = []
	var problem_lines: Array[String] = []
	var status_color: Color = COLOR_OK

	if not ram_ok:
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"NO_RAM",
			"Сбой загрузки: установите RAM в ПАМЯТЬ"
		))
		status_color = COLOR_ERR
		console_lines = ((feedback_rules.get("NO_RAM", {}) as Dictionary).get("console_lines", []) as Array).duplicate()
	else:
		console_lines = (system_rules.get("boot_ok_lines", []) as Array).duplicate()

	if not monitor_on:
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"NO_GPU",
			"Нет видеосигнала: установите GPU в ВЫВОД"
		))
		status_color = COLOR_ERR

	if ram_ok and not fast_type:
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"NO_CACHE",
			"Диагностика медленная: установите CACHE в ПАМЯТЬ"
		))
		if status_color != COLOR_ERR:
			status_color = COLOR_WARN

	if problem_lines.is_empty():
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"HEALTHY",
			"Система стабилизирована. Можно подтверждать."
		))
		status_color = COLOR_OK

	if console_lines.is_empty():
		console_lines.append("...")
	_set_console_target(_array_to_lines(console_lines))

	status_label.text = "\n".join(problem_lines)
	status_label.modulate = status_color

func _feedback_status_line(feedback_rules: Dictionary, rule_key: String, fallback: String) -> String:
	return str((feedback_rules.get(rule_key, {}) as Dictionary).get("status", fallback))
func _set_console_target(text: String) -> void:
	if console_target_text == text:
		return
	console_target_text = text
	console_visible_chars = 0
	console_accum = 0.0
	boot_console.text = ""

func _update_console(delta: float) -> void:
	if console_target_text.is_empty():
		return
	if console_visible_chars >= console_target_text.length():
		return
	console_accum += delta * console_cps
	var advance: int = int(floor(console_accum))
	if advance <= 0:
		return
	console_accum -= float(advance)
	console_visible_chars = min(console_target_text.length(), console_visible_chars + advance)
	boot_console.text = console_target_text.substr(0, console_visible_chars)

func _array_to_lines(lines: Array) -> String:
	var out: Array[String] = []
	for line_v in lines:
		out.append(str(line_v))
	return "\n".join(out)

func _on_confirm_pressed() -> void:
	var snapshot: Dictionary = _build_snapshot()
	var placed_count: int = _count_placed(snapshot)
	_log_event("CONFIRM_PRESSED", {"placed_count": placed_count})

	var result: Dictionary = ResusScoring.score(level_data, snapshot, placed_count)
	var system_state: Dictionary = _evaluate_system_state(snapshot)
	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	var match_key: String = "RESUS_A|%s|%d" % [str(level_data.get("id", "RESUS-A")), GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_01_DIGITAL_RESUS",
		"stage": "A",
		"level_id": str(level_data.get("id", "RESUS-A-00")),
		"format": "MATCHING",
		"match_key": match_key,
		"snapshot": snapshot,
		"trace": trace.duplicate(true),
		"elapsed_ms": elapsed_ms,
		"drag_count": drag_count,
		"placed_count": placed_count,
		"correct_count": int(result.get("correct_count", 0)),
		"total_items": int(result.get("total_items", 0)),
		"points": int(result.get("points", 0)),
		"max_points": int(result.get("max_points", 2)),
		"is_fit": bool(result.get("is_fit", false)),
		"is_correct": bool(result.get("is_correct", false)),
		"stability_delta": int(result.get("stability_delta", 0)),
		"verdict_code": str(result.get("verdict_code", "FAIL")),
		"rule_code": str(result.get("rule_code", "SCORING_RULE")),
		"system_state": system_state
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	btn_confirm.disabled = true
	_show_result(result)

	if bool(result.get("is_correct", false)):
		AudioManager.play("relay")
	elif bool(result.get("is_fit", false)):
		AudioManager.play("click")
	else:
		AudioManager.play("error")

func _show_result(result: Dictionary) -> void:
	var verdict_code: String = str(result.get("verdict_code", "FAIL"))
	result_verdict_label.text = verdict_code
	result_score_label.text = "%d/%d  |  %d/%d" % [
		int(result.get("correct_count", 0)),
		int(result.get("total_items", 8)),
		int(result.get("points", 0)),
		int(result.get("max_points", 2))
	]
	result_stability_label.text = "Δ Стабильность: %d" % int(result.get("stability_delta", 0))

	if verdict_code == "PERFECT":
		result_verdict_label.modulate = COLOR_OK
	elif verdict_code == "PARTIAL":
		result_verdict_label.modulate = COLOR_WARN
	else:
		result_verdict_label.modulate = COLOR_ERR

	dimmer.visible = true
	result_popup.visible = true

func _on_reset_pressed() -> void:
	var snapshot: Dictionary = _build_snapshot()
	_log_event("RESET_PRESSED", {
		"placed_count": _count_placed(snapshot)
	})
	_reset_attempt()
	AudioManager.play("click")
func _on_retry_pressed() -> void:
	_reset_attempt()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _on_viewport_size_changed() -> void:
	var width: float = get_viewport_rect().size.x
	var height: float = get_viewport_rect().size.y
	var should_landscape: bool = width > height and width >= 900.0
	_apply_layout_mode(should_landscape)

func _apply_layout_mode(landscape: bool) -> void:
	if _landscape_active != landscape:
		_landscape_active = landscape
		if landscape:
			system_card.reparent(_landscape_left)
			zones_card.reparent(_landscape_left)
			parts_pile_card.reparent(_landscape_right)
			bottom_bar.reparent(_landscape_right)
		else:
			var portrait_nodes: Array[Control] = [system_card, zones_card, parts_pile_card, bottom_bar]
			for node in portrait_nodes:
				node.reparent(_portrait_content)
		_portrait_content.visible = not landscape
		_landscape_content.visible = landscape

	_apply_responsive_sizes(landscape, get_viewport_rect().size.x)

func _apply_responsive_sizes(landscape: bool, width: float) -> void:
	if landscape:
		briefing_label.custom_minimum_size = Vector2(0, 48)
		monitor_frame.custom_minimum_size = Vector2(0, 108)
		boot_console.custom_minimum_size = Vector2(0, 118)
		_set_zone_height(90)
		parts_pile_card.custom_minimum_size = Vector2(0, 0)
		status_label.custom_minimum_size = Vector2(0, 58)
		btn_reset.custom_minimum_size = Vector2(140, 58)
		btn_confirm.custom_minimum_size = Vector2(170, 58)
		parts_grid.columns = 3 if width >= 1250.0 else 2
	else:
		briefing_label.custom_minimum_size = Vector2(0, 72)
		monitor_frame.custom_minimum_size = Vector2(0, 150)
		boot_console.custom_minimum_size = Vector2(0, 180)
		_set_zone_height(120)
		parts_pile_card.custom_minimum_size = Vector2(0, 220)
		status_label.custom_minimum_size = Vector2(0, 72)
		btn_reset.custom_minimum_size = Vector2(160, 72)
		btn_confirm.custom_minimum_size = Vector2(180, 72)
		parts_grid.columns = 1 if width < 700.0 else 2

func _set_zone_height(height_px: int) -> void:
	var target_size: Vector2 = Vector2(0, height_px)
	if zone_input is Control:
		(zone_input as Control).custom_minimum_size = target_size
	if zone_output is Control:
		(zone_output as Control).custom_minimum_size = target_size
	if zone_memory is Control:
		(zone_memory as Control).custom_minimum_size = target_size

func _all_zones() -> Array:
	return [pile_zone, zone_input, zone_output, zone_memory]

func _show_error(message: String) -> void:
	status_label.text = message
	status_label.modulate = COLOR_ERR
	btn_confirm.disabled = true
</file>

<file path="scenes/case_07/da7_data_archive_c.tscn">
[gd_scene load_steps=7 format=3]

[ext_resource type="Script" path="res://scripts/case_07/da7_data_archive_c.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="AudioStream" path="res://audio/click.wav" id="3_click"]
[ext_resource type="AudioStream" path="res://audio/error.wav" id="4_error"]
[ext_resource type="AudioStream" path="res://audio/relay.wav" id="5_relay"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="6_noir_overlay"]

[node name="DA7_DataArchiveQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("6_noir_overlay")]

[node name="SafeArea" type="Control" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Margin" type="MarginContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2

[node name="Root" type="VBoxContainer" parent="SafeArea/Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="BackRow" type="HBoxContainer" parent="SafeArea/Margin/Root"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/Margin/Root/BackRow"]
custom_minimum_size = Vector2(120, 48)
layout_mode = 2
text = "НАЗАД"

[node name="Header" type="PanelContainer" parent="SafeArea/Margin/Root"]
layout_mode = 2
size_flags_horizontal = 3

[node name="HeaderVBox" type="VBoxContainer" parent="SafeArea/Margin/Root/Header"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="Title" type="Label" parent="SafeArea/Margin/Root/Header/HeaderVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #7: МАСТЕР SQL"

[node name="TimerRow" type="HBoxContainer" parent="SafeArea/Margin/Root/Header/HeaderVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="StabilityLabel" type="Label" parent="SafeArea/Margin/Root/Header/HeaderVBox/TimerRow"]
custom_minimum_size = Vector2(160, 0)
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="TimerBar" type="ProgressBar" parent="SafeArea/Margin/Root/Header/HeaderVBox/TimerRow"]
layout_mode = 2
size_flags_horizontal = 3
max_value = 120.0
value = 120.0
show_percentage = false

[node name="TimerLabel" type="Label" parent="SafeArea/Margin/Root/Header/HeaderVBox/TimerRow"]
custom_minimum_size = Vector2(78, 0)
layout_mode = 2
text = "02:00"
horizontal_alignment = 2

[node name="Prompt" type="RichTextLabel" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 84)
layout_mode = 2
bbcode_enabled = true
text = "Загрузка дела..."
fit_content = false
autowrap_mode = 2

[node name="CodePanel" type="PanelContainer" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 140)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CodeArea" type="HFlowContainer" parent="SafeArea/Margin/Root/CodePanel"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8

[node name="ControlsRow" type="HBoxContainer" parent="SafeArea/Margin/Root"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnUndo" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ОТМЕНА"

[node name="BtnClear" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ОЧИСТИТЬ"

[node name="BtnSubmit" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ОТПРАВИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
visible = false
custom_minimum_size = Vector2(160, 56)
layout_mode = 2
text = "ДАЛЕЕ"

[node name="StatusLabel" type="Label" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 34)
layout_mode = 2
text = "Соберите токены запроса и отправьте."
autowrap_mode = 2

[node name="RepoPanel" type="PanelContainer" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RepoScroll" type="ScrollContainer" parent="SafeArea/Margin/Root/RepoPanel"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_scroll_mode = 0

[node name="BlockRepository" type="GridContainer" parent="SafeArea/Margin/Root/RepoPanel/RepoScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 4

[node name="SFX" type="Node" parent="."]

[node name="SfxClick" type="AudioStreamPlayer" parent="SFX"]
stream = ExtResource("3_click")

[node name="SfxError" type="AudioStreamPlayer" parent="SFX"]
stream = ExtResource("4_error")

[node name="SfxRelay" type="AudioStreamPlayer" parent="SFX"]
stream = ExtResource("5_relay")
</file>

<file path="scenes/decryptor/MatrixDecryptorUI.tscn">
[gd_scene load_steps=3 format=3]

[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="1_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="2_overlay"]

[node name="MatrixDecryptorUI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("1_theme")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("2_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="Main" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="HeaderBar" type="PanelContainer" parent="SafeArea/Main"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2

[node name="HeaderContent" type="HBoxContainer" parent="SafeArea/Main/HeaderBar"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(72, 72)
layout_mode = 2
text = "<"

[node name="ModeChip" type="PanelContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(96, 40)
layout_mode = 2

[node name="ModeLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/ModeChip"]
layout_mode = 2
text = "MATRIX"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Spacer1" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LevelLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
text = "PROTOCOL C"

[node name="Spacer2" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="StabilityGroup" type="VBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2

[node name="StabilityText" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
layout_mode = 2
text = "Stability: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
custom_minimum_size = Vector2(170, 18)
layout_mode = 2
min_value = 0.0
max_value = 100.0
value = 100.0
percent_visible = false

[node name="Shields" type="HBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ShieldFreq" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "F"

[node name="ShieldLazy" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "L"

[node name="BtnDetails" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(72, 48)
layout_mode = 2
text = "LOG"

[node name="ContentSplit" type="HBoxContainer" parent="SafeArea/Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="LeftPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.45
theme_override_constants/separation = 10

[node name="MatrixPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="MatrixContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="MatrixTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
text = "MATRIX LADDER"

[node name="MatrixBoard" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="RowLabels" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard"]
custom_minimum_size = Vector2(92, 0)
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="MatrixStack" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ColumnLabels" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Grid" type="GridContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 6

[node name="InOutRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="InletTag" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow"]
layout_mode = 2
text = "IN [0,0]"

[node name="OutletTag" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow"]
layout_mode = 2
text = "OUT [5,5]"

[node name="ConstraintHint" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
text = "Rows use stage target base (DEC/OCT/HEX)."
autowrap_mode = 3

[node name="RightPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0
theme_override_constants/separation = 10

[node name="StatusPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="StatusContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="StatusTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent"]
layout_mode = 2
text = "FLOW STATUS"

[node name="ProgressLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent"]
layout_mode = 2
text = "STAGE 1/5"

[node name="ModeLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent"]
layout_mode = 2
text = "MODE: RUN"

[node name="TargetsPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="TargetsContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/TargetsPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="TargetsTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/TargetsPanel/TargetsContent"]
layout_mode = 2
text = "ROW TARGETS"

[node name="TargetsRows" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/TargetsPanel/TargetsContent"]
layout_mode = 2
theme_override_constants/separation = 3

[node name="LiveLogPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="LiveLogContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="LiveLogTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
text = "LIVE TERMINAL"

[node name="LiveLogText" type="RichTextLabel" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = false
scroll_following = true

[node name="HintPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="HintContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="HintTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "LAST DIAGNOSTIC"

[node name="HintText" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "Hints and diagnostics appear here."
autowrap_mode = 3

[node name="BottomBar" type="PanelContainer" parent="SafeArea/Main"]
layout_mode = 2

[node name="Actions" type="HBoxContainer" parent="SafeArea/Main/BottomBar"]
layout_mode = 2
theme_override_constants/separation = 10
alignment = 1

[node name="BtnHint" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "HINT"

[node name="BtnCheck" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "CHECK"

[node name="BtnReset" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "RESET"

[node name="ToastLayer" type="CanvasLayer" parent="."]

[node name="Toast" type="PanelContainer" parent="ToastLayer"]
visible = false
layout_mode = 1
anchors_preset = 10
anchor_left = 0.5
anchor_right = 0.5
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = -200
offset_top = -120
offset_right = 200
offset_bottom = -60

[node name="ToastLabel" type="Label" parent="ToastLayer/Toast"]
layout_mode = 2
text = ""
horizontal_alignment = 1
vertical_alignment = 1

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 13
anchor_left = 0.0
anchor_right = 1.0
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = 0
offset_bottom = 360

[node name="DetailsContent" type="VBoxContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="DetailsHeader" type="HBoxContainer" parent="DetailsSheet/DetailsContent"]
layout_mode = 2

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsContent/DetailsHeader"]
layout_mode = 2
text = "DETAIL LOG"

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsContent/DetailsHeader"]
custom_minimum_size = Vector2(84, 42)
layout_mode = 2
text = "CLOSE"

[node name="DetailsScroll" type="ScrollContainer" parent="DetailsSheet/DetailsContent"]
layout_mode = 2
custom_minimum_size = Vector2(0, 260)

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsContent/DetailsScroll"]
layout_mode = 2
bbcode_enabled = true
text = ""
</file>

<file path="scenes/MainMenu.gd">
extends Control

@onready var menu_root: VBoxContainer = $Center/Menu
@onready var start_btn: Button = $Center/Menu/NotebookArea
@onready var learn_btn: Button = $Center/Menu/PapersArea

func _ready() -> void:
	start_btn.pressed.connect(_on_start_pressed)
	learn_btn.pressed.connect(_on_learn_pressed)
	_animate_intro()

func _on_start_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_learn_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/LearnSelect.tscn")

func _animate_intro() -> void:
	menu_root.modulate.a = 0.0
	menu_root.position.y += 32.0
	var tween: Tween = create_tween()
	tween.tween_property(menu_root, "modulate:a", 1.0, 0.35).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	tween.parallel().tween_property(menu_root, "position:y", menu_root.position.y - 32.0, 0.42).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)
</file>

<file path="scenes/MatrixDecryptor.tscn">
[gd_scene load_steps=3 format=3 uid="uid://rr4uj50uqt2r"]

[ext_resource type="Script" path="res://scenes/MatrixDecryptor.gd" id="1_script"]
[ext_resource type="PackedScene" path="res://scenes/decryptor/MatrixDecryptorUI.tscn" id="2_ui"]

[node name="MatrixDecryptor" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="UI" parent="." instance=ExtResource("2_ui")]
layout_mode = 1
</file>

<file path="scenes/NetworkTraceQuestB.tscn">
[gd_scene load_steps=5 format=3 uid="uid://bc7hh137v5i1q"]

[ext_resource type="Script" path="res://scripts/quests/network_trace/NetworkTraceQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="3_diag_panel"]
[ext_resource type="PackedScene" path="res://scenes/ui/pipeline/PipelineSlot.tscn" id="4_pipeline_slot"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="5_noir"]

[node name="NetworkTraceQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("5_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="Main" type="MarginContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="V" type="VBoxContainer" parent="SafeArea/Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/Main/V"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnBack" type="Button" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(118, 58)
layout_mode = 2
text = "НАЗАД"

[node name="LblTitle" type="Label" parent="SafeArea/Main/V/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "СЕТЕВОЙ СЛЕД | B"

[node name="LblMeta" type="Label" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(340, 52)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ДЕЛО -- | ОШ 0/3 | T-02:00"
horizontal_alignment = 2
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(140, 38)
layout_mode = 2
max_value = 100.0
value = 100.0
show_percentage = false

[node name="PaletteSelect" type="OptionButton" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(130, 52)
layout_mode = 2

[node name="Body" type="BoxContainer" parent="SafeArea/Main/V"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="TerminalPane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.4

[node name="TerminalMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/TerminalPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="TerminalV" type="VBoxContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblBriefing" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 76)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="LblPrompt" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="InterceptBox" type="VBoxContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="LblPayload" type="Label" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox"]
layout_mode = 2
text = "Данные: --"

[node name="LblWindow" type="Label" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox"]
layout_mode = 2
text = "Окно: --"

[node name="LblTargetUnit" type="Label" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox"]
layout_mode = 2
text = "Целевая единица: --"

[node name="BtnAnalyze" type="Button" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="LogScroll" type="ScrollContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LogText" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll"]
custom_minimum_size = Vector2(0, 190)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
fit_content = false
selection_enabled = true
autowrap_mode = 2

[node name="ConsolePane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.35

[node name="ConsoleMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/ConsolePane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="ConsoleV" type="VBoxContainer" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblConsoleTitle" type="Label" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "КОНСОЛЬ ШЛЮЗА"

[node name="PipelineBoard" type="GridContainer" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="SlotKilo" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("4_pipeline_slot")]
layout_mode = 2

[node name="SlotBit" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("4_pipeline_slot")]
layout_mode = 2

[node name="SlotTime" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("4_pipeline_slot")]
layout_mode = 2

[node name="SlotOut" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("4_pipeline_slot")]
layout_mode = 2

[node name="LblModuleTray" type="Label" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ЛОТОК МОДУЛЕЙ"

[node name="ModuleTrayScroll" type="ScrollContainer" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 166)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ModuleTray" type="GridContainer" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/ModuleTrayScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 4

[node name="BtnRunCalc" type="Button" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "ЗАПУСТИТЬ РАСЧЁТ"

[node name="LblPreview" type="Label" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "СКОРОСТЬ = ???"

[node name="TransferBar" type="ProgressBar" parent="SafeArea/Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="AnswersPane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="AnswersMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/AnswersPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="AnswersV" type="VBoxContainer" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="OptionsGrid" type="GridContainer" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="ActionBtn1" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn2" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn3" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn4" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn5" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn6" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="LblStatus" type="Label" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Статус"

[node name="BottomRow" type="HBoxContainer" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnNext" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
visible = false
text = "ДАЛЕЕ"

[node name="DiagnosticsPanel" parent="." instance=ExtResource("3_diag_panel")]
layout_mode = 1
anchor_left = 0.1
anchor_top = 0.12
anchor_right = 0.9
anchor_bottom = 0.9
</file>

<file path="scenes/ui/DiagnosticsPanelC.tscn">
[gd_scene load_steps=3 format=3 uid="uid://diagnostics_panel_c_new"]

[ext_resource type="Script" path="res://scripts/ui/DiagnosticsPanelC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]

[node name="DiagnosticsPanelC" type="PanelContainer"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.15
anchor_top = 0.2
anchor_right = 0.85
anchor_bottom = 0.8
offset_left = 0.0
offset_top = 0.0
offset_right = 0.0
offset_bottom = 0.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
mouse_filter = 0
script = ExtResource("1_script")

[node name="Root" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 12

[node name="LblTitle" type="Label" parent="Root"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДИАГНОСТИКА"
horizontal_alignment = 1

[node name="Body" type="RichTextLabel" parent="Root"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "..."

[node name="BtnClose" type="Button" parent="Root"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scenes/ui/FixMenuC.tscn">
[gd_scene load_steps=3 format=3 uid="uid://fix_menu_c_new"]

[ext_resource type="Script" path="res://scripts/ui/FixMenuC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]

[node name="FixMenuC" type="PopupPanel"]
initial_position = 1
size = Vector2i(860, 420)
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Root" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 12

[node name="LblTitle" type="Label" parent="Root"]
layout_mode = 2
theme_override_font_sizes/font_size = 28
text = "ИСПРАВИТЬ СТРОКУ 01"
horizontal_alignment = 1

[node name="LblOriginal" type="Label" parent="Root"]
layout_mode = 2
autowrap_mode = 2
text = "оригинал: if i > 3:"

[node name="Options" type="VBoxContainer" parent="Root"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnOptA" type="Button" parent="Root/Options"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "A) --"

[node name="BtnOptB" type="Button" parent="Root/Options"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "B) --"

[node name="BtnOptC" type="Button" parent="Root/Options"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "C) --"

[node name="Actions" type="HBoxContainer" parent="Root"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="BtnApply" type="Button" parent="Root/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПРИМЕНИТЬ"

[node name="BtnClose" type="Button" parent="Root/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ОТМЕНА"
</file>

<file path="scripts/case_01/ResusScoring.gd">
extends RefCounted

static func score(level: Dictionary, snapshot: Dictionary, placed_count: int) -> Dictionary:
	var items: Array = level.get("items", []) as Array
	var total_items: int = items.size()
	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = (scoring_model.get("rules", []) as Array).duplicate()
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary

	var correct_count: int = 0
	for item_v in items:
		if typeof(item_v) != TYPE_DICTIONARY:
			continue
		var item: Dictionary = item_v as Dictionary
		var item_id: String = str(item.get("item_id", ""))
		var expected_bucket: String = str(item.get("correct_bucket_id", "")).to_upper()
		var actual_bucket: String = str(snapshot.get(item_id, "PILE")).to_upper()
		if expected_bucket == actual_bucket:
			correct_count += 1

	var max_points: int = 0
	for rule_v in rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			continue
		var rule_data: Dictionary = rule_v as Dictionary
		max_points = max(max_points, int(rule_data.get("points", 0)))

	if placed_count <= 0:
		return {
			"correct_count": correct_count,
			"total_items": total_items,
			"points": int(default_rule.get("points", 0)),
			"max_points": max_points,
			"is_fit": false,
			"is_correct": false,
			"stability_delta": int(default_rule.get("stability_delta", -50)),
			"verdict_code": str(default_rule.get("verdict_code", "EMPTY")),
			"rule_code": str(default_rule.get("code", "EMPTY_CONFIRM"))
		}

	var selected_rule: Dictionary = {}
	var selected_min_correct: int = -9999
	for rule_v in rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_v as Dictionary
		var min_correct: int = int(rule.get("min_correct", 0))
		if correct_count >= min_correct and min_correct > selected_min_correct:
			selected_min_correct = min_correct
			selected_rule = rule

	if selected_rule.is_empty():
		selected_rule = {
			"points": 0,
			"stability_delta": -30,
			"verdict_code": "FAIL",
			"code": "FALLBACK"
		}

	var points: int = int(selected_rule.get("points", 0))
	var is_correct: bool = correct_count == total_items and points == max_points
	var is_fit: bool = points > 0

	return {
		"correct_count": correct_count,
		"total_items": total_items,
		"points": points,
		"max_points": max_points,
		"is_fit": is_fit,
		"is_correct": is_correct,
		"stability_delta": int(selected_rule.get("stability_delta", -30)),
		"verdict_code": str(selected_rule.get("verdict_code", "FAIL")),
		"rule_code": str(selected_rule.get("code", "SCORING_RULE"))
	}

static func calculate_stage_b_result(stage_b_data: Dictionary, snapshot: Dictionary) -> Dictionary:
	var selected_option_id: String = str(snapshot.get("selected_option_id", "")).strip_edges()
	var scoring_model: Dictionary = stage_b_data.get("scoring_model", {}) as Dictionary
	var feedback_rules: Dictionary = stage_b_data.get("feedback_rules", {}) as Dictionary
	var correct_option_id: String = str(stage_b_data.get("correct_option_id", ""))
	var max_points: int = int(stage_b_data.get("stage_max_points", int(scoring_model.get("correct_points", 2))))

	if selected_option_id == "":
		var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
		return {
			"points": int(default_rule.get("points", 0)),
			"max_points": max_points,
			"is_correct": false,
			"is_fit": false,
			"stability_delta": int(default_rule.get("stability_delta", -50)),
			"verdict_code": str(default_rule.get("verdict_code", "EMPTY")),
			"error_code": "EMPTY",
			"diagnostic_headline": "Вариант не выбран",
			"diagnostic_details": ["Выберите один из 4 вариантов и подтвердите решение."]
		}

	var is_correct: bool = selected_option_id == correct_option_id
	var points: int = int(scoring_model.get("correct_points", 2)) if is_correct else int(scoring_model.get("wrong_points", 0))
	var stability_delta: int = int(scoring_model.get("stability_delta_correct", 0)) if is_correct else int(scoring_model.get("stability_delta_wrong", -10))
	var verdict_code: String = "SUCCESS" if is_correct else "WRONG"

	var feedback: Dictionary = feedback_rules.get(selected_option_id, {}) as Dictionary
	if feedback.is_empty() and feedback_rules.has(correct_option_id):
		feedback = feedback_rules.get(correct_option_id, {}) as Dictionary

	var error_code: String = str(feedback.get("error_code", "OK" if is_correct else "WRONG"))
	var headline: String = str(feedback.get("headline", "Конфигурация проверена"))
	var details: Array = (feedback.get("details", []) as Array).duplicate()

	return {
		"points": points,
		"max_points": max_points,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"error_code": error_code,
		"diagnostic_headline": headline,
		"diagnostic_details": details
	}

static func calculate_stage_c_result(stage_c_data: Dictionary, snapshot: Dictionary) -> Dictionary:
	var options: Array = stage_c_data.get("options", []) as Array
	var scoring_model: Dictionary = stage_c_data.get("scoring_model", {}) as Dictionary
	var feedback_rules: Dictionary = stage_c_data.get("feedback_rules", {}) as Dictionary

	var option_by_id: Dictionary = {}
	var correct_set: Dictionary = {}
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", "")).strip_edges()
		if option_id == "":
			continue
		option_by_id[option_id] = option_data
		if bool(option_data.get("is_correct", false)):
			correct_set[option_id] = true

	var slots_raw: Array = snapshot.get("slots", []) as Array
	var slots: Array[String] = []
	for slot_v in slots_raw:
		slots.append(str(slot_v).strip_edges())

	var selected_raw: Array = snapshot.get("selected", []) as Array
	if selected_raw.is_empty() and not slots.is_empty():
		selected_raw = slots_raw
	var selected_set: Dictionary = {}
	var selected_ids: Array[String] = []
	for selected_v in selected_raw:
		var selected_id: String = str(selected_v).strip_edges()
		if selected_id == "" or selected_set.has(selected_id):
			continue
		selected_set[selected_id] = true
		selected_ids.append(selected_id)
	selected_ids.sort()

	var correct_selected: int = 0
	var wrong_selected: int = 0
	var explain_selected: Array = []
	for selected_id in selected_ids:
		var is_option_correct: bool = correct_set.has(selected_id)
		if is_option_correct:
			correct_selected += 1
		else:
			wrong_selected += 1

		var option_data_v: Variant = option_by_id.get(selected_id, {})
		var option_data: Dictionary = option_data_v as Dictionary
		explain_selected.append({
			"option_id": selected_id,
			"label": str(option_data.get("label", selected_id)),
			"is_correct": is_option_correct,
			"why": str(option_data.get("why", "Пояснение отсутствует."))
		})

	var selected_count: int = selected_ids.size()
	var unique_used_count: int = int(snapshot.get("unique_used_count", selected_count))
	var strategy_flags: Array[String] = []
	if options.size() > 0 and unique_used_count >= options.size():
		strategy_flags.append("TOUCHED_ALL_OPTIONS")
	var max_points: int = int(stage_c_data.get("stage_max_points", 2))
	var verdict_code: String = "FAIL"
	var points: int = 0
	var stability_delta: int = -50

	var rule_2: Dictionary = scoring_model.get("rule_2", {}) as Dictionary
	var rule_1a: Dictionary = scoring_model.get("rule_1a", {}) as Dictionary
	var rule_1b: Dictionary = scoring_model.get("rule_1b", {}) as Dictionary
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	var empty_rule: Dictionary = scoring_model.get("empty_rule", {}) as Dictionary
	var select_all_rule: Dictionary = scoring_model.get("select_all_rule", default_rule) as Dictionary
	var is_select_all_behavior: bool = options.size() > 0 and selected_count == options.size()

	if selected_count == 0:
		verdict_code = str(empty_rule.get("verdict_code", "EMPTY"))
		points = int(empty_rule.get("points", 0))
		stability_delta = int(empty_rule.get("stability_delta", -50))
	elif is_select_all_behavior:
		verdict_code = str(select_all_rule.get("verdict_code", "SELECT_ALL"))
		points = int(select_all_rule.get("points", 0))
		stability_delta = int(select_all_rule.get("stability_delta", -50))
	elif correct_selected == int(rule_2.get("need_correct", 3)) and wrong_selected <= int(rule_2.get("max_wrong", 0)):
		verdict_code = str(rule_2.get("verdict_code", "PERFECT"))
		points = int(rule_2.get("points", 2))
		stability_delta = int(rule_2.get("stability_delta", 0))
	elif correct_selected == int(rule_1a.get("need_correct", 2)) and wrong_selected <= int(rule_1a.get("max_wrong", 0)):
		verdict_code = str(rule_1a.get("verdict_code", "GOOD"))
		points = int(rule_1a.get("points", 1))
		stability_delta = int(rule_1a.get("stability_delta", 0))
	elif correct_selected == int(rule_1b.get("need_correct", 3)) and wrong_selected <= int(rule_1b.get("max_wrong", 1)):
		verdict_code = str(rule_1b.get("verdict_code", "NOISY"))
		points = int(rule_1b.get("points", 1))
		stability_delta = int(rule_1b.get("stability_delta", -10))
	else:
		verdict_code = str(default_rule.get("verdict_code", "FAIL"))
		points = int(default_rule.get("points", 0))
		stability_delta = int(default_rule.get("stability_delta", -50))

	var required_ids: Array[String] = []
	for option_id_v in correct_set.keys():
		required_ids.append(str(option_id_v))
	required_ids.sort()

	var missing_required: Array[String] = []
	for required_id in required_ids:
		if not selected_set.has(required_id):
			missing_required.append(required_id)

	var feedback: Dictionary = feedback_rules.get(verdict_code, {}) as Dictionary
	var feedback_headline: String = str(feedback.get("headline", verdict_code))
	var feedback_details: Array = (feedback.get("details", []) as Array).duplicate()

	return {
		"points": points,
		"max_points": max_points,
		"is_correct": verdict_code == "PERFECT",
		"is_fit": points > 0,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"slots": slots.duplicate(),
		"selected_ids": selected_ids.duplicate(),
		"correct_selected": correct_selected,
		"wrong_selected": wrong_selected,
		"selected_count": selected_count,
		"unique_used_count": unique_used_count,
		"strategy_flags": strategy_flags.duplicate(),
		"missing_required": missing_required.duplicate(),
		"feedback_headline": feedback_headline,
		"feedback_details": feedback_details,
		"explain_selected": explain_selected
	}
</file>

<file path="scripts/case_07/da7_cases.gd">
extends Node

const CasesA = preload("res://scripts/case_07/da7_cases_a.gd")
const CasesB = preload("res://scripts/case_07/da7_cases_b.gd")
const CasesC = preload("res://scripts/case_07/da7_cases_c.gd")

static func get_cases(level: String) -> Array:
	match level.to_upper():
		"A":
			return CasesA.CASES_A.duplicate(true)
		"B":
			return CasesB.CASES_B.duplicate(true)
		"C":
			return CasesC.CASES_C.duplicate(true)
	return []
</file>

<file path="scripts/case_07/da7_data_archive_c.gd">
extends Control

const CasesHub = preload("res://scripts/case_07/da7_cases.gd")
const CasesModuleC = preload("res://scripts/case_07/da7_cases_c.gd")

const BREAKPOINT_PX := 900
const SESSION_CASE_COUNT := 6
const TYPEWRITER_INTERVAL_SEC := 0.05
const LAYOUT_MOBILE := "mobile"
const LAYOUT_DESKTOP := "desktop"

var session_cases: Array = []
var current_case_index: int = -1
var current_case: Dictionary = {}
var current_layout: String = LAYOUT_DESKTOP
var session_finished: bool = false

var case_started_ts: int = 0
var time_to_first_action_ms: int = -1
var is_trial_active: bool = false
var trial_locked: bool = false
var timed_out: bool = false

var limit_sec: int = 120
var time_left_sec: float = 120.0
var typewriter_active: bool = false
var typewriter_accum: float = 0.0

var selected_sequence_ids: Array[String] = []
var block_by_id: Dictionary = {}
var repo_button_by_id: Dictionary = {}
var allow_repeat_roles: Array = []

var reorder_count: int = 0
var undo_count: int = 0
var block_pick_count: int = 0
var clear_used: bool = false
var unique_blocks_used: Dictionary = {}

@onready var title_label: Label = $SafeArea/Margin/Root/Header/HeaderVBox/Title
@onready var btn_back: Button = $SafeArea/Margin/Root/BackRow/BtnBack
@onready var stability_label: Label = $SafeArea/Margin/Root/Header/HeaderVBox/TimerRow/StabilityLabel
@onready var timer_bar: ProgressBar = $SafeArea/Margin/Root/Header/HeaderVBox/TimerRow/TimerBar
@onready var timer_label: Label = $SafeArea/Margin/Root/Header/HeaderVBox/TimerRow/TimerLabel
@onready var prompt_label: RichTextLabel = $SafeArea/Margin/Root/Prompt
@onready var code_area: HFlowContainer = $SafeArea/Margin/Root/CodePanel/CodeArea
@onready var btn_undo: Button = $SafeArea/Margin/Root/ControlsRow/BtnUndo
@onready var btn_clear: Button = $SafeArea/Margin/Root/ControlsRow/BtnClear
@onready var btn_submit: Button = $SafeArea/Margin/Root/ControlsRow/BtnSubmit
@onready var btn_next: Button = $SafeArea/Margin/Root/ControlsRow/BtnNext
@onready var status_label: Label = $SafeArea/Margin/Root/StatusLabel
@onready var block_repository: GridContainer = $SafeArea/Margin/Root/RepoPanel/RepoScroll/BlockRepository
@onready var sfx_click: AudioStreamPlayer = $SFX/SfxClick
@onready var sfx_error: AudioStreamPlayer = $SFX/SfxError
@onready var sfx_relay: AudioStreamPlayer = $SFX/SfxRelay

func _ready() -> void:
	randomize()
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	btn_back.pressed.connect(_on_back_pressed)
	btn_undo.pressed.connect(_on_undo_pressed)
	btn_clear.pressed.connect(_on_clear_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_next.pressed.connect(_on_next_pressed)

	_init_session()
	call_deferred("_on_viewport_size_changed")
	_load_next_case()

func _process(delta: float) -> void:
	if typewriter_active:
		typewriter_accum += delta
		while typewriter_accum >= TYPEWRITER_INTERVAL_SEC and typewriter_active:
			typewriter_accum -= TYPEWRITER_INTERVAL_SEC
			if prompt_label.visible_characters < prompt_label.get_total_character_count():
				prompt_label.visible_characters += 1
			else:
				typewriter_active = false
				prompt_label.visible_characters = -1

	if not is_trial_active:
		return

	time_left_sec = max(0.0, time_left_sec - delta)
	_update_timer_ui()
	if time_left_sec <= 0.0 and not timed_out:
		timed_out = true
		var timeout_eval: Dictionary = _evaluate_sequence(selected_sequence_ids, true)
		_finish_trial(false, "TIMEOUT", timeout_eval, "TIMEOUT")

func _init_session() -> void:
	var all_cases: Array = CasesHub.get_cases("C")
	var valid_cases: Array = []
	for case_v in all_cases:
		if typeof(case_v) != TYPE_DICTIONARY:
			continue
		var case_data: Dictionary = case_v as Dictionary
		if CasesModuleC.validate_case_c(case_data):
			valid_cases.append(case_data)
	valid_cases.shuffle()
	session_cases = valid_cases.slice(0, min(SESSION_CASE_COUNT, valid_cases.size()))
	current_case_index = -1
	GlobalMetrics.stability = 100.0
	_update_stability_ui()

func _load_next_case() -> void:
	current_case_index += 1
	if current_case_index >= session_cases.size():
		_finish_session()
		return
	current_case = (session_cases[current_case_index] as Dictionary).duplicate(true)
	session_finished = false
	case_started_ts = Time.get_ticks_msec()
	time_to_first_action_ms = -1
	is_trial_active = true
	trial_locked = false
	timed_out = false
	reorder_count = 0
	undo_count = 0
	block_pick_count = 0
	clear_used = false
	unique_blocks_used.clear()
	selected_sequence_ids.clear()
	repo_button_by_id.clear()
	block_by_id.clear()
	_render_case()

func _render_case() -> void:
	var case_id: String = str(current_case.get("id", "DA7-C-00"))
	title_label.text = "ДЕЛО #7: МАСТЕР SQL [%s]" % case_id
	var timing_policy: Dictionary = current_case.get("timing_policy", {}) as Dictionary
	limit_sec = int(timing_policy.get("limit_sec", 120))
	time_left_sec = float(limit_sec)
	timer_bar.max_value = max(1.0, float(limit_sec))
	timer_bar.value = timer_bar.max_value
	prompt_label.bbcode_enabled = true
	prompt_label.text = "[b]%s[/b]" % str(current_case.get("prompt", "Соберите SQL-последовательность."))
	prompt_label.visible_characters = 0
	typewriter_active = true
	typewriter_accum = 0.0
	var rules: Dictionary = _active_rules()
	allow_repeat_roles = (rules.get("allow_repeat_roles", []) as Array).duplicate()
	_build_block_repository()
	_rebuild_code_area()
	_set_input_locked(false)
	btn_next.text = "ДАЛЕЕ"
	btn_next.visible = false
	status_label.text = "Соберите токены запроса и отправьте."
	_update_timer_ui()
	_update_stability_ui()

func _active_rules() -> Dictionary:
	var rules: Dictionary = current_case.get("rules", {}) as Dictionary
	if rules.is_empty():
		rules = current_case.get("constraints", {}) as Dictionary
	return rules

func _build_block_repository() -> void:
	for child in block_repository.get_children():
		child.queue_free()
	var blocks: Array = (current_case.get("available_blocks", []) as Array).duplicate()
	var anti_cheat: Dictionary = current_case.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_blocks", false)):
		blocks.shuffle()
	for block_v in blocks:
		if typeof(block_v) != TYPE_DICTIONARY:
			continue
		var block_data: Dictionary = block_v as Dictionary
		var block_id: String = str(block_data.get("id", ""))
		if block_id == "":
			continue
		block_by_id[block_id] = block_data
		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 56)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.text = str(block_data.get("text", block_id))
		btn.pressed.connect(_on_block_pressed.bind(block_id))
		block_repository.add_child(btn)
		repo_button_by_id[block_id] = btn

func _on_block_pressed(block_id: String) -> void:
	if trial_locked or not is_trial_active:
		return
	if not block_by_id.has(block_id):
		return
	_register_interaction()
	var role: String = str((block_by_id.get(block_id, {}) as Dictionary).get("role", ""))
	if _role_is_single_use(role) and _sequence_has_role(role):
		status_label.text = "Роль %s уже использована." % role
		return
	selected_sequence_ids.append(block_id)
	block_pick_count += 1
	unique_blocks_used[block_id] = true
	var btn: Button = repo_button_by_id.get(block_id, null) as Button
	if is_instance_valid(btn):
		btn.disabled = true
	if is_instance_valid(sfx_click):
		sfx_click.play()
	_rebuild_code_area()

func _rebuild_code_area() -> void:
	for child in code_area.get_children():
		child.queue_free()
	for idx in range(selected_sequence_ids.size()):
		var block_id: String = selected_sequence_ids[idx]
		var block_data: Dictionary = block_by_id.get(block_id, {}) as Dictionary
		var chip: PanelContainer = PanelContainer.new()
		chip.custom_minimum_size = Vector2(0, 54)
		var row: HBoxContainer = HBoxContainer.new()
		row.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		row.add_theme_constant_override("separation", 6)
		chip.add_child(row)

		var btn_left: Button = Button.new()
		btn_left.text = "<"
		btn_left.custom_minimum_size = Vector2(36, 42)
		btn_left.disabled = idx == 0
		btn_left.pressed.connect(_on_move_token.bind(idx, -1))
		row.add_child(btn_left)

		var lbl: Label = Label.new()
		lbl.text = str(block_data.get("text", block_id))
		lbl.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		row.add_child(lbl)

		var btn_right: Button = Button.new()
		btn_right.text = ">"
		btn_right.custom_minimum_size = Vector2(36, 42)
		btn_right.disabled = idx >= selected_sequence_ids.size() - 1
		btn_right.pressed.connect(_on_move_token.bind(idx, 1))
		row.add_child(btn_right)

		var btn_remove: Button = Button.new()
		btn_remove.text = "X"
		btn_remove.custom_minimum_size = Vector2(36, 42)
		btn_remove.pressed.connect(_on_remove_token.bind(idx))
		row.add_child(btn_remove)

		code_area.add_child(chip)
	_update_submit_state()

func _on_move_token(index: int, direction: int) -> void:
	if trial_locked or not is_trial_active:
		return
	var new_index: int = index + direction
	if new_index < 0 or new_index >= selected_sequence_ids.size():
		return
	_register_interaction()
	var token: String = selected_sequence_ids[index]
	selected_sequence_ids[index] = selected_sequence_ids[new_index]
	selected_sequence_ids[new_index] = token
	reorder_count += 1
	if is_instance_valid(sfx_click):
		sfx_click.play()
	_rebuild_code_area()

func _on_remove_token(index: int) -> void:
	if trial_locked or not is_trial_active:
		return
	if index < 0 or index >= selected_sequence_ids.size():
		return
	_register_interaction()
	var block_id: String = selected_sequence_ids[index]
	selected_sequence_ids.remove_at(index)
	var btn: Button = repo_button_by_id.get(block_id, null) as Button
	if is_instance_valid(btn):
		btn.disabled = false
	if is_instance_valid(sfx_click):
		sfx_click.play()
	_rebuild_code_area()

func _on_undo_pressed() -> void:
	if trial_locked or not is_trial_active:
		return
	if selected_sequence_ids.is_empty():
		return
	undo_count += 1
	_on_remove_token(selected_sequence_ids.size() - 1)

func _on_clear_pressed() -> void:
	if trial_locked or not is_trial_active:
		return
	if selected_sequence_ids.is_empty():
		return
	clear_used = true
	selected_sequence_ids.clear()
	for block_id in repo_button_by_id.keys():
		var btn: Button = repo_button_by_id.get(block_id, null) as Button
		if is_instance_valid(btn):
			btn.disabled = false
	_rebuild_code_area()
	status_label.text = "Последовательность очищена."

func _on_submit_pressed() -> void:
	if trial_locked or not is_trial_active:
		return
	_register_interaction()
	var eval_result: Dictionary = _evaluate_sequence(selected_sequence_ids)
	var is_correct: bool = bool(eval_result.get("is_correct", false))
	var f_reason: Variant = eval_result.get("f_reason", null)
	var end_state: String = "SUCCESS" if is_correct else "FAIL"
	_finish_trial(is_correct, f_reason, eval_result, end_state)

func _finish_trial(is_correct: bool, f_reason: Variant, eval_result: Dictionary, end_state: String) -> void:
	trial_locked = true
	is_trial_active = false
	typewriter_active = false
	prompt_label.visible_characters = -1
	_set_input_locked(true)
	if is_correct:
		status_label.text = "ДОСТУП РАЗРЕШЁН. Запрос корректен."
		if is_instance_valid(sfx_relay):
			sfx_relay.play()
	else:
		status_label.text = "ОШИБКА: %s" % str(f_reason)
		if is_instance_valid(sfx_error):
			sfx_error.play()
	_log_trial(is_correct, f_reason, eval_result, end_state)
	_update_stability_ui()
	btn_next.visible = true

func _evaluate_sequence(selected_ids: Array[String], force_timeout: bool = false) -> Dictionary:
	var rules: Dictionary = _active_rules()
	var required_roles: Array = rules.get("required_roles", []) as Array
	var forbidden_roles: Array = rules.get("forbidden_roles", []) as Array
	var forbidden_block_ids: Array = rules.get("forbidden_block_ids", []) as Array
	var skeleton_roles: Array = rules.get("skeleton_roles", []) as Array
	var order_rules: Array = rules.get("order_rules", []) as Array
	var min_tokens: int = int(rules.get("min_tokens", 1))
	var correct_ids: Array[String] = _to_string_array(current_case.get("correct_sequence_ids", []) as Array)

	var selected_roles: Array[String] = _roles_for_ids(selected_ids)
	var missing_roles: Array[String] = _missing_required_roles(selected_roles, required_roles)
	var diff: Dictionary = _build_diff(selected_ids, correct_ids)

	if force_timeout:
		return _build_eval("TIMEOUT", selected_roles, missing_roles, diff)
	if selected_ids == correct_ids:
		return _build_eval("SUCCESS", selected_roles, [], diff)
	if _has_forbidden_tokens(selected_ids, selected_roles, forbidden_block_ids, forbidden_roles):
		return _build_eval("SQL_SYNTAX_ERROR", selected_roles, missing_roles, diff)
	if selected_ids.size() < min_tokens or not missing_roles.is_empty():
		return _build_eval("INCOMPLETE_QUERY", selected_roles, missing_roles, diff)
	if _violates_order_rules(selected_roles, order_rules) or _violates_skeleton_order(selected_roles, skeleton_roles):
		return _build_eval("KEYWORD_ORDER", selected_roles, missing_roles, diff)
	if _same_multiset(selected_ids, correct_ids) and selected_ids != correct_ids:
		return _build_eval("KEYWORD_ORDER", selected_roles, missing_roles, diff)
	if (diff.get("extra_ids", []) as Array).size() > 0:
		return _build_eval("EXTRA_TOKENS", selected_roles, missing_roles, diff)
	return _build_eval("LOGIC_MISMATCH", selected_roles, missing_roles, diff)

func _build_eval(reason: String, selected_roles: Array[String], missing_roles: Array[String], diff: Dictionary) -> Dictionary:
	var is_correct: bool = reason == "SUCCESS"
	var final_reason: Variant = null if is_correct else reason
	return {
		"is_correct": is_correct,
		"f_reason": final_reason,
		"selected_roles": selected_roles,
		"missing_roles": missing_roles,
		"diff": diff
	}

func _to_string_array(values: Array) -> Array[String]:
	var out: Array[String] = []
	for value_v in values:
		out.append(str(value_v))
	return out

func _roles_for_ids(ids: Array[String]) -> Array[String]:
	var roles: Array[String] = []
	for id in ids:
		var block_data: Dictionary = block_by_id.get(id, {}) as Dictionary
		roles.append(str(block_data.get("role", "")))
	return roles

func _missing_required_roles(selected_roles: Array[String], required_roles: Array) -> Array[String]:
	var lookup: Dictionary = {}
	for role_v in selected_roles:
		lookup[str(role_v)] = true
	var missing: Array[String] = []
	for role_v in required_roles:
		var role: String = str(role_v)
		if not lookup.has(role):
			missing.append(role)
	return missing

func _has_forbidden_tokens(selected_ids: Array[String], selected_roles: Array[String], forbidden_block_ids: Array, forbidden_roles: Array) -> bool:
	var forbidden_block_lookup: Dictionary = {}
	for block_id_v in forbidden_block_ids:
		forbidden_block_lookup[str(block_id_v)] = true
	for selected_id in selected_ids:
		if forbidden_block_lookup.has(selected_id):
			return true

	var forbidden_role_lookup: Dictionary = {}
	for role_v in forbidden_roles:
		forbidden_role_lookup[str(role_v)] = true
	for selected_role in selected_roles:
		if forbidden_role_lookup.has(selected_role):
			return true
	return false

func _violates_order_rules(selected_roles: Array[String], order_rules: Array) -> bool:
	for rule_v in order_rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_v as Dictionary
		var before_role: String = str(rule.get("before", ""))
		var after_role: String = str(rule.get("after", ""))
		if before_role == "" or after_role == "":
			continue
		var before_idx: int = _first_role_index(selected_roles, before_role)
		var after_idx: int = _first_role_index(selected_roles, after_role)
		if before_idx < 0 or after_idx < 0:
			continue
		if before_idx <= after_idx:
			return true
	return false

func _violates_skeleton_order(selected_roles: Array[String], skeleton_roles: Array) -> bool:
	var cursor: int = -1
	for role_v in skeleton_roles:
		var role: String = str(role_v)
		var idx: int = _first_role_index(selected_roles, role)
		if idx < 0:
			continue
		if idx < cursor:
			return true
		cursor = idx
	return false

func _first_role_index(selected_roles: Array[String], role: String) -> int:
	for idx in range(selected_roles.size()):
		if selected_roles[idx] == role:
			return idx
	return -1

func _build_diff(selected_ids: Array[String], correct_ids: Array[String]) -> Dictionary:
	var selected_counts: Dictionary = _counts(selected_ids)
	var correct_counts: Dictionary = _counts(correct_ids)

	var missing_ids: Array[String] = []
	for key_v in correct_counts.keys():
		var key: String = str(key_v)
		var need: int = int(correct_counts[key]) - int(selected_counts.get(key, 0))
		for _i in range(max(0, need)):
			missing_ids.append(key)

	var extra_ids: Array[String] = []
	for key_v in selected_counts.keys():
		var key: String = str(key_v)
		var extra: int = int(selected_counts[key]) - int(correct_counts.get(key, 0))
		for _j in range(max(0, extra)):
			extra_ids.append(key)

	var first_mismatch_index: int = -1
	var max_len: int = max(selected_ids.size(), correct_ids.size())
	for idx in range(max_len):
		var selected_id: String = selected_ids[idx] if idx < selected_ids.size() else "<none>"
		var correct_id: String = correct_ids[idx] if idx < correct_ids.size() else "<none>"
		if selected_id != correct_id:
			first_mismatch_index = idx
			break

	return {
		"missing_ids": missing_ids,
		"extra_ids": extra_ids,
		"first_mismatch_index": first_mismatch_index
	}

func _counts(ids: Array[String]) -> Dictionary:
	var out: Dictionary = {}
	for id in ids:
		out[id] = int(out.get(id, 0)) + 1
	return out

func _same_multiset(a: Array[String], b: Array[String]) -> bool:
	if a.size() != b.size():
		return false
	return _counts(a) == _counts(b)

func _role_is_single_use(role: String) -> bool:
	return not allow_repeat_roles.has(role)

func _sequence_has_role(role: String) -> bool:
	for block_id in selected_sequence_ids:
		var block_data: Dictionary = block_by_id.get(block_id, {}) as Dictionary
		if str(block_data.get("role", "")) == role:
			return true
	return false

func _register_interaction() -> void:
	if time_to_first_action_ms < 0:
		time_to_first_action_ms = Time.get_ticks_msec() - case_started_ts

func _log_trial(is_correct: bool, f_reason: Variant, eval_result: Dictionary, end_state: String) -> void:
	var now_ms: int = Time.get_ticks_msec()
	var elapsed_ms: int = now_ms - case_started_ts
	var effective_first_action_ms: int = max(0, time_to_first_action_ms)
	if time_to_first_action_ms < 0:
		effective_first_action_ms = elapsed_ms

	var timing_policy: Dictionary = current_case.get("timing_policy", {}) as Dictionary
	var rules: Dictionary = _active_rules()
	var diff: Dictionary = eval_result.get("diff", {}) as Dictionary
	var payload: Dictionary = {
		"quest_id": "DA7",
		"level": "C",
		"stage": "C",
		"case_id": str(current_case.get("id", "DA7-C-00")),
		"question_id": str(current_case.get("id", "DA7-C-00")),
		"interaction_type": str(current_case.get("interaction_type", "ASSEMBLE_BLOCKS")),
		"topic": str(current_case.get("topic", "DB_SQL")),
		"schema_version": str(current_case.get("schema_version", "DA7.C.v1")),
		"match_key": "DA7_C|%s" % str(current_case.get("id", "DA7-C-00")),
		"is_correct": is_correct,
		"f_reason": f_reason,
		"end_state": end_state,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"timing": {
			"policy_mode": str(timing_policy.get("mode", "EXAM")),
			"limit_sec": int(timing_policy.get("limit_sec", limit_sec)),
			"effective_elapsed_ms": elapsed_ms,
			"time_to_first_action_ms": effective_first_action_ms
		},
		"answer": {
			"user_sequence_ids": selected_sequence_ids.duplicate(),
			"selected_roles": eval_result.get("selected_roles", [])
		},
		"expected": {
			"correct_sequence_ids": _to_string_array(current_case.get("correct_sequence_ids", []) as Array),
			"required_roles": rules.get("required_roles", []),
			"skeleton_roles": rules.get("skeleton_roles", []),
			"order_rules": rules.get("order_rules", [])
		},
		"diff": {
			"missing_ids": diff.get("missing_ids", []),
			"extra_ids": diff.get("extra_ids", []),
			"first_mismatch_index": int(diff.get("first_mismatch_index", -1))
		},
		"telemetry": {
			"time_to_first_action_ms": effective_first_action_ms,
			"pick_count": block_pick_count,
			"block_pick_count": block_pick_count,
			"unique_blocks_used": unique_blocks_used.size(),
			"unique_blocks_used_ids": unique_blocks_used.keys(),
			"reorder_count": reorder_count,
			"undo_count": undo_count,
			"clear_used": clear_used
		},
		"flags": {
			"timed_out": timed_out
		},
		"ui": {
			"layout": current_layout,
			"vw": int(get_viewport_rect().size.x),
			"vh": int(get_viewport_rect().size.y)
		},
		"anti_cheat": current_case.get("anti_cheat", {}) as Dictionary
	}
	GlobalMetrics.register_trial(payload)

func _set_input_locked(locked: bool) -> void:
	btn_undo.disabled = locked
	btn_clear.disabled = locked
	btn_submit.disabled = locked or selected_sequence_ids.is_empty()
	for block_id_v in repo_button_by_id.keys():
		var block_id: String = str(block_id_v)
		var btn_v: Variant = repo_button_by_id[block_id]
		if not (btn_v is Button):
			continue
		var btn: Button = btn_v as Button
		if locked:
			btn.disabled = true
		else:
			btn.disabled = selected_sequence_ids.has(block_id)

func _update_submit_state() -> void:
	btn_submit.disabled = trial_locked or not is_trial_active or selected_sequence_ids.is_empty()

func _update_timer_ui() -> void:
	timer_bar.value = time_left_sec
	var minutes: int = int(time_left_sec) / 60
	var seconds: int = int(time_left_sec) % 60
	timer_label.text = "%02d:%02d" % [minutes, seconds]
	if time_left_sec <= 20.0:
		timer_label.modulate = Color(1.0, 0.4, 0.3, 1.0)
	else:
		timer_label.modulate = Color(1.0, 1.0, 1.0, 1.0)

func _on_next_pressed() -> void:
	if session_finished:
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return
	_load_next_case()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _finish_session() -> void:
	is_trial_active = false
	trial_locked = true
	session_finished = true
	typewriter_active = false
	title_label.text = "ДЕЛО #7: МАСТЕР SQL [ЗАВЕРШЕНО]"
	status_label.text = "Сессия завершена."
	btn_next.text = "ВЫХОД"
	btn_next.disabled = false
	btn_next.visible = true
	_set_input_locked(true)

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_label.text = "Стабильность: %d%%" % int(GlobalMetrics.stability)

func _on_viewport_size_changed() -> void:
	var size: Vector2 = get_viewport_rect().size
	if size.x < BREAKPOINT_PX:
		current_layout = LAYOUT_MOBILE
		block_repository.columns = 3
	else:
		current_layout = LAYOUT_DESKTOP
		block_repository.columns = 4
</file>

<file path="scripts/radio_intercept/RadioQuestA.gd">
extends Control

const N_VALUES = [32, 64, 100, 128, 200, 256]
const POINT_COUNT = 96
const MAX_NOISE = 24.0
const PHONE_LANDSCAPE_MAX_HEIGHT := 520.0

@onready var safe_area: MarginContainer = $SafeArea
@onready var root_vbox: VBoxContainer = $SafeArea/RootPanel/VBox
@onready var oscillo_box: PanelContainer = $SafeArea/RootPanel/VBox/OscilloBox
@onready var tuner_row: HBoxContainer = $SafeArea/RootPanel/VBox/TunerRow
@onready var buttons_row: HBoxContainer = $SafeArea/RootPanel/VBox/ButtonsRow
@onready var task_label: Label = $SafeArea/RootPanel/VBox/HeaderBar/TaskLabel
@onready var oscillo_area: Control = $SafeArea/RootPanel/VBox/OscilloBox/OscilloArea
@onready var osc_line: Line2D = $SafeArea/RootPanel/VBox/OscilloBox/OscilloArea/OscilloNode/OscLine
@onready var bits_label: Label = $SafeArea/RootPanel/VBox/TunerRow/BitsLabel
@onready var bits_slider: HSlider = $SafeArea/RootPanel/VBox/TunerRow/BitsSlider
@onready var hint_button: Button = $SafeArea/RootPanel/VBox/ButtonsRow/HintButton
@onready var confirm_button: Button = $SafeArea/RootPanel/VBox/ButtonsRow/ConfirmButton
@onready var hint_label: Label = $SafeArea/RootPanel/VBox/HintLabel

var current_n: int = 0
var i_min: int = 0
var used_hint: bool = false
var forced_sampling: bool = false
var started_at: int = 0
var first_action_at: int = 0
var _phase: float = 0.0
var _animate: bool = true

func _ready():
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)
	_on_viewport_size_changed()
	_start_new_task()
	call_deferred("_draw_signal")

func _process(delta: float) -> void:
	if _animate:
		_phase += delta * 2.0
		_draw_signal()

	if not forced_sampling and first_action_at == 0:
		var elapsed = Time.get_ticks_msec() - started_at
		if elapsed >= 8000:
			forced_sampling = true
			hint_label.text = "Режим принудительного замера активирован."

func _start_new_task():
	current_n = N_VALUES[randi() % N_VALUES.size()]
	i_min = int(ceil(log(float(current_n)) / log(2.0)))
	used_hint = false
	forced_sampling = false
	started_at = Time.get_ticks_msec()
	first_action_at = 0

	task_label.text = "Перехват... Мощность алфавита: %d символов. Настройте глубину кодирования." % current_n
	bits_slider.value = 1
	bits_label.text = "Биты: %d" % int(bits_slider.value)
	hint_label.text = ""

func _on_bits_slider_value_changed(value: float) -> void:
	if first_action_at == 0:
		first_action_at = Time.get_ticks_msec()
	bits_label.text = "Биты: %d" % int(value)
	_draw_signal()

func _on_hint_button_pressed() -> void:
	used_hint = true
	var hint = "Формула Хартли: N = 2^i\nМинимум i для %d: %d" % [current_n, i_min]
	hint_label.text = hint

func _on_confirm_button_pressed() -> void:
	var chosen_i = int(bits_slider.value)
	var capacity = int(pow(2.0, chosen_i))
	var correct = capacity >= current_n
	var overkill = correct and chosen_i > i_min
	var elapsed_ms = Time.get_ticks_msec() - started_at

	var payload = {
		"quest": "radio_intercept",
		"stage": "A",
		"N": current_n,
		"i_min": i_min,
		"chosen_i": chosen_i,
		"capacity": capacity,
		"is_correct": correct,
		"is_overkill": overkill,
		"used_hint": used_hint,
		"forced_sampling": forced_sampling,
		"elapsed_ms": elapsed_ms
	}
	GlobalMetrics.register_trial(payload)

	_start_new_task()
	_draw_signal()

func _on_slider_value_changed(value: float) -> void:
	_on_bits_slider_value_changed(value)

func _on_hint_pressed() -> void:
	_on_hint_button_pressed()

func _on_confirm_pressed() -> void:
	_on_confirm_button_pressed()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/LearnSelect.tscn")

func _on_viewport_size_changed() -> void:
	var size: Vector2 = get_viewport_rect().size
	var is_phone_landscape: bool = _is_phone_landscape(size)
	if is_phone_landscape:
		safe_area.add_theme_constant_override("margin_left", 10)
		safe_area.add_theme_constant_override("margin_right", 10)
		safe_area.add_theme_constant_override("margin_top", 8)
		safe_area.add_theme_constant_override("margin_bottom", 8)
		root_vbox.add_theme_constant_override("separation", 12)
		task_label.add_theme_font_size_override("font_size", 20)
		bits_label.add_theme_font_size_override("font_size", 24)
		oscillo_box.custom_minimum_size.y = clampf(size.y * 0.35, 150.0, 220.0)
		tuner_row.custom_minimum_size.y = 62.0
		bits_slider.custom_minimum_size.x = clampf(size.x * 0.30, 220.0, 340.0)
		buttons_row.add_theme_constant_override("separation", 16)
		hint_button.custom_minimum_size = Vector2(150, 52)
		confirm_button.custom_minimum_size = Vector2(170, 52)
		hint_label.custom_minimum_size.y = 40.0
	else:
		safe_area.add_theme_constant_override("margin_left", 16)
		safe_area.add_theme_constant_override("margin_right", 16)
		safe_area.add_theme_constant_override("margin_top", 12)
		safe_area.add_theme_constant_override("margin_bottom", 12)
		root_vbox.add_theme_constant_override("separation", 20)
		task_label.add_theme_font_size_override("font_size", 24)
		bits_label.add_theme_font_size_override("font_size", 32)
		oscillo_box.custom_minimum_size.y = 280.0
		tuner_row.custom_minimum_size.y = 80.0
		bits_slider.custom_minimum_size.x = 400.0
		buttons_row.add_theme_constant_override("separation", 40)
		hint_button.custom_minimum_size = Vector2(200, 60)
		confirm_button.custom_minimum_size = Vector2(200, 60)
		hint_label.custom_minimum_size.y = 50.0
	call_deferred("_draw_signal")

func _is_phone_landscape(size: Vector2) -> bool:
	return size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

func _draw_signal():
	if not is_instance_valid(oscillo_area):
		return
	var size = oscillo_area.size
	if size.x <= 1 or size.y <= 1:
		return

	var chosen_i = int(bits_slider.value)
	var capacity = int(pow(2.0, chosen_i))
	var correct = capacity >= current_n
	var overkill = correct and chosen_i > i_min

	var noise_strength = 0.0
	if not correct:
		noise_strength = MAX_NOISE
	elif overkill:
		noise_strength = MAX_NOISE * 0.12
	else:
		noise_strength = 0.0

	var points := PackedVector2Array()
	points.resize(POINT_COUNT)
	var mid_y = size.y * 0.5
	var amp = size.y * 0.35
	for i in range(POINT_COUNT):
		var t = float(i) / float(POINT_COUNT - 1)
		var x = t * size.x
		var y = mid_y + sin(t * TAU * 2.0 + _phase) * amp
		if noise_strength > 0.0:
			y += randf_range(-noise_strength, noise_strength)
		points[i] = Vector2(x, y)

	osc_line.points = points
</file>

<file path="scripts/ui/ConfigCard.gd">
extends PanelContainer

signal selected(option_id: String)

const COLOR_BASE := Color(1.0, 1.0, 1.0, 1.0)
const COLOR_SELECTED := Color(1.08, 1.08, 1.08, 1.0)
const COLOR_BUDGET_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_BUDGET_BAD := Color(0.93, 0.34, 0.38, 1.0)

var option_id: String = ""
var total_price: int = 0
var budget_limit: int = 0
var _locked: bool = false

@onready var title_label: Label = _resolve_label("VBox/Title")
@onready var price_label: Label = _resolve_label("VBox/Price")
@onready var parts_label: Label = _resolve_label("VBox/Parts", "VBox/Детали")
@onready var tags_label: Label = _resolve_label("VBox/Tags", "VBox/Теги")

func _resolve_label(primary_path: String, fallback_path: String = "") -> Label:
	var node: Node = get_node_or_null(primary_path)
	if node == null and fallback_path != "":
		node = get_node_or_null(fallback_path)
	return node as Label

func setup(option_data: Dictionary, budget: int) -> void:
	option_id = str(option_data.get("option_id", ""))
	total_price = int(option_data.get("total_price", 0))
	budget_limit = budget

	if is_instance_valid(title_label):
		title_label.text = str(option_data.get("title", option_id))
	if is_instance_valid(price_label):
		price_label.text = "Бюджет: %d$" % total_price
		price_label.modulate = COLOR_BUDGET_BAD if total_price > budget_limit else COLOR_BUDGET_OK
	
	var parts_lines: Array[String] = []
	var parts: Array = option_data.get("parts", []) as Array
	for part_v in parts:
		if typeof(part_v) != TYPE_DICTIONARY:
			continue
		var part: Dictionary = part_v as Dictionary
		parts_lines.append("%s: %s (%s$)" % [str(part.get("k", "?")), str(part.get("v", "?")), str(part.get("price", 0))])
	if is_instance_valid(parts_label):
		parts_label.text = "\n".join(parts_lines)

	var tags: Array = option_data.get("tags", []) as Array
	var tags_text: String = ""
	for tag_v in tags:
		if tags_text != "":
			tags_text += "  |  "
		tags_text += str(tag_v)
	if is_instance_valid(tags_label):
		tags_label.text = tags_text

func set_selected_state(is_selected: bool) -> void:
	modulate = COLOR_SELECTED if is_selected else COLOR_BASE

func set_locked(locked: bool) -> void:
	_locked = locked

func _gui_input(event: InputEvent) -> void:
	if _locked:
		return
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event as InputEventMouseButton
		if mouse_event.pressed and mouse_event.button_index == MOUSE_BUTTON_LEFT:
			accept_event()
			selected.emit(option_id)
	elif event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event as InputEventScreenTouch
		if touch_event.pressed:
			accept_event()
			selected.emit(option_id)
</file>

<file path="scenes/LearnSelect.tscn">
[gd_scene load_steps=4 format=3 uid="uid://d2r81qjl2u0td"]

[ext_resource type="Script" path="res://scenes/LearnSelect.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="LearnSelect" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.04, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 24
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 24
theme_override_constants/margin_bottom = 16

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 20
alignment = 1

[node name="Title" type="Label" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_font_sizes/font_size = 58
text = "ОБУЧЕНИЕ"
horizontal_alignment = 1

[node name="QuestGrid" type="GridContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/h_separation = 14
theme_override_constants/v_separation = 14
columns = 3

[node name="CluesButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Цифровая реанимация"

[node name="RadioButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Радиоперехват A"

[node name="DecryptorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Дешифрование A"

[node name="LieDetectorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Детектор лжи A"

[node name="SuspectScriptButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Скрипт подозреваемого"

[node name="CityMapButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Карта города"

[node name="DataArchiveButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Архив данных"

[node name="FinalReportButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Финальный отчет"

[node name="NetworkTraceButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Сетевой след"

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Выберите учебный модуль"
horizontal_alignment = 1
vertical_alignment = 1
</file>

<file path="scenes/LogicQuestC.gd">
extends Control

const MAX_ATTEMPTS := 3

const CASES := [
	{
		"id": "C_01",
		"story": "Упростите формулу без изменения смысла: A AND (B OR C).",
		"vars": ["A", "B", "C"],
		"expr_start": ["OR", ["AND", "A", "B"], ["AND", "A", "C"]],
		"target_gates": 3,
		"options": [
			{
				"label": "A ∧ (B ∨ C)",
				"expr": ["AND", "A", ["OR", "B", "C"]],
				"explain": "Дистрибутивность: A∧B ∨ A∧C = A∧(B∨C)."
			},
			{
				"label": "(A ∨ B) ∧ C",
				"expr": ["AND", ["OR", "A", "B"], "C"],
				"explain": "Порядок переменных изменен некорректно."
			},
			{
				"label": "A ∨ (B ∧ C)",
				"expr": ["OR", "A", ["AND", "B", "C"]],
				"explain": "Это другая формула, не эквивалентная исходной."
			}
		]
	},
	{
		"id": "C_02",
		"story": "Проверьте поглощение: A OR (A AND B).",
		"vars": ["A", "B"],
		"expr_start": ["OR", "A", ["AND", "A", "B"]],
		"target_gates": 1,
		"options": [
			{
				"label": "A",
				"expr": "A",
				"explain": "Закон поглощения: A ∨ (A ∧ B) = A."
			},
			{
				"label": "A ∧ B",
				"expr": ["AND", "A", "B"],
				"explain": "Слишком сильное ограничение."
			},
			{
				"label": "A ∨ B",
				"expr": ["OR", "A", "B"],
				"explain": "Добавляет лишние истинные случаи."
			}
		]
	},
	{
		"id": "C_03",
		"story": "Примените закон де Моргана к NOT(A AND B).",
		"vars": ["A", "B"],
		"expr_start": ["NOT", ["AND", "A", "B"]],
		"target_gates": 3,
		"options": [
			{
				"label": "¬A ∨ ¬B",
				"expr": ["OR", ["NOT", "A"], ["NOT", "B"]],
				"explain": "Корректный закон де Моргана."
			},
			{
				"label": "¬A ∧ ¬B",
				"expr": ["AND", ["NOT", "A"], ["NOT", "B"]],
				"explain": "Это форма для NOT(A OR B), а не для AND."
			},
			{
				"label": "A ∨ B",
				"expr": ["OR", "A", "B"],
				"explain": "Инверсия полностью потеряна."
			}
		]
	},
	{
		"id": "C_04",
		"story": "Сократите двойное отрицание: NOT(NOT(A)).",
		"vars": ["A"],
		"expr_start": ["NOT", ["NOT", "A"]],
		"target_gates": 0,
		"options": [
			{
				"label": "A",
				"expr": "A",
				"explain": "Двойное отрицание убирается: ¬¬A = A."
			},
			{
				"label": "¬A",
				"expr": ["NOT", "A"],
				"explain": "Инверсия осталась, это другая формула."
			},
			{
				"label": "0",
				"expr": false,
				"explain": "Константа 0 не эквивалентна переменной A."
			}
		]
	}
]

@onready var clue_title_label: Label = $SafeArea/MainLayout/Header/LblClueTitle
@onready var session_label: Label = $SafeArea/MainLayout/Header/LblSessionId
@onready var facts_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/FactsBar
@onready var energy_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/EnergyBar
@onready var target_label: Label = $SafeArea/MainLayout/TargetDisplay/LblTarget
@onready var terminal_text: RichTextLabel = $SafeArea/MainLayout/TerminalFrame/TerminalScroll/TerminalRichText
@onready var stats_label: Label = $SafeArea/MainLayout/StatusRow/StatsLabel
@onready var feedback_label: Label = $SafeArea/MainLayout/StatusRow/FeedbackLabel

@onready var expr_value_label: RichTextLabel = $SafeArea/MainLayout/InteractionRow/ExprSlot/ExprVBox/ExprValue
@onready var patch_value_label: Label = $SafeArea/MainLayout/InteractionRow/PatchSlot/PatchVBox/PatchValue
@onready var load_bar: ProgressBar = $SafeArea/MainLayout/InteractionRow/LoadSlot/LoadVBox/LoadBar
@onready var load_label: Label = $SafeArea/MainLayout/InteractionRow/LoadSlot/LoadVBox/LoadLabel
@onready var patch_container: VBoxContainer = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/PatchContainer

@onready var btn_hint: Button = $SafeArea/MainLayout/Actions/BtnHint
@onready var btn_scan: Button = $SafeArea/MainLayout/Actions/BtnScan
@onready var btn_next: Button = $SafeArea/MainLayout/Actions/BtnNext
@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack

@onready var diagnostics_blocker: ColorRect = $DiagnosticsBlocker
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanelC
@onready var diagnostics_title: Label = $DiagnosticsPanelC/PopupMargin/PopupVBox/PopupTitle
@onready var diagnostics_text: RichTextLabel = $DiagnosticsPanelC/PopupMargin/PopupVBox/PopupText
@onready var diagnostics_next_button: Button = $DiagnosticsPanelC/PopupMargin/PopupVBox/PopupBtnNext
@onready var click_player: AudioStreamPlayer = $ClickPlayer

var current_case_idx: int = 0
var current_case: Dictionary = {}
var attempts: int = 0
var hints_used: int = 0
var scan_count: int = 0
var selected_option_idx: int = -1
var is_complete: bool = false
var is_safe_mode: bool = false
var is_locked: bool = false
var case_started_ms: int = 0
var first_action_ms: int = -1
var patch_press_count: int = 0
var trace_lines: Array[String] = []
var patch_buttons: Array[Button] = []

func _ready() -> void:
	_connect_ui_signals()
	_update_stability_ui(GlobalMetrics.stability, 0.0)
	if not GlobalMetrics.stability_changed.is_connected(_update_stability_ui):
		GlobalMetrics.stability_changed.connect(_update_stability_ui)
	if not GlobalMetrics.game_over.is_connected(_on_game_over):
		GlobalMetrics.game_over.connect(_on_game_over)
	load_case(0)

func _connect_ui_signals() -> void:
	if not btn_back.pressed.is_connected(_on_back_pressed):
		btn_back.pressed.connect(_on_back_pressed)
	if not btn_hint.pressed.is_connected(_on_hint_pressed):
		btn_hint.pressed.connect(_on_hint_pressed)
	if not btn_scan.pressed.is_connected(_on_scan_pressed):
		btn_scan.pressed.connect(_on_scan_pressed)
	if not btn_next.pressed.is_connected(_on_next_pressed):
		btn_next.pressed.connect(_on_next_pressed)
	if not diagnostics_next_button.pressed.is_connected(_on_diagnostics_close_pressed):
		diagnostics_next_button.pressed.connect(_on_diagnostics_close_pressed)

func load_case(idx: int) -> void:
	if idx >= CASES.size():
		idx = 0

	current_case_idx = idx
	current_case = CASES[idx]
	attempts = 0
	hints_used = 0
	scan_count = 0
	selected_option_idx = -1
	is_complete = false
	is_safe_mode = false
	is_locked = false
	case_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	patch_press_count = 0
	trace_lines.clear()

	clue_title_label.text = "ДЕТЕКТОР ЛЖИ C-01"
	btn_hint.disabled = false
	btn_scan.disabled = true
	btn_next.visible = false
	feedback_label.visible = false
	feedback_label.text = ""
	_hide_diagnostics()

	expr_value_label.text = "[b]%s[/b]" % _format_expr(current_case.get("expr_start"))
	patch_value_label.text = "PATCH: EMPTY"
	var base_load := count_gates(current_case.get("expr_start"))
	load_bar.max_value = maxi(base_load, int(current_case.get("target_gates", 0))) + 2
	load_bar.value = base_load
	load_label.text = "LOAD: %d / %d" % [base_load, int(current_case.get("target_gates", 0))]
	_create_patch_buttons()

	_append_trace("Сценарий загружен. Выберите патч и запустите СКАН.")
	_update_terminal()
	_update_ui_state()
	_update_stats_ui()

func _create_patch_buttons() -> void:
	for child in patch_container.get_children():
		child.queue_free()
	patch_buttons.clear()

	var options: Array = current_case.get("options", [])
	for i in range(options.size()):
		var option: Dictionary = options[i]
		var btn := Button.new()
		btn.custom_minimum_size = Vector2(0, 64)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.text = str(option.get("label", "PATCH"))
		btn.pressed.connect(_on_patch_pressed.bind(i))
		patch_container.add_child(btn)
		patch_buttons.append(btn)

func _on_patch_pressed(option_idx: int) -> void:
	if is_complete or is_safe_mode or is_locked:
		return
	_mark_first_action()
	selected_option_idx = option_idx
	patch_press_count += 1

	for i in range(patch_buttons.size()):
		patch_buttons[i].add_theme_color_override("font_color", Color(0.95, 0.95, 0.90, 1.0) if i == option_idx else Color(0.74, 0.74, 0.70, 1.0))

	var option: Dictionary = current_case.get("options", [])[option_idx]
	patch_value_label.text = "PATCH: %s" % str(option.get("label", ""))
	_append_trace("PATCH SELECTED: %s" % str(option.get("label", "")))
	_show_feedback("Патч выбран. Запустите СКАН.", Color(0.56, 0.78, 0.96))
	btn_scan.disabled = false
	_update_terminal()
	_update_ui_state()
	_play_click()

func _on_scan_pressed() -> void:
	if is_complete or is_safe_mode or is_locked:
		return
	if selected_option_idx < 0:
		return
	_mark_first_action()
	scan_count += 1

	var option: Dictionary = current_case.get("options", [])[selected_option_idx]
	var start_expr: Variant = current_case.get("expr_start")
	var selected_expr: Variant = option.get("expr")
	var vars: Array = current_case.get("vars", [])
	var eq_result: Dictionary = equivalent(start_expr, selected_expr, vars)

	_append_trace("SCAN #%d: %s" % [scan_count, str(option.get("label", ""))])

	if bool(eq_result.get("ok", false)):
		is_complete = true
		btn_next.visible = true
		btn_hint.disabled = true
		btn_scan.disabled = true
		for btn in patch_buttons:
			btn.disabled = true

		var new_load := count_gates(selected_expr)
		load_bar.value = new_load
		load_label.text = "LOAD: %d / %d" % [new_load, int(current_case.get("target_gates", 0))]
		expr_value_label.text = "[b]%s[/b]" % _format_expr(selected_expr)
		_show_feedback("EQUIVALENT: патч принят.", Color(0.45, 0.92, 0.62))
		_append_trace("RESULT: EQUIVALENT ✅")
		_register_trial("SUCCESS", true, {
			"selected_label": str(option.get("label", "")),
			"new_load": new_load,
			"target_load": int(current_case.get("target_gates", 0))
		})
	else:
		attempts += 1
		var penalty := 15.0 + float(attempts * 5)
		_apply_penalty(penalty)
		var counterexample: Dictionary = eq_result.get("counterexample", {})
		_show_feedback("NOT EQUIVALENT: найден контрпример (-%d)." % int(penalty), Color(1.0, 0.35, 0.32))
		_append_trace("RESULT: NOT EQUIVALENT ❌ %s | orig=%d new=%d" % [
			_format_counterexample(counterexample),
			1 if bool(eq_result.get("orig", false)) else 0,
			1 if bool(eq_result.get("new", false)) else 0
		])
		_register_trial("NOT_EQUIVALENT", false, {
			"selected_label": str(option.get("label", "")),
			"counterexample": counterexample,
			"orig_value": bool(eq_result.get("orig", false)),
			"new_value": bool(eq_result.get("new", false))
		})
		if attempts >= MAX_ATTEMPTS:
			_enter_safe_mode()
		else:
			_lock_controls(1.2)

	_update_terminal()
	_update_ui_state()
	_update_stats_ui()
	_play_click()

func _on_hint_pressed() -> void:
	if is_complete or is_safe_mode:
		return
	_mark_first_action()
	hints_used += 1
	_apply_penalty(5.0)

	var correct_idx := _find_correct_option_idx()
	if correct_idx >= 0:
		var option: Dictionary = current_case.get("options", [])[correct_idx]
		_show_feedback("Подсказка: ориентируйтесь на %s..." % str(option.get("label", "")).substr(0, 8), Color(0.56, 0.78, 0.96))
	else:
		_show_feedback("Подсказка недоступна.", Color(0.66, 0.66, 0.66))
	_append_trace("HINT: -5 stability.")
	_update_terminal()
	_update_ui_state()
	_update_stats_ui()

func _enter_safe_mode() -> void:
	is_safe_mode = true
	is_complete = true
	btn_next.visible = true
	btn_hint.disabled = true
	btn_scan.disabled = true

	var correct_idx := _find_correct_option_idx()
	if correct_idx >= 0:
		selected_option_idx = correct_idx
		for i in range(patch_buttons.size()):
			patch_buttons[i].disabled = true
			patch_buttons[i].add_theme_color_override("font_color", Color(0.45, 0.92, 0.62, 1.0) if i == correct_idx else Color(0.60, 0.60, 0.58, 1.0))
		var correct_option: Dictionary = current_case.get("options", [])[correct_idx]
		patch_value_label.text = "PATCH: %s" % str(correct_option.get("label", ""))
		_append_trace("SAFE MODE: правильный патч %s" % str(correct_option.get("label", "")))
		_show_feedback("SAFE MODE: правильный патч подставлен.", Color(1.0, 0.74, 0.32))
		_show_diagnostics("SAFE MODE", "Обнаружено превышение порога ошибок.\nПравильный патч подсвечен, изучите разбор и переходите далее.")
	else:
		for btn in patch_buttons:
			btn.disabled = true
		_show_feedback("SAFE MODE: патч заблокирован.", Color(1.0, 0.74, 0.32))

	_update_terminal()
	_update_ui_state()
	_update_stats_ui()

func _lock_controls(seconds: float) -> void:
	is_locked = true
	btn_scan.disabled = true
	var timer := get_tree().create_timer(seconds)
	await timer.timeout
	if is_complete or is_safe_mode:
		return
	is_locked = false
	btn_scan.disabled = selected_option_idx < 0

func _find_correct_option_idx() -> int:
	var options: Array = current_case.get("options", [])
	for i in range(options.size()):
		var option: Dictionary = options[i]
		var result: Dictionary = equivalent(current_case.get("expr_start"), option.get("expr"), current_case.get("vars", []))
		if bool(result.get("ok", false)):
			return i
	return -1

func _format_counterexample(env: Dictionary) -> String:
	if env.is_empty():
		return "N/A"
	var keys := env.keys()
	keys.sort()
	var parts: Array[String] = []
	for key in keys:
		parts.append("%s=%d" % [str(key), 1 if bool(env[key]) else 0])
	return ", ".join(parts)

func eval_expr(expr: Variant, env: Dictionary) -> bool:
	if typeof(expr) == TYPE_BOOL:
		return bool(expr)
	if typeof(expr) == TYPE_STRING:
		return bool(env.get(expr, false))
	if typeof(expr) == TYPE_ARRAY:
		var arr: Array = expr
		var op := str(arr[0])
		match op:
			"AND":
				for i in range(1, arr.size()):
					if not eval_expr(arr[i], env):
						return false
				return true
			"OR":
				for i in range(1, arr.size()):
					if eval_expr(arr[i], env):
						return true
				return false
			"NOT":
				return not eval_expr(arr[1], env)
			"XOR":
				return eval_expr(arr[1], env) != eval_expr(arr[2], env)
	return false

func count_gates(expr: Variant) -> int:
	if typeof(expr) != TYPE_ARRAY:
		return 0
	var arr: Array = expr
	var total := 1
	for i in range(1, arr.size()):
		total += count_gates(arr[i])
	return total

func equivalent(expr1: Variant, expr2: Variant, vars: Array) -> Dictionary:
	var combinations := 1 << vars.size()
	for i in range(combinations):
		var env := {}
		for bit in range(vars.size()):
			env[vars[bit]] = (i & (1 << bit)) != 0
		var val1 := eval_expr(expr1, env)
		var val2 := eval_expr(expr2, env)
		if val1 != val2:
			return {"ok": false, "counterexample": env, "orig": val1, "new": val2}
	return {"ok": true}

func _format_expr(expr: Variant) -> String:
	if typeof(expr) == TYPE_STRING:
		return str(expr)
	if typeof(expr) == TYPE_BOOL:
		return "1" if bool(expr) else "0"
	if typeof(expr) == TYPE_ARRAY:
		var arr: Array = expr
		var op := str(arr[0])
		match op:
			"NOT":
				return "¬%s" % _format_expr_sub(arr[1])
			"AND":
				var parts_and: Array[String] = []
				for i in range(1, arr.size()):
					parts_and.append(_format_expr_sub(arr[i]))
				return " ∧ ".join(parts_and)
			"OR":
				var parts_or: Array[String] = []
				for i in range(1, arr.size()):
					parts_or.append(_format_expr_sub(arr[i]))
				return " ∨ ".join(parts_or)
			"XOR":
				return "%s ⊕ %s" % [_format_expr_sub(arr[1]), _format_expr_sub(arr[2])]
	return "?"

func _format_expr_sub(expr: Variant) -> String:
	if typeof(expr) == TYPE_ARRAY and str((expr as Array)[0]) != "NOT":
		return "(%s)" % _format_expr(expr)
	return _format_expr(expr)

func _append_trace(line: String) -> void:
	trace_lines.append(line)
	if trace_lines.size() > 12:
		trace_lines.remove_at(0)

func _update_terminal() -> void:
	var lines: Array[String] = []
	lines.append("[b]БРИФИНГ[/b]")
	lines.append(str(current_case.get("story", "")))
	lines.append("")
	lines.append("[b]TRACE[/b]")
	if trace_lines.is_empty():
		lines.append("• ЖУРНАЛ ПУСТ")
	else:
		for i in range(trace_lines.size()):
			var row := "• " + trace_lines[i]
			if i == trace_lines.size() - 1:
				row = "[color=#f4f2e6]> %s[/color]" % row
			lines.append(row)
	terminal_text.text = "\n".join(lines)

func _show_feedback(msg: String, col: Color) -> void:
	feedback_label.text = msg
	feedback_label.add_theme_color_override("font_color", col)
	feedback_label.visible = true

func _update_ui_state() -> void:
	if is_complete:
		target_label.text = "ШАГ 3/3: проверка завершена, переходите далее"
		facts_bar.value = 100.0
	elif selected_option_idx < 0:
		target_label.text = "ШАГ 1/3: выберите патч в инвентаре"
		facts_bar.value = 0.0
	else:
		target_label.text = "ШАГ 2/3: нажмите СКАН для проверки эквивалентности"
		facts_bar.value = 50.0
	energy_bar.value = clampf(GlobalMetrics.stability, 0.0, 100.0)
	btn_scan.disabled = is_complete or is_safe_mode or is_locked or selected_option_idx < 0

func _update_stats_ui() -> void:
	var case_id := str(current_case.get("id", "C_00"))
	session_label.text = "СЕССИЯ: %02d/%02d • CASE %s" % [current_case_idx + 1, CASES.size(), case_id]
	stats_label.text = "ПОП: %d/%d • СКАНЫ: %d • СТАБ: %d%%" % [
		attempts,
		MAX_ATTEMPTS,
		scan_count,
		int(GlobalMetrics.stability)
	]

func _apply_penalty(amount: float) -> void:
	GlobalMetrics.stability = max(0.0, GlobalMetrics.stability - amount)
	GlobalMetrics.stability_changed.emit(GlobalMetrics.stability, -amount)

func _update_stability_ui(val: float, _diff: float) -> void:
	energy_bar.value = clampf(val, 0.0, 100.0)
	_update_stats_ui()

func _show_diagnostics(title: String, message: String) -> void:
	diagnostics_title.text = title
	diagnostics_text.text = message
	diagnostics_blocker.visible = true
	diagnostics_panel.visible = true
	diagnostics_next_button.grab_focus()

func _hide_diagnostics() -> void:
	diagnostics_blocker.visible = false
	diagnostics_panel.visible = false

func _on_diagnostics_close_pressed() -> void:
	_hide_diagnostics()

func _on_next_pressed() -> void:
	_hide_diagnostics()
	load_case(current_case_idx + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_game_over() -> void:
	_enter_safe_mode()

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - case_started_ms

func _register_trial(verdict_code: String, is_correct: bool, extra: Dictionary = {}) -> void:
	var case_id := str(current_case.get("id", "C_00"))
	var variant_hash := str(hash(JSON.stringify(current_case.get("expr_start", []))))
	var payload := TrialV2.build("LOGIC_QUEST", "C", case_id, "PATCH_SCAN", variant_hash)
	var elapsed_ms := maxi(0, Time.get_ticks_msec() - case_started_ms)
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_correct
	payload["is_fit"] = is_correct
	payload["stability_delta"] = 0
	payload["verdict_code"] = verdict_code
	payload["attempts"] = attempts
	payload["hints_used"] = hints_used
	payload["scan_count"] = scan_count
	payload["patch_press_count"] = patch_press_count
	payload["selected_option_idx"] = selected_option_idx
	for key in extra.keys():
		payload[key] = extra[key]
	GlobalMetrics.register_trial(payload)

func _play_click() -> void:
	if click_player.stream:
		click_player.play()
</file>

<file path="scenes/NetworkTraceQuestA.tscn">
[gd_scene load_steps=5 format=3 uid="uid://dnn0a5mgt8u1a"]

[ext_resource type="Script" path="res://scripts/quests/network_trace/NetworkTraceQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="3_diag_panel"]
[ext_resource type="Script" path="res://scripts/ui/network_trace/topology_board_a.gd" id="4_topology"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="5_noir"]

[node name="NetworkTraceQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("5_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="Main" type="MarginContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="V" type="VBoxContainer" parent="SafeArea/Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/Main/V"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "НАЗАД"

[node name="LblTitle" type="Label" parent="SafeArea/Main/V/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 26
text = "СЕТЕВОЙ СЛЕД | A"

[node name="LblMeta" type="Label" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(360, 48)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ДЕЛО -- | ОШ 0/3 | 02:00"
horizontal_alignment = 2
vertical_alignment = 1

[node name="PaletteSelect" type="OptionButton" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(150, 52)
layout_mode = 2

[node name="Body" type="BoxContainer" parent="SafeArea/Main/V"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="TerminalPane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.55

[node name="TerminalMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/TerminalPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="TerminalV" type="VBoxContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblBriefing" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 84)
layout_mode = 2
fit_content = false
bbcode_enabled = true
scroll_active = false

[node name="LblPrompt" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 76)
layout_mode = 2
fit_content = false
bbcode_enabled = true
scroll_active = false

[node name="LogScroll" type="ScrollContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
size_flags_vertical = 3

[node name="LogList" type="VBoxContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="EvidenceLabel" type="Label" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "УЛИКИ"

[node name="EvidenceRow" type="HBoxContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 66)
layout_mode = 2
theme_override_constants/separation = 6

[node name="MapPane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.15

[node name="MapMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/MapPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="MapV" type="VBoxContainer" parent="SafeArea/Main/V/Body/MapPane/MapMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="TopologyBoard" type="Control" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 240)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("4_topology")

[node name="PaletteLabel" type="Label" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ПАЛИТРА УСТРОЙСТВ"

[node name="PaletteScroll" type="ScrollContainer" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 94)
layout_mode = 2
horizontal_scroll_mode = 1
vertical_scroll_mode = 0

[node name="Palette" type="HBoxContainer" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV/PaletteScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 8

[node name="Actions" type="HBoxContainer" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnAnalyze" type="Button" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "АНАЛИЗ"

[node name="BtnRunTrace" type="Button" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ЗАПУСТИТЬ ТРАССИРОВКУ"

[node name="BtnReset" type="Button" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "СБРОС"

[node name="BtnNext" type="Button" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
visible = false
text = "ДАЛЕЕ"

[node name="LblStatus" type="Label" parent="SafeArea/Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Статус"

[node name="DiagnosticsPanel" parent="." instance=ExtResource("3_diag_panel")]
layout_mode = 1
anchor_left = 0.1
anchor_top = 0.12
anchor_right = 0.9
anchor_bottom = 0.9
</file>

<file path="scripts/ui/DropZone.gd">
extends PanelContainer

signal block_dropped(block_data)

var required_type: String = "INT"
var current_block_data = null
var last_prev_block_id = null
var breathing_tween: Tween

@onready var lbl_hint = $Label

func _ready():
	_start_breathing()

func setup(type: String):
	required_type = type
	_reset_state()

func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	# Ensure the data is a dictionary and has the right type
	if typeof(data) == TYPE_DICTIONARY and data.get("kind") == "CODE_BLOCK":
		return data.get("slot_type") == required_type
	return false

func _drop_data(at_position: Vector2, data: Variant) -> void:
	# Stop breathing
	if breathing_tween:
		breathing_tween.kill()

	last_prev_block_id = get_block_id()
	current_block_data = data
	lbl_hint.text = str(data.get("label", "ОШИБКА"))

	# Snapping Effect
	modulate = Color(1, 1, 1, 1) # Full opaque
	var tween = create_tween()
	tween.tween_property(self, "scale", Vector2(1.1, 1.1), 0.1)
	tween.tween_property(self, "scale", Vector2(1.0, 1.0), 0.1)

	block_dropped.emit(data)

func _start_breathing():
	if breathing_tween:
		breathing_tween.kill()

	modulate = Color(1, 1, 1, 0.7)
	breathing_tween = create_tween().set_loops()
	breathing_tween.tween_property(self, "modulate:a", 1.0, 1.0)
	breathing_tween.tween_property(self, "modulate:a", 0.6, 1.0)

func _reset_state():
	current_block_data = null
	last_prev_block_id = null
	lbl_hint.text = "[СЛОТ]"
	_start_breathing()

func reset() -> void:
	_reset_state()

func get_block_id():
	if current_block_data:
		return current_block_data.get("block_id")
	return null

func get_block_data():
	if current_block_data == null:
		return null
	return current_block_data.duplicate(true)

func get_last_prev_block_id():
	return last_prev_block_id
</file>

<file path="scripts/ui/FixMenuC.gd">
extends PopupPanel

signal option_selected(option_id: String)
signal apply_requested(option_id: String)
signal canceled

@onready var lbl_title: Label = $Root/LblTitle
@onready var lbl_original: Label = $Root/LblOriginal
@onready var btn_opt_a: Button = $Root/Options/BtnOptA
@onready var btn_opt_b: Button = $Root/Options/BtnOptB
@onready var btn_opt_c: Button = $Root/Options/BtnOptC
@onready var btn_apply: Button = $Root/Actions/BtnApply
@onready var btn_close: Button = $Root/Actions/BtnClose

var selected_option_id := ""
var options_by_id: Dictionary = {}

func _normalize_option_id(value: Variant) -> String:
	return str(value).strip_edges().to_upper()

func _short_line(line_text: String, max_chars: int = 48) -> String:
	var clean := line_text.strip_edges()
	if clean.length() <= max_chars:
		return clean
	return clean.substr(0, max_chars - 3) + "..."

func _ready() -> void:
	btn_opt_a.pressed.connect(_on_option_pressed.bind("A"))
	btn_opt_b.pressed.connect(_on_option_pressed.bind("B"))
	btn_opt_c.pressed.connect(_on_option_pressed.bind("C"))
	btn_apply.pressed.connect(_on_apply_pressed)
	btn_close.pressed.connect(_on_close_pressed)
	btn_apply.disabled = true

func setup(line_number_1_based: int, original_line: String, fix_options: Array, preselected_option_id: String = "") -> void:
	lbl_title.text = "ИСПРАВИТЬ СТРОКУ %02d" % line_number_1_based
	lbl_original.text = "оригинал: %s" % _short_line(original_line, 64)

	options_by_id.clear()
	var option_buttons := {
		"A": btn_opt_a,
		"B": btn_opt_b,
		"C": btn_opt_c
	}
	var ordered_ids := ["A", "B", "C"]

	for option_id in ordered_ids:
		var btn: Button = option_buttons[option_id]
		btn.text = "%s) --" % option_id
		btn.disabled = true

	for opt_var in fix_options:
		if typeof(opt_var) != TYPE_DICTIONARY:
			continue
		var opt: Dictionary = opt_var
		var option_id := _normalize_option_id(opt.get("option_id", ""))
		if not option_buttons.has(option_id):
			continue
		options_by_id[option_id] = opt
		var btn: Button = option_buttons[option_id]
		btn.disabled = false
		btn.text = "%s) %s  ->  s=%s" % [
			option_id,
			_short_line(str(opt.get("replace_line", ""))),
			str(opt.get("result_s", "?"))
		]

	var normalized_preselected := _normalize_option_id(preselected_option_id)
	selected_option_id = normalized_preselected if options_by_id.has(normalized_preselected) else ""
	_refresh_selection_visuals()

func _on_option_pressed(option_id: String) -> void:
	var normalized_option_id := _normalize_option_id(option_id)
	if not options_by_id.has(normalized_option_id):
		return
	selected_option_id = normalized_option_id
	_refresh_selection_visuals()
	option_selected.emit(normalized_option_id)

func _refresh_selection_visuals() -> void:
	var map := {
		"A": btn_opt_a,
		"B": btn_opt_b,
		"C": btn_opt_c
	}
	for option_id in map.keys():
		var btn: Button = map[option_id]
		if option_id == selected_option_id:
			btn.modulate = Color(0.95, 0.95, 0.93, 1.0)
		else:
			btn.modulate = Color(0.78, 0.78, 0.76, 1.0)
	btn_apply.disabled = selected_option_id == ""

func _on_apply_pressed() -> void:
	if selected_option_id == "":
		return
	apply_requested.emit(selected_option_id)
	hide()

func _on_close_pressed() -> void:
	canceled.emit()
	hide()
</file>

<file path="scenes/LogicQuestB.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/LogicQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_u1woe"]

[node name="LogicQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_u1woe")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕТЕКТОР ЛЖИ B-01"

[node name="LblSessionId" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "СЕССИЯ: 00/00 • CASE B_00"
horizontal_alignment = 2

[node name="BarsRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="FactsBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="EnergyBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 100.0
show_percentage = false

[node name="TargetDisplay" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="LblTarget" type="Label" parent="SafeArea/MainLayout/TargetDisplay"]
layout_mode = 2
text = "ШАГ 1/3: выберите слот и установите 2 модуля"
horizontal_alignment = 1

[node name="TerminalFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="TerminalScroll" type="ScrollContainer" parent="SafeArea/MainLayout/TerminalFrame"]
layout_mode = 2

[node name="TerminalRichText" type="RichTextLabel" parent="SafeArea/MainLayout/TerminalFrame/TerminalScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "[b]БРИФИНГ[/b]"
fit_content = true

[node name="InteractionRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="InputAFrame" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(200, 96)
layout_mode = 2

[node name="InputAVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/InputAFrame"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InputATitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/InputAFrame/InputAVBox"]
layout_mode = 2
text = "ВХОД A"
horizontal_alignment = 1

[node name="InputA_Btn" type="Button" parent="SafeArea/MainLayout/InteractionRow/InputAFrame/InputAVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
toggle_mode = true
text = "A
[0]"

[node name="InputBFrame" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(200, 96)
layout_mode = 2

[node name="InputBVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/InputBFrame"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InputBTitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/InputBFrame/InputBVBox"]
layout_mode = 2
text = "ВХОД B"
horizontal_alignment = 1

[node name="InputB_Btn" type="Button" parent="SafeArea/MainLayout/InteractionRow/InputBFrame/InputBVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
toggle_mode = true
text = "B
[0]"

[node name="InputCFrame" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(200, 96)
layout_mode = 2

[node name="InputCVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/InputCFrame"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InputCTitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/InputCFrame/InputCVBox"]
layout_mode = 2
text = "ВХОД C"
horizontal_alignment = 1

[node name="InputC_Btn" type="Button" parent="SafeArea/MainLayout/InteractionRow/InputCFrame/InputCVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
toggle_mode = true
text = "C
[0]"

[node name="Slot1Frame" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(200, 96)
layout_mode = 2

[node name="Slot1VBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/Slot1Frame"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="Slot1Title" type="Label" parent="SafeArea/MainLayout/InteractionRow/Slot1Frame/Slot1VBox"]
layout_mode = 2
text = "SLOT 1"
horizontal_alignment = 1

[node name="Slot1SelectBtn" type="Button" parent="SafeArea/MainLayout/InteractionRow/Slot1Frame/Slot1VBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "УСТАНОВИТЬ
?"

[node name="Slot2Frame" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(200, 96)
layout_mode = 2

[node name="Slot2VBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/Slot2Frame"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="Slot2Title" type="Label" parent="SafeArea/MainLayout/InteractionRow/Slot2Frame/Slot2VBox"]
layout_mode = 2
text = "SLOT 2"
horizontal_alignment = 1

[node name="Slot2SelectBtn" type="Button" parent="SafeArea/MainLayout/InteractionRow/Slot2Frame/Slot2VBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "УСТАНОВИТЬ
?"

[node name="InterSlot" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(160, 96)
layout_mode = 2

[node name="InterVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/InterSlot"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InterTitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/InterSlot/InterVBox"]
layout_mode = 2
text = "INTER"
horizontal_alignment = 1

[node name="InterValueLabel" type="Label" parent="SafeArea/MainLayout/InteractionRow/InterSlot/InterVBox"]
layout_mode = 2
text = "I = 0"
horizontal_alignment = 1

[node name="OutputSlot" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(160, 96)
layout_mode = 2

[node name="OutputVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/OutputSlot"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="OutputTitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/OutputSlot/OutputVBox"]
layout_mode = 2
text = "OUTPUT"
horizontal_alignment = 1

[node name="OutputValueLabel" type="Label" parent="SafeArea/MainLayout/InteractionRow/OutputSlot/OutputVBox"]
layout_mode = 2
text = "F = 0"
horizontal_alignment = 1

[node name="InventoryFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.5

[node name="InventoryMargin" type="MarginContainer" parent="SafeArea/MainLayout/InventoryFrame"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="InventoryScroll" type="ScrollContainer" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin"]
layout_mode = 2

[node name="GatesContainer" type="HBoxContainer" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 14
alignment = 1

[node name="GateAndBtn" type="Button" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "∧ AND"

[node name="GateOrBtn" type="Button" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "∨ OR"

[node name="GateNotBtn" type="Button" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "¬ NOT"

[node name="GateXorBtn" type="Button" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "⊕ XOR"

[node name="GateNandBtn" type="Button" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "⊼ NAND"

[node name="GateNorBtn" type="Button" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "⊽ NOR"

[node name="StatusRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="StatsLabel" type="Label" parent="SafeArea/MainLayout/StatusRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ПОП: 0/3 • ТЕСТЫ: 0 • СТАБ: 100%"

[node name="FeedbackLabel" type="Label" parent="SafeArea/MainLayout/StatusRow"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
text = "..."
horizontal_alignment = 2

[node name="Actions" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnHint" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПОДСКАЗКА"

[node name="BtnTest" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРОВЕРИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/Actions"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="ClickPlayer" type="AudioStreamPlayer" parent="."]

[node name="DiagnosticsBlocker" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.45)

[node name="DiagnosticsPanelB" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -360.0
offset_top = -210.0
offset_right = 360.0
offset_bottom = 210.0
grow_horizontal = 2
grow_vertical = 2

[node name="PopupMargin" type="MarginContainer" parent="DiagnosticsPanelB"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="PopupVBox" type="VBoxContainer" parent="DiagnosticsPanelB/PopupMargin"]
layout_mode = 2
theme_override_constants/separation = 16

[node name="PopupTitle" type="Label" parent="DiagnosticsPanelB/PopupMargin/PopupVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 26
text = "SAFE MODE"
horizontal_alignment = 1

[node name="PopupText" type="RichTextLabel" parent="DiagnosticsPanelB/PopupMargin/PopupVBox"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Диагностический отчёт."
fit_content = true

[node name="PopupBtnNext" type="Button" parent="DiagnosticsPanelB/PopupMargin/PopupVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "ДАЛЕЕ"

[connection signal="pressed" from="DiagnosticsPanelB/PopupMargin/PopupVBox/PopupBtnNext" to="." method="_on_diagnostics_close_pressed"]
</file>

<file path="scenes/LogicQuestC.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/LogicQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_a03yj"]

[node name="LogicQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_a03yj")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕТЕКТОР ЛЖИ C-01"

[node name="LblSessionId" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "СЕССИЯ: 00/00 • CASE C_00"
horizontal_alignment = 2

[node name="BarsRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="FactsBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="EnergyBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 100.0
show_percentage = false

[node name="TargetDisplay" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="LblTarget" type="Label" parent="SafeArea/MainLayout/TargetDisplay"]
layout_mode = 2
text = "ШАГ 1/3: выберите патч"
horizontal_alignment = 1

[node name="TerminalFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="TerminalScroll" type="ScrollContainer" parent="SafeArea/MainLayout/TerminalFrame"]
layout_mode = 2

[node name="TerminalRichText" type="RichTextLabel" parent="SafeArea/MainLayout/TerminalFrame/TerminalScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "[b]БРИФИНГ[/b]"
fit_content = true

[node name="InteractionRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="ExprSlot" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(360, 108)
layout_mode = 2
size_flags_horizontal = 3

[node name="ExprVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/ExprSlot"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ExprTitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/ExprSlot/ExprVBox"]
layout_mode = 2
text = "CURRENT CONDITION"
horizontal_alignment = 1

[node name="ExprValue" type="RichTextLabel" parent="SafeArea/MainLayout/InteractionRow/ExprSlot/ExprVBox"]
layout_mode = 2
theme_override_font_sizes/normal_font_size = 24
bbcode_enabled = true
text = "[b]A[/b]"
fit_content = true

[node name="PatchSlot" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(360, 108)
layout_mode = 2
size_flags_horizontal = 3

[node name="PatchVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/PatchSlot"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="PatchTitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/PatchSlot/PatchVBox"]
layout_mode = 2
text = "PATCH SLOT"
horizontal_alignment = 1

[node name="PatchValue" type="Label" parent="SafeArea/MainLayout/InteractionRow/PatchSlot/PatchVBox"]
layout_mode = 2
text = "PATCH: EMPTY"
horizontal_alignment = 1

[node name="LoadSlot" type="PanelContainer" parent="SafeArea/MainLayout/InteractionRow"]
custom_minimum_size = Vector2(280, 108)
layout_mode = 2
size_flags_horizontal = 3

[node name="LoadVBox" type="VBoxContainer" parent="SafeArea/MainLayout/InteractionRow/LoadSlot"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LoadTitle" type="Label" parent="SafeArea/MainLayout/InteractionRow/LoadSlot/LoadVBox"]
layout_mode = 2
text = "LOAD"
horizontal_alignment = 1

[node name="LoadBar" type="ProgressBar" parent="SafeArea/MainLayout/InteractionRow/LoadSlot/LoadVBox"]
custom_minimum_size = Vector2(0, 16)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="LoadLabel" type="Label" parent="SafeArea/MainLayout/InteractionRow/LoadSlot/LoadVBox"]
layout_mode = 2
text = "LOAD: 0 / 0"
horizontal_alignment = 1

[node name="InventoryFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.55

[node name="InventoryMargin" type="MarginContainer" parent="SafeArea/MainLayout/InventoryFrame"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="InventoryScroll" type="ScrollContainer" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin"]
layout_mode = 2

[node name="PatchContainer" type="VBoxContainer" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="StatusRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="StatsLabel" type="Label" parent="SafeArea/MainLayout/StatusRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ПОП: 0/3 • СКАНЫ: 0 • СТАБ: 100%"

[node name="FeedbackLabel" type="Label" parent="SafeArea/MainLayout/StatusRow"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
text = "..."
horizontal_alignment = 2

[node name="Actions" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnHint" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПОДСКАЗКА"

[node name="BtnScan" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "СКАН"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/Actions"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="ClickPlayer" type="AudioStreamPlayer" parent="."]

[node name="DiagnosticsBlocker" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.45)

[node name="DiagnosticsPanelC" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -360.0
offset_top = -210.0
offset_right = 360.0
offset_bottom = 210.0
grow_horizontal = 2
grow_vertical = 2

[node name="PopupMargin" type="MarginContainer" parent="DiagnosticsPanelC"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="PopupVBox" type="VBoxContainer" parent="DiagnosticsPanelC/PopupMargin"]
layout_mode = 2
theme_override_constants/separation = 16

[node name="PopupTitle" type="Label" parent="DiagnosticsPanelC/PopupMargin/PopupVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 26
text = "SAFE MODE"
horizontal_alignment = 1

[node name="PopupText" type="RichTextLabel" parent="DiagnosticsPanelC/PopupMargin/PopupVBox"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Диагностический отчёт."
fit_content = true

[node name="PopupBtnNext" type="Button" parent="DiagnosticsPanelC/PopupMargin/PopupVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "ДАЛЕЕ"

[connection signal="pressed" from="DiagnosticsPanelC/PopupMargin/PopupVBox/PopupBtnNext" to="." method="_on_diagnostics_close_pressed"]
</file>

<file path="scenes/NetworkTraceQuestC.tscn">
[gd_scene load_steps=8 format=3]

[ext_resource type="Script" path="res://scripts/quests/network_trace/NetworkTraceQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="3_diag_panel"]
[ext_resource type="PackedScene" path="res://scenes/ui/subnet/LockIndicator.tscn" id="4_lock_indicator"]
[ext_resource type="PackedScene" path="res://scenes/ui/subnet/MaskOverlay.tscn" id="5_mask_overlay"]
[ext_resource type="PackedScene" path="res://scenes/ui/subnet/SubnetRuler.tscn" id="6_subnet_ruler"]
[ext_resource type="Script" path="res://scripts/ui/subnet/MaskDropTarget.gd" id="7_drop_target"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="8_noir"]

[node name="NetworkTraceQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("8_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="CanvasModulate" type="CanvasModulate" parent="."]
color = Color(0.9, 1, 0.94, 1)

[node name="Main" type="MarginContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="V" type="VBoxContainer" parent="SafeArea/Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/Main/V"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnBack" type="Button" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(118, 58)
layout_mode = 2
text = "НАЗАД"

[node name="LblTitle" type="Label" parent="SafeArea/Main/V/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "СЕТЕВОЙ СЛЕД | C"

[node name="LblMeta" type="Label" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(330, 52)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ДЕЛО -- | ОШ 0/3 | T-02:00"
horizontal_alignment = 2
vertical_alignment = 1

[node name="PaletteSelect" type="OptionButton" parent="SafeArea/Main/V/Header"]
custom_minimum_size = Vector2(132, 52)
layout_mode = 2

[node name="Body" type="BoxContainer" parent="SafeArea/Main/V"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="TerminalPane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.4

[node name="TerminalMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/TerminalPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="TerminalV" type="VBoxContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblBriefing" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="LblPrompt" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="TargetBox" type="VBoxContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="LblTargetIp" type="Label" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox"]
layout_mode = 2
text = "IP: --"

[node name="LblTargetCidr" type="Label" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox"]
layout_mode = 2
text = "CIDR: --"

[node name="LblTargetAsk" type="Label" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox"]
layout_mode = 2
text = "ЗАПРОС: --"

[node name="LogScroll" type="ScrollContainer" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LogText" type="RichTextLabel" parent="SafeArea/Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll"]
custom_minimum_size = Vector2(0, 180)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
fit_content = false
selection_enabled = true
autowrap_mode = 2

[node name="BoardPane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.25

[node name="BoardMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/BoardPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BoardV" type="VBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LockIndicator" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV" instance=ExtResource("4_lock_indicator")]
layout_mode = 2

[node name="BitBoard" type="VBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="RowIpLine" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblRowIp" type="Label" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowIpLine"]
custom_minimum_size = Vector2(62, 44)
layout_mode = 2
text = "IP"
vertical_alignment = 1

[node name="RowIp" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowIpLine"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="RowMaskLine" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblRowMask" type="Label" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine"]
custom_minimum_size = Vector2(62, 44)
layout_mode = 2
text = "МАСКА"
vertical_alignment = 1

[node name="MaskDropTarget" type="PanelContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
script = ExtResource("7_drop_target")

[node name="RowMask" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine/MaskDropTarget"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
offset_left = 6.0
offset_top = 4.0
offset_right = -6.0
offset_bottom = -4.0
theme_override_constants/separation = 4

[node name="RowResLine" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard"]
visible = false
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblRowRes" type="Label" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine"]
custom_minimum_size = Vector2(62, 44)
layout_mode = 2
text = "РЕЗУЛЬТАТ"
vertical_alignment = 1

[node name="RowRes" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="MaskTray" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="LblMaskTray" type="Label" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/MaskTray"]
custom_minimum_size = Vector2(94, 52)
layout_mode = 2
text = "МАСКА"
vertical_alignment = 1

[node name="MaskOverlay" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/MaskTray" instance=ExtResource("5_mask_overlay")]
layout_mode = 2

[node name="Ruler" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV" instance=ExtResource("6_subnet_ruler")]
layout_mode = 2

[node name="BoardActions" type="HBoxContainer" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnAnalyze" type="Button" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "АНАЛИЗ"

[node name="BtnApplyAnd" type="Button" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРИМЕНИТЬ И"

[node name="BtnReset" type="Button" parent="SafeArea/Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="AnswersPane" type="PanelContainer" parent="SafeArea/Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="AnswersMargin" type="MarginContainer" parent="SafeArea/Main/V/Body/AnswersPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="AnswersV" type="VBoxContainer" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="OptionsGrid" type="GridContainer" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="ActionBtn1" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn2" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn3" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn4" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn5" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn6" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="LblStatus" type="Label" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Статус"

[node name="BottomRow" type="HBoxContainer" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnNext" type="Button" parent="SafeArea/Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
visible = false
text = "ДАЛЕЕ"

[node name="DiagnosticsPanel" parent="." instance=ExtResource("3_diag_panel")]
layout_mode = 1
anchor_left = 0.1
anchor_top = 0.12
anchor_right = 0.9
anchor_bottom = 0.9
</file>

<file path="scenes/QuestSelect.tscn">
[gd_scene load_steps=6 format=3 uid="uid://c6l2jvi53qwcf"]

[ext_resource type="Script" path="res://scenes/QuestSelect.gd" id="1_script"]
[ext_resource type="Shader" path="res://scenes/Blur.gdshader" id="2_shader"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="3_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="4_noir"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_1"]
shader = ExtResource("2_shader")
shader_parameter/lod = 2.5
shader_parameter/modulate = Color(0, 0, 0, 0.82)

[node name="QuestSelect" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("3_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.04, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("4_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 24
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 24
theme_override_constants/margin_bottom = 16

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 20
alignment = 1

[node name="Title" type="Label" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_font_sizes/font_size = 58
text = "ВЫБОР КВЕСТА"
horizontal_alignment = 1

[node name="QuestGrid" type="GridContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/h_separation = 14
theme_override_constants/v_separation = 14
columns = 3

[node name="CluesButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Цифровая реанимация"

[node name="RadioButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Радиоперехват"

[node name="DecryptorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Дешифрование"

[node name="LieDetectorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Детектор лжи"

[node name="SuspectScriptButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Скрипт подозреваемого"

[node name="CityMapButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Карта города"

[node name="DataArchiveButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Архив данных"

[node name="FinalReportButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Финальный отчет"

[node name="NetworkTraceButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Сетевой след"

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Выберите квест"
horizontal_alignment = 1
vertical_alignment = 1

[node name="ModalLayer" type="CanvasLayer" parent="."]

[node name="ModeSelectionModal" type="Panel" parent="ModalLayer"]
visible = false
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundDim" type="ColorRect" parent="ModalLayer/ModeSelectionModal"]
material = SubResource("ShaderMaterial_1")
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="CenterContainer" type="CenterContainer" parent="ModalLayer/ModeSelectionModal"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="ModalLayer/ModeSelectionModal/CenterContainer"]
custom_minimum_size = Vector2(620, 420)
layout_mode = 2
theme_override_constants/separation = 20

[node name="ModalTitle" type="Label" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 44
text = "ВЫБОР СЛОЖНОСТИ"
horizontal_alignment = 1

[node name="BtnComplexityA" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 74)
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "СЛОЖНОСТЬ A"

[node name="BtnComplexityB" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 74)
layout_mode = 2
theme_override_font_sizes/font_size = 30
disabled = true
text = "СЛОЖНОСТЬ B"

[node name="BtnComplexityC" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 74)
layout_mode = 2
theme_override_font_sizes/font_size = 30
disabled = true
text = "СЛОЖНОСТЬ C"

[node name="BtnClose" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "НАЗАД"
</file>

<file path="scenes/RadioQuestB.gd">
extends Control

enum Phase {
	CALC,
	SELECT,
	DONE
}

const POOL_NORMAL: Array[int] = [64, 80, 100, 128, 256, 512, 1024]
const POOL_ANCHOR: Array[int] = [75, 110, 125, 300, 750, 1000]
const SAMPLE_SLOTS: int = 7
const PHONE_LANDSCAPE_MAX_HEIGHT: float = 520.0

const COLOR_IDLE: Color = Color(0.18, 0.18, 0.18, 1.0)
const COLOR_GOOD: Color = Color(0.20, 0.90, 0.30, 1.0)
const COLOR_WARN: Color = Color(0.95, 0.75, 0.20, 1.0)
const COLOR_BAD: Color = Color(0.95, 0.25, 0.25, 1.0)

const TXT_TITLE: String = "\u0420\u0410\u0414\u0418\u041e\u041f\u0415\u0420\u0415\u0425\u0412\u0410\u0422 | B"
const TXT_BACK: String = "\u041d\u0410\u0417\u0410\u0414"
const TXT_STORAGE_TITLE: String = "\u0421\u041a\u041b\u0410\u0414 \u041d\u041e\u0421\u0418\u0422\u0415\u041b\u0415\u0419"
const TXT_CONTEXT_TITLE: String = "\u0422\u0415\u0420\u041c\u0418\u041d\u0410\u041b"
const TXT_TASK: String = "\u0412\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435 I = K*i \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_CALC_TITLE: String = "\u0420\u0410\u0421\u0427\u0401\u0422 I"
const TXT_BTN_CHECK: String = "\u041f\u0420\u041e\u0412\u0415\u0420\u0418\u0422\u042c"
const TXT_PREVIEW_TITLE: String = "\u0414\u0418\u0410\u0413\u041d\u041e\u0421\u0422\u0418\u041a\u0410"
const TXT_BTN_CONVERTER: String = "\u041a\u041e\u041d\u0412\u0415\u0420\u0422\u0415\u0420"
const TXT_BTN_CONFIRM: String = "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TXT_BTN_NEXT: String = "\u0414\u0410\u041b\u0415\u0415"
const TXT_BTN_DETAILS_CLOSED: String = "\u041f\u041e\u0414\u0420\u041e\u0411\u041d\u0415\u0415 \u25be"
const TXT_BTN_DETAILS_OPEN: String = "\u0421\u041a\u0420\u042b\u0422\u042c \u25b4"
const TXT_DETAILS_TITLE: String = "\u041f\u041e\u042f\u0421\u041d\u0415\u041d\u0418\u0415"
const TXT_DETAILS_CLOSE: String = "\u0417\u0410\u041a\u0420\u042b\u0422\u042c"

const TXT_STATUS_PLAN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u0439\u0442\u0435 I, \u0437\u0430\u0442\u0435\u043c \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_STATUS_CALC_OK: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0420\u0430\u0441\u0447\u0451\u0442 I \u0432\u0435\u0440\u043d\u044b\u0439. \u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_STATUS_CALC_WARN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0420\u0430\u0441\u0447\u0451\u0442 I \u043d\u0435\u0442\u043e\u0447\u043d\u044b\u0439. \u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c \u043e\u0441\u043e\u0437\u043d\u0430\u043d\u043d\u043e."
const TXT_STATUS_CONVERTER: String = "\u0421\u0422\u0410\u0422\u0423\u0421: I = %d \u0431\u0438\u0442 (%d \u0431\u0430\u0439\u0442)."
const TXT_RESULT_BEST: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041e\u0442\u043b\u0438\u0447\u043d\u043e. \u041e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_RESULT_UNDER: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e. \u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c \u043d\u0435 \u0432\u043c\u0435\u0449\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435."
const TXT_RESULT_CALC: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0412\u044b\u0431\u043e\u0440 \u0441\u0434\u0435\u043b\u0430\u043d, \u043d\u043e \u0440\u0430\u0441\u0447\u0451\u0442 I \u0431\u044b\u043b \u043d\u0435\u0442\u043e\u0447\u043d\u044b\u043c."
const TXT_RESULT_UNIT: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u043e\u0445\u043e\u0436\u0435 \u043d\u0430 \u043f\u0443\u0442\u0430\u043d\u0438\u0446\u0443 \u0435\u0434\u0438\u043d\u0438\u0446 (\u0431\u0438\u0442/\u0431\u0430\u0439\u0442)."
const TXT_RESULT_OVER: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0412\u0435\u0440\u043d\u043e, \u043d\u043e \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c \u0438\u0437\u0431\u044b\u0442\u043e\u0447\u0435\u043d."

@onready var safe_area: MarginContainer = $SafeArea
@onready var root_vbox: VBoxContainer = $SafeArea/RootVBox
@onready var body_split: HSplitContainer = $SafeArea/RootVBox/BodyHSplit
@onready var left_pane: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane
@onready var right_vbox: VBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox
@onready var storage_grid: GridContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid

@onready var btn_back: Button = $SafeArea/RootVBox/Header/HeaderHBox/BtnBack
@onready var title_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/TitleLabel
@onready var meta_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/MetaLabel

@onready var storage_title: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageTitle
@onready var storage_btns: Array[Button] = [
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn1,
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn2,
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn3,
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn4
]

@onready var context_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/ContextTitle
@onready var i_info_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/IInfoLabel
@onready var k_info_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/KInfoLabel
@onready var task_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/TaskLabel

@onready var calc_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/CalcTitle
@onready var btn_minus: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow/BtnMinus
@onready var i_bits_value_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow/IBitsValue
@onready var btn_plus: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow/BtnPlus
@onready var btn_check_calc: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/BtnCheckCalc

@onready var preview_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewTitle
@onready var preview_calc_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewCalcLabel
@onready var preview_fit_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewFitLabel
@onready var preview_class_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewClassLabel

@onready var btn_converter: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnConverter
@onready var btn_capture: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnCapture
@onready var btn_next: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnNext
@onready var sample_strip: HBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip
@onready var status_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/StatusLabel
@onready var btn_details: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/BtnDetails
@onready var footer_label: Label = $SafeArea/RootVBox/Footer/FooterMargin/FooterLabel

@onready var dimmer: ColorRect = $Dimmer
@onready var details_sheet: PanelContainer = $DetailsSheet
@onready var details_title: Label = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsTitle
@onready var details_text: RichTextLabel = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsText
@onready var btn_close_details: Button = $DetailsSheet/DetailsMargin/DetailsVBox/BtnCloseDetails

var phase: Phase = Phase.CALC
var i_bits: int = 7
var k_symbols: int = 0
var i_bits_true: int = 0
var i_bits_user: int = 0
var calc_checked: bool = false
var selected_storage_idx: int = -1
var storage_options: Array[Dictionary] = []
var used_converter: bool = false
var forced_sampling: bool = false
var is_timed: bool = false

var start_ms: int = 0
var first_action_ms: int = -1
var current_trial_idx: int = 0
var anchor_countdown: int = 0
var pool_type: String = "NORMAL"
var sample_refs: Array[Dictionary] = []

var _current_stability: float = 100.0
var _ui_ready: bool = false

func _ready() -> void:
	randomize()
	_apply_static_texts()
	_connect_signals()
	_collect_sample_refs()
	_reset_sample_strip()
	_set_details_visible(false)
	_apply_safe_area_padding()
	_configure_layout()

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	_on_stability_changed(GlobalMetrics.stability, 0.0)

	anchor_countdown = randi_range(7, 10)
	_start_trial()
	_ui_ready = true

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and _ui_ready:
		_apply_safe_area_padding()
		_configure_layout()

func _apply_static_texts() -> void:
	title_label.text = TXT_TITLE
	btn_back.text = TXT_BACK
	storage_title.text = TXT_STORAGE_TITLE
	context_title.text = TXT_CONTEXT_TITLE
	task_label.text = TXT_TASK
	calc_title.text = TXT_CALC_TITLE
	btn_minus.text = "-8"
	btn_plus.text = "+8"
	btn_check_calc.text = TXT_BTN_CHECK
	preview_title.text = TXT_PREVIEW_TITLE
	btn_converter.text = TXT_BTN_CONVERTER
	btn_capture.text = TXT_BTN_CONFIRM
	btn_next.text = TXT_BTN_NEXT
	btn_details.text = TXT_BTN_DETAILS_CLOSED
	details_title.text = TXT_DETAILS_TITLE
	btn_close_details.text = TXT_DETAILS_CLOSE

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_minus.pressed.connect(_on_minus_pressed)
	btn_plus.pressed.connect(_on_plus_pressed)
	btn_check_calc.pressed.connect(_on_check_calc_pressed)
	btn_converter.pressed.connect(_on_converter_pressed)
	btn_capture.pressed.connect(_on_capture_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_close_pressed)
	dimmer.gui_input.connect(_on_dimmer_gui_input)

	for idx in range(storage_btns.size()):
		storage_btns[idx].pressed.connect(_on_storage_selected.bind(idx))

func _collect_sample_refs() -> void:
	sample_refs.clear()
	for child_var in sample_strip.get_children():
		var child_node: Node = child_var as Node
		var bg_node: ColorRect = child_node.get_node_or_null("BG") as ColorRect
		var mark_node: Label = child_node.get_node_or_null("AnchorMark") as Label
		if bg_node != null and mark_node != null:
			sample_refs.append({"bg": bg_node, "mark": mark_node})

func _reset_sample_strip() -> void:
	for slot_var in sample_refs:
		var slot: Dictionary = slot_var as Dictionary
		var bg: ColorRect = slot["bg"] as ColorRect
		var mark: Label = slot["mark"] as Label
		bg.color = COLOR_IDLE
		mark.visible = false
	current_trial_idx = 0

func _start_trial() -> void:
	phase = Phase.CALC
	calc_checked = false
	selected_storage_idx = -1
	used_converter = false
	i_bits_user = 0
	start_ms = Time.get_ticks_msec()
	first_action_ms = -1

	if anchor_countdown <= 0:
		k_symbols = POOL_ANCHOR.pick_random()
		pool_type = "ANCHOR"
		anchor_countdown = randi_range(7, 10)
	else:
		k_symbols = POOL_NORMAL.pick_random()
		pool_type = "NORMAL"
		anchor_countdown -= 1

	i_bits_true = k_symbols * i_bits
	_generate_storage_options()

	i_info_label.text = "i = %d \u0431\u0438\u0442" % i_bits
	k_info_label.text = "K = %d \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432" % k_symbols
	i_bits_value_label.text = str(i_bits_user)
	i_bits_value_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))

	btn_minus.disabled = false
	btn_plus.disabled = false
	btn_check_calc.disabled = false
	btn_capture.disabled = true
	btn_capture.visible = true
	btn_next.visible = false

	for idx in range(storage_btns.size()):
		var btn: Button = storage_btns[idx]
		btn.disabled = true
		btn.button_pressed = false
		btn.text = _format_storage_option(storage_options[idx])
		btn.modulate = Color(1, 1, 1, 1)

	status_label.text = TXT_STATUS_PLAN
	status_label.add_theme_color_override("font_color", Color(0.85, 0.85, 0.85, 1.0))
	footer_label.text = ""
	_update_preview()
	_update_header_meta()
	_update_details_text()

func _generate_storage_options() -> void:
	storage_options.clear()

	var best_cap: int = 1
	while best_cap <= i_bits_true:
		best_cap *= 2
	if best_cap == i_bits_true:
		best_cap *= 2
	storage_options.append(_make_auto_option(best_cap, "BEST"))

	var under_cap: int = maxi(1, int(floor(float(i_bits_true) * 0.75)))
	storage_options.append(_make_auto_option(under_cap, "UNDER"))

	if i_bits_true % 8 == 0:
		storage_options.append({
			"capacity_bits": i_bits_true * 8,
			"display_size": i_bits_true,
			"display_unit": "\u0431\u0430\u0439\u0442",
			"tag": "UNIT_TRAP"
		})
	else:
		storage_options.append({
			"capacity_bits": i_bits_true * 8192,
			"display_size": i_bits_true,
			"display_unit": "\u041a\u0411",
			"tag": "UNIT_TRAP"
		})

	var over_cap: int = int(ceil((float(i_bits_true) * 4.0) / 100.0) * 100.0)
	storage_options.append(_make_auto_option(over_cap, "OVER"))

	storage_options.shuffle()

func _make_auto_option(capacity_bits: int, tag: String) -> Dictionary:
	var display_size: int = capacity_bits
	var display_unit: String = "\u0431\u0438\u0442"
	if capacity_bits >= 8192 and capacity_bits % 8192 == 0:
		display_size = capacity_bits / 8192
		display_unit = "\u041a\u0411"
	elif capacity_bits >= 8 and capacity_bits % 8 == 0:
		display_size = capacity_bits / 8
		display_unit = "\u0431\u0430\u0439\u0442"
	return {
		"capacity_bits": capacity_bits,
		"display_size": display_size,
		"display_unit": display_unit,
		"tag": tag
	}

func _format_storage_option(opt: Dictionary) -> String:
	return "%d %s" % [int(opt["display_size"]), str(opt["display_unit"])]

func _register_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec()

func _on_minus_pressed() -> void:
	if phase != Phase.CALC:
		return
	_register_action()
	i_bits_user = maxi(0, i_bits_user - 8)
	i_bits_value_label.text = str(i_bits_user)
	_update_preview()
	_update_details_text()

func _on_plus_pressed() -> void:
	if phase != Phase.CALC:
		return
	_register_action()
	i_bits_user += 8
	i_bits_value_label.text = str(i_bits_user)
	_update_preview()
	_update_details_text()

func _on_check_calc_pressed() -> void:
	if phase != Phase.CALC:
		return
	_register_action()

	calc_checked = true
	phase = Phase.SELECT

	for btn in storage_btns:
		btn.disabled = false

	btn_minus.disabled = true
	btn_plus.disabled = true
	btn_check_calc.disabled = true

	if i_bits_user == i_bits_true:
		status_label.text = TXT_STATUS_CALC_OK
		status_label.add_theme_color_override("font_color", COLOR_GOOD)
		i_bits_value_label.add_theme_color_override("font_color", COLOR_GOOD)
	else:
		status_label.text = TXT_STATUS_CALC_WARN
		status_label.add_theme_color_override("font_color", COLOR_WARN)
		i_bits_value_label.add_theme_color_override("font_color", COLOR_WARN)

	_update_preview()
	_update_details_text()

func _on_storage_selected(idx: int) -> void:
	if phase != Phase.SELECT:
		return
	_register_action()

	selected_storage_idx = idx
	for i in range(storage_btns.size()):
		storage_btns[i].button_pressed = (i == idx)
		storage_btns[i].modulate = Color(1, 1, 0.75, 1) if i == idx else Color(1, 1, 1, 1)

	btn_capture.disabled = false
	_update_preview()
	_update_details_text()

func _on_converter_pressed() -> void:
	if phase == Phase.DONE:
		return
	_register_action()
	used_converter = true
	status_label.text = TXT_STATUS_CONVERTER % [i_bits_true, i_bits_true / 8]
	status_label.add_theme_color_override("font_color", Color(0.55, 0.85, 1.0, 1.0))
	_update_preview()
	_update_details_text()

func _on_capture_pressed() -> void:
	if phase != Phase.SELECT or selected_storage_idx < 0:
		return
	_register_action()
	_finish_trial()

func _finish_trial() -> void:
	phase = Phase.DONE
	btn_capture.visible = false
	btn_next.visible = true

	var choice: Dictionary = storage_options[selected_storage_idx]
	var choice_cap: int = int(choice["capacity_bits"])
	var calc_correct: bool = (i_bits_user == i_bits_true)
	var is_fit: bool = choice_cap >= i_bits_true
	var is_best_fit: bool = false
	var is_overkill: bool = false
	var waste_ratio: float = 0.0
	if i_bits_true > 0:
		waste_ratio = float(choice_cap) / float(i_bits_true)

	var error_type: String = "unknown"
	if choice_cap < i_bits_true:
		error_type = "underfit"
	elif not calc_correct:
		error_type = "calc_wrong"
	elif str(choice["tag"]) == "UNIT_TRAP":
		error_type = "unit_confusion_bits_bytes"
	elif str(choice["tag"]) == "BEST":
		error_type = "best_fit"
		is_best_fit = true
	elif waste_ratio > 4.0:
		error_type = "overkill_hard"
		is_overkill = true
	else:
		error_type = "overkill_soft"
		is_overkill = true

	var valid_mastery: bool = (not used_converter) and calc_correct and is_best_fit

	if error_type == "best_fit":
		status_label.text = TXT_RESULT_BEST
		status_label.add_theme_color_override("font_color", COLOR_GOOD)
		_update_sample_slot(COLOR_GOOD)
	elif error_type == "underfit":
		status_label.text = TXT_RESULT_UNDER
		status_label.add_theme_color_override("font_color", COLOR_BAD)
		_update_sample_slot(COLOR_BAD)
	elif error_type == "calc_wrong":
		status_label.text = TXT_RESULT_CALC
		status_label.add_theme_color_override("font_color", COLOR_BAD)
		_update_sample_slot(COLOR_BAD)
	elif error_type == "unit_confusion_bits_bytes":
		status_label.text = TXT_RESULT_UNIT
		status_label.add_theme_color_override("font_color", COLOR_WARN)
		_update_sample_slot(COLOR_WARN)
	else:
		status_label.text = TXT_RESULT_OVER
		status_label.add_theme_color_override("font_color", COLOR_WARN)
		_update_sample_slot(COLOR_WARN)

	var payload: Dictionary = {
		"quest_id": "radio_intercept",
		"stage_id": "B",
		"match_key": "RI_B_%s" % ("TIMED" if is_timed else "UNTIMED"),
		"pool_type": pool_type,
		"dependency_mode": "default_i",
		"i_bits": i_bits,
		"K_symbols": k_symbols,
		"I_bits_true": i_bits_true,
		"I_bits_user": i_bits_user,
		"calc_correct": calc_correct,
		"used_converter": used_converter,
		"choice_capacity_bits": choice_cap,
		"choice_display_size": int(choice["display_size"]),
		"choice_display_unit": str(choice["display_unit"]),
		"is_fit": is_fit,
		"is_best_fit": is_best_fit,
		"is_overkill": is_overkill,
		"waste_ratio": waste_ratio,
		"error_type": error_type,
		"valid_for_mastery": valid_mastery,
		"valid_for_diagnostics": true,
		"elapsed_ms": Time.get_ticks_msec() - start_ms,
		"time_to_first_action_ms": (first_action_ms - start_ms) if first_action_ms > 0 else 0,
		"is_timed": is_timed,
		"forced_sampling": forced_sampling
	}
	GlobalMetrics.register_trial(payload)

	_update_preview()
	_update_details_text()

func _update_sample_slot(color: Color) -> void:
	if sample_refs.is_empty():
		return
	var slot: Dictionary = sample_refs[current_trial_idx] as Dictionary
	var bg: ColorRect = slot["bg"] as ColorRect
	var mark: Label = slot["mark"] as Label
	bg.color = color
	mark.visible = pool_type == "ANCHOR"
	current_trial_idx = (current_trial_idx + 1) % min(SAMPLE_SLOTS, sample_refs.size())

func _update_preview() -> void:
	if i_bits_user <= 0:
		preview_calc_label.text = "\u0420\u0430\u0441\u0447\u0451\u0442 I: \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d"
		preview_calc_label.add_theme_color_override("font_color", Color(0.75, 0.75, 0.75, 1.0))
	elif i_bits_user == i_bits_true:
		preview_calc_label.text = "\u0420\u0430\u0441\u0447\u0451\u0442 I: \u0432\u0435\u0440\u043d\u043e (%d \u0431\u0438\u0442)" % i_bits_true
		preview_calc_label.add_theme_color_override("font_color", COLOR_GOOD)
	else:
		preview_calc_label.text = "\u0420\u0430\u0441\u0447\u0451\u0442 I: \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 (%d vs %d)" % [i_bits_user, i_bits_true]
		preview_calc_label.add_theme_color_override("font_color", COLOR_WARN)

	if selected_storage_idx < 0:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043d\u0435 \u0432\u044b\u0431\u0440\u0430\u043d"
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: \u2014"
		preview_fit_label.add_theme_color_override("font_color", Color(0.75, 0.75, 0.75, 1.0))
		preview_class_label.add_theme_color_override("font_color", Color(0.75, 0.75, 0.75, 1.0))
		return

	var opt: Dictionary = storage_options[selected_storage_idx]
	var cap: int = int(opt["capacity_bits"])
	var tag: String = str(opt["tag"])

	if cap < i_bits_true:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043d\u0435 \u043f\u043e\u043c\u0435\u0449\u0430\u0435\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_BAD)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: UNDERFIT"
		preview_class_label.add_theme_color_override("font_color", COLOR_BAD)
	elif tag == "BEST":
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_GOOD)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: BEST FIT"
		preview_class_label.add_theme_color_override("font_color", COLOR_GOOD)
	elif tag == "UNIT_TRAP":
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u0435\u0434\u0438\u043d\u0438\u0446\u044b"
		preview_fit_label.add_theme_color_override("font_color", COLOR_WARN)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: UNIT CONFUSION"
		preview_class_label.add_theme_color_override("font_color", COLOR_WARN)
	elif cap >= i_bits_true * 4:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_WARN)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: OVERKILL"
		preview_class_label.add_theme_color_override("font_color", COLOR_WARN)
	else:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_WARN)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: SOFT OVERKILL"
		preview_class_label.add_theme_color_override("font_color", COLOR_WARN)

func _update_details_text() -> void:
	var lines: Array[String] = []
	lines.append("i: %d" % i_bits)
	lines.append("K: %d" % k_symbols)
	lines.append("I_true: %d" % i_bits_true)
	lines.append("I_user: %d" % i_bits_user)
	lines.append("pool: %s" % pool_type)
	if selected_storage_idx >= 0:
		var opt: Dictionary = storage_options[selected_storage_idx]
		lines.append("choice: %d %s" % [int(opt["display_size"]), str(opt["display_unit"])])
		lines.append("choice_bits: %d" % int(opt["capacity_bits"]))
	if used_converter:
		lines.append("converter: used")
	details_text.text = "\n".join(lines)

func _on_next_pressed() -> void:
	_start_trial()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_details_pressed() -> void:
	_set_details_visible(true)

func _on_details_close_pressed() -> void:
	_set_details_visible(false)

func _on_dimmer_gui_input(event: InputEvent) -> void:
	if (event is InputEventMouseButton and event.pressed) or (event is InputEventScreenTouch and event.pressed):
		_set_details_visible(false)

func _set_details_visible(visible: bool) -> void:
	details_sheet.visible = visible
	dimmer.visible = visible
	btn_details.text = TXT_BTN_DETAILS_OPEN if visible else TXT_BTN_DETAILS_CLOSED

func _update_header_meta() -> void:
	var mode_text: String = "\u0411\u0415\u0417 \u0422\u0410\u0419\u041c\u0415\u0420\u0410"
	meta_label.text = "\u0420\u0415\u0416\u0418\u041c: %s | \u0421\u0422\u0410\u0411: %d%%" % [mode_text, int(_current_stability)]

func _on_stability_changed(new_value: float, _delta: float) -> void:
	_current_stability = new_value
	_update_header_meta()

func _apply_safe_area_padding() -> void:
	var left: float = 16.0
	var top: float = 12.0
	var right: float = 16.0
	var bottom: float = 12.0

	var safe_rect: Rect2i = DisplayServer.get_display_safe_area()
	if safe_rect.size.x > 0 and safe_rect.size.y > 0:
		var viewport_size: Vector2 = get_viewport_rect().size
		left = maxf(left, float(safe_rect.position.x))
		top = maxf(top, float(safe_rect.position.y))
		right = maxf(right, viewport_size.x - float(safe_rect.position.x + safe_rect.size.x))
		bottom = maxf(bottom, viewport_size.y - float(safe_rect.position.y + safe_rect.size.y))

	safe_area.add_theme_constant_override("margin_left", int(round(left)))
	safe_area.add_theme_constant_override("margin_top", int(round(top)))
	safe_area.add_theme_constant_override("margin_right", int(round(right)))
	safe_area.add_theme_constant_override("margin_bottom", int(round(bottom)))

func _configure_layout() -> void:
	var size: Vector2 = get_viewport_rect().size
	var phone_landscape: bool = size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

	if phone_landscape:
		body_split.split_offset = int(size.x * 0.52)
		root_vbox.add_theme_constant_override("separation", 8)
		storage_grid.columns = 2
		for btn in storage_btns:
			btn.custom_minimum_size.y = 80
		for btn in [btn_back, btn_minus, btn_plus, btn_check_calc, btn_converter, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 56
		meta_label.add_theme_font_size_override("font_size", 16)
		status_label.add_theme_font_size_override("font_size", 16)
	elif size.x < 1280.0:
		body_split.split_offset = int(size.x * 0.54)
		root_vbox.add_theme_constant_override("separation", 10)
		storage_grid.columns = 2
		for btn in storage_btns:
			btn.custom_minimum_size.y = 88
		for btn in [btn_back, btn_minus, btn_plus, btn_check_calc, btn_converter, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58
		meta_label.add_theme_font_size_override("font_size", 17)
		status_label.add_theme_font_size_override("font_size", 18)
	else:
		body_split.split_offset = int(size.x * 0.55)
		root_vbox.add_theme_constant_override("separation", 10)
		storage_grid.columns = 2
		for btn in storage_btns:
			btn.custom_minimum_size.y = 92
		for btn in [btn_back, btn_minus, btn_plus, btn_check_calc, btn_converter, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58
		meta_label.add_theme_font_size_override("font_size", 18)
		status_label.add_theme_font_size_override("font_size", 18)
</file>

<file path="scenes/RadioQuestC.gd">
extends Control

enum State {
	TUNE,
	ANALYZED,
	EXEC,
	DONE
}

enum Decision {
	NONE,
	RISK,
	ABORT
}

enum Outcome {
	NONE,
	SUCCESS_SEND,
	INTERCEPTED,
	SAFE_ABORT,
	MISSED_WINDOW
}

const EPS: float = 0.05
const MIN_ESTIMATE: float = 0.0
const MAX_ESTIMATE: float = 30.0
const SAMPLE_SLOTS: int = 7
const PHONE_LANDSCAPE_MAX_HEIGHT: float = 520.0

const UNIT_MB := "\u041c\u0411"
const UNIT_GB := "\u0413\u0411"
const UNIT_MBIT_SEC := "\u041c\u0431\u0438\u0442/\u0441"
const SYMBOL_SEC := "\u0441"

const TXT_MODE := "\u0420\u0415\u0416\u0418\u041c: \u0411\u0415\u0417 \u0412\u0420\u0415\u041c\u0415\u041d\u0418"
const TXT_TITLE := "\u0420\u0410\u0414\u0418\u041e\u041f\u0415\u0420\u0415\u0425\u0412\u0410\u0422 \u2022 C"
const TXT_MISSION := "\u042d\u041a\u0421\u0422\u0420\u0415\u041d\u041d\u0410\u042f \u041f\u0415\u0420\u0415\u0414\u0410\u0427\u0410"
const TXT_HINT := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043e\u0446\u0435\u043d\u0438 t. \u041f\u043e\u0442\u043e\u043c \u0410\u041d\u0410\u041b\u0418\u0417. \u041f\u043e\u0442\u043e\u043c \u0440\u0435\u0448\u0435\u043d\u0438\u0435."
const TXT_STEP_1 := "\u0428\u0410\u0413 1: \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438"
const TXT_STEP_2 := "\u0428\u0410\u0413 2: \u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c \u0440\u0438\u0441\u043a\u0430"
const TXT_STEP_3 := "\u0428\u0410\u0413 3: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0440\u0435\u0448\u0435\u043d\u0438\u0435"
const TXT_DETECT_TITLE := "\u041f\u0415\u041b\u0415\u041d\u0413\u0410\u0426\u0418\u042f"
const TXT_TRANSFER_TITLE := "\u041f\u0415\u0420\u0415\u0414\u0410\u0427\u0410"

const TXT_BTN_UNITS := "\u041f\u041e\u0414\u0421\u041a\u0410\u0417\u041a\u0410 (\u0435\u0434\u0438\u043d\u0438\u0446\u044b)"
const TXT_BTN_ANALYZE := "\u0410\u041d\u0410\u041b\u0418\u0417"
const TXT_BTN_RISK := "\u0420\u0418\u0421\u041a\u041d\u0423\u0422\u042c"
const TXT_BTN_ABORT := "\u0421\u0411\u0420\u041e\u0421"
const TXT_BTN_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TXT_BTN_DETAILS := "\u041f\u041e\u0414\u0420\u041e\u0411\u041d\u0415\u0415 \u25be"
const TXT_DETAILS_TITLE := "\u041f\u041e\u042f\u0421\u041d\u0415\u041d\u0418\u0415"
const TXT_DETAILS_CLOSE := "\u0417\u0410\u041a\u0420\u042b\u0422\u042c"

const TXT_RISK_UNKNOWN := "\u0420\u0438\u0441\u043a: \u041d\u0415\u0418\u0417\u0412\u0415\u0421\u0422\u0415\u041d"
const TXT_RISK_LOW := "\u041d\u0418\u0417\u041a\u0418\u0419"
const TXT_RISK_MID := "\u0421\u0420\u0415\u0414\u041d\u0418\u0419"
const TXT_RISK_HIGH := "\u0412\u042b\u0421\u041e\u041a\u0418\u0419"

const TXT_PLAN_STATUS := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u043f\u0440\u043e\u0433\u043d\u043e\u0437 \u0438 \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0410\u041d\u0410\u041b\u0418\u0417\u00bb."
const TXT_ANALYZED_OK := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0442\u043e\u0447\u043d\u044b\u0439. \u0420\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u043e \u0440\u0435\u0448\u0435\u043d\u0438\u0435."
const TXT_ANALYZED_MID := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0431\u043b\u0438\u0437\u043a\u0438\u0439. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0440\u0438\u0441\u043a\u043e\u0432\u0430\u043d\u043d\u043e."
const TXT_ANALYZED_BAD := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u043d\u0435\u0442\u043e\u0447\u043d\u044b\u0439. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0440\u0438\u0441\u043a\u043e\u0432\u0430\u043d\u043d\u043e."
const TXT_EXEC_STARTED := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u0437\u0430\u043f\u0443\u0449\u0435\u043d\u0430."
const TXT_UNITS_HINT := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041c\u0411 -> \u041c\u0431\u0438\u0442: x8, \u0413\u0411 -> \u041c\u0411: x1024, t = I / v."

const TXT_OUT_SUCCESS := "\u0421\u0422\u0410\u0422\u0423\u0421: \u0423\u0421\u041f\u0415\u0425. \u041f\u0430\u043a\u0435\u0442 \u0443\u0448\u0451\u043b \u0434\u043e \u043f\u0435\u043b\u0435\u043d\u0433\u0430\u0446\u0438\u0438."
const TXT_OUT_INTERCEPT := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0420\u041e\u0412\u0410\u041b. \u0412\u0430\u0441 \u0437\u0430\u0441\u0435\u043a\u043b\u0438."
const TXT_OUT_SAFE_ABORT := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0420\u0410\u0412\u0418\u041b\u042c\u041d\u041e. \u041e\u0442\u043a\u0430\u0437 \u0441\u043f\u0430\u0441 \u043c\u0438\u0441\u0441\u0438\u044e."
const TXT_OUT_MISSED := "\u0421\u0422\u0410\u0422\u0423\u0421: \u0423\u041f\u0423\u0429\u0415\u041d\u041e. \u0412\u044b \u043c\u043e\u0433\u043b\u0438 \u0443\u0441\u043f\u0435\u0442\u044c."

const POOL_MB_NORMAL: Array[float] = [1.0, 2.0, 4.0, 5.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 40.0]
const POOL_GB_NORMAL: Array[float] = [0.5, 1.0, 1.5, 2.0]
const POOL_SPEED_INT: Array[float] = [1.0, 2.0, 4.0, 5.0, 8.0, 10.0, 16.0, 20.0, 25.0]
const POOL_SPEED_FRAC: Array[float] = [1.5, 2.5, 7.5, 12.5]

const COLOR_SAMPLE_IDLE: Color = Color(0.18, 0.18, 0.18, 1.0)
const COLOR_SAMPLE_SUCCESS: Color = Color(0.20, 0.90, 0.30, 1.0)
const COLOR_SAMPLE_FAIL: Color = Color(0.95, 0.25, 0.25, 1.0)
const COLOR_SAMPLE_WARN: Color = Color(0.95, 0.75, 0.20, 1.0)

@onready var safe_area: MarginContainer = $SafeArea
@onready var body_split: HSplitContainer = $SafeArea/RootVBox/BodyHSplit
@onready var top_bar: PanelContainer = $SafeArea/RootVBox/TopBar
@onready var mission_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard
@onready var actions_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard

@onready var title_label: Label = $SafeArea/RootVBox/TopBar/TopBarHBox/TitleLabel
@onready var mode_chip: Label = $SafeArea/RootVBox/TopBar/TopBarHBox/ModeChip
@onready var stability_label: Label = $SafeArea/RootVBox/TopBar/TopBarHBox/StabilityLabel
@onready var btn_back: Button = $SafeArea/RootVBox/TopBar/TopBarHBox/BtnBack

@onready var mission_title: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/MissionTitle
@onready var task_line_1: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/TaskLine1
@onready var task_line_2: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/TaskLine2
@onready var task_line_3: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/TaskLine3
@onready var micro_hint: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/MicroHint

@onready var step_1_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/Step1Label
@onready var estimate_value_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/EstimateValue
@onready var time_knob: Control = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/KnobCenter/TimeKnob
@onready var btn_minus_1: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnMinus1
@onready var btn_minus_01: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnMinus01
@onready var btn_plus_01: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnPlus01
@onready var btn_plus_1: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnPlus1
@onready var btn_analyze: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/BtnAnalyze

@onready var status_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/StatusCard/StatusMargin/StatusLabel

@onready var step_2_label: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/Step2Label
@onready var detection_title: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/DetectionTitle
@onready var detection_bar: ProgressBar = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/DetectionBar
@onready var detect_countdown: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/DetectCountdown
@onready var transfer_title: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/TransferTitle
@onready var transfer_bar: ProgressBar = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/TransferBar
@onready var transfer_countdown: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/TransferCountdown
@onready var risk_label: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/RiskLabel

@onready var step_3_label: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/Step3Label
@onready var btn_units: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow/BtnUnits
@onready var btn_details: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow/BtnDetails
@onready var btn_risk: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow/BtnRisk
@onready var btn_abort: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow/BtnAbort
@onready var btn_next: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow/BtnNext
@onready var sample_strip: HBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip

@onready var details_overlay: Control = $DetailsOverlay
@onready var details_sheet_title: Label = $DetailsOverlay/BottomSheet/SheetMargin/SheetVBox/SheetTitle
@onready var details_sheet_text: RichTextLabel = $DetailsOverlay/BottomSheet/SheetMargin/SheetVBox/SheetText
@onready var btn_close_details: Button = $DetailsOverlay/BottomSheet/SheetMargin/SheetVBox/BtnCloseDetails

@onready var alarm_flash: ColorRect = $AlarmFlash

var state: State = State.TUNE
var decision: Decision = Decision.NONE
var outcome: Outcome = Outcome.NONE

var file_size_value: float = 0.0
var file_size_unit: String = UNIT_MB
var speed_mbit: float = 0.0
var t_detect: float = 0.0
var t_true: float = 0.0
var t_est: float = 0.0

var pool_type: String = "NORMAL"
var anchor_type: String = "none"
var anchor_countdown: int = 0

var detection_elapsed: float = 0.0
var transfer_elapsed: float = 0.0
var transfer_started: bool = false
var used_units: bool = false

var start_ms: int = 0
var first_action_ms: int = -1
var check_ms: int = -1
var decision_ms: int = -1

var analyze_count: int = 0
var knob_moves_count: int = 0
var direction_changes: int = 0
var _last_move_sign: int = 0

var sample_cursor: int = 0
var sample_refs: Array = []
var _ui_ready: bool = false

func _ready() -> void:
	randomize()
	_apply_static_texts()
	_connect_signals()
	_collect_sample_refs()
	_reset_sample_strip()
	_apply_safe_area_padding()
	_configure_layout()
	_set_details_visible(false)

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	_on_stability_changed(GlobalMetrics.stability, 0.0)

	anchor_countdown = randi_range(7, 10)
	_start_trial()
	_ui_ready = true

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and _ui_ready:
		_apply_safe_area_padding()
		_configure_layout()

func _process(delta: float) -> void:
	if state != State.ANALYZED and state != State.EXEC:
		return

	detection_elapsed += delta
	if decision == Decision.RISK and transfer_started:
		transfer_elapsed += delta

	_update_runtime_ui()

	if decision == Decision.RISK:
		if transfer_elapsed >= t_true and detection_elapsed <= t_detect + EPS:
			_finalize_trial(Outcome.SUCCESS_SEND, "RISK")
			return
		if detection_elapsed >= t_detect and transfer_elapsed < t_true - EPS:
			_play_alarm_flash()
			_finalize_trial(Outcome.INTERCEPTED, "RISK")
			return
	else:
		if detection_elapsed >= t_detect:
			if decision_ms < 0:
				decision_ms = Time.get_ticks_msec()
			_play_alarm_flash()
			_finalize_trial(Outcome.INTERCEPTED, "NONE")

func _apply_static_texts() -> void:
	title_label.text = TXT_TITLE
	mode_chip.text = TXT_MODE
	mission_title.text = TXT_MISSION
	micro_hint.text = TXT_HINT
	step_1_label.text = TXT_STEP_1
	step_2_label.text = TXT_STEP_2
	step_3_label.text = TXT_STEP_3
	detection_title.text = TXT_DETECT_TITLE
	transfer_title.text = TXT_TRANSFER_TITLE

	btn_units.text = TXT_BTN_UNITS
	btn_details.text = TXT_BTN_DETAILS
	btn_analyze.text = TXT_BTN_ANALYZE
	btn_risk.text = TXT_BTN_RISK
	btn_abort.text = TXT_BTN_ABORT
	btn_next.text = TXT_BTN_NEXT
	details_sheet_title.text = TXT_DETAILS_TITLE
	btn_close_details.text = TXT_DETAILS_CLOSE

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_minus_1.pressed.connect(_on_minus_1_pressed)
	btn_minus_01.pressed.connect(_on_minus_01_pressed)
	btn_plus_01.pressed.connect(_on_plus_01_pressed)
	btn_plus_1.pressed.connect(_on_plus_1_pressed)
	btn_units.pressed.connect(_on_units_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_close_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_risk.pressed.connect(_on_risk_pressed)
	btn_abort.pressed.connect(_on_abort_pressed)
	btn_next.pressed.connect(_on_next_pressed)

	var knob_callback: Callable = Callable(self, "_on_knob_value_changed")
	if not time_knob.is_connected("value_changed", knob_callback):
		time_knob.connect("value_changed", knob_callback)

func _apply_safe_area_padding() -> void:
	if safe_area == null:
		return

	var base_left: float = 16.0
	var base_top: float = 12.0
	var base_right: float = 16.0
	var base_bottom: float = 12.0

	var safe_rect: Rect2i = DisplayServer.get_display_safe_area()
	if safe_rect.size.x > 0 and safe_rect.size.y > 0:
		var viewport_size: Vector2 = get_viewport_rect().size
		base_left = maxf(base_left, float(safe_rect.position.x))
		base_top = maxf(base_top, float(safe_rect.position.y))
		base_right = maxf(base_right, viewport_size.x - float(safe_rect.position.x + safe_rect.size.x))
		base_bottom = maxf(base_bottom, viewport_size.y - float(safe_rect.position.y + safe_rect.size.y))

	safe_area.add_theme_constant_override("margin_left", int(round(base_left)))
	safe_area.add_theme_constant_override("margin_top", int(round(base_top)))
	safe_area.add_theme_constant_override("margin_right", int(round(base_right)))
	safe_area.add_theme_constant_override("margin_bottom", int(round(base_bottom)))

func _configure_layout() -> void:
	if body_split == null or time_knob == null:
		return

	var size: Vector2 = get_viewport_rect().size
	var is_phone_landscape: bool = size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT
	if is_phone_landscape:
		body_split.split_offset = int(size.x * 0.54)
		top_bar.custom_minimum_size.y = 58.0
		mission_card.custom_minimum_size.y = 140.0
		actions_card.custom_minimum_size.y = 200.0
		time_knob.custom_minimum_size = Vector2(220, 220)
		title_label.add_theme_font_size_override("font_size", 24)
		mode_chip.add_theme_font_size_override("font_size", 15)
		stability_label.add_theme_font_size_override("font_size", 15)
		estimate_value_label.add_theme_font_size_override("font_size", 30)
		for btn in [btn_back, btn_minus_1, btn_minus_01, btn_plus_01, btn_plus_1, btn_analyze, btn_risk, btn_abort, btn_units, btn_details, btn_next, btn_close_details]:
			btn.custom_minimum_size.y = 56.0
	elif size.x < 1500.0:
		body_split.split_offset = int(size.x * 0.55)
		top_bar.custom_minimum_size.y = 62.0
		mission_card.custom_minimum_size.y = 150.0
		actions_card.custom_minimum_size.y = 210.0
		time_knob.custom_minimum_size = Vector2(270, 270)
		title_label.add_theme_font_size_override("font_size", 28)
		mode_chip.add_theme_font_size_override("font_size", 17)
		stability_label.add_theme_font_size_override("font_size", 17)
		estimate_value_label.add_theme_font_size_override("font_size", 34)
		for btn in [btn_back, btn_minus_1, btn_minus_01, btn_plus_01, btn_plus_1, btn_analyze, btn_risk, btn_abort, btn_units, btn_details, btn_next, btn_close_details]:
			btn.custom_minimum_size.y = 58.0
	else:
		body_split.split_offset = int(size.x * 0.56)
		top_bar.custom_minimum_size.y = 62.0
		mission_card.custom_minimum_size.y = 160.0
		actions_card.custom_minimum_size.y = 220.0
		time_knob.custom_minimum_size = Vector2(320, 320)
		title_label.add_theme_font_size_override("font_size", 30)
		mode_chip.add_theme_font_size_override("font_size", 18)
		stability_label.add_theme_font_size_override("font_size", 18)
		estimate_value_label.add_theme_font_size_override("font_size", 38)
		for btn in [btn_back, btn_minus_1, btn_minus_01, btn_plus_01, btn_plus_1, btn_analyze, btn_risk, btn_abort, btn_units, btn_details, btn_next, btn_close_details]:
			btn.custom_minimum_size.y = 58.0

func _collect_sample_refs() -> void:
	sample_refs.clear()
	for child_var in sample_strip.get_children():
		var child_node: Node = child_var as Node
		var bg_node: ColorRect = child_node.get_node_or_null("BG") as ColorRect
		var mark_node: Label = child_node.get_node_or_null("AnchorMark") as Label
		if bg_node != null and mark_node != null:
			mark_node.text = "\u042f"
			sample_refs.append({"bg": bg_node, "mark": mark_node})

func _reset_sample_strip() -> void:
	for slot_var in sample_refs:
		var slot: Dictionary = slot_var as Dictionary
		var bg: ColorRect = slot["bg"] as ColorRect
		var mark: Label = slot["mark"] as Label
		bg.color = COLOR_SAMPLE_IDLE
		mark.visible = false

func _start_trial() -> void:
	state = State.TUNE
	decision = Decision.NONE
	outcome = Outcome.NONE
	transfer_started = false
	used_units = false

	detection_elapsed = 0.0
	transfer_elapsed = 0.0

	analyze_count = 0
	knob_moves_count = 0
	direction_changes = 0
	_last_move_sign = 0

	start_ms = Time.get_ticks_msec()
	first_action_ms = -1
	check_ms = -1
	decision_ms = -1

	_generate_trial()
	_refresh_task_labels()
	_reset_runtime_ui()
	_set_tune_state_ui()

	time_knob.call("set_knob_value", 0.0, false)
	_set_estimate(0.0)
	_update_details_text()

func _generate_trial() -> void:
	var generated: Dictionary = {}
	if anchor_countdown <= 0:
		pool_type = "ANCHOR"
		var anchor_pick: int = randi() % 3
		if anchor_pick == 0:
			generated = _generate_anchor_forgot_x8()
		elif anchor_pick == 1:
			generated = _generate_anchor_boundary()
		else:
			generated = _generate_anchor_gb()
		if generated.is_empty():
			generated = _generate_normal_trial()
			pool_type = "NORMAL"
		anchor_countdown = randi_range(7, 10)
	else:
		pool_type = "NORMAL"
		generated = _generate_normal_trial()
		anchor_countdown -= 1

	file_size_value = float(generated["size_value"])
	file_size_unit = str(generated["size_unit"])
	speed_mbit = float(generated["speed_mbit"])
	t_detect = float(generated["t_detect"])
	t_true = float(generated["t_true"])
	anchor_type = str(generated["anchor_type"])

func _generate_normal_trial() -> Dictionary:
	for _i in range(500):
		var use_gb: bool = randf() < 0.10
		var size_value: float = 0.0
		var size_unit: String = UNIT_MB
		if use_gb:
			size_value = POOL_GB_NORMAL[randi() % POOL_GB_NORMAL.size()]
			size_unit = UNIT_GB
		else:
			size_value = POOL_MB_NORMAL[randi() % POOL_MB_NORMAL.size()]
			size_unit = UNIT_MB

		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, size_unit, speed)
		if true_time < 2.0 or true_time > 20.0:
			continue

		var detect_time: float = clampf(true_time + randf_range(-3.0, 3.0), 0.8, 24.0)
		if absf(true_time - detect_time) < 0.2:
			detect_time = clampf(detect_time + 0.4, 0.8, 24.0)

		return {
			"size_value": size_value,
			"size_unit": size_unit,
			"speed_mbit": speed,
			"t_detect": detect_time,
			"t_true": true_time,
			"anchor_type": "none"
		}

	return {
		"size_value": 10.0,
		"size_unit": UNIT_MB,
		"speed_mbit": 16.0,
		"t_detect": 6.0,
		"t_true": 5.0,
		"anchor_type": "none"
	}

func _generate_anchor_forgot_x8() -> Dictionary:
	for _i in range(500):
		var size_value: float = POOL_MB_NORMAL[randi() % POOL_MB_NORMAL.size()]
		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, UNIT_MB, speed)
		if true_time < 4.0 or true_time > 20.0:
			continue

		var fake_time: float = size_value / speed
		var detect_low: float = maxf(fake_time + 0.2, 0.6)
		var detect_high: float = true_time - 0.2
		if detect_high <= detect_low:
			continue

		return {
			"size_value": size_value,
			"size_unit": UNIT_MB,
			"speed_mbit": speed,
			"t_detect": randf_range(detect_low, detect_high),
			"t_true": true_time,
			"anchor_type": "forgot_x8"
		}
	return {}

func _generate_anchor_boundary() -> Dictionary:
	for _i in range(500):
		var use_gb: bool = randf() < 0.30
		var size_value: float = 0.0
		var size_unit: String = UNIT_MB
		if use_gb:
			size_value = POOL_GB_NORMAL[randi() % POOL_GB_NORMAL.size()]
			size_unit = UNIT_GB
		else:
			size_value = POOL_MB_NORMAL[randi() % POOL_MB_NORMAL.size()]
			size_unit = UNIT_MB

		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, size_unit, speed)
		if true_time < 2.0 or true_time > 20.0:
			continue

		var detect_time: float = clampf(true_time + randf_range(-0.18, 0.18), 0.8, 24.0)
		if absf(true_time - detect_time) <= 0.2:
			return {
				"size_value": size_value,
				"size_unit": size_unit,
				"speed_mbit": speed,
				"t_detect": detect_time,
				"t_true": true_time,
				"anchor_type": "boundary"
			}
	return {}

func _generate_anchor_gb() -> Dictionary:
	for _i in range(500):
		var size_value: float = POOL_GB_NORMAL[randi() % POOL_GB_NORMAL.size()]
		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, UNIT_GB, speed)
		if true_time < 6.0 or true_time > 20.0:
			continue

		var fake_time: float = (size_value * 8.0) / speed
		var detect_low: float = fake_time + 0.1
		var detect_high: float = true_time - 0.3
		if detect_high <= detect_low:
			continue

		return {
			"size_value": size_value,
			"size_unit": UNIT_GB,
			"speed_mbit": speed,
			"t_detect": randf_range(detect_low, detect_high),
			"t_true": true_time,
			"anchor_type": "forgot_x1024"
		}
	return {}

func _pick_speed() -> float:
	if randf() < 0.30:
		return POOL_SPEED_FRAC[randi() % POOL_SPEED_FRAC.size()]
	return POOL_SPEED_INT[randi() % POOL_SPEED_INT.size()]

func _compute_true_time(size_value: float, size_unit: String, speed: float) -> float:
	var i_mbit: float = size_value * 8.0
	if size_unit == UNIT_GB:
		i_mbit = size_value * 1024.0 * 8.0
	return i_mbit / speed

func _refresh_task_labels() -> void:
	task_line_1.text = "\u041e\u0431\u044a\u0451\u043c \u043f\u0430\u043a\u0435\u0442\u0430: %s %s" % [_format_num(file_size_value), file_size_unit]
	task_line_2.text = "\u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043a\u0430\u043d\u0430\u043b\u0430: %s %s" % [_format_num(speed_mbit), UNIT_MBIT_SEC]
	task_line_3.text = "\u0414\u043e \u043f\u0435\u043b\u0435\u043d\u0433\u0430\u0446\u0438\u0438: %s %s" % [_format_num(t_detect), SYMBOL_SEC]

func _reset_runtime_ui() -> void:
	detection_bar.value = 0.0
	transfer_bar.value = 0.0
	detect_countdown.text = "%s %s" % [_format_num(t_detect), SYMBOL_SEC]
	transfer_countdown.text = "\u2014"
	risk_label.text = TXT_RISK_UNKNOWN
	alarm_flash.color = Color(1.0, 0.05, 0.05, 0.0)

func _set_tune_state_ui() -> void:
	state = State.TUNE
	_set_knob_interactive(true)
	btn_analyze.disabled = false
	btn_risk.disabled = true
	btn_abort.disabled = true
	btn_units.disabled = false
	btn_next.visible = false
	status_label.text = TXT_PLAN_STATUS

func _set_analyzed_state_ui() -> void:
	state = State.ANALYZED
	_set_knob_interactive(false)
	btn_analyze.disabled = true
	btn_risk.disabled = false
	btn_abort.disabled = false
	btn_units.disabled = false
	btn_next.visible = false

	var abs_error: float = absf(t_est - t_true)
	if abs_error <= 0.3:
		status_label.text = TXT_ANALYZED_OK
	elif abs_error <= 1.0:
		status_label.text = TXT_ANALYZED_MID
	else:
		status_label.text = TXT_ANALYZED_BAD

	risk_label.text = "\u0420\u0438\u0441\u043a: %s" % _estimate_risk_text()

func _set_exec_state_ui() -> void:
	state = State.EXEC
	_set_knob_interactive(false)
	btn_analyze.disabled = true
	btn_risk.disabled = true
	btn_abort.disabled = true
	btn_units.disabled = true
	btn_next.visible = false

func _set_done_state_ui() -> void:
	state = State.DONE
	_set_knob_interactive(false)
	btn_analyze.disabled = true
	btn_risk.disabled = true
	btn_abort.disabled = true
	btn_units.disabled = true
	btn_next.visible = true

func _set_knob_interactive(is_enabled: bool) -> void:
	time_knob.mouse_filter = Control.MOUSE_FILTER_STOP if is_enabled else Control.MOUSE_FILTER_IGNORE
	btn_minus_1.disabled = not is_enabled
	btn_minus_01.disabled = not is_enabled
	btn_plus_01.disabled = not is_enabled
	btn_plus_1.disabled = not is_enabled

func _on_knob_value_changed(new_value: float, delta: float) -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_set_estimate(new_value)
	_register_knob_move(delta)

func _on_minus_01_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(-0.1)

func _on_plus_01_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(0.1)

func _on_minus_1_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(-1.0)

func _on_plus_1_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(1.0)

func _apply_estimate_delta(delta: float) -> void:
	var next_value: float = clampf(t_est + delta, MIN_ESTIMATE, MAX_ESTIMATE)
	if is_equal_approx(next_value, t_est):
		return
	time_knob.call("set_knob_value", next_value, false)
	_set_estimate(next_value)
	_register_knob_move(delta)

func _set_estimate(value_sec: float) -> void:
	t_est = clampf(value_sec, MIN_ESTIMATE, MAX_ESTIMATE)
	estimate_value_label.text = "t = %s %s" % [_format_num(t_est), SYMBOL_SEC]
	_update_details_text()

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec()

func _register_knob_move(delta: float) -> void:
	if is_zero_approx(delta):
		return
	knob_moves_count += 1
	var sign: int = 1 if delta > 0.0 else -1
	if _last_move_sign != 0 and sign != _last_move_sign:
		direction_changes += 1
	_last_move_sign = sign

func _on_analyze_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	analyze_count += 1
	if check_ms < 0:
		check_ms = Time.get_ticks_msec()
	detection_elapsed = 0.0
	transfer_elapsed = 0.0
	_set_analyzed_state_ui()
	_update_details_text()

func _on_risk_pressed() -> void:
	if state != State.ANALYZED and state != State.EXEC:
		return
	_register_first_action()
	if decision == Decision.RISK:
		return

	if decision_ms < 0:
		decision_ms = Time.get_ticks_msec()
	decision = Decision.RISK
	transfer_started = true
	transfer_elapsed = 0.0
	_set_exec_state_ui()
	status_label.text = TXT_EXEC_STARTED
	_update_details_text()

func _on_abort_pressed() -> void:
	if state != State.ANALYZED and state != State.EXEC:
		return
	_register_first_action()
	if decision_ms < 0:
		decision_ms = Time.get_ticks_msec()
	decision = Decision.ABORT

	if t_true > t_detect + EPS:
		_finalize_trial(Outcome.SAFE_ABORT, "ABORT")
	else:
		_finalize_trial(Outcome.MISSED_WINDOW, "ABORT")

func _on_units_pressed() -> void:
	if state == State.DONE:
		return
	_register_first_action()
	used_units = true
	status_label.text = TXT_UNITS_HINT
	_update_details_text()

func _on_details_pressed() -> void:
	_set_details_visible(true)

func _on_details_close_pressed() -> void:
	_set_details_visible(false)

func _set_details_visible(is_visible: bool) -> void:
	details_overlay.visible = is_visible

func _on_next_pressed() -> void:
	_start_trial()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _update_runtime_ui() -> void:
	var detect_ratio: float = 0.0
	if t_detect > 0.0:
		detect_ratio = clampf(detection_elapsed / t_detect, 0.0, 1.0)
	detection_bar.value = detect_ratio * 100.0
	detect_countdown.text = "%s %s" % [_format_num(maxf(0.0, t_detect - detection_elapsed)), SYMBOL_SEC]

	if decision == Decision.RISK and transfer_started and t_true > 0.0:
		var transfer_ratio: float = clampf(transfer_elapsed / t_true, 0.0, 1.0)
		transfer_bar.value = transfer_ratio * 100.0
		transfer_countdown.text = "%s %s" % [_format_num(maxf(0.0, t_true - transfer_elapsed)), SYMBOL_SEC]
	else:
		transfer_bar.value = 0.0
		transfer_countdown.text = "\u043e\u0436\u0438\u0434\u0430\u043d\u0438\u0435"

func _estimate_risk_text() -> String:
	if t_est <= t_detect - 0.5:
		return TXT_RISK_LOW
	if t_est <= t_detect + 0.5:
		return TXT_RISK_MID
	return TXT_RISK_HIGH

func _finalize_trial(result: Outcome, decision_label: String) -> void:
	if state == State.DONE:
		return

	outcome = result
	_set_done_state_ui()

	var is_success: bool = (outcome == Outcome.SUCCESS_SEND or outcome == Outcome.SAFE_ABORT)
	var sample_color: Color = COLOR_SAMPLE_FAIL
	match outcome:
		Outcome.SUCCESS_SEND:
			status_label.text = TXT_OUT_SUCCESS
			sample_color = COLOR_SAMPLE_SUCCESS
		Outcome.INTERCEPTED:
			status_label.text = TXT_OUT_INTERCEPT
			sample_color = COLOR_SAMPLE_FAIL
		Outcome.SAFE_ABORT:
			status_label.text = TXT_OUT_SAFE_ABORT
			sample_color = COLOR_SAMPLE_SUCCESS
		Outcome.MISSED_WINDOW:
			status_label.text = TXT_OUT_MISSED
			sample_color = COLOR_SAMPLE_WARN
		_:
			status_label.text = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u043e"
			sample_color = COLOR_SAMPLE_FAIL

	_update_sample_slot(sample_color)
	_send_trial_payload(is_success, decision_label)
	_update_details_text()

func _update_sample_slot(color: Color) -> void:
	if sample_refs.is_empty():
		return
	var slot: Dictionary = sample_refs[sample_cursor] as Dictionary
	var bg: ColorRect = slot["bg"] as ColorRect
	var mark: Label = slot["mark"] as Label
	bg.color = color
	mark.visible = (pool_type == "ANCHOR")
	sample_cursor = (sample_cursor + 1) % min(SAMPLE_SLOTS, sample_refs.size())

func _send_trial_payload(is_success: bool, decision_label: String) -> void:
	var now_ms: int = Time.get_ticks_msec()
	var elapsed_ms: int = now_ms - start_ms
	var time_to_first_action_ms: int = 0
	if first_action_ms >= 0:
		time_to_first_action_ms = first_action_ms - start_ms

	var time_to_check_ms: int = 0
	if check_ms >= 0:
		time_to_check_ms = check_ms - start_ms

	var time_to_decision_ms: int = elapsed_ms
	if decision_ms >= 0:
		time_to_decision_ms = decision_ms - start_ms

	var error_abs: float = absf(t_est - t_true)
	var error_rel: float = 0.0
	if t_true > 0.0:
		error_rel = error_abs / t_true

	var low_certainty: bool = (knob_moves_count >= 6 or direction_changes >= 2)
	var error_type: String = _classify_error_type(time_to_decision_ms)

	var payload: Dictionary = {
		"quest_id": "radio_intercept",
		"stage_id": "C",
		"match_key": _build_match_key(),
		"pool_type": pool_type,
		"anchor_type": anchor_type,
		"anchor": (pool_type == "ANCHOR"),
		"file_size_value": file_size_value,
		"file_size_unit": file_size_unit,
		"speed_mbit": speed_mbit,
		"t_detect": t_detect,
		"t_true": t_true,
		"t_est": t_est,
		"estimate_sec": t_est,
		"true_sec": t_true,
		"error_sec_abs": error_abs,
		"error_sec_rel": error_rel,
		"decision": decision_label,
		"outcome": _outcome_to_text(outcome),
		"used_units": used_units,
		"error_type": error_type,
		"knob_moves_count": knob_moves_count,
		"direction_changes": direction_changes,
		"analyze_count": analyze_count,
		"low_certainty": low_certainty,
		"valid_for_diagnostics": true,
		"valid_for_mastery": (not used_units) and (outcome == Outcome.SUCCESS_SEND or outcome == Outcome.SAFE_ABORT),
		"is_correct": is_success,
		"is_fit": is_success,
		"elapsed_ms": elapsed_ms,
		"time_to_first_action_ms": time_to_first_action_ms,
		"time_to_check_ms": time_to_check_ms,
		"time_to_decision_ms": time_to_decision_ms
	}
	GlobalMetrics.register_trial(payload)

func _classify_error_type(time_to_decision_ms: int) -> String:
	if used_units:
		return "assisted"
	if t_true <= 0.0:
		return "arithmetic_error"

	var rel_x8: float = absf((t_est * 8.0) - t_true) / t_true
	if rel_x8 < 0.15:
		return "forgot_x8"

	if file_size_unit == UNIT_GB:
		var rel_x1024: float = absf((t_est * 1024.0) - t_true) / t_true
		if rel_x1024 < 0.15:
			return "forgot_x1024"

	var rel_error: float = absf(t_est - t_true) / t_true
	if rel_error > 0.25:
		return "arithmetic_error"
	if time_to_decision_ms > 15000:
		return "hesitation"
	return "none"

func _build_match_key() -> String:
	var unit_token: String = "MB"
	if file_size_unit == UNIT_GB:
		unit_token = "GB"
	return "RI_C_%s%s_v%s_T%s_%s" % [
		unit_token,
		_format_key_num(file_size_value),
		_format_key_num(speed_mbit),
		_format_key_num(t_detect),
		pool_type
	]

func _outcome_to_text(current_outcome: Outcome) -> String:
	match current_outcome:
		Outcome.SUCCESS_SEND:
			return "SUCCESS_SEND"
		Outcome.INTERCEPTED:
			return "INTERCEPTED"
		Outcome.SAFE_ABORT:
			return "SAFE_ABORT"
		Outcome.MISSED_WINDOW:
			return "MISSED_WINDOW"
		_:
			return "NONE"

func _update_details_text() -> void:
	var lines: Array[String] = []
	lines.append("\u0424\u043e\u0440\u043c\u0443\u043b\u0430: t = I / v")
	lines.append("I (%s): %s" % [file_size_unit, _format_num(file_size_value)])
	lines.append("v (%s): %s" % [UNIT_MBIT_SEC, _format_num(speed_mbit)])
	lines.append("T_detect: %s %s" % [_format_num(t_detect), SYMBOL_SEC])
	lines.append("t_est: %s %s" % [_format_num(t_est), SYMBOL_SEC])
	if used_units:
		lines.append("\u041f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430 \u0435\u0434\u0438\u043d\u0438\u0446 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0430.")
	if state == State.DONE:
		lines.append("t_true: %s %s" % [_format_num(t_true), SYMBOL_SEC])
		lines.append("outcome: %s" % _outcome_to_text(outcome))
	else:
		lines.append("t_true: \u0441\u043a\u0440\u044b\u0442\u043e \u0434\u043e \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f")
	lines.append("\u0420\u0435\u0436\u0438\u043c \u043f\u0443\u043b\u0430: %s (%s)" % ["\u044f\u043a\u043e\u0440\u043d\u044b\u0439" if pool_type == "ANCHOR" else "\u043e\u0431\u044b\u0447\u043d\u044b\u0439", anchor_type])
	details_sheet_text.text = "\n".join(lines)

func _format_num(value: float) -> String:
	return "%.1f" % value

func _format_key_num(value: float) -> String:
	var text_value: String = "%.2f" % value
	while text_value.ends_with("0"):
		text_value = text_value.substr(0, text_value.length() - 1)
	if text_value.ends_with("."):
		text_value = text_value.substr(0, text_value.length() - 1)
	return text_value

func _play_alarm_flash() -> void:
	alarm_flash.color = Color(1.0, 0.05, 0.05, 0.0)
	var tw: Tween = create_tween()
	tw.tween_property(alarm_flash, "color:a", 0.35, 0.10)
	tw.tween_property(alarm_flash, "color:a", 0.0, 0.24)

func _on_stability_changed(new_value: float, _change: float) -> void:
	stability_label.text = "\u0421\u0422\u0410\u0411\u0418\u041b\u042c\u041d\u041e\u0421\u0422\u042c: %d%%" % int(new_value)
</file>

<file path="scenes/RadioQuestC.tscn">
[gd_scene load_steps=6 format=3]

[ext_resource type="Script" path="res://scenes/RadioQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="Script" path="res://scenes/TimeKnob.gd" id="3_knob_script"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="4_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_w857s"]

[node name="RadioQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("4_noir")]
layer = 100
script = ExtResource("4_w857s")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="TopBar" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2

[node name="TopBarHBox" type="HBoxContainer" parent="SafeArea/RootVBox/TopBar"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="BtnBack" type="Button" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "<-"

[node name="TitleLabel" type="Label" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 30
text = "ЗАГОЛОВОК"

[node name="ModeChip" type="Label" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ"

[node name="StabilityLabel" type="Label" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ"

[node name="BodyHSplit" type="HSplitContainer" parent="SafeArea/RootVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 760

[node name="LeftCol" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="MissionCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol"]
custom_minimum_size = Vector2(0, 160)
layout_mode = 2

[node name="MissionMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="MissionVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="MissionTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "МИССИЯ"

[node name="TaskLine1" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "СТРОКА1"

[node name="TaskLine2" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "СТРОКА2"

[node name="TaskLine3" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
theme_override_colors/font_color = Color(1, 0.8, 0.3, 1)
text = "СТРОКА3"

[node name="MicroHint" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
theme_override_colors/font_color = Color(0.75, 0.75, 0.75, 1)
text = "ПОДСКАЗКА"
autowrap_mode = 2

[node name="KnobCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol"]
layout_mode = 2
size_flags_vertical = 3

[node name="KnobMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="KnobVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Step1Label" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ШАГ1"

[node name="KnobCenter" type="CenterContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="TimeKnob" type="Control" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/KnobCenter"]
custom_minimum_size = Vector2(320, 320)
layout_mode = 2
script = ExtResource("3_knob_script")
min_value = 0.0
max_value = 30.0
step = 0.1
start_angle_deg = -225.0
end_angle_deg = 45.0
value = 0.0

[node name="EstimateValue" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 38
text = "t = 0.0"
horizontal_alignment = 1

[node name="FineButtonsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnMinus1" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "-1"

[node name="BtnMinus01" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "-0.1"

[node name="BtnPlus01" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "+0.1"

[node name="BtnPlus1" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "+1"

[node name="BtnAnalyze" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "АНАЛИЗ"

[node name="StatusCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol"]
custom_minimum_size = Vector2(0, 96)
layout_mode = 2

[node name="StatusMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/StatusCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 8

[node name="StatusLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/StatusCard/StatusMargin"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "СТАТУС"
autowrap_mode = 2

[node name="RightCol" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="RiskCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol"]
layout_mode = 2
size_flags_vertical = 3

[node name="RiskMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="RiskVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Step2Label" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ШАГ2"

[node name="DetectionTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "ОБНАРУЖЕНИЕ"

[node name="DetectionBar" type="ProgressBar" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
show_percentage = false

[node name="DetectCountdown" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "--"

[node name="TransferTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "ПЕРЕДАЧА"

[node name="TransferBar" type="ProgressBar" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
show_percentage = false

[node name="TransferCountdown" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "--"

[node name="RiskLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "РИСК"

[node name="ActionsCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2

[node name="ActionsMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="ActionsVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Step3Label" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ШАГ3"

[node name="PrimaryActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnRisk" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "РИСК"

[node name="BtnAbort" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРЕРВАТЬ"

[node name="SecondaryActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnUnits" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ЕДИНИЦЫ"

[node name="BtnDetails" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕТАЛИ"

[node name="BtnNext" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="SampleStrip" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="Sample1" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample1"]
layout_mode = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample1"]
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample2" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample2"]
layout_mode = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample2"]
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample3" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample3"]
layout_mode = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample3"]
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample4" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample4"]
layout_mode = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample4"]
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample5" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample5"]
layout_mode = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample5"]
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample6" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample6"]
layout_mode = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample6"]
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample7" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample7"]
layout_mode = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample7"]
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="DetailsOverlay" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1

[node name="Dim" type="ColorRect" parent="DetailsOverlay"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
color = Color(0, 0, 0, 0.6)

[node name="BottomSheet" type="PanelContainer" parent="DetailsOverlay"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.12
anchor_top = 0.3
anchor_right = 0.88
anchor_bottom = 0.94
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1

[node name="SheetMargin" type="MarginContainer" parent="DetailsOverlay/BottomSheet"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="SheetVBox" type="VBoxContainer" parent="DetailsOverlay/BottomSheet/SheetMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="SheetTitle" type="Label" parent="DetailsOverlay/BottomSheet/SheetMargin/SheetVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 28
text = "ДЕТАЛИ"

[node name="SheetText" type="RichTextLabel" parent="DetailsOverlay/BottomSheet/SheetMargin/SheetVBox"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2
size_flags_vertical = 3

[node name="BtnCloseDetails" type="Button" parent="DetailsOverlay/BottomSheet/SheetMargin/SheetVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "ЗАКРЫТЬ"

[node name="AlarmFlash" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
color = Color(1, 0.05, 0.05, 0)
</file>

<file path="scenes/decryptor/DecryptorUI.tscn">
[gd_scene load_steps=3 format=3 uid="uid://c4p1o1h01r4g6"]

[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="1_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="2_overlay"]

[node name="DecryptorUI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("1_theme")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("2_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="Main" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="HeaderBar" type="PanelContainer" parent="SafeArea/Main"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2

[node name="HeaderContent" type="HBoxContainer" parent="SafeArea/Main/HeaderBar"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(64, 52)
layout_mode = 2
text = "<"

[node name="ModeChip" type="PanelContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(80, 40)
layout_mode = 2

[node name="ModeLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/ModeChip"]
layout_mode = 2
text = "ДЕК"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Spacer1" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LevelLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
text = "ПРОТОКОЛ A-1"

[node name="Spacer2" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="StabilityGroup" type="VBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2

[node name="StabilityText" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
custom_minimum_size = Vector2(170, 18)
layout_mode = 2
value = 100.0

[node name="Shields" type="HBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ShieldFreq" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "F"

[node name="ShieldLazy" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "L"

[node name="BtnDetails" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(72, 48)
layout_mode = 2
text = "ЛОГ"

[node name="ContentSplit" type="HBoxContainer" parent="SafeArea/Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="LeftPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.45
theme_override_constants/separation = 10

[node name="TargetPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2

[node name="TargetContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="TargetTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent"]
layout_mode = 2
text = "ЦЕЛЬ"

[node name="TargetValueBig" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent"]
layout_mode = 2
theme_override_font_sizes/font_size = 36
text = "00"
horizontal_alignment = 1

[node name="TargetSub" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent"]
layout_mode = 2
horizontal_alignment = 1

[node name="InputPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2

[node name="InputContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InputBin" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent"]
layout_mode = 2
text = "BIN: 0000 0000"

[node name="InputBasesRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="InputDec" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow"]
layout_mode = 2
text = "DEC: 0"

[node name="InputOct" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow"]
layout_mode = 2
text = "OCT: 0"

[node name="InputHex" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow"]
layout_mode = 2
text = "HEX: 0"

[node name="SwitchesPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="SwitchesContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="NibblesCenter" type="CenterContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="NibblesRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="UpperNibble" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="UpperTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/UpperNibble"]
layout_mode = 2
text = "ВЫСОКИЙ"
horizontal_alignment = 1

[node name="UpperBits" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/UpperNibble"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="LowerNibble" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="LowerTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/LowerNibble"]
layout_mode = 2
text = "НИЗКИЙ"
horizontal_alignment = 1

[node name="LowerBits" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/LowerNibble"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="WeightsRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="RightPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="RankPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="RankContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="RankTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent"]
layout_mode = 2
text = "РАНГ"

[node name="RankLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "НОВИЧОК"

[node name="ProgressLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent"]
layout_mode = 2
text = "УРОВЕНЬ 1 / 30"

[node name="ProtocolPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="ProtocolContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="ProtocolTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent"]
layout_mode = 2
text = "ДИАГНОСТИКА ПРОТОКОЛА"

[node name="RegsRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="RegAValue" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow"]
layout_mode = 2
text = "A: --"

[node name="RegBValue" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow"]
layout_mode = 2
text = "B: --"

[node name="OpValue" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow"]
layout_mode = 2
text = "OP: --"

[node name="ShiftStatus" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent"]
layout_mode = 2
text = "СДВИГ: ожидание"

[node name="LiveLogPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="LiveLogContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="LiveLogTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
text = "ЖИВОЙ ТЕРМИНАЛ"

[node name="LiveLogText" type="RichTextLabel" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
size_flags_vertical = 3
scroll_following = true

[node name="HintPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="HintContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="HintTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "ПОСЛЕДНЯЯ ДИАГНОСТИКА"

[node name="HintText" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "Диагностики пока нет."
autowrap_mode = 3

[node name="BottomBar" type="PanelContainer" parent="SafeArea/Main"]
layout_mode = 2

[node name="Actions" type="HBoxContainer" parent="SafeArea/Main/BottomBar"]
layout_mode = 2
theme_override_constants/separation = 10
alignment = 1

[node name="BtnHint" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ПОДСКАЗКА"

[node name="BtnCheck" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПРОВЕРИТЬ"

[node name="BtnReset" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "СБРОС"

[node name="ToastLayer" type="CanvasLayer" parent="."]

[node name="Toast" type="PanelContainer" parent="ToastLayer"]
visible = false
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -180.0
offset_top = -120.0
offset_right = 180.0
offset_bottom = -60.0
grow_horizontal = 2

[node name="ToastLabel" type="Label" parent="ToastLayer/Toast"]
layout_mode = 2
horizontal_alignment = 1
vertical_alignment = 1

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = 0.0
offset_bottom = 380.0
grow_horizontal = 2
grow_vertical = 2

[node name="DetailsContent" type="VBoxContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="DetailsHeader" type="HBoxContainer" parent="DetailsSheet/DetailsContent"]
layout_mode = 2

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsContent/DetailsHeader"]
layout_mode = 2
text = "ДЕТАЛИ"

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsContent/DetailsHeader"]
custom_minimum_size = Vector2(84, 42)
layout_mode = 2
text = "ЗАКРЫТЬ"

[node name="DetailsScroll" type="ScrollContainer" parent="DetailsSheet/DetailsContent"]
custom_minimum_size = Vector2(0, 260)
layout_mode = 2

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsContent/DetailsScroll"]
layout_mode = 2
bbcode_enabled = true

[node name="SafeModeOverlay" type="CanvasLayer" parent="."]
visible = false

[node name="Dim" type="ColorRect" parent="SafeModeOverlay"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.6)

[node name="CenterContainer" type="CenterContainer" parent="SafeModeOverlay"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="SafePanel" type="PanelContainer" parent="SafeModeOverlay/CenterContainer"]
custom_minimum_size = Vector2(0, 360)
layout_mode = 2

[node name="SafeContent" type="VBoxContainer" parent="SafeModeOverlay/CenterContainer/SafePanel"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="SafeTitle" type="Label" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
layout_mode = 2
text = "БЕЗОПАСНЫЙ РЕЖИМ: АНАЛИЗ ОШИБОК"

[node name="SafeSummary" type="RichTextLabel" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
bbcode_enabled = true

[node name="SafeBitsRow" type="HBoxContainer" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="SafeActions" type="HBoxContainer" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnRetry" type="Button" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ПОВТОРИТЬ"

[node name="BtnContinue" type="Button" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ПРОДОЛЖИТЬ"
</file>

<file path="scenes/LearnSelect.gd">
extends Control

const PHONE_LANDSCAPE_MAX_HEIGHT := 520.0
const MOBILE_BREAKPOINT := 840.0
const TABLET_BREAKPOINT := 1300.0

@onready var safe_area: MarginContainer = $SafeArea
@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var title_label: Label = $SafeArea/MainLayout/Title
@onready var quest_grid: GridContainer = $SafeArea/MainLayout/QuestGrid
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel

@onready var btn_clues: Button = $SafeArea/MainLayout/QuestGrid/CluesButton
@onready var btn_radio: Button = $SafeArea/MainLayout/QuestGrid/RadioButton
@onready var btn_decryptor: Button = $SafeArea/MainLayout/QuestGrid/DecryptorButton
@onready var btn_lie: Button = $SafeArea/MainLayout/QuestGrid/LieDetectorButton
@onready var btn_script: Button = $SafeArea/MainLayout/QuestGrid/SuspectScriptButton
@onready var btn_city: Button = $SafeArea/MainLayout/QuestGrid/CityMapButton
@onready var btn_archive: Button = $SafeArea/MainLayout/QuestGrid/DataArchiveButton
@onready var btn_report: Button = $SafeArea/MainLayout/QuestGrid/FinalReportButton
@onready var btn_network_trace: Button = $SafeArea/MainLayout/QuestGrid/NetworkTraceButton

const COLOR_READY := Color(0.88, 0.88, 0.88, 1.0)
const COLOR_LOCKED := Color(0.92, 0.36, 0.4, 1.0)

const TITLE_TEXT := "ОБУЧЕНИЕ"
const STATUS_READY := "Выберите учебный модуль"
const STATUS_LOCKED := "Этот модуль пока не готов"

const BTN_CLUES_TEXT := "Цифровая реанимация (скоро)"
const BTN_RADIO_TEXT := "Радиоперехват A"
const BTN_DECRYPTOR_TEXT := "Дешифрование A"
const BTN_LIE_TEXT := "Детектор лжи A"
const BTN_SCRIPT_TEXT := "Скрипт подозреваемого (скоро)"
const BTN_CITY_TEXT := "Карта города (скоро)"
const BTN_ARCHIVE_TEXT := "Архив данных (скоро)"
const BTN_REPORT_TEXT := "Финальный отчет (скоро)"
const BTN_NETWORK_TRACE_TEXT := "Сетевой след (скоро)"

func _ready() -> void:
	title_label.text = TITLE_TEXT
	status_label.text = STATUS_READY
	status_label.modulate = COLOR_READY

	_set_button_labels()
	_connect_buttons()
	_disable_unready()
	_on_viewport_size_changed()
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)
	call_deferred("_animate_intro")

func _set_button_labels() -> void:
	btn_clues.text = BTN_CLUES_TEXT
	btn_radio.text = BTN_RADIO_TEXT
	btn_decryptor.text = BTN_DECRYPTOR_TEXT
	btn_lie.text = BTN_LIE_TEXT
	btn_script.text = BTN_SCRIPT_TEXT
	btn_city.text = BTN_CITY_TEXT
	btn_archive.text = BTN_ARCHIVE_TEXT
	btn_report.text = BTN_REPORT_TEXT
	btn_network_trace.text = BTN_NETWORK_TRACE_TEXT

func _connect_buttons() -> void:
	btn_decryptor.pressed.connect(_on_decryptor_pressed)
	btn_lie.pressed.connect(_on_lie_detector_pressed)
	btn_radio.pressed.connect(_on_radio_pressed)
	btn_clues.pressed.connect(_on_locked_pressed)
	btn_script.pressed.connect(_on_locked_pressed)
	btn_city.pressed.connect(_on_locked_pressed)
	btn_archive.pressed.connect(_on_locked_pressed)
	btn_report.pressed.connect(_on_locked_pressed)
	btn_network_trace.pressed.connect(_on_locked_pressed)

func _disable_unready() -> void:
	btn_clues.disabled = true
	btn_radio.disabled = false
	btn_script.disabled = true
	btn_city.disabled = true
	btn_archive.disabled = true
	btn_report.disabled = true
	btn_network_trace.disabled = true

func _on_decryptor_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/Decryptor.tscn")

func _on_lie_detector_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/LogicQuestA.tscn")

func _on_radio_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/RadioQuestA.tscn")

func _on_locked_pressed() -> void:
	status_label.text = STATUS_LOCKED
	status_label.modulate = COLOR_LOCKED

func _on_viewport_size_changed() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var width: float = viewport_size.x
	if _is_phone_landscape(viewport_size):
		quest_grid.columns = 3
		_apply_layout_profile(38, 15, 70, 8, 10, 6)
	elif width < MOBILE_BREAKPOINT:
		quest_grid.columns = 1
		_apply_layout_profile(48, 18, 100, 12, 16, 12)
	elif width < TABLET_BREAKPOINT:
		quest_grid.columns = 2
		_apply_layout_profile(54, 19, 108, 14, 20, 14)
	else:
		quest_grid.columns = 3
		_apply_layout_profile(58, 20, 118, 14, 24, 16)

func _is_phone_landscape(size: Vector2) -> bool:
	return size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

func _apply_layout_profile(title_size: int, info_size: int, button_height: float, gap: int, margin_side: int, margin_vertical: int) -> void:
	title_label.add_theme_font_size_override("font_size", title_size)
	status_label.add_theme_font_size_override("font_size", info_size)
	status_label.custom_minimum_size.y = max(32.0, button_height * 0.4)
	main_layout.add_theme_constant_override("separation", gap + 6)
	quest_grid.add_theme_constant_override("h_separation", gap)
	quest_grid.add_theme_constant_override("v_separation", gap)
	safe_area.add_theme_constant_override("margin_left", margin_side)
	safe_area.add_theme_constant_override("margin_right", margin_side)
	safe_area.add_theme_constant_override("margin_top", margin_vertical)
	safe_area.add_theme_constant_override("margin_bottom", margin_vertical)
	for btn in _all_module_buttons():
		btn.custom_minimum_size = Vector2(0.0, button_height)
		btn.add_theme_font_size_override("font_size", clamp(info_size + 1, 16, 20))

func _animate_intro() -> void:
	title_label.modulate.a = 0.0
	var tween: Tween = create_tween()
	tween.tween_property(title_label, "modulate:a", 1.0, 0.3)

	for i in range(_all_module_buttons().size()):
		var btn: Button = _all_module_buttons()[i]
		btn.modulate.a = 0.0
		btn.scale = Vector2(0.97, 0.97)
		btn.pivot_offset = btn.size * 0.5
		var item_tween: Tween = create_tween()
		var delay: float = 0.06 * float(i)
		item_tween.tween_property(btn, "modulate:a", 1.0, 0.2).set_delay(delay)
		item_tween.parallel().tween_property(btn, "scale", Vector2.ONE, 0.24).set_delay(delay).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)

func _all_module_buttons() -> Array[Button]:
	return [
		btn_clues,
		btn_radio,
		btn_decryptor,
		btn_lie,
		btn_script,
		btn_city,
		btn_archive,
		btn_report,
		btn_network_trace
	]
</file>

<file path="scenes/LogicQuestA.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/LogicQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_14mg7"]

[node name="LogicQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_14mg7")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8
alignment = 1

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕТЕКТОР ЛЖИ A-01"

[node name="LblSessionId" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "СЕССИЯ: 00/00 • CASE A_00"
horizontal_alignment = 2

[node name="BarsRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="FactsBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="EnergyBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 100.0
show_percentage = false

[node name="TargetDisplay" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="LblTarget" type="Label" parent="SafeArea/MainLayout/TargetDisplay"]
layout_mode = 2
text = "ЦЕЛЬ: собрать факты 0/0 и вынести вердикт"
horizontal_alignment = 1

[node name="ContentHSplit" type="HSplitContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 600

[node name="LeftPane" type="VBoxContainer" parent="SafeArea/MainLayout/ContentHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="TerminalFrame" type="PanelContainer" parent="SafeArea/MainLayout/ContentHSplit/LeftPane"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="TerminalScroll" type="ScrollContainer" parent="SafeArea/MainLayout/ContentHSplit/LeftPane/TerminalFrame"]
layout_mode = 2

[node name="TerminalRichText" type="RichTextLabel" parent="SafeArea/MainLayout/ContentHSplit/LeftPane/TerminalFrame/TerminalScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "[b]БРИФИНГ[/b]
..."
fit_content = true

[node name="RightPane" type="VBoxContainer" parent="SafeArea/MainLayout/ContentHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="InteractionRow" type="HBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 12
alignment = 1

[node name="InputAFrame" type="PanelContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow"]
layout_mode = 2
size_flags_horizontal = 3

[node name="InputAVBox" type="VBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputAFrame"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InputATitle" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputAFrame/InputAVBox"]
layout_mode = 2
text = "КЛЮЧ A"
horizontal_alignment = 1

[node name="InputA_Btn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputAFrame/InputAVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
toggle_mode = true
text = "A
[0]"

[node name="InputBFrame" type="PanelContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow"]
layout_mode = 2
size_flags_horizontal = 3

[node name="InputBVBox" type="VBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputBFrame"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InputBTitle" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputBFrame/InputBVBox"]
layout_mode = 2
text = "КЛЮЧ B"
horizontal_alignment = 1

[node name="InputB_Btn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputBFrame/InputBVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
toggle_mode = true
text = "B
[0]"

[node name="GateSlot" type="PanelContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow"]
layout_mode = 2
size_flags_horizontal = 3

[node name="GateVBox" type="VBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/GateSlot"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="GateTitle" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/GateSlot/GateVBox"]
layout_mode = 2
text = "ВЕНТИЛЬ"
horizontal_alignment = 1

[node name="GateLabel" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/GateSlot/GateVBox"]
layout_mode = 2
text = "GATE: ?"
horizontal_alignment = 1

[node name="OutputSlot" type="PanelContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow"]
layout_mode = 2
size_flags_horizontal = 3

[node name="OutputVBox" type="VBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/OutputSlot"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="OutputTitle" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/OutputSlot/OutputVBox"]
layout_mode = 2
text = "ВЫВОД"
horizontal_alignment = 1

[node name="OutputValueLabel" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/OutputSlot/OutputVBox"]
layout_mode = 2
text = "F = 0"
horizontal_alignment = 1

[node name="InventoryFrame" type="PanelContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="InventoryMargin" type="MarginContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="InventoryScroll" type="ScrollContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin"]
layout_mode = 2

[node name="GatesContainer" type="HBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 14
alignment = 1

[node name="GateAndBtn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "∧ AND"

[node name="GateOrBtn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "∨ OR"

[node name="GateNotBtn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "¬ NOT"

[node name="GateXorBtn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "⊕ XOR"

[node name="GateNandBtn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "⊼ NAND"

[node name="GateNorBtn" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer"]
custom_minimum_size = Vector2(128, 64)
layout_mode = 2
toggle_mode = true
text = "⊽ NOR"

[node name="StatusRow" type="HBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="StatsLabel" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/StatusRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ПОП: 0/3 • ФАКТЫ: 0/0 • СТАБ: 100%"

[node name="FeedbackLabel" type="Label" parent="SafeArea/MainLayout/ContentHSplit/RightPane/StatusRow"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
text = "..."
horizontal_alignment = 2

[node name="Actions" type="HBoxContainer" parent="SafeArea/MainLayout/ContentHSplit/RightPane"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnHint" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПОДСКАЗКА"

[node name="BtnVerdict" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ВЕРДИКТ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/ContentHSplit/RightPane/Actions"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="ClickPlayer" type="AudioStreamPlayer" parent="."]

[node name="DiagnosticsBlocker" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.45)

[node name="DiagnosticsPanelA" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -360.0
offset_top = -210.0
offset_right = 360.0
offset_bottom = 210.0
grow_horizontal = 2
grow_vertical = 2

[node name="PopupMargin" type="MarginContainer" parent="DiagnosticsPanelA"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="PopupVBox" type="VBoxContainer" parent="DiagnosticsPanelA/PopupMargin"]
layout_mode = 2
theme_override_constants/separation = 16

[node name="PopupTitle" type="Label" parent="DiagnosticsPanelA/PopupMargin/PopupVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 26
text = "SAFE MODE"
horizontal_alignment = 1

[node name="PopupText" type="RichTextLabel" parent="DiagnosticsPanelA/PopupMargin/PopupVBox"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Диагностический отчёт."
fit_content = true

[node name="PopupBtnNext" type="Button" parent="DiagnosticsPanelA/PopupMargin/PopupVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "ДАЛЕЕ"

[connection signal="pressed" from="SafeArea/MainLayout/Header/BtnBack" to="." method="_on_back_button_pressed"]
[connection signal="toggled" from="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputAFrame/InputAVBox/InputA_Btn" to="." method="_on_input_a_toggled"]
[connection signal="toggled" from="SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputBFrame/InputBVBox/InputB_Btn" to="." method="_on_input_b_toggled"]
[connection signal="pressed" from="SafeArea/MainLayout/ContentHSplit/RightPane/Actions/BtnHint" to="." method="_on_hint_pressed"]
[connection signal="pressed" from="SafeArea/MainLayout/ContentHSplit/RightPane/Actions/BtnVerdict" to="." method="_on_verdict_pressed"]
[connection signal="pressed" from="SafeArea/MainLayout/ContentHSplit/RightPane/Actions/BtnNext" to="." method="_on_next_button_pressed"]
[connection signal="pressed" from="DiagnosticsPanelA/PopupMargin/PopupVBox/PopupBtnNext" to="." method="_on_diagnostics_close_pressed"]
</file>

<file path="scenes/LogicQuestB.gd">
extends Control

const LAYOUT_CASCADE_TOP := "CASCADE_TOP" # (A op B) op C
const LAYOUT_CASCADE_BOTTOM := "CASCADE_BOTTOM" # A op (B op C)

const GATE_NONE := "NONE"
const GATE_AND := "AND"
const GATE_OR := "OR"
const GATE_NOT := "NOT"
const GATE_XOR := "XOR"
const GATE_NAND := "NAND"
const GATE_NOR := "NOR"

const MAX_ATTEMPTS := 3

const CASES := [
	{
		"id": "B_01",
		"layout": LAYOUT_CASCADE_TOP,
		"story": "Соберите двухэтапную схему: сначала узел A/B, затем результат с C.",
		"labels": ["ДАТЧИК A", "ДАТЧИК B", "ДАТЧИК C"],
		"correct_gates": [GATE_OR, GATE_AND],
		"hint": "Сначала объедините A и B через OR, затем примените AND с C."
	},
	{
		"id": "B_02",
		"layout": LAYOUT_CASCADE_BOTTOM,
		"story": "Схема перестроена: сначала обрабатывается пара B/C, затем узел A.",
		"labels": ["КЛЮЧ A", "КЛЮЧ B", "КЛЮЧ C"],
		"correct_gates": [GATE_AND, GATE_OR],
		"hint": "Во внутреннем слоте нужен AND, во внешнем слоте - OR."
	},
	{
		"id": "B_03",
		"layout": LAYOUT_CASCADE_TOP,
		"story": "Нужен канал, где первый этап ловит различие A/B, а второй фильтрует через C.",
		"labels": ["КАНАЛ A", "КАНАЛ B", "ФИЛЬТР C"],
		"correct_gates": [GATE_XOR, GATE_AND],
		"hint": "Различие на первом этапе даёт XOR."
	},
	{
		"id": "B_04",
		"layout": LAYOUT_CASCADE_BOTTOM,
		"story": "Схема с инверсией: сначала инвертируется B/C, затем объединяется с A.",
		"labels": ["ОПОРНЫЙ A", "ШУМ B", "ШУМ C"],
		"correct_gates": [GATE_NOR, GATE_OR],
		"hint": "Внутренний этап - NOR, внешний - OR."
	},
	{
		"id": "B_05",
		"layout": LAYOUT_CASCADE_TOP,
		"story": "Соберите устойчивый тракт с финальным отрицанием совпадения.",
		"labels": ["ЛИНИЯ A", "ЛИНИЯ B", "ЛИНИЯ C"],
		"correct_gates": [GATE_AND, GATE_NAND],
		"hint": "Сначала нужно совпадение A и B, затем отрицание с C."
	}
]

@onready var clue_title_label: Label = $SafeArea/MainLayout/Header/LblClueTitle
@onready var session_label: Label = $SafeArea/MainLayout/Header/LblSessionId
@onready var facts_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/FactsBar
@onready var energy_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/EnergyBar
@onready var target_label: Label = $SafeArea/MainLayout/TargetDisplay/LblTarget
@onready var terminal_text: RichTextLabel = $SafeArea/MainLayout/TerminalFrame/TerminalScroll/TerminalRichText
@onready var stats_label: Label = $SafeArea/MainLayout/StatusRow/StatsLabel
@onready var feedback_label: Label = $SafeArea/MainLayout/StatusRow/FeedbackLabel

@onready var input_a_btn: Button = $SafeArea/MainLayout/InteractionRow/InputAFrame/InputAVBox/InputA_Btn
@onready var input_b_btn: Button = $SafeArea/MainLayout/InteractionRow/InputBFrame/InputBVBox/InputB_Btn
@onready var input_c_btn: Button = $SafeArea/MainLayout/InteractionRow/InputCFrame/InputCVBox/InputC_Btn
@onready var slot1_btn: Button = $SafeArea/MainLayout/InteractionRow/Slot1Frame/Slot1VBox/Slot1SelectBtn
@onready var slot2_btn: Button = $SafeArea/MainLayout/InteractionRow/Slot2Frame/Slot2VBox/Slot2SelectBtn
@onready var inter_value_label: Label = $SafeArea/MainLayout/InteractionRow/InterSlot/InterVBox/InterValueLabel
@onready var output_value_label: Label = $SafeArea/MainLayout/InteractionRow/OutputSlot/OutputVBox/OutputValueLabel

@onready var gate_and_btn: Button = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateAndBtn
@onready var gate_or_btn: Button = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateOrBtn
@onready var gate_not_btn: Button = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateNotBtn
@onready var gate_xor_btn: Button = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateXorBtn
@onready var gate_nand_btn: Button = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateNandBtn
@onready var gate_nor_btn: Button = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateNorBtn

@onready var btn_hint: Button = $SafeArea/MainLayout/Actions/BtnHint
@onready var btn_test: Button = $SafeArea/MainLayout/Actions/BtnTest
@onready var btn_next: Button = $SafeArea/MainLayout/Actions/BtnNext
@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack

@onready var diagnostics_blocker: ColorRect = $DiagnosticsBlocker
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanelB
@onready var diagnostics_title: Label = $DiagnosticsPanelB/PopupMargin/PopupVBox/PopupTitle
@onready var diagnostics_text: RichTextLabel = $DiagnosticsPanelB/PopupMargin/PopupVBox/PopupText
@onready var diagnostics_next_button: Button = $DiagnosticsPanelB/PopupMargin/PopupVBox/PopupBtnNext
@onready var click_player: AudioStreamPlayer = $ClickPlayer

var current_case_idx: int = 0
var current_case: Dictionary = {}

var inputs: Array[bool] = [false, false, false]
var placed_gates: Array[String] = [GATE_NONE, GATE_NONE]
var selected_slot_idx: int = -1

var attempts: int = 0
var hints_used: int = 0
var test_count: int = 0
var is_complete: bool = false
var is_safe_mode: bool = false
var case_started_ms: int = 0
var first_action_ms: int = -1
var trace_lines: Array[String] = []

var gate_buttons: Dictionary = {}

func _ready() -> void:
	_connect_ui_signals()
	_setup_gate_buttons()
	_update_stability_ui(GlobalMetrics.stability, 0.0)
	if not GlobalMetrics.stability_changed.is_connected(_update_stability_ui):
		GlobalMetrics.stability_changed.connect(_update_stability_ui)
	if not GlobalMetrics.game_over.is_connected(_on_game_over):
		GlobalMetrics.game_over.connect(_on_game_over)
	load_case(0)

func _connect_ui_signals() -> void:
	if not btn_back.pressed.is_connected(_on_back_button_pressed):
		btn_back.pressed.connect(_on_back_button_pressed)
	if not input_a_btn.toggled.is_connected(_on_input_a_toggled):
		input_a_btn.toggled.connect(_on_input_a_toggled)
	if not input_b_btn.toggled.is_connected(_on_input_b_toggled):
		input_b_btn.toggled.connect(_on_input_b_toggled)
	if not input_c_btn.toggled.is_connected(_on_input_c_toggled):
		input_c_btn.toggled.connect(_on_input_c_toggled)
	if not slot1_btn.pressed.is_connected(_on_slot1_pressed):
		slot1_btn.pressed.connect(_on_slot1_pressed)
	if not slot2_btn.pressed.is_connected(_on_slot2_pressed):
		slot2_btn.pressed.connect(_on_slot2_pressed)

	var gate_callbacks: Dictionary = {
		gate_and_btn: Callable(self, "_on_gate_button_toggled").bind(GATE_AND),
		gate_or_btn: Callable(self, "_on_gate_button_toggled").bind(GATE_OR),
		gate_not_btn: Callable(self, "_on_gate_button_toggled").bind(GATE_NOT),
		gate_xor_btn: Callable(self, "_on_gate_button_toggled").bind(GATE_XOR),
		gate_nand_btn: Callable(self, "_on_gate_button_toggled").bind(GATE_NAND),
		gate_nor_btn: Callable(self, "_on_gate_button_toggled").bind(GATE_NOR)
	}
	for gate_btn_var in gate_callbacks.keys():
		var gate_btn: Button = gate_btn_var
		var cb: Callable = gate_callbacks[gate_btn]
		if not gate_btn.toggled.is_connected(cb):
			gate_btn.toggled.connect(cb)

	if not btn_hint.pressed.is_connected(_on_hint_pressed):
		btn_hint.pressed.connect(_on_hint_pressed)
	if not btn_test.pressed.is_connected(_on_test_pressed):
		btn_test.pressed.connect(_on_test_pressed)
	if not btn_next.pressed.is_connected(_on_next_button_pressed):
		btn_next.pressed.connect(_on_next_button_pressed)
	if not diagnostics_next_button.pressed.is_connected(_on_diagnostics_close_pressed):
		diagnostics_next_button.pressed.connect(_on_diagnostics_close_pressed)

func _setup_gate_buttons() -> void:
	gate_buttons = {
		GATE_AND: gate_and_btn,
		GATE_OR: gate_or_btn,
		GATE_NOT: gate_not_btn,
		GATE_XOR: gate_xor_btn,
		GATE_NAND: gate_nand_btn,
		GATE_NOR: gate_nor_btn
	}
	_clear_gate_button_presses()

func load_case(idx: int) -> void:
	if idx >= CASES.size():
		idx = 0

	current_case_idx = idx
	current_case = CASES[idx]
	inputs = [false, false, false]
	placed_gates = [GATE_NONE, GATE_NONE]
	selected_slot_idx = -1
	attempts = 0
	hints_used = 0
	test_count = 0
	is_complete = false
	is_safe_mode = false
	case_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	trace_lines.clear()

	clue_title_label.text = "ДЕТЕКТОР ЛЖИ B-01"
	input_a_btn.text = "%s\n[0]" % str(current_case.get("labels", ["A"])[0])
	input_b_btn.text = "%s\n[0]" % str(current_case.get("labels", ["A", "B"])[1])
	input_c_btn.text = "%s\n[0]" % str(current_case.get("labels", ["A", "B", "C"])[2])
	input_a_btn.button_pressed = false
	input_b_btn.button_pressed = false
	input_c_btn.button_pressed = false
	input_a_btn.disabled = false
	input_b_btn.disabled = false
	input_c_btn.disabled = false

	btn_hint.disabled = false
	btn_test.disabled = true
	btn_next.visible = false
	feedback_label.visible = false
	feedback_label.text = ""
	_hide_diagnostics()
	_set_gate_buttons_enabled(false)
	_clear_gate_button_presses()

	_update_slot_visual(0)
	_update_slot_visual(1)
	_update_outputs()
	_append_trace("Сценарий загружен. Выберите слот и установите модуль.")
	_update_terminal()
	_update_stats_ui()
	_update_ui_state()

func _on_input_a_toggled(pressed: bool) -> void:
	_mark_first_action()
	inputs[0] = pressed
	input_a_btn.text = "%s\n[%d]" % [str(current_case.get("labels", ["A"])[0]), 1 if pressed else 0]
	_update_outputs()
	_update_terminal()
	_update_ui_state()
	_play_click()

func _on_input_b_toggled(pressed: bool) -> void:
	_mark_first_action()
	inputs[1] = pressed
	input_b_btn.text = "%s\n[%d]" % [str(current_case.get("labels", ["A", "B"])[1]), 1 if pressed else 0]
	_update_outputs()
	_update_terminal()
	_update_ui_state()
	_play_click()

func _on_input_c_toggled(pressed: bool) -> void:
	_mark_first_action()
	inputs[2] = pressed
	input_c_btn.text = "%s\n[%d]" % [str(current_case.get("labels", ["A", "B", "C"])[2]), 1 if pressed else 0]
	_update_outputs()
	_update_terminal()
	_update_ui_state()
	_play_click()

func _on_slot1_pressed() -> void:
	if is_complete:
		return
	_mark_first_action()
	selected_slot_idx = 0
	_update_slot_selection_visual()
	_set_gate_buttons_enabled(true)
	_show_feedback("Выбран SLOT 1. Установите модуль из инвентаря.", Color(0.56, 0.78, 0.96))
	_play_click()

func _on_slot2_pressed() -> void:
	if is_complete:
		return
	_mark_first_action()
	selected_slot_idx = 1
	_update_slot_selection_visual()
	_set_gate_buttons_enabled(true)
	_show_feedback("Выбран SLOT 2. Установите модуль из инвентаря.", Color(0.56, 0.78, 0.96))
	_play_click()

func _on_gate_button_toggled(arg1: Variant, arg2: Variant = null) -> void:
	var pressed := false
	var gate_id := ""
	if arg1 is bool:
		pressed = arg1
		gate_id = str(arg2)
	else:
		gate_id = str(arg1)
		pressed = bool(arg2)
	if gate_id.is_empty():
		return

	if not pressed:
		return
	if is_complete or is_safe_mode:
		_clear_gate_button_presses()
		return
	if selected_slot_idx < 0:
		_show_feedback("Сначала выберите SLOT 1 или SLOT 2.", Color(1.0, 0.78, 0.32))
		_clear_gate_button_presses()
		return

	_mark_first_action()
	placed_gates[selected_slot_idx] = gate_id
	_update_slot_visual(selected_slot_idx)
	_append_trace("SLOT %d <= %s" % [selected_slot_idx + 1, _gate_symbol(gate_id)])
	selected_slot_idx = -1
	_update_slot_selection_visual()
	_set_gate_buttons_enabled(false)
	_clear_gate_button_presses()
	_update_outputs()
	_update_terminal()
	_update_ui_state()
	_play_click()

func _update_slot_visual(idx: int) -> void:
	var gate_id := placed_gates[idx]
	var slot_btn := slot1_btn if idx == 0 else slot2_btn
	if gate_id == GATE_NONE:
		slot_btn.text = "УСТАНОВИТЬ\n?"
	else:
		slot_btn.text = "УСТАНОВЛЕНО\n%s" % _gate_symbol(gate_id)

func _update_slot_selection_visual() -> void:
	slot1_btn.add_theme_color_override("font_color", Color(0.95, 0.95, 0.90, 1.0) if selected_slot_idx == 0 else Color(0.74, 0.74, 0.70, 1.0))
	slot2_btn.add_theme_color_override("font_color", Color(0.95, 0.95, 0.90, 1.0) if selected_slot_idx == 1 else Color(0.74, 0.74, 0.70, 1.0))

func _update_outputs() -> void:
	var result := _calculate_circuit()
	inter_value_label.text = "I = %d" % (1 if bool(result.get("inter", false)) else 0)
	output_value_label.text = "F = %d" % (1 if bool(result.get("final", false)) else 0)
	inter_value_label.add_theme_color_override("font_color", Color(0.95, 0.95, 0.90, 1.0) if bool(result.get("inter", false)) else Color(0.55, 0.55, 0.55, 1.0))
	output_value_label.add_theme_color_override("font_color", Color(0.95, 0.95, 0.90, 1.0) if bool(result.get("final", false)) else Color(0.55, 0.55, 0.55, 1.0))

func _calculate_circuit() -> Dictionary:
	var g1 := placed_gates[0]
	var g2 := placed_gates[1]
	var inter := false
	var final := false

	if str(current_case.get("layout", LAYOUT_CASCADE_TOP)) == LAYOUT_CASCADE_TOP:
		if g1 != GATE_NONE:
			inter = _gate_op(inputs[0], inputs[1], g1)
		if g2 != GATE_NONE:
			final = _gate_op(inter, inputs[2], g2)
	else:
		if g1 != GATE_NONE:
			inter = _gate_op(inputs[1], inputs[2], g1)
		if g2 != GATE_NONE:
			final = _gate_op(inputs[0], inter, g2)

	return {"inter": inter, "final": final}

func _gate_op(a: bool, b: bool, gate_id: String) -> bool:
	match gate_id:
		GATE_AND:
			return a and b
		GATE_OR:
			return a or b
		GATE_NOT:
			return not a
		GATE_XOR:
			return a != b
		GATE_NAND:
			return not (a and b)
		GATE_NOR:
			return not (a or b)
	return false

func _on_test_pressed() -> void:
	if is_complete or is_safe_mode:
		return
	_mark_first_action()

	if placed_gates[0] == GATE_NONE or placed_gates[1] == GATE_NONE:
		_show_feedback("Заполните оба слота перед проверкой.", Color(1.0, 0.78, 0.32))
		return

	test_count += 1
	var result := _calculate_circuit()
	_append_trace("TEST #%d | A=%d B=%d C=%d | I=%d F=%d" % [
		test_count, 1 if inputs[0] else 0, 1 if inputs[1] else 0, 1 if inputs[2] else 0,
		1 if bool(result.get("inter", false)) else 0,
		1 if bool(result.get("final", false)) else 0
	])

	var correct: Array = current_case.get("correct_gates", [])
	var is_correct := placed_gates[0] == str(correct[0]) and placed_gates[1] == str(correct[1])

	if is_correct:
		is_complete = true
		btn_next.visible = true
		btn_hint.disabled = true
		btn_test.disabled = true
		_disable_controls()
		_show_feedback("PASS: конфигурация подтверждена.", Color(0.45, 0.92, 0.62))
		_register_trial("SUCCESS", true)
	else:
		attempts += 1
		var penalty := 15.0 + float(attempts * 5)
		_apply_penalty(penalty)
		_show_feedback("FAIL: схема не прошла проверку (-%d)." % int(penalty), Color(1.0, 0.35, 0.32))
		_register_trial("WRONG_GATE", false)
		if attempts >= MAX_ATTEMPTS:
			_enter_safe_mode()

	_update_terminal()
	_update_ui_state()

func _on_hint_pressed() -> void:
	if is_complete:
		return
	_mark_first_action()
	hints_used += 1
	_apply_penalty(5.0)
	_show_feedback("Подсказка: %s" % str(current_case.get("hint", "")), Color(0.56, 0.78, 0.96))
	_append_trace("HINT: -5 stability.")
	_update_terminal()
	_update_ui_state()

func _enter_safe_mode() -> void:
	is_safe_mode = true
	is_complete = true
	btn_next.visible = true
	btn_test.disabled = true
	btn_hint.disabled = true

	var correct: Array = current_case.get("correct_gates", [])
	placed_gates[0] = str(correct[0])
	placed_gates[1] = str(correct[1])
	_update_slot_visual(0)
	_update_slot_visual(1)
	_update_outputs()
	_disable_controls()
	_set_gate_buttons_enabled(false)
	_clear_gate_button_presses()

	var safe_msg := "SAFE MODE: SLOT1=%s, SLOT2=%s" % [_gate_symbol(placed_gates[0]), _gate_symbol(placed_gates[1])]
	_show_feedback(safe_msg, Color(1.0, 0.74, 0.32))
	_append_trace(safe_msg)
	_show_diagnostics("SAFE MODE", "Правильная конфигурация подставлена автоматически.\nИзучите сборку и переходите далее.")
	_update_terminal()
	_update_ui_state()

func _disable_controls() -> void:
	input_a_btn.disabled = true
	input_b_btn.disabled = true
	input_c_btn.disabled = true
	slot1_btn.disabled = true
	slot2_btn.disabled = true

func _on_game_over() -> void:
	_enter_safe_mode()

func _on_back_button_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_next_button_pressed() -> void:
	_hide_diagnostics()
	load_case(current_case_idx + 1)

func _on_diagnostics_close_pressed() -> void:
	_hide_diagnostics()

func _show_diagnostics(title: String, message: String) -> void:
	diagnostics_title.text = title
	diagnostics_text.text = message
	diagnostics_blocker.visible = true
	diagnostics_panel.visible = true
	diagnostics_next_button.grab_focus()

func _hide_diagnostics() -> void:
	diagnostics_blocker.visible = false
	diagnostics_panel.visible = false

func _set_gate_buttons_enabled(enabled: bool) -> void:
	for gate_id in gate_buttons.keys():
		var gate_btn: Button = gate_buttons[gate_id]
		gate_btn.disabled = not enabled

func _clear_gate_button_presses() -> void:
	for gate_id in gate_buttons.keys():
		var gate_btn: Button = gate_buttons[gate_id]
		gate_btn.set_pressed_no_signal(false)

func _append_trace(line: String) -> void:
	trace_lines.append(line)
	if trace_lines.size() > 12:
		trace_lines.remove_at(0)

func _update_terminal() -> void:
	var lines: Array[String] = []
	lines.append("[b]БРИФИНГ[/b]")
	lines.append(str(current_case.get("story", "")))
	lines.append("")
	lines.append("[b]TRACE[/b]")
	if trace_lines.is_empty():
		lines.append("• ЖУРНАЛ ПУСТ")
	else:
		for i in range(trace_lines.size()):
			var row := "• " + trace_lines[i]
			if i == trace_lines.size() - 1:
				row = "[color=#f4f2e6]> %s[/color]" % row
			lines.append(row)
	terminal_text.text = "\n".join(lines)

func _show_feedback(msg: String, col: Color) -> void:
	feedback_label.text = msg
	feedback_label.add_theme_color_override("font_color", col)
	feedback_label.visible = true

func _update_ui_state() -> void:
	var filled_slots := 0
	if placed_gates[0] != GATE_NONE:
		filled_slots += 1
	if placed_gates[1] != GATE_NONE:
		filled_slots += 1

	var step_text := ""
	if is_complete:
		step_text = "ШАГ 3/3: проверка завершена, переходите далее"
	elif filled_slots < 2:
		step_text = "ШАГ 1/3: выберите слот и установите 2 модуля"
	else:
		step_text = "ШАГ 2/3: нажмите ПРОВЕРИТЬ"

	target_label.text = step_text
	facts_bar.value = 100.0 if is_complete else float(filled_slots) * 50.0
	energy_bar.value = clampf(GlobalMetrics.stability, 0.0, 100.0)
	btn_test.disabled = is_complete or is_safe_mode or filled_slots < 2
	_update_stats_ui()

func _update_stats_ui() -> void:
	var case_id := str(current_case.get("id", "B_00"))
	session_label.text = "СЕССИЯ: %02d/%02d • CASE %s" % [current_case_idx + 1, CASES.size(), case_id]
	stats_label.text = "ПОП: %d/%d • ТЕСТЫ: %d • СТАБ: %d%%" % [
		attempts,
		MAX_ATTEMPTS,
		test_count,
		int(GlobalMetrics.stability)
	]

func _apply_penalty(amount: float) -> void:
	GlobalMetrics.stability = max(0.0, GlobalMetrics.stability - amount)
	GlobalMetrics.stability_changed.emit(GlobalMetrics.stability, -amount)

func _update_stability_ui(val: float, _diff: float) -> void:
	energy_bar.value = clampf(val, 0.0, 100.0)
	_update_stats_ui()

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - case_started_ms

func _register_trial(verdict_code: String, is_correct: bool) -> void:
	var case_id := str(current_case.get("id", "B_00"))
	var variant_hash := str(hash("%s|%s|%s" % [str(current_case.get("layout", "")), placed_gates[0], placed_gates[1]]))
	var payload := TrialV2.build("LOGIC_QUEST", "B", case_id, "MODULE_ASSEMBLY", variant_hash)
	var elapsed_ms := maxi(0, Time.get_ticks_msec() - case_started_ms)
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_correct
	payload["is_fit"] = is_correct
	payload["stability_delta"] = 0
	payload["verdict_code"] = verdict_code
	payload["attempts"] = attempts
	payload["hints_used"] = hints_used
	payload["test_count"] = test_count
	payload["placed_gates"] = placed_gates.duplicate()
	payload["correct_gates"] = current_case.get("correct_gates", []).duplicate()
	payload["inputs"] = [inputs[0], inputs[1], inputs[2]]
	GlobalMetrics.register_trial(payload)

func _play_click() -> void:
	if click_player.stream:
		click_player.play()

func _gate_symbol(gate_id: String) -> String:
	match gate_id:
		GATE_AND:
			return "∧"
		GATE_OR:
			return "∨"
		GATE_NOT:
			return "¬"
		GATE_XOR:
			return "⊕"
		GATE_NAND:
			return "⊼"
		GATE_NOR:
			return "⊽"
		_:
			return "?"
</file>

<file path="scenes/MatrixDecryptor.gd">
extends Control

const STATE_UNSET := -1
const STATE_ZERO := 0
const STATE_ONE := 1

enum CellState { INACTIVE, ACTIVE, LOCKED }
enum MatrixMode { CLASSIC, LADDER }

const MATRIX_SIZE := 6
const MATRIX_WEIGHTS := [32, 16, 8, 4, 2, 1]
const LADDER_DATA_PATH := "res://data/matrix_ladder_levels.json"
const DEFAULT_LADDER_ID := "C_LADDER_001"

const COLOR_OK := Color("33ff66")
const COLOR_WARN := Color("ffcc00")
const COLOR_BAD := Color("ff5555")
const COLOR_DIM := Color(0.65, 0.65, 0.65)

const MIN_CELL_SIZE := 64
const DETAILS_SHEET_H := 360.0
const FREQ_WINDOW_SEC := 1.6
const FREQ_MAX_IN_WINDOW := 3

@onready var btn_back: Button = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnBack
@onready var btn_details: Button = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnDetails
@onready var btn_close_details: Button = $UI/DetailsSheet/DetailsContent/DetailsHeader/BtnCloseDetails
@onready var level_label: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/LevelLabel
@onready var stability_text: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityText
@onready var progress_stability: ProgressBar = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityBar
@onready var shield_freq: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldFreq
@onready var shield_lazy: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldLazy

@onready var matrix_title: Label = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixTitle
@onready var row_labels: VBoxContainer = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/RowLabels
@onready var col_labels: HBoxContainer = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack/ColumnLabels
@onready var grid: GridContainer = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack/Grid
@onready var inlet_tag: Label = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow/InletTag
@onready var outlet_tag: Label = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow/OutletTag
@onready var constraint_hint: Label = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/ConstraintHint

@onready var btn_hint: Button = $UI/SafeArea/Main/BottomBar/Actions/BtnHint
@onready var btn_check: Button = $UI/SafeArea/Main/BottomBar/Actions/BtnCheck
@onready var btn_reset: Button = $UI/SafeArea/Main/BottomBar/Actions/BtnReset

@onready var progress_label: Label = $UI/SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent/ProgressLabel
@onready var mode_state_label: Label = $UI/SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent/ModeLabel
@onready var hint_text: Label = $UI/SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent/HintText
@onready var live_log_text: RichTextLabel = $UI/SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent/LiveLogText
@onready var targets_rows: VBoxContainer = $UI/SafeArea/Main/ContentSplit/RightPanel/TargetsPanel/TargetsContent/TargetsRows

@onready var toast_panel: PanelContainer = $UI/ToastLayer/Toast
@onready var toast_label: Label = $UI/ToastLayer/Toast/ToastLabel
@onready var details_sheet: PanelContainer = $UI/DetailsSheet
@onready var details_text: RichTextLabel = $UI/DetailsSheet/DetailsContent/DetailsScroll/DetailsText
@onready var noir_overlay = $UI/NoirOverlay

var mode: int = MatrixMode.LADDER
var ladder_id: String = DEFAULT_LADDER_ID
var _stages: Array = []
var _stage_index := 0
var _active_size := 2
var _active_base := "DEC"
var _active_targets: Array[int] = []
var _lock_previous := true

var _values: Array = []
var _states: Array = []
var _changed: Dictionary = {}

var _buttons: Array = []
var _row_nodes: Array = []
var _col_nodes: Array = []
var _target_nodes: Array = []
var _now_nodes: Array = []
var _state_nodes: Array = []
var _font: Font

var _input_locked := false
var _safe_mode := false
var _details_open := false
var _shield_token := 0

var _task_started_ms := 0
var _first_action_ms := -1
var _check_count := 0
var _actions_since_check := 0

var _check_times: Array[float] = []
var _lazy_streak := 0
var _blocked_until := 0.0
var _logs: Array[String] = []

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not GlobalMetrics.shield_triggered.is_connected(_on_shield_triggered):
		GlobalMetrics.shield_triggered.connect(_on_shield_triggered)

	btn_back.pressed.connect(_on_menu_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_check.pressed.connect(_on_check_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)

	_setup_font()
	_build_row_labels()
	_build_col_labels()
	_build_grid()
	_build_targets_panel()
	toast_panel.visible = false
	details_sheet.visible = false
	_reset_shield_marks()

	await get_tree().process_frame
	_set_details_open(false, true)
	_start_run()

func _start_run() -> void:
	_safe_mode = false
	_input_locked = false
	_reset_trial_clock()
	_check_times.clear()
	_lazy_streak = 0
	_blocked_until = 0.0
	_changed.clear()
	GlobalMetrics.stability = 100.0
	GlobalMetrics.emit_signal("stability_changed", GlobalMetrics.stability, 0.0)
	if mode == MatrixMode.CLASSIC:
		mode = MatrixMode.LADDER
	if not _load_ladder_data():
		_use_fallback_ladder()
	_init_arrays()
	_apply_stage(0, true)
	_set_input_enabled(true)
	_refresh_stability(GlobalMetrics.stability)

func _load_ladder_data() -> bool:
	var file := FileAccess.open(LADDER_DATA_PATH, FileAccess.READ)
	if file == null:
		return false
	var parsed = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_DICTIONARY:
		return false
	var levels = parsed.get("levels", [])
	if typeof(levels) != TYPE_ARRAY:
		return false
	for level in levels:
		if typeof(level) != TYPE_DICTIONARY:
			continue
		if str(level.get("id", "")) != ladder_id:
			continue
		var stages = level.get("stages", [])
		if typeof(stages) != TYPE_ARRAY or stages.is_empty():
			return false
		_stages = stages.duplicate(true)
		var options = level.get("options", {})
		_lock_previous = bool(options.get("lock_previous", true))
		return true
	return false

func _use_fallback_ladder() -> void:
	_stages = [
		{"size": 2, "base": "DEC", "row_targets": [3, 0]},
		{"size": 3, "base": "DEC", "row_targets": [3, 4, 2]},
		{"size": 4, "base": "OCT", "row_targets": ["13", "14", "02", "16"]},
		{"size": 5, "base": "OCT", "row_targets": ["13", "34", "22", "16", "05"]},
		{"size": 6, "base": "HEX", "row_targets": ["2B", "1C", "32", "0E", "25", "17"]}
	]
	_lock_previous = true

func _init_arrays() -> void:
	_values.clear()
	_states.clear()
	for _r in range(MATRIX_SIZE):
		var row_vals: Array = []
		var row_states: Array = []
		for _c in range(MATRIX_SIZE):
			row_vals.append(STATE_UNSET)
			row_states.append(CellState.INACTIVE)
		_values.append(row_vals)
		_states.append(row_states)

func _apply_stage(index: int, fresh: bool) -> void:
	if index < 0 or index >= _stages.size():
		return
	_stage_index = index
	var stage: Dictionary = _stages[index]
	_active_size = clampi(int(stage.get("size", 2)), 2, MATRIX_SIZE)
	_active_base = str(stage.get("base", "DEC")).to_upper()
	_active_targets = _parse_targets(stage.get("row_targets", []), _active_base, _active_size)
	if fresh:
		for r in range(MATRIX_SIZE):
			for c in range(MATRIX_SIZE):
				_values[r][c] = STATE_UNSET
				_states[r][c] = CellState.INACTIVE
	for r in range(MATRIX_SIZE):
		for c in range(MATRIX_SIZE):
			if int(_states[r][c]) != CellState.LOCKED:
				_states[r][c] = CellState.INACTIVE
	var col_start := _col_start(_active_size)
	for r in range(_active_size):
		for c in range(col_start, MATRIX_SIZE):
			if int(_states[r][c]) != CellState.LOCKED:
				_states[r][c] = CellState.ACTIVE
	_reset_trial_clock()
	_actions_since_check = 0
	_check_times.clear()
	_lazy_streak = 0
	_changed.clear()
	_refresh_header()
	_refresh_labels()
	_refresh_grid()
	_refresh_targets()
	_update_status()
	constraint_hint.text = "Match each row sum to target (%s)." % _active_base
	hint_text.text = "Fill active cells and press CHECK."
	_log("Stage %d/%d loaded (%dx%d %s)." % [_stage_index + 1, _stages.size(), _active_size, _active_size, _active_base], COLOR_OK)

func _parse_targets(raw: Variant, base_name: String, expected: int) -> Array[int]:
	var out: Array[int] = []
	if typeof(raw) != TYPE_ARRAY:
		for _i in range(expected):
			out.append(0)
		return out
	var arr: Array = raw
	for i in range(expected):
		out.append(_parse_target(arr[i] if i < arr.size() else 0, base_name))
	return out

func _parse_target(v: Variant, base_name: String) -> int:
	if base_name == "DEC":
		return int(v)
	var base := 8 if base_name == "OCT" else 16
	var text := str(v).strip_edges().to_upper()
	if text.begins_with("0X"):
		text = text.substr(2)
	if text.begins_with("0O"):
		text = text.substr(2)
	return _parse_base(text, base)

func _parse_base(text: String, base: int) -> int:
	var digits := "0123456789ABCDEF"
	var val := 0
	for i in range(text.length()):
		var ch := text.substr(i, 1)
		var n := digits.find(ch)
		if n < 0 or n >= base:
			return 0
		val = val * base + n
	return val

func _to_base(value: int, base: int) -> String:
	if value == 0:
		return "0"
	var digits := "0123456789ABCDEF"
	var v := value
	var out := ""
	while v > 0:
		var d := v % base
		out = digits.substr(d, 1) + out
		v = int(float(v) / float(base))
	return out

func _format_value(value: int) -> String:
	if _active_base == "DEC":
		return str(value)
	if _active_base == "OCT":
		var oct_text := _to_base(value, 8)
		if _active_size >= 4 and oct_text.length() < 2:
			oct_text = "0" + oct_text
		return oct_text
	return "%02X" % value

func _setup_font() -> void:
	var f = load("res://fonts/IBMPlexMono-Medium.ttf")
	if f:
		_font = f
	else:
		var fallback := SystemFont.new()
		fallback.font_names = PackedStringArray(["Courier New", "Consolas", "Liberation Mono"])
		_font = fallback

func _build_row_labels() -> void:
	_row_nodes.clear()
	for child in row_labels.get_children():
		child.queue_free()
	for _i in range(MATRIX_SIZE):
		var lbl := Label.new()
		lbl.custom_minimum_size = Vector2(92, MIN_CELL_SIZE)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		lbl.add_theme_font_override("font", _font)
		lbl.add_theme_font_size_override("font_size", 20)
		lbl.add_theme_color_override("font_color", COLOR_DIM)
		row_labels.add_child(lbl)
		_row_nodes.append(lbl)

func _build_col_labels() -> void:
	_col_nodes.clear()
	for child in col_labels.get_children():
		child.queue_free()
	for _i in range(MATRIX_SIZE):
		var lbl := Label.new()
		lbl.custom_minimum_size = Vector2(MIN_CELL_SIZE, 42)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		lbl.add_theme_font_override("font", _font)
		lbl.add_theme_font_size_override("font_size", 18)
		lbl.add_theme_color_override("font_color", COLOR_DIM)
		col_labels.add_child(lbl)
		_col_nodes.append(lbl)

func _build_grid() -> void:
	_buttons.clear()
	for child in grid.get_children():
		child.queue_free()
	grid.columns = MATRIX_SIZE
	for r in range(MATRIX_SIZE):
		var row_btns: Array = []
		for c in range(MATRIX_SIZE):
			var btn := Button.new()
			btn.custom_minimum_size = Vector2(MIN_CELL_SIZE, MIN_CELL_SIZE)
			btn.focus_mode = Control.FOCUS_NONE
			btn.text = "."
			btn.add_theme_font_override("font", _font)
			btn.add_theme_font_size_override("font_size", 22)
			btn.pressed.connect(_on_cell_pressed.bind(r, c))
			grid.add_child(btn)
			row_btns.append(btn)
		_buttons.append(row_btns)

func _build_targets_panel() -> void:
	_target_nodes.clear()
	_now_nodes.clear()
	_state_nodes.clear()
	for child in targets_rows.get_children():
		child.queue_free()
	for i in range(MATRIX_SIZE):
		var row := HBoxContainer.new()
		row.add_theme_constant_override("separation", 10)
		var n := Label.new(); n.custom_minimum_size = Vector2(42, 28); n.text = "R%d" % i
		var t := Label.new(); t.custom_minimum_size = Vector2(90, 28); t.text = "target --"
		var cur := Label.new(); cur.custom_minimum_size = Vector2(80, 28); cur.text = "now --"
		var st := Label.new(); st.custom_minimum_size = Vector2(60, 28); st.text = "N/A"; st.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		for lbl in [n, t, cur, st]:
			lbl.add_theme_font_override("font", _font)
			lbl.add_theme_font_size_override("font_size", 18)
		row.add_child(n); row.add_child(t); row.add_child(cur); row.add_child(st)
		targets_rows.add_child(row)
		_target_nodes.append(t)
		_now_nodes.append(cur)
		_state_nodes.append(st)

func _refresh_header() -> void:
	level_label.text = "PROTOCOL C | LADDER %d/%d | %dx%d" % [_stage_index + 1, _stages.size(), _active_size, _active_size]
	matrix_title.text = "MATRIX LADDER"
	var c0 := _col_start(_active_size)
	inlet_tag.text = "IN [0,%d]" % c0
	outlet_tag.text = "OUT [%d,%d]" % [_active_size - 1, MATRIX_SIZE - 1]

func _refresh_stability(value: float) -> void:
	progress_stability.value = value
	stability_text.text = "Stability: %d%%" % int(value)

func _refresh_labels() -> void:
	for r in range(MATRIX_SIZE):
		if r < _active_size:
			_row_nodes[r].text = _format_value(_active_targets[r])
			_row_nodes[r].add_theme_color_override("font_color", COLOR_DIM)
		else:
			_row_nodes[r].text = "?"
			_row_nodes[r].add_theme_color_override("font_color", Color(0.38, 0.38, 0.38, 1.0))
	var c0 := _col_start(_active_size)
	for c in range(MATRIX_SIZE):
		if c >= c0:
			_col_nodes[c].text = str(MATRIX_WEIGHTS[c])
			_col_nodes[c].add_theme_color_override("font_color", COLOR_DIM)
		else:
			_col_nodes[c].text = "."
			_col_nodes[c].add_theme_color_override("font_color", Color(0.38, 0.38, 0.38, 1.0))

func _refresh_grid() -> void:
	if _buttons.size() != MATRIX_SIZE or _states.size() != MATRIX_SIZE or _values.size() != MATRIX_SIZE:
		return
	for r in range(MATRIX_SIZE):
		for c in range(MATRIX_SIZE):
			_draw_cell(r, c)

func _draw_cell(r: int, c: int) -> void:
	if r < 0 or r >= _buttons.size() or r >= _states.size() or r >= _values.size():
		return
	var row_buttons: Array = _buttons[r]
	var row_states: Array = _states[r]
	var row_values: Array = _values[r]
	if c < 0 or c >= row_buttons.size() or c >= row_states.size() or c >= row_values.size():
		return
	var btn: Button = row_buttons[c]
	var st := int(row_states[c])
	var v := int(row_values[c])
	btn.disabled = _input_locked or st != CellState.ACTIVE
	if st == CellState.INACTIVE:
		btn.text = "."
		btn.self_modulate = Color(0.62, 0.62, 0.62, 1.0)
		btn.add_theme_color_override("font_color", Color(0.42, 0.42, 0.42, 1.0))
	elif st == CellState.LOCKED:
		btn.text = _cell_text(v)
		btn.self_modulate = Color(0.72, 0.72, 0.72, 1.0)
		btn.add_theme_color_override("font_color", Color(0.82, 0.82, 0.82, 1.0))
	else:
		btn.text = _cell_text(v)
		btn.self_modulate = Color(1, 1, 1, 1)
		if v == STATE_ONE:
			btn.add_theme_color_override("font_color", Color(1, 1, 1, 1))
		elif v == STATE_ZERO:
			btn.add_theme_color_override("font_color", Color(0.82, 0.82, 0.82, 1))
		else:
			btn.add_theme_color_override("font_color", Color(0.55, 0.55, 0.55, 1))
	var in_col := _col_start(_active_size)
	if r == 0 and c == in_col:
		btn.text += "\nIN"
		btn.self_modulate = Color(0.78, 1.0, 0.82, 1.0)
	elif r == _active_size - 1 and c == MATRIX_SIZE - 1:
		btn.text += "\nOUT"
		btn.self_modulate = Color(0.78, 0.94, 1.0, 1.0)

func _cell_text(v: int) -> String:
	if v == STATE_ZERO:
		return "0"
	if v == STATE_ONE:
		return "1"
	return "."

func _on_cell_pressed(r: int, c: int) -> void:
	if _input_locked or int(_states[r][c]) != CellState.ACTIVE:
		return
	if _first_action_ms < 0:
		_first_action_ms = Time.get_ticks_msec() - _task_started_ms
	AudioManager.play("click")
	var cur := int(_values[r][c])
	_values[r][c] = STATE_ZERO if cur == STATE_UNSET else (STATE_ONE if cur == STATE_ZERO else STATE_UNSET)
	_changed["%d,%d" % [r, c]] = true
	_actions_since_check += 1
	_draw_cell(r, c)
	_refresh_targets()
	_update_status()

func _col_start(size: int) -> int:
	return MATRIX_SIZE - size

func _row_sum(r: int) -> int:
	var sum := 0
	var c0 := _col_start(_active_size)
	for c in range(c0, MATRIX_SIZE):
		if int(_values[r][c]) == STATE_ONE:
			sum += int(MATRIX_WEIGHTS[c])
	return sum

func _eval_stage() -> Dictionary:
	var wrong := 0
	var delta := 0
	var first := -1
	var nows: Array = []
	var oks: Array = []
	for r in range(_active_size):
		var now := _row_sum(r)
		var target := int(_active_targets[r])
		var ok := now == target
		nows.append(now)
		oks.append(ok)
		if not ok:
			wrong += 1
			delta += abs(now - target)
			if first < 0:
				first = r
	return {"success": wrong == 0, "wrong": wrong, "delta": delta, "first": first, "nows": nows, "oks": oks}

func _refresh_targets() -> void:
	var e := _eval_stage()
	var nows: Array = e.get("nows", [])
	var oks: Array = e.get("oks", [])
	for r in range(MATRIX_SIZE):
		if r < _active_size:
			_target_nodes[r].text = "target %s" % _format_value(_active_targets[r])
			_now_nodes[r].text = "now %s" % _format_value(int(nows[r]))
			var ok := bool(oks[r])
			_state_nodes[r].text = "OK" if ok else "ERR"
			_state_nodes[r].add_theme_color_override("font_color", COLOR_OK if ok else COLOR_BAD)
		else:
			_target_nodes[r].text = "target --"
			_now_nodes[r].text = "now --"
			_state_nodes[r].text = "N/A"
			_state_nodes[r].add_theme_color_override("font_color", Color(0.45, 0.45, 0.45, 1.0))

func _filled_count() -> int:
	var n := 0
	var c0 := _col_start(_active_size)
	for r in range(_active_size):
		for c in range(c0, MATRIX_SIZE):
			if int(_values[r][c]) != STATE_UNSET:
				n += 1
	return n

func _update_status() -> void:
	var e := _eval_stage()
	var cool := maxi(0.0, _blocked_until - (Time.get_ticks_msec() / 1000.0))
	progress_label.text = "STAGE %d/%d | BASE %s | FILLED %d/%d | WRONG %d" % [_stage_index + 1, _stages.size(), _active_base, _filled_count(), _active_size * _active_size, int(e.get("wrong", 0))]
	mode_state_label.text = "MODE: %s | SHIELD: %s" % ["SAFE" if _safe_mode else "RUN", "COOLDOWN %.1fs" % cool if cool > 0.0 else "READY"]

func _on_hint_pressed() -> void:
	if _input_locked:
		hint_text.text = "Input is locked."
		_show_toast("Input locked", COLOR_WARN)
		return
	var e := _eval_stage()
	if bool(e.get("success", false)):
		hint_text.text = "All rows match target. Press CHECK."
		_show_toast("Ready for check", COLOR_OK)
		return
	var r := int(e.get("first", -1))
	if r < 0:
		hint_text.text = "No hint available."
		return
	var t := int(_active_targets[r])
	var now := _row_sum(r)
	var best := _best_edit(r, t)
	if best.is_empty():
		hint_text.text = "Row %d mismatch. Edit active cells." % (r + 1)
	else:
		hint_text.text = "Row %d target %s now %s. Try weight %d -> %d." % [r + 1, _format_value(t), _format_value(now), int(best.get("weight", 0)), int(best.get("new_bit", 0))]
	_log("Hint requested for row %d." % (r + 1), COLOR_WARN)
	_show_toast("Hint updated", COLOR_WARN)

func _best_edit(r: int, target: int) -> Dictionary:
	var best: Dictionary = {}
	var best_score := 1_000_000
	var c0 := _col_start(_active_size)
	var sum := _row_sum(r)
	for c in range(c0, MATRIX_SIZE):
		if int(_states[r][c]) != CellState.ACTIVE:
			continue
		var cur_cell := int(_values[r][c])
		var cur_bit := 1 if cur_cell == STATE_ONE else 0
		for bit in [0, 1]:
			var bit_i: int = int(bit)
			if bit_i == cur_bit:
				continue
			var w := int(MATRIX_WEIGHTS[c])
			var ns: int = sum - cur_bit * w + bit_i * w
			var score: int = abs(target - ns)
			if score < best_score:
				best_score = score
				best = {"col": c, "weight": w, "new_bit": bit_i, "new_sum": ns}
	return best

func _on_check_pressed() -> void:
	if _input_locked:
		return
	_check_count += 1
	var now_sec := Time.get_ticks_msec() / 1000.0
	if now_sec < _blocked_until:
		_register({"success": false, "error": "SHIELD_ACTIVE", "penalty": 0.0, "stability_delta": 0.0, "wrong": 0, "delta": 0})
		hint_text.text = "Shield cooldown %.1fs" % maxi(0.0, _blocked_until - now_sec)
		_show_toast("SHIELD: COOLDOWN", COLOR_WARN)
		return
	_check_times.append(now_sec)
	var cut := now_sec - FREQ_WINDOW_SEC
	while _check_times.size() > 0 and _check_times[0] < cut:
		_check_times.pop_front()
	if _check_times.size() > FREQ_MAX_IN_WINDOW:
		_trigger_shield("FREQUENCY", 2.5, "Shield: too frequent checks.")
		_register({"success": false, "error": "SHIELD_FREQ", "penalty": 0.0, "stability_delta": 0.0, "wrong": 0, "delta": 0})
		_actions_since_check = 0
		_changed.clear()
		return

	var e := _eval_stage()
	var wrong := int(e.get("wrong", 0))
	if _actions_since_check <= 1 and wrong >= 2:
		_lazy_streak += 1
	else:
		_lazy_streak = 0
	if _lazy_streak >= 3:
		_trigger_shield("LAZY", 3.0, "Shield: brute-force behavior blocked.")
		_register({"success": false, "error": "SHIELD_LAZY", "penalty": 0.0, "stability_delta": 0.0, "wrong": wrong, "delta": int(e.get("delta", 0))})
		_actions_since_check = 0
		_changed.clear()
		return

	if bool(e.get("success", false)):
		AudioManager.play("relay")
		_overlay_glitch(0.12, 0.10)
		_register({"success": true, "error": "NONE", "penalty": 0.0, "stability_delta": 0.0, "wrong": 0, "delta": 0})
		_show_toast("STAGE PASS", COLOR_OK)
		_log("Stage %d solved." % (_stage_index + 1), COLOR_OK)
		_actions_since_check = 0
		_changed.clear()
		await _stage_pass()
		return

	var delta := int(e.get("delta", 0))
	var penalty := float(wrong * 6 + clampi(int(round(float(delta) / 4.0)), 0, 12))
	_register({"success": false, "error": "INCORRECT", "penalty": penalty, "stability_delta": -penalty, "wrong": wrong, "delta": delta})
	AudioManager.play("error")
	_overlay_glitch(0.55, 0.18)
	hint_text.text = "Wrong rows: %d | delta: %d | penalty: %d" % [wrong, delta, int(penalty)]
	_log("Check failed. wrong=%d delta=%d penalty=%d" % [wrong, delta, int(penalty)], COLOR_BAD)
	_show_toast("INCORRECT", COLOR_BAD)
	_actions_since_check = 0
	_changed.clear()
	_refresh_targets()
	_update_status()

func _stage_pass() -> void:
	if _stage_index >= _stages.size() - 1:
		_show_toast("LADDER COMPLETE", COLOR_OK)
		_log("Ladder completed. Restarting run.", COLOR_OK)
		await get_tree().create_timer(1.2).timeout
		_start_run()
		return
	if _lock_previous:
		var c0 := _col_start(_active_size)
		for r in range(_active_size):
			for c in range(c0, MATRIX_SIZE):
				if int(_states[r][c]) == CellState.ACTIVE:
					_states[r][c] = CellState.LOCKED
	_apply_stage(_stage_index + 1, false)

func _trigger_shield(name: String, duration: float, msg: String) -> void:
	_blocked_until = (Time.get_ticks_msec() / 1000.0) + duration
	hint_text.text = msg
	_log(msg, COLOR_WARN)
	_show_toast("SHIELD: %s" % name, COLOR_WARN)
	GlobalMetrics.emit_signal("shield_triggered", name, duration)

func _on_reset_pressed() -> void:
	if _input_locked:
		return
	var c0 := _col_start(_active_size)
	for r in range(_active_size):
		for c in range(c0, MATRIX_SIZE):
			if int(_states[r][c]) == CellState.ACTIVE:
				_values[r][c] = STATE_UNSET
	_changed.clear()
	_actions_since_check = 0
	_lazy_streak = 0
	_reset_trial_clock()
	_refresh_grid()
	_refresh_targets()
	_update_status()
	hint_text.text = "Active stage reset."
	_log("Stage reset.", COLOR_WARN)
	_show_toast("RESET", COLOR_WARN)

func _on_shield_triggered(name: String, duration: float) -> void:
	if name != "FREQUENCY" and name != "LAZY":
		return
	AudioManager.play("error")
	_overlay_glitch(0.5, 0.16)
	if name == "FREQUENCY":
		_flash_mark(shield_freq)
	else:
		_flash_mark(shield_lazy)
	_shield_token += 1
	var token := _shield_token
	_set_input_enabled(false)
	await get_tree().create_timer(duration).timeout
	if token != _shield_token:
		return
	if not _safe_mode and (Time.get_ticks_msec() / 1000.0) >= _blocked_until:
		_set_input_enabled(true)
		_log("Shield released.", COLOR_OK)

func _on_stability_changed(new_val: float, _change: float) -> void:
	_refresh_stability(new_val)
	if new_val <= 0.0 and not _safe_mode:
		_safe_mode = true
		_set_input_enabled(false)
		_update_status()
		await _run_safe_mode()

func _run_safe_mode() -> void:
	_log("Safe mode: conflict analysis started.", COLOR_WARN)
	var e := _eval_stage()
	var r := int(e.get("first", -1))
	if r < 0:
		hint_text.text = "Safe mode: no direct conflict found."
	else:
		var t := int(_active_targets[r])
		var best := _best_edit(r, t)
		if best.is_empty():
			hint_text.text = "Safe mode: row %d mismatch. Check active bits." % (r + 1)
			_highlight(r, -1)
		else:
			var col := int(best.get("col", -1))
			hint_text.text = "Safe mode: row %d target %s now %s. Try weight %d." % [r + 1, _format_value(t), _format_value(_row_sum(r)), int(best.get("weight", 0))]
			_highlight(r, col)
	await get_tree().create_timer(6.0).timeout
	_clear_highlight()
	_safe_mode = false
	if (Time.get_ticks_msec() / 1000.0) >= _blocked_until:
		_set_input_enabled(true)
	_update_status()
	_log("Safe mode finished.", COLOR_OK)

func _highlight(r: int, c: int) -> void:
	for rr in range(MATRIX_SIZE):
		for cc in range(MATRIX_SIZE):
			var btn: Button = _buttons[rr][cc]
			if rr == r or (c >= 0 and cc == c):
				btn.self_modulate = Color(1.0, 0.45, 0.45, 1.0)
			elif int(_states[rr][cc]) == CellState.INACTIVE:
				btn.self_modulate = Color(0.62, 0.62, 0.62, 1.0)
			else:
				btn.self_modulate = Color(0.84, 0.84, 0.84, 1.0)
	if r >= 0 and r < _row_nodes.size():
		_row_nodes[r].add_theme_color_override("font_color", COLOR_BAD)
	if r >= 0 and r < _state_nodes.size():
		_state_nodes[r].add_theme_color_override("font_color", COLOR_BAD)

func _clear_highlight() -> void:
	_refresh_labels()
	_refresh_grid()
	_refresh_targets()

func _set_input_enabled(enabled: bool) -> void:
	_input_locked = not enabled
	btn_check.disabled = not enabled
	btn_hint.disabled = not enabled
	btn_reset.disabled = not enabled
	_refresh_grid()

func _reset_trial_clock() -> void:
	_task_started_ms = Time.get_ticks_msec()
	_first_action_ms = -1
	_check_count = 0

func _register(result: Dictionary) -> void:
	var hash_key := str(hash("%s|%d|%s" % [ladder_id, _stage_index, _active_base]))
	var payload := TrialV2.build("MATRIX_DECRYPTOR", "C", "MATRIX_LADDER", "GRID_CHECK", hash_key)
	var elapsed_ms: int = maxi(0, Time.get_ticks_msec() - _task_started_ms)
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = _first_action_ms if _first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = bool(result.get("success", false))
	payload["is_fit"] = bool(result.get("success", false))
	payload["stability_delta"] = float(result.get("stability_delta", 0.0))
	payload["error_type"] = str(result.get("error", "NONE"))
	payload["penalty_reported"] = float(result.get("penalty", 0.0))
	payload["changed_cells_count"] = _changed.size()
	payload["check_count"] = _check_count
	payload["stage_index"] = _stage_index + 1
	payload["stage_total"] = _stages.size()
	payload["stage_size"] = _active_size
	payload["stage_base"] = _active_base
	payload["wrong_rows"] = int(result.get("wrong", 0))
	payload["delta_sum"] = int(result.get("delta", 0))
	GlobalMetrics.register_trial(payload)

func _log(msg: String, color: Color) -> void:
	var line := "[%s] %s" % [Time.get_time_string_from_system(), msg]
	_logs.append(line)
	if _logs.size() > 220:
		_logs.remove_at(0)
	details_text.text = "\n".join(_logs)
	var tail = _logs.slice(maxi(0, _logs.size() - 18), _logs.size())
	live_log_text.text = "\n".join(tail)
	live_log_text.add_theme_color_override("default_color", color)

func _show_toast(msg: String, color: Color) -> void:
	toast_label.text = msg
	toast_label.add_theme_color_override("font_color", color)
	toast_panel.visible = true
	toast_panel.modulate = Color(1, 1, 1, 0)
	var tw := create_tween()
	tw.tween_property(toast_panel, "modulate", Color(1, 1, 1, 1), 0.15)
	tw.tween_interval(0.9)
	tw.tween_property(toast_panel, "modulate", Color(1, 1, 1, 0), 0.25)
	tw.tween_callback(func() -> void: toast_panel.visible = false)

func _flash_mark(label: Label) -> void:
	label.modulate = Color(1, 1, 1, 1)
	var tw := create_tween()
	tw.tween_property(label, "modulate", Color(1, 1, 1, 0.25), 0.6)

func _reset_shield_marks() -> void:
	shield_freq.modulate = Color(1, 1, 1, 0.25)
	shield_lazy.modulate = Color(1, 1, 1, 0.25)

func _on_details_pressed() -> void:
	_set_details_open(not _details_open, false)

func _set_details_open(open: bool, immediate: bool) -> void:
	_details_open = open
	if open:
		details_sheet.visible = true
	var t_top := -DETAILS_SHEET_H if open else 0.0
	var t_bottom := 0.0 if open else DETAILS_SHEET_H
	if immediate:
		details_sheet.offset_top = t_top
		details_sheet.offset_bottom = t_bottom
		if not open:
			details_sheet.visible = false
		return
	var tw := create_tween()
	tw.tween_property(details_sheet, "offset_top", t_top, 0.22).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	tw.parallel().tween_property(details_sheet, "offset_bottom", t_bottom, 0.22).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	if not open:
		tw.tween_callback(func() -> void: details_sheet.visible = false)

func _overlay_glitch(strength: float, duration: float) -> void:
	if noir_overlay != null and noir_overlay.has_method("glitch_burst"):
		noir_overlay.call("glitch_burst", strength, duration)

func _on_menu_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
</file>

<file path="scenes/RadioQuestB.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/RadioQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_tmvn2"]

[node name="RadioQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_tmvn2")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Header" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2

[node name="HeaderHBox" type="HBoxContainer" parent="SafeArea/RootVBox/Header"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "BACK"

[node name="TitleLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 28
text = "RADIO INTERCEPT | B"

[node name="MetaLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(360, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "MODE | STABILITY"
horizontal_alignment = 2

[node name="BodyHSplit" type="HSplitContainer" parent="SafeArea/RootVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 720

[node name="LeftPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LeftMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="LeftVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="StorageTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "STORAGE BAY"

[node name="StorageGrid" type="GridContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 10
columns = 2

[node name="StorageBtn1" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 1"

[node name="StorageBtn2" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 2"

[node name="StorageBtn3" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 3"

[node name="StorageBtn4" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 4"

[node name="RightPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RightMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="RightVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="ContextCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 124)
layout_mode = 2

[node name="ContextMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="ContextVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="ContextTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "TERMINAL"

[node name="IInfoLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "i = 7 bits"

[node name="KInfoLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "K = 128 symbols"

[node name="TaskLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Compute I = K*i and choose best storage option"
autowrap_mode = 2

[node name="CalcCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2

[node name="CalcMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="CalcVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="CalcTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "CALC I"

[node name="IBitsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnMinus" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow"]
custom_minimum_size = Vector2(72, 56)
layout_mode = 2
text = "-8"

[node name="IBitsValue" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow"]
custom_minimum_size = Vector2(140, 0)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 34
text = "0"
horizontal_alignment = 1

[node name="BtnPlus" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow"]
custom_minimum_size = Vector2(72, 56)
layout_mode = 2
text = "+8"

[node name="BtnCheckCalc" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "CHECK"

[node name="PreviewCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2

[node name="PreviewMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="PreviewVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="PreviewTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "DIAGNOSTICS"

[node name="PreviewCalcLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Calc:"

[node name="PreviewFitLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Fit:"

[node name="PreviewClassLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Class:"

[node name="ActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnConverter" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "CONVERTER"

[node name="BtnCapture" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "CONFIRM"

[node name="BtnNext" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "NEXT"

[node name="SampleStrip" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 32)
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Sample1" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample2" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample3" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample4" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample5" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample6" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample7" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StatusLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 88)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Status"
autowrap_mode = 2

[node name="BtnDetails" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "DETAILS"

[node name="Footer" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2

[node name="FooterMargin" type="MarginContainer" parent="SafeArea/RootVBox/Footer"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="FooterLabel" type="Label" parent="SafeArea/RootVBox/Footer/FooterMargin"]
layout_mode = 2
theme_override_font_sizes/font_size = 18

[node name="Dimmer" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
color = Color(0, 0, 0, 0.6)

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -320.0
grow_horizontal = 2
grow_vertical = 0

[node name="DetailsMargin" type="MarginContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="DetailsVBox" type="VBoxContainer" parent="DetailsSheet/DetailsMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "DETAILS"

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_vertical = 3

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "CLOSE"
</file>

<file path="scripts/case_07/da7_cases_a.gd">
extends Node

const SCHEMA_VERSION := "DA7.A.v3"
const LEVEL := "A"

const CASES_A: Array = [
	{
		"id": "DA7-A-01",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "ACCESS_LOG_07",
		"briefing": "Зеркало архива восстановлено. Следы доступа частично обфусцированы. Проверьте только реальные записи с высоким уровнем доступа.",
		"objective": "Определите ID, где Доступ >= 3.",
		"prompt": "Какие записи удовлетворяют Доступ >= 3?",
		"table": {
			"columns": [
				{"col_id": "id", "title": "ID"},
				{"col_id": "name", "title": "Имя"},
				{"col_id": "acc", "title": "Доступ"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"id": "101", "name": "Альфа", "acc": "2"}},
				{"row_id": "r2", "cells": {"id": "102", "name": "Бета", "acc": "3"}},
				{"row_id": "r3", "cells": {"id": "103", "name": "Гамма", "acc": "4"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Оформить отчёт: список высокого доступа содержит ID 101", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Отправить пакет доказательств: ID 102 и 103", "f_reason": null},
			{"id": "opt_3", "text": "Эскалировать все строки как высокий доступ", "f_reason": "MISSED_ROW"},
			{"id": "opt_4", "text": "Подтвердить только ID 103", "f_reason": "MISSED_ROW"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Строки r2 и r3 удовлетворяют Доступ >= 3. Строка r1 ниже порога.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Значения Доступ прочитаны неверно. Используйте столбец Доступ как ключ фильтра.",
				"MISSED_ROW": "Хотя бы одна подходящая строка пропущена или лишняя строка включена."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r2", "r3"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-02",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "SYSTEM_STATUS_12",
		"briefing": "Оперативный канал сообщает о всплесках нестабильности. Извлеките только явные записи с ОШИБКОЙ из хронологии инцидента.",
		"objective": "Определите отметки времени, где Статус == ОШИБКА.",
		"prompt": "Какие отметки времени помечены как ОШИБКА?",
		"table": {
			"columns": [
				{"col_id": "time", "title": "Время"},
				{"col_id": "status", "title": "Статус"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"time": "09:00", "status": "НОРМА"}},
				{"row_id": "r2", "cells": {"time": "09:05", "status": "ОШИБКА"}},
				{"row_id": "r3", "cells": {"time": "09:10", "status": "ПРЕДУПРЕЖДЕНИЕ"}},
				{"row_id": "r4", "cells": {"time": "09:15", "status": "ОШИБКА"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Отметить 09:00 и 09:10 как критические сбои", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Открыть тикет инцидента для 09:05 и 09:15", "f_reason": null},
			{"id": "opt_3", "text": "Эскалировать только 09:05", "f_reason": "MISSED_ROW"},
			{"id": "opt_4", "text": "Пометить каждую строку как ОШИБКА", "f_reason": "COUNT_HEADER_AS_RECORD"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Только строки с явным статусом ОШИБКА — r2 и r4.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Фильтр должен строиться по Статус; одних значений времени недостаточно.",
				"MISSED_ROW": "Одна строка с ОШИБКОЙ была пропущена.",
				"COUNT_HEADER_AS_RECORD": "Не считайте заголовки или нерелевантные статусы строками инцидента."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r2", "r4"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-03",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "RELATION_MAP_03",
		"briefing": "Карта сущностей восстановлена с резервного узла. Подтвердите зависимость пользователь-пост перед связыванием архивов.",
		"objective": "Определите тип связи: один пользователь может написать много постов.",
		"prompt": "Какая связь соответствует Пользователи.id -> Посты.user_id?",
		"table": {
			"columns": [
				{"col_id": "table", "title": "Таблица"},
				{"col_id": "key", "title": "Ключ"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"table": "Пользователи", "key": "id (PK)"}},
				{"row_id": "r2", "cells": {"table": "Посты", "key": "user_id (FK)"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Подтвердить связь один-к-одному", "f_reason": "CONFUSED_PK_FIELD"},
			{"id": "opt_2", "text": "Подтвердить связь один-ко-многим", "f_reason": null},
			{"id": "opt_3", "text": "Подтвердить связь многие-ко-многим", "f_reason": "CONFUSED_ROW_COLUMN"},
			{"id": "opt_4", "text": "Отклонить связь", "f_reason": "CONFUSED_PK_FIELD"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Пользователи.id (PK), на который ссылается Посты.user_id (FK), образует связь 1:M.",
			"on_wrong_by_reason": {
				"CONFUSED_PK_FIELD": "Связь PK->FK здесь допускает несколько постов на одного пользователя.",
				"CONFUSED_ROW_COLUMN": "Тип связи определяется семантикой ключей, а не порядком таблиц в сетке."
			}
		},
		"highlight": {
			"mode": "COLUMNS",
			"target_col_ids": ["key"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-04",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "ORDERS_AUDIT_22",
		"briefing": "Платёжные логи содержат заказы с разными суммами. Выделите только транзакции с малой суммой для ручной проверки.",
		"objective": "Определите заказы, где Сумма < 100.",
		"prompt": "Какие заказы удовлетворяют Сумма < 100?",
		"table": {
			"columns": [
				{"col_id": "ord", "title": "Заказ"},
				{"col_id": "sum", "title": "Сумма"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"ord": "A-10", "sum": "150"}},
				{"row_id": "r2", "cells": {"ord": "A-11", "sum": "80"}},
				{"row_id": "r3", "cells": {"ord": "A-12", "sum": "99"}},
				{"row_id": "r4", "cells": {"ord": "A-13", "sum": "100"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Заморозить для проверки заказы A-11 и A-12", "f_reason": null},
			{"id": "opt_2", "text": "Заморозить A-11, A-12 и A-13", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_3", "text": "Заморозить только A-10", "f_reason": "MISSED_ROW"},
			{"id": "opt_4", "text": "Заморозить только A-13", "f_reason": "MISSED_COLUMN"}
		],
		"answer_id": "opt_1",
		"reveal": {
			"on_correct": "A-11 (80) и A-12 (99) строго меньше 100.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Используйте строгое '< 100'. Значение 100 исключается.",
				"MISSED_ROW": "Вы выбрали неподходящие строки и пропустили корректные малые суммы."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r2", "r3"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-05",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "STATUS_FILTER_31",
		"briefing": "Шаблон запроса повреждён. Восстановите оператор, исключающий состояние ЗАКРЫТ.",
		"objective": "Выберите оператор для условия: статус не равно ЗАКРЫТ.",
		"prompt": "Какое выражение корректно означает 'статус не равно ЗАКРЫТ'?",
		"table": {
			"columns": [
				{"col_id": "field", "title": "Поле"},
				{"col_id": "value", "title": "Значение"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"field": "статус", "value": "ЗАКРЫТ"}},
				{"row_id": "r2", "cells": {"field": "статус", "value": "ОТКРЫТ"}},
				{"row_id": "r3", "cells": {"field": "статус", "value": "ОЖИДАНИЕ"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Применить фильтр: статус == ЗАКРЫТ", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Применить фильтр: статус != ЗАКРЫТ", "f_reason": null},
			{"id": "opt_3", "text": "Применить фильтр: статус > ЗАКРЫТ", "f_reason": "CONFUSED_ROW_COLUMN"},
			{"id": "opt_4", "text": "Применить фильтр: статус <= ЗАКРЫТ", "f_reason": "CONFUSED_ROW_COLUMN"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Оператор '!=' исключает ЗАКРЫТ и оставляет ОТКРЫТ/ОЖИДАНИЕ.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Проверка равенства выбирает сам ЗАКРЫТ, а не множество исключения.",
				"CONFUSED_ROW_COLUMN": "Операторы сравнения строк здесь не выражают логическое исключение."
			}
		},
		"highlight": {
			"mode": "CELL",
			"target_cell": {"row_id": "r1", "col_id": "value"}
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-06",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "CLIENT_CITY_19",
		"briefing": "Региональный экспортный список повреждён. Восстановите только ID клиентов, связанных с записями Алматы.",
		"objective": "Выберите клиентов, где Город == Алматы.",
		"prompt": "Какие клиенты из Алматы?",
		"table": {
			"columns": [
				{"col_id": "cid", "title": "CID"},
				{"col_id": "city", "title": "Город"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"cid": "C1", "city": "Алматы"}},
				{"row_id": "r2", "cells": {"cid": "C2", "city": "Астана"}},
				{"row_id": "r3", "cells": {"cid": "C3", "city": "Алматы"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Выдать ордер только для C2", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Выдать ордер для C1 и C3", "f_reason": null},
			{"id": "opt_3", "text": "Выдать ордер для всех клиентов", "f_reason": "COUNT_HEADER_AS_RECORD"},
			{"id": "opt_4", "text": "Закрыть дело: подходящих клиентов нет", "f_reason": "MISSED_ROW"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "C1 и C3 помечены как Город = Алматы.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Фильтр должен совпадать по Город, а не по порядку CID.",
				"COUNT_HEADER_AS_RECORD": "Не эскалируйте неподходящие строки.",
				"MISSED_ROW": "Корректные строки Алматы были пропущены."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r1", "r3"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	}
]
</file>

<file path="ui/theme_terminal_amber.tres">
[gd_resource type="Theme" load_steps=8 format=3 uid="uid://bc6epa3jyjbri"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.09, 0.07, 0.04, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.3, 0.24, 0.13, 0.7)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.17, 0.12, 0.05, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.8, 0.38, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.12, 0.09, 0.04, 0.95)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.690196, 0, 0.85)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.22, 0.15, 0.06, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.85, 0.5, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.12, 0.09, 0.04, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.690196, 0, 0.85)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.08, 0.06, 0.03, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(1, 0.690196, 0, 0.92)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[resource]
default_font_size = 18
Button/colors/font_color = Color(1, 0.690196, 0, 1)
Button/colors/font_disabled_color = Color(0.42, 0.35, 0.23, 1)
Button/colors/font_hover_color = Color(1, 0.82, 0.45, 1)
Button/colors/font_pressed_color = Color(1, 0.9, 0.65, 1)
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(1, 0.690196, 0, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(1, 0.690196, 0, 1)
</file>

<file path="ui/theme_terminal_green.tres">
[gd_resource type="Theme" load_steps=8 format=3 uid="uid://cfgksggpp15wa"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.05, 0.06, 0.05, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.13, 0.22, 0.13, 0.7)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.08, 0.13, 0.08, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.3, 1, 0.45, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.05, 0.08, 0.05, 0.95)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0, 1, 0.254902, 0.85)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.12, 0.18, 0.12, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.55, 1, 0.62, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.05, 0.08, 0.05, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0, 1, 0.254902, 0.85)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.03, 0.05, 0.03, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0, 1, 0.254902, 0.92)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[resource]
default_font_size = 18
Button/colors/font_color = Color(0, 1, 0.254902, 1)
Button/colors/font_disabled_color = Color(0.27, 0.35, 0.27, 1)
Button/colors/font_hover_color = Color(0.45, 1, 0.55, 1)
Button/colors/font_pressed_color = Color(0.75, 1, 0.75, 1)
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(0, 1, 0.254902, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0, 1, 0.254902, 1)
</file>

<file path="ui/theme_untformatic.tres">
[gd_resource type="Theme" load_steps=8 format=3 uid="uid://jxdl2tctb0ca"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.06, 0.07, 0.09, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.2, 0.25, 0.3, 0.7)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.1, 0.13, 0.17, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.4, 0.8, 1, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.07, 0.09, 0.12, 0.95)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.203922, 0.658824, 1, 0.85)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.14, 0.18, 0.24, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.6, 0.9, 1, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.07, 0.09, 0.12, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.203922, 0.658824, 1, 0.8)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.04, 0.05, 0.06, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0.203922, 0.658824, 1, 0.9)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[resource]
default_font_size = 18
Button/colors/font_color = Color(0.8, 0.92, 1, 1)
Button/colors/font_disabled_color = Color(0.45, 0.52, 0.6, 1)
Button/colors/font_hover_color = Color(0.9, 0.97, 1, 1)
Button/colors/font_pressed_color = Color(1, 1, 1, 1)
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(0.8, 0.92, 1, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0.8, 0.92, 1, 1)
</file>

<file path="scenes/CityMapQuestB.gd">
extends Control

const PACK_PATH := "res://data/city_map/pack_6_2_B.json"
const LOG_PREFIX := "case_6_2"
const DEFAULT_ACCENT := Color(0.40, 0.72, 1.0, 1.0)
const ARROW_ANGLE_RAD := 0.52
const ARROW_LEN := 16.0

@onready var content_split: BoxContainer = $SafeArea/MainVBox/ContentSplit
@onready var graph_container: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer
@onready var edges_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/EdgesLayer
@onready var nodes_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/NodesLayer
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack
@onready var label_progress: Label = $SafeArea/MainVBox/Header/LabelProgress
@onready var btn_reset: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnReset
@onready var btn_submit: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnSubmit
@onready var btn_next: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnNext
@onready var sum_input: LineEdit = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumInput
@onready var path_display: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/PathDisplay
@onready var sum_live_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumLiveLabel
@onready var constraint_info_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ConstraintInfoLabel
@onready var backtrack_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/BacktrackLabel
@onready var warning_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/WarningLabel
@onready var status_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/StatusLabel
@onready var label_state: Label = $SafeArea/MainVBox/Header/LabelState
@onready var label_timer: Label = $SafeArea/MainVBox/Header/LabelTimer
@onready var footer_label: Label = $SafeArea/MainVBox/Footer/FooterLabel
@onready var briefing_title: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingTitle
@onready var briefing_text: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingText
@onready var briefing_constraint: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/ConstraintLabel

var level_data: Dictionary = {}
var pack_data: Dictionary = {}
var pack_levels: Array = []
var node_defs: Dictionary = {}
var adjacency: Dictionary = {}
var edge_visuals: Dictionary = {}
var edge_key_to_visuals: Dictionary = {}
var node_buttons: Dictionary = {}
var config_hash: String = ""
var input_regex := RegEx.new()
var pack_id: String = "CITY_MAP_B_PACK_01"
var level_index: int = 0
var level_total: int = 0
var run_id: String = ""
var run_started_unix: int = 0
var attempt_in_sublevel: int = 0
var attempt_in_run: int = 0
var levels_completed: int = 0
var levels_perfect: int = 0
var run_total_time_seconds: int = 0
var run_total_calc_errors: int = 0
var run_total_opt_errors: int = 0
var run_total_parse_errors: int = 0
var run_total_reset_errors: int = 0
var run_total_transit_errors: int = 0
var run_total_cycle_errors: int = 0

var min_sum: int = 0
var accent_color: Color = DEFAULT_ACCENT
var node_radius_px: float = 25.0
var must_visit_nodes: Array[String] = []

var current_node: String = ""
var path: Array[String] = []
var path_sum: int = 0
var stability: float = 100.0
var t_elapsed_seconds: int = 0
var is_game_over: bool = false
var stage_completed: bool = false
var input_locked: bool = false
var first_attempt_edge: String = ""
var level_started_ms: int = 0
var first_action_ms: int = -1

var backtrack_count: int = 0
var cycle_events: int = 0
var cycle_detected: bool = false
var constraint_violations: int = 0

var n_calc: int = 0
var n_opt: int = 0
var n_parse: int = 0
var n_reset: int = 0
var n_transit: int = 0
var n_cycle: int = 0

func _ready() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	sum_input.text_changed.connect(_on_sum_input_changed)
	graph_container.resized.connect(_on_graph_resized)

	_load_pack(PACK_PATH)
	_apply_content_layout_mode()
	_setup_timer()
	call_deferred("_start_pack_run")

func _start_pack_run() -> void:
	run_started_unix = int(Time.get_unix_time_from_system())
	run_id = "CITYMAP_%s_%d" % ["B", run_started_unix]
	level_index = 0
	attempt_in_run = 0
	levels_completed = 0
	levels_perfect = 0
	run_total_time_seconds = 0
	run_total_calc_errors = 0
	run_total_opt_errors = 0
	run_total_parse_errors = 0
	run_total_reset_errors = 0
	run_total_transit_errors = 0
	run_total_cycle_errors = 0
	_load_sublevel(level_index)

func _load_pack(pack_path: String) -> void:
	pack_data.clear()
	pack_levels.clear()
	level_total = 0

	var file := FileAccess.open(pack_path, FileAccess.READ)
	if file == null:
		push_error("Failed to open pack data: %s" % pack_path)
		pack_levels = [{"id": "6_2_01", "path": "res://data/city_map/level_6_2.json"}]
		level_total = pack_levels.size()
		return

	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid pack JSON in %s" % pack_path)
		pack_levels = [{"id": "6_2_01", "path": "res://data/city_map/level_6_2.json"}]
		level_total = pack_levels.size()
		return

	pack_data = parsed
	pack_id = str(pack_data.get("pack_id", "CITY_MAP_B_PACK_01"))
	var raw_levels: Array = pack_data.get("levels", [])
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_entry: Dictionary = level_var
		if str(level_entry.get("path", "")).is_empty():
			continue
		pack_levels.append(level_entry)

	if pack_levels.is_empty():
		pack_levels = [{"id": "6_2_01", "path": "res://data/city_map/level_6_2.json"}]
	level_total = pack_levels.size()

func _load_sublevel(index: int) -> void:
	if index < 0 or index >= pack_levels.size():
		return

	level_index = index
	var level_entry := _current_level_entry()
	var level_path := str(level_entry.get("path", ""))
	if level_path.is_empty():
		push_error("Missing level path in pack entry at index %d" % index)
		return

	_load_level_data(level_path)
	attempt_in_sublevel = 0
	is_game_over = false
	stage_completed = false
	input_locked = false
	t_elapsed_seconds = 0
	n_calc = 0
	n_opt = 0
	n_parse = 0
	n_reset = 0
	n_transit = 0
	n_cycle = 0
	backtrack_count = 0
	cycle_events = 0
	cycle_detected = false
	constraint_violations = 0

	_set_briefing()
	_rebuild_graph_ui()
	_reset_round_state(true)
	_lock_input(false)
	_update_timer_display()
	_recalculate_stability()
	if is_game_over:
		return
	btn_next.visible = false
	btn_next.disabled = true
	_set_progress_ui()

func _current_level_entry() -> Dictionary:
	if level_index < 0 or level_index >= pack_levels.size():
		return {}
	var level_var: Variant = pack_levels[level_index]
	if typeof(level_var) != TYPE_DICTIONARY:
		return {}
	return level_var

func _set_progress_ui() -> void:
	var shown_index := maxi(1, level_index + 1)
	var total := maxi(1, level_total)
	var level_entry := _current_level_entry()
	var sub_id := str(level_entry.get("id", ""))
	label_progress.text = "ЗАДАНИЕ: %d/%d%s" % [shown_index, total, ("" if sub_id.is_empty() else " • " + sub_id)]
	if level_index >= total - 1:
		btn_next.text = "ЗАВЕРШИТЬ"
	else:
		btn_next.text = "ДАЛЕЕ"

func _is_round_locked() -> bool:
	return is_game_over or stage_completed or input_locked

func _lock_input(locked: bool) -> void:
	input_locked = locked
	sum_input.editable = not locked and not is_game_over and not stage_completed
	btn_submit.disabled = locked or is_game_over or stage_completed
	btn_reset.disabled = locked or is_game_over or stage_completed
	_update_visuals()

func _on_next_pressed() -> void:
	if not stage_completed:
		return
	if level_index + 1 >= level_total:
		_finalize_pack_run()
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return
	_load_sublevel(level_index + 1)

func _finalize_pack_run() -> void:
	var summary := {
		"schema_version": "city_map.run.v1",
		"quest_id": "CITY_MAP",
		"mode": "B",
		"run_id": run_id,
		"pack_id": pack_id,
		"levels_total": level_total,
		"levels_completed": levels_completed,
		"levels_perfect": levels_perfect,
		"total_time_seconds": run_total_time_seconds,
		"total_calc_errors": run_total_calc_errors,
		"total_opt_errors": run_total_opt_errors,
		"total_parse_errors": run_total_parse_errors,
		"total_reset_errors": run_total_reset_errors,
		"total_transit_errors": run_total_transit_errors,
		"total_cycle_errors": run_total_cycle_errors,
		"finished_at_unix": int(Time.get_unix_time_from_system())
	}
	_save_json_log(summary, true)

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_content_layout_mode()
		_rebuild_graph_ui()
		_update_visuals()
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_OUT:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = true
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_IN:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = false

func _apply_content_layout_mode() -> void:
	content_split.vertical = get_viewport_rect().size.x < get_viewport_rect().size.y

func _setup_timer() -> void:
	var timer := Timer.new()
	timer.name = "ResearchTimer"
	timer.wait_time = 1.0
	timer.autostart = true
	timer.timeout.connect(_on_timer_tick)
	add_child(timer)

func _on_timer_tick() -> void:
	if is_game_over or stage_completed or level_data.is_empty():
		return
	t_elapsed_seconds += 1
	_update_timer_display()
	if t_elapsed_seconds > int(level_data.get("time_limit_sec", 120)):
		_recalculate_stability()

func _load_level_data(path_to_file: String) -> void:
	var file := FileAccess.open(path_to_file, FileAccess.READ)
	if file == null:
		push_error("Failed to open level data: %s" % path_to_file)
		return

	var raw_json := file.get_as_text()
	config_hash = raw_json.sha256_text()
	var parsed: Variant = JSON.parse_string(raw_json)
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid level JSON in %s" % path_to_file)
		return

	level_data = parsed
	node_defs.clear()
	adjacency.clear()
	must_visit_nodes.clear()

	for node_var in level_data.get("nodes", []):
		var node: Dictionary = node_var
		node_defs[str(node.get("id", ""))] = node

	for transit_var in level_data.get("constraints", {}).get("must_visit", []):
		must_visit_nodes.append(str(transit_var))

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		var w := int(edge.get("w", 0))
		if from_id.is_empty() or to_id.is_empty():
			continue
		_add_adjacency(from_id, to_id, w)
		if edge.get("two_way", false):
			_add_adjacency(to_id, from_id, w)

	input_regex = RegEx.new()
	var regex_pattern := "^[0-9]+$"
	if level_data.has("rules") and level_data.rules.has("input_regex"):
		regex_pattern = str(level_data.rules.input_regex)
	input_regex.compile(regex_pattern)

	min_sum = int(level_data.get("min_sum", -1))
	if min_sum < 0:
		min_sum = _calculate_min_sum_with_constraints()

	if level_data.has("ui"):
		if level_data.ui.has("accent_color"):
			accent_color = Color(level_data.ui.accent_color)
		if level_data.ui.has("node_radius_px"):
			var raw_radius := float(level_data.ui.node_radius_px)
			node_radius_px = raw_radius * 0.5 if raw_radius > 32.0 else raw_radius
			node_radius_px = maxf(16.0, node_radius_px)

func _add_adjacency(from_id: String, to_id: String, weight: int) -> void:
	if not adjacency.has(from_id):
		adjacency[from_id] = {}
	adjacency[from_id][to_id] = weight

func _set_briefing() -> void:
	briefing_title.text = "ПРОВЕРКА ТРАНЗИТА"
	briefing_text.text = "Доберитесь до узла E, укажите точную сумму маршрута и докажите его оптимальность в ориентированном графе."
	var constraint_text := "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО ПОСЕТИТЬ %s" % ",".join(must_visit_nodes)
	briefing_constraint.text = constraint_text
	constraint_info_label.text = constraint_text
	footer_label.text = "Двусторонние дороги активны только там, где в данных есть обратное ребро."

func _calculate_min_sum_with_constraints() -> int:
	var start_node := str(level_data.get("start_node", ""))
	var end_node := str(level_data.get("end_node", ""))
	if start_node.is_empty() or end_node.is_empty():
		return 0

	var frontier: Array[Dictionary] = [{
		"node": start_node,
		"cost": 0,
		"path": [start_node]
	}]
	var best := 1_000_000_000

	while not frontier.is_empty():
		var best_index := 0
		for i in range(1, frontier.size()):
			if int(frontier[i].cost) < int(frontier[best_index].cost):
				best_index = i
		var state: Dictionary = frontier.pop_at(best_index)

		var node_id := str(state.node)
		var cost := int(state.cost)
		var path_local: Array = state.path
		if cost >= best:
			continue

		if node_id == end_node and _path_has_all_transit(path_local):
			best = min(best, cost)
			continue

		for next_id in adjacency.get(node_id, {}).keys():
			var local_visits := 0
			for p in path_local:
				if str(p) == str(next_id):
					local_visits += 1
			if local_visits >= 2:
				continue
			frontier.append({
				"node": str(next_id),
				"cost": cost + int(adjacency[node_id][next_id]),
				"path": path_local + [str(next_id)]
			})

	return 0 if best >= 1_000_000_000 else best

func _path_has_all_transit(path_local: Array) -> bool:
	for must_node in must_visit_nodes:
		if not path_local.has(must_node):
			return false
	return true

func _on_graph_resized() -> void:
	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return
	_rebuild_graph_ui()
	_update_visuals()

func _rebuild_graph_ui() -> void:
	for child in edges_layer.get_children():
		child.queue_free()
	for child in nodes_layer.get_children():
		child.queue_free()
	edge_visuals.clear()
	edge_key_to_visuals.clear()
	node_buttons.clear()

	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty() or not node_defs.has(from_id) or not node_defs.has(to_id):
			continue

		var visual_id := str(edge.get("id", _edge_key(from_id, to_id)))
		var start_pos := _node_screen_pos(node_defs[from_id])
		var end_pos := _node_screen_pos(node_defs[to_id])

		var line := Line2D.new()
		line.width = 4.0
		line.points = PackedVector2Array([start_pos, end_pos])
		line.gradient = _build_gradient(Color(0.18, 0.22, 0.30, 0.28), Color(0.30, 0.38, 0.52, 0.48))
		edges_layer.add_child(line)

		var arrows: Array[Polygon2D] = []
		var forward_arrow := _create_arrow_polygon(start_pos, end_pos)
		edges_layer.add_child(forward_arrow)
		arrows.append(forward_arrow)

		var keys: Array[String] = [_edge_key(from_id, to_id)]
		if edge.get("two_way", false):
			var reverse_arrow := _create_arrow_polygon(end_pos, start_pos)
			edges_layer.add_child(reverse_arrow)
			arrows.append(reverse_arrow)
			keys.append(_edge_key(to_id, from_id))

		var label := Label.new()
		label.text = str(edge.get("w", 0))
		label.add_theme_font_size_override("font_size", 15)
		label.position = _edge_label_pos(start_pos, end_pos)
		label.add_theme_color_override("font_color", Color(0.62, 0.74, 0.90))
		edges_layer.add_child(label)

		edge_visuals[visual_id] = {
			"line": line,
			"arrows": arrows,
			"label": label,
			"keys": keys
		}

		for key in keys:
			if not edge_key_to_visuals.has(key):
				edge_key_to_visuals[key] = []
			edge_key_to_visuals[key].append(visual_id)

	for node_id in node_defs.keys():
		var node: Dictionary = node_defs[node_id]
		var btn := Button.new()
		btn.text = str(node.get("label", node_id))
		var diameter := node_radius_px * 2.0
		btn.size = Vector2(diameter, diameter)
		btn.position = _node_screen_pos(node) - Vector2(node_radius_px, node_radius_px)
		btn.pressed.connect(_on_node_pressed.bind(node_id))
		nodes_layer.add_child(btn)
		node_buttons[node_id] = btn

func _edge_label_pos(start_pos: Vector2, end_pos: Vector2) -> Vector2:
	var dir := (end_pos - start_pos).normalized()
	var normal := Vector2(-dir.y, dir.x)
	return ((start_pos + end_pos) * 0.5) + (normal * 12.0) - Vector2(10.0, 10.0)

func _create_arrow_polygon(start_pos: Vector2, end_pos: Vector2) -> Polygon2D:
	var dir := (end_pos - start_pos).normalized()
	var tip := end_pos - dir * (node_radius_px + 4.0)
	var base := tip - dir * ARROW_LEN
	var side_len := ARROW_LEN * 0.65

	var polygon := Polygon2D.new()
	polygon.polygon = PackedVector2Array([
		tip,
		base + dir.rotated(ARROW_ANGLE_RAD) * side_len,
		base + dir.rotated(-ARROW_ANGLE_RAD) * side_len
	])
	polygon.color = Color(0.45, 0.66, 0.96, 0.95)
	return polygon

func _build_gradient(start_color: Color, end_color: Color) -> Gradient:
	var gradient := Gradient.new()
	gradient.set_color(0, start_color)
	gradient.set_color(1, end_color)
	return gradient

func _node_screen_pos(node_data: Dictionary) -> Vector2:
	var pos: Dictionary = node_data.get("pos", {})
	var x := float(pos.get("x", 0.0))
	var y := float(pos.get("y", 0.0))

	if x >= 0.0 and x <= 1.0 and y >= 0.0 and y <= 1.0:
		var padding := node_radius_px + 4.0
		var usable := graph_container.size - Vector2(padding * 2.0, padding * 2.0)
		usable.x = maxf(1.0, usable.x)
		usable.y = maxf(1.0, usable.y)
		return Vector2(padding + x * usable.x, padding + y * usable.y)

	return Vector2(x, y)

func _reset_round_state(full_reset: bool) -> void:
	current_node = str(level_data.get("start_node", "A"))
	path = [current_node]
	path_sum = 0
	backtrack_count = 0
	cycle_events = 0
	cycle_detected = false
	first_attempt_edge = ""
	first_action_ms = -1
	sum_input.clear()
	status_label.text = ""

	if full_reset:
		level_started_ms = Time.get_ticks_msec()

	_update_visuals()

func _update_visuals() -> void:
	path_display.text = "ПУТЬ: %s" % " -> ".join(path)
	sum_live_label.text = "СУММА: %d" % path_sum
	backtrack_label.text = "ОТКАТЫ: %d" % backtrack_count
	if cycle_detected:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ОБНАРУЖЕН ЦИКЛ"
	elif backtrack_count > 0:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ИСПОЛЬЗОВАН ОТКАТ"
	else:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: -"

	for node_id in node_buttons.keys():
		var btn: Button = node_buttons[node_id]
		var is_current: bool = node_id == current_node
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(node_id)
		btn.disabled = is_current or not is_available or _is_round_locked()
		if is_current:
			btn.modulate = Color(0.95, 0.86, 0.45)
		elif is_available:
			btn.modulate = Color(1, 1, 1)
		else:
			btn.modulate = Color(0.42, 0.46, 0.56)

	for visual_id in edge_visuals.keys():
		_apply_style_to_visual(visual_id, "dim")

	if adjacency.has(current_node):
		for next_id in adjacency[current_node].keys():
			_set_edge_style_by_key(_edge_key(current_node, str(next_id)), "available")

	for i in range(path.size() - 1):
		_set_edge_style_by_key(_edge_key(path[i], path[i + 1]), "traversed")

func _set_edge_style_by_key(key: String, state: String) -> void:
	if not edge_key_to_visuals.has(key):
		return
	for visual_id in edge_key_to_visuals[key]:
		_apply_style_to_visual(str(visual_id), state)

func _apply_style_to_visual(visual_id: String, state: String) -> void:
	if not edge_visuals.has(visual_id):
		return
	var visual: Dictionary = edge_visuals[visual_id]
	var line: Line2D = visual["line"]
	var arrows: Array = visual["arrows"]
	var label: Label = visual["label"]

	var start_color := Color(0.18, 0.22, 0.30, 0.28)
	var end_color := Color(0.30, 0.38, 0.52, 0.48)
	if state == "available":
		start_color = Color(0.24, 0.40, 0.62, 0.48)
		end_color = accent_color
		end_color.a = 0.95
	elif state == "traversed":
		start_color = accent_color.lightened(0.10)
		start_color.a = 0.80
		end_color = Color(0.92, 0.97, 1.0, 1.0)

	line.gradient = _build_gradient(start_color, end_color)
	for arrow in arrows:
		(arrow as Polygon2D).color = end_color
	label.add_theme_color_override("font_color", end_color.lightened(0.10))

func _edge_key(from_id: String, to_id: String) -> String:
	return "%s->%s" % [from_id, to_id]

func _on_node_pressed(node_id: String) -> void:
	if _is_round_locked():
		return
	if not adjacency.has(current_node) or not adjacency[current_node].has(node_id):
		return

	if first_attempt_edge.is_empty():
		first_attempt_edge = _edge_key(current_node, node_id)
		first_action_ms = Time.get_ticks_msec() - level_started_ms

	if path.size() >= 2 and path[path.size() - 2] == node_id:
		backtrack_count += 1

	if path.has(node_id):
		cycle_events += 1
		cycle_detected = true

	path_sum += int(adjacency[current_node][node_id])
	path.append(node_id)
	current_node = node_id
	_update_visuals()

func _on_reset_pressed() -> void:
	if _is_round_locked():
		return
	n_reset += 1
	_reset_round_state(false)
	_recalculate_stability()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_sum_input_changed(new_text: String) -> void:
	var digits := ""
	for ch in new_text:
		if ch >= "0" and ch <= "9":
			digits += ch
	if digits != new_text:
		sum_input.text = digits
		sum_input.caret_column = digits.length()

func _on_submit_pressed() -> void:
	if _is_round_locked():
		return

	attempt_in_sublevel += 1
	attempt_in_run += 1
	var verdict := _judge_solution(sum_input.text.strip_edges())
	_log_attempt(verdict)

	if verdict.result_code == "OK":
		status_label.text = "Маршрут принят. Ограничение и оптимальность подтверждены."
		status_label.add_theme_color_override("font_color", Color(0.38, 1.0, 0.62))
		stage_completed = true
		levels_completed += 1
		run_total_time_seconds += t_elapsed_seconds
		run_total_calc_errors += n_calc
		run_total_opt_errors += n_opt
		run_total_parse_errors += n_parse
		run_total_reset_errors += n_reset
		run_total_transit_errors += n_transit
		run_total_cycle_errors += n_cycle
		if attempt_in_sublevel == 1:
			levels_perfect += 1
		btn_next.visible = true
		btn_next.disabled = false
		_lock_input(true)
		_set_progress_ui()
		return

	status_label.text = _result_message(str(verdict.result_code))
	status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.28))
	_recalculate_stability()

func _result_message(result_code: String) -> String:
	match result_code:
		"ERR_INCOMPLETE":
			return "Дойдите до узла E перед отправкой."
		"ERR_MISSING_TRANSIT":
			return "Ограничение не выполнено: посетите обязательные транзитные узлы."
		"ERR_CYCLE":
			return "В маршруте обнаружен цикл."
		"ERR_PARSE":
			return "Вводите только цифры."
		"ERR_CALC":
			return "Введённая сумма не совпадает с выбранным маршрутом."
		"ERR_NOT_OPT":
			return "Маршрут корректный, но не оптимальный."
		"ERR_PATH_INVALID":
			return "Маршрут недопустим для ориентированных рёбер."
		_:
			return "Необработанный результат: %s" % result_code

func _judge_solution(input_text: String) -> Dictionary:
	var sum_actual := _compute_path_sum()
	var sum_input_value: Variant = null
	var result_code := "OK"

	if sum_actual < 0:
		result_code = "ERR_PATH_INVALID"
	elif current_node != str(level_data.get("end_node", "E")):
		result_code = "ERR_INCOMPLETE"
	elif not _path_has_all_transit(path):
		n_transit += 1
		constraint_violations += 1
		result_code = "ERR_MISSING_TRANSIT"
	elif cycle_events > 0:
		n_cycle += 1
		constraint_violations += 1
		result_code = "ERR_CYCLE"
	elif input_regex.search(input_text) == null:
		n_parse += 1
		result_code = "ERR_PARSE"
	else:
		sum_input_value = int(input_text)
		if int(sum_input_value) != sum_actual:
			n_calc += 1
			result_code = "ERR_CALC"
		elif sum_actual != min_sum:
			n_opt += 1
			result_code = "ERR_NOT_OPT"

	return {
		"result_code": result_code,
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"must_visit_ok": _path_has_all_transit(path)
	}

func _compute_path_sum() -> int:
	var total := 0
	for i in range(path.size() - 1):
		var from_id := path[i]
		var to_id := path[i + 1]
		if not adjacency.has(from_id) or not adjacency[from_id].has(to_id):
			return -1
		total += int(adjacency[from_id][to_id])
	return total

func _recalculate_stability() -> void:
	var trust_cfg: Dictionary = level_data.get("trust", {})
	var overtime_div := int(trust_cfg.get("overtime_div", 2))
	overtime_div = maxi(1, overtime_div)
	var overtime: int = maxi(0, t_elapsed_seconds - int(level_data.get("time_limit_sec", 120)))
	var overtime_penalty := int(floor(float(overtime) / float(overtime_div)))

	var penalties := (
		n_calc * int(trust_cfg.get("penalty_calc", 25))
		+ n_opt * int(trust_cfg.get("penalty_opt", 25))
		+ n_parse * int(trust_cfg.get("penalty_parse", 5))
		+ n_reset * int(trust_cfg.get("penalty_reset", 5))
		+ n_transit * int(trust_cfg.get("penalty_transit", 25))
		+ n_cycle * int(trust_cfg.get("penalty_cycle", 10))
		+ overtime_penalty
	)

	stability = clampf(float(trust_cfg.get("initial", 100)) - float(penalties), 0.0, 100.0)
	label_state.text = "СТАБИЛЬНОСТЬ: %d%%" % int(stability)

	if stability <= 10.0 and not is_game_over:
		is_game_over = true
		stage_completed = false
		status_label.text = "МИССИЯ ПРОВАЛЕНА: КРИТИЧЕСКАЯ СТАБИЛЬНОСТЬ."
		status_label.add_theme_color_override("font_color", Color(1.0, 0.30, 0.30))
		btn_next.visible = false
		btn_next.disabled = true
		_lock_input(true)

func _update_timer_display() -> void:
	var time_limit := int(level_data.get("time_limit_sec", 120))
	var remaining: int = maxi(0, time_limit - t_elapsed_seconds)
	var mm: int = remaining / 60
	var ss: int = remaining % 60
	label_timer.text = "ВРЕМЯ: %02d:%02d" % [mm, ss]
	if t_elapsed_seconds > time_limit:
		label_timer.add_theme_color_override("font_color", Color(1.0, 0.36, 0.36))
	else:
		label_timer.add_theme_color_override("font_color", Color(1, 1, 1))

func _log_attempt(verdict: Dictionary) -> void:
	var sum_actual := int(verdict.get("sum_actual", -1))
	var sum_input_value: Variant = verdict.get("sum_input", null)
	var result_code := str(verdict.get("result_code", "ERR_UNKNOWN"))
	var must_visit_ok := bool(verdict.get("must_visit_ok", false))
	var level_entry := _current_level_entry()
	var sublevel_id := str(level_entry.get("id", "6_2_%02d" % (level_index + 1)))
	var sublevel_path := str(level_entry.get("path", ""))
	var next_available := result_code == "OK" and level_index + 1 < level_total

	var attempt_no := GlobalMetrics.session_history.size() + 1
	var log_data := {
		"schema_version": "city_map.v2.2.0",
		"quest_id": "CITY_MAP",
		"stage": "B",
		"task_id": str(level_data.get("level_id", "6.2")),
		"run_id": run_id,
		"pack_id": pack_id,
		"sublevel_index": level_index + 1,
		"sublevel_total": level_total,
		"sublevel_id": sublevel_id,
		"sublevel_path": sublevel_path,
		"attempt_in_sublevel": attempt_in_sublevel,
		"attempt_in_run": attempt_in_run,
		"next_available": next_available,
		"match_key": "CITY_MAP|B|%s|v%s" % [str(level_data.get("level_id", "6.2")), config_hash.substr(0, 8)],
		"variant_hash": config_hash,
		"contract_version": str(level_data.get("contract_version", "city_map.v2.1.0")),
		"attempt_no": attempt_no,
		"result_code": result_code,
		"calc_ok": sum_input_value != null and int(sum_input_value) == sum_actual,
		"optimal_ok": sum_actual == min_sum and result_code == "OK" and must_visit_ok,
		"must_visit_ok": must_visit_ok,
		"first_attempt_edge": null if first_attempt_edge.is_empty() else first_attempt_edge,
		"t_elapsed_seconds": t_elapsed_seconds,
		"path": path.duplicate(),
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"min_sum": min_sum,
		"backtrack_count": backtrack_count,
		"cycle_events": cycle_events,
		"constraint_violations": constraint_violations,
		"stability_final": int(stability),
		"n_calc": n_calc,
		"n_opt": n_opt,
		"n_parse": n_parse,
		"n_reset": n_reset,
		"n_transit": n_transit,
		"n_cycle": n_cycle,
		"is_correct": result_code == "OK",
		"is_fit": result_code == "OK",
		"stability_delta": 0,
		"elapsed_ms": t_elapsed_seconds * 1000,
		"duration": float(t_elapsed_seconds),
		"time_to_first_action_ms": first_action_ms if first_action_ms >= 0 else t_elapsed_seconds * 1000,
		"error_type": "NONE" if result_code == "OK" else result_code
	}

	GlobalMetrics.register_trial(log_data)
	_save_json_log(log_data)

func _save_json_log(data: Dictionary, is_summary: bool = false) -> void:
	var dir := DirAccess.open("user://")
	if dir == null:
		return
	if not dir.dir_exists("research_logs"):
		dir.make_dir("research_logs")

	var stamp_msec: int = Time.get_ticks_msec()
	var attempt_tag := ""
	if data.has("attempt_in_run"):
		attempt_tag = "_a%s" % str(data.get("attempt_in_run"))

	var filename := "user://research_logs/%s_%s_%d%s.json" % [LOG_PREFIX, run_id, stamp_msec, attempt_tag]
	if is_summary:
		filename = "user://research_logs/%s_run_%s_%d.json" % [LOG_PREFIX, run_id, stamp_msec]
	var file := FileAccess.open(filename, FileAccess.WRITE)
	if file != null:
		file.store_string(JSON.stringify(data, "\t"))
		file.close()
</file>

<file path="scenes/CityMapQuestB.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/CityMapQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_awbyl"]

[node name="CityMapQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_awbyl")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(56, 56)
layout_mode = 2
text = "<"

[node name="LabelCase" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО 6: КАРТА ГОРОДА"

[node name="LabelMode" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ: B"

[node name="LabelProgress" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ЗАДАНИЕ: 1/1"

[node name="Spacer" type="Control" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LabelState" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="LabelTimer" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ВРЕМЯ: 02:00"

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingMargin" type="MarginContainer" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BriefingVBox" type="VBoxContainer" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="BriefingTitle" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ПРОВЕРКА ТРАНЗИТА"

[node name="BriefingText" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
text = "Доберитесь до узла E, укажите точную сумму маршрута и докажите его оптимальность в ориентированном графе."
autowrap_mode = 2

[node name="ConstraintLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО ПОСЕТИТЬ C"
autowrap_mode = 2

[node name="ContentSplit" type="BoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="GraphPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 2.0

[node name="GraphMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/GraphPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="GraphContainer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin"]
custom_minimum_size = Vector2(420, 320)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EdgesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="NodesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="InfoPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
custom_minimum_size = Vector2(320, 0)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="InfoMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="InfoVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ConstraintInfoLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО ПОСЕТИТЬ C"

[node name="PathDisplay" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ПУТЬ: A"
autowrap_mode = 2

[node name="SumLiveLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СУММА: 0"

[node name="BacktrackLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ОТКАТЫ: 0"

[node name="WarningLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ПРЕДУПРЕЖДЕНИЯ: -"
autowrap_mode = 2

[node name="InputLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ВВЕДИТЕ ИТОГОВУЮ СУММУ"

[node name="SumInput" type="LineEdit" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
placeholder_text = "0"
max_length = 6

[node name="ButtonsRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnSubmit" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ОТПРАВИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
visible = false
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
disabled = true
text = "ДАЛЕЕ"

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_vertical = 3
autowrap_mode = 2

[node name="Footer" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
theme_override_constants/separation = 8

[node name="FooterLabel" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Двусторонние дороги активны только там, где в данных есть обратное ребро."

[node name="FooterMeta" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
text = "КАРТА ГОРОДА / B"
</file>

<file path="scenes/CityMapQuestC.gd">
extends Control

const PACK_PATH := "res://data/city_map/pack_6_3_C.json"
const LOG_PREFIX := "case_6_3"
const DEFAULT_ACCENT := Color(0.40, 0.72, 1.0, 1.0)
const ARROW_ANGLE_RAD := 0.52
const ARROW_LEN := 16.0

@onready var content_split: BoxContainer = $SafeArea/MainVBox/ContentSplit
@onready var graph_container: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer
@onready var edges_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/EdgesLayer
@onready var nodes_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/NodesLayer
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack
@onready var label_progress: Label = $SafeArea/MainVBox/Header/LabelProgress
@onready var btn_reset: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnReset
@onready var btn_submit: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnSubmit
@onready var btn_next: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnNext
@onready var sum_input: LineEdit = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumInput
@onready var path_display: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/PathDisplay
@onready var sim_time_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SimTimeLabel
@onready var sum_live_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumLiveLabel
@onready var constraint_info_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ConstraintInfoLabel
@onready var warning_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/WarningLabel
@onready var status_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/StatusLabel
@onready var schedule_list: VBoxContainer = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox/ScheduleScroll/ScheduleList
@onready var label_state: Label = $SafeArea/MainVBox/Header/LabelState
@onready var label_timer: Label = $SafeArea/MainVBox/Header/LabelTimer
@onready var footer_label: Label = $SafeArea/MainVBox/Footer/FooterLabel
@onready var briefing_title: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingTitle
@onready var briefing_text: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingText
@onready var briefing_constraint: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/ConstraintLabel

var level_data: Dictionary = {}
var pack_data: Dictionary = {}
var pack_levels: Array = []
var node_defs: Dictionary = {}
var adjacency: Dictionary = {}
var edge_visuals: Dictionary = {}
var node_buttons: Dictionary = {}
var config_hash: String = ""
var input_regex := RegEx.new()
var pack_id: String = "CITY_MAP_C_PACK_01"
var level_index: int = 0
var level_total: int = 0
var run_id: String = ""
var run_started_unix: int = 0
var attempt_in_sublevel: int = 0
var attempt_in_run: int = 0
var levels_completed: int = 0
var levels_perfect: int = 0
var run_total_time_seconds: int = 0
var run_total_calc_errors: int = 0
var run_total_opt_errors: int = 0
var run_total_parse_errors: int = 0
var run_total_reset_errors: int = 0
var run_total_transit_errors: int = 0
var run_total_logic_errors: int = 0
var run_total_closed_errors: int = 0
var run_total_ambush_hits: int = 0

var min_sum: int = 0
var accent_color: Color = DEFAULT_ACCENT
var node_radius_px: float = 25.0
var must_visit_nodes: Array[String] = []
var blacklist_nodes: Array[String] = []
var xor_groups: Array = []

var current_node: String = ""
var path: Array[String] = []
var path_sum: int = 0
var step_weights: Array[int] = []
var stability: float = 100.0
var real_time_sec: int = 0
var sim_time_sec: int = 0
var is_game_over: bool = false
var stage_completed: bool = false
var input_locked: bool = false
var first_attempt_edge: String = ""
var level_started_ms: int = 0
var first_action_ms: int = -1
var planning_time_ms: int = 0

var backtrack_count: int = 0
var cycle_events: int = 0
var cycle_detected: bool = false
var constraint_violations: int = 0
var closed_edge_attempts: int = 0
var ambush_hits: int = 0
var xor_violation: bool = false
var dynamic_weight_awareness: bool = true

var n_calc: int = 0
var n_opt: int = 0
var n_parse: int = 0
var n_reset: int = 0
var n_transit: int = 0
var n_logic: int = 0
var n_closed: int = 0

func _ready() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	sum_input.text_changed.connect(_on_sum_input_changed)
	graph_container.resized.connect(_on_graph_resized)

	_load_pack(PACK_PATH)
	_apply_content_layout_mode()
	_setup_timer()
	call_deferred("_start_pack_run")

func _start_pack_run() -> void:
	run_started_unix = int(Time.get_unix_time_from_system())
	run_id = "CITYMAP_%s_%d" % ["C", run_started_unix]
	level_index = 0
	attempt_in_run = 0
	levels_completed = 0
	levels_perfect = 0
	run_total_time_seconds = 0
	run_total_calc_errors = 0
	run_total_opt_errors = 0
	run_total_parse_errors = 0
	run_total_reset_errors = 0
	run_total_transit_errors = 0
	run_total_logic_errors = 0
	run_total_closed_errors = 0
	run_total_ambush_hits = 0
	_load_sublevel(level_index)

func _load_pack(pack_path: String) -> void:
	pack_data.clear()
	pack_levels.clear()
	level_total = 0

	var file := FileAccess.open(pack_path, FileAccess.READ)
	if file == null:
		push_error("Failed to open pack data: %s" % pack_path)
		pack_levels = [{"id": "6_3_01", "path": "res://data/city_map/level_6_3.json"}]
		level_total = pack_levels.size()
		return

	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid pack JSON in %s" % pack_path)
		pack_levels = [{"id": "6_3_01", "path": "res://data/city_map/level_6_3.json"}]
		level_total = pack_levels.size()
		return

	pack_data = parsed
	pack_id = str(pack_data.get("pack_id", "CITY_MAP_C_PACK_01"))
	var raw_levels: Array = pack_data.get("levels", [])
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_entry: Dictionary = level_var
		if str(level_entry.get("path", "")).is_empty():
			continue
		pack_levels.append(level_entry)

	if pack_levels.is_empty():
		pack_levels = [{"id": "6_3_01", "path": "res://data/city_map/level_6_3.json"}]
	level_total = pack_levels.size()

func _load_sublevel(index: int) -> void:
	if index < 0 or index >= pack_levels.size():
		return

	level_index = index
	var level_entry := _current_level_entry()
	var level_path := str(level_entry.get("path", ""))
	if level_path.is_empty():
		push_error("Missing level path in pack entry at index %d" % index)
		return

	_load_level_data(level_path)
	attempt_in_sublevel = 0
	is_game_over = false
	stage_completed = false
	input_locked = false
	real_time_sec = 0
	sim_time_sec = 0
	n_calc = 0
	n_opt = 0
	n_parse = 0
	n_reset = 0
	n_transit = 0
	n_logic = 0
	n_closed = 0
	backtrack_count = 0
	cycle_events = 0
	cycle_detected = false
	constraint_violations = 0
	closed_edge_attempts = 0
	ambush_hits = 0
	xor_violation = false
	dynamic_weight_awareness = true

	_set_briefing()
	_rebuild_graph_ui()
	_build_schedule_ui()
	_reset_round_state(true)
	_lock_input(false)
	_update_timer_display()
	_recalculate_stability()
	if is_game_over:
		return
	btn_next.visible = false
	btn_next.disabled = true
	_set_progress_ui()

func _current_level_entry() -> Dictionary:
	if level_index < 0 or level_index >= pack_levels.size():
		return {}
	var level_var: Variant = pack_levels[level_index]
	if typeof(level_var) != TYPE_DICTIONARY:
		return {}
	return level_var

func _set_progress_ui() -> void:
	var shown_index := maxi(1, level_index + 1)
	var total := maxi(1, level_total)
	var level_entry := _current_level_entry()
	var sub_id := str(level_entry.get("id", ""))
	label_progress.text = "ЗАДАНИЕ: %d/%d%s" % [shown_index, total, ("" if sub_id.is_empty() else " • " + sub_id)]
	if level_index >= total - 1:
		btn_next.text = "ЗАВЕРШИТЬ"
	else:
		btn_next.text = "ДАЛЕЕ"

func _is_round_locked() -> bool:
	return is_game_over or stage_completed or input_locked

func _lock_input(locked: bool) -> void:
	input_locked = locked
	sum_input.editable = not locked and not is_game_over and not stage_completed
	btn_submit.disabled = locked or is_game_over or stage_completed
	btn_reset.disabled = locked or is_game_over or stage_completed
	_update_visuals()

func _on_next_pressed() -> void:
	if not stage_completed:
		return
	if level_index + 1 >= level_total:
		_finalize_pack_run()
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return
	_load_sublevel(level_index + 1)

func _finalize_pack_run() -> void:
	var summary := {
		"schema_version": "city_map.run.v1",
		"quest_id": "CITY_MAP",
		"mode": "C",
		"run_id": run_id,
		"pack_id": pack_id,
		"levels_total": level_total,
		"levels_completed": levels_completed,
		"levels_perfect": levels_perfect,
		"total_time_seconds": run_total_time_seconds,
		"total_calc_errors": run_total_calc_errors,
		"total_opt_errors": run_total_opt_errors,
		"total_parse_errors": run_total_parse_errors,
		"total_reset_errors": run_total_reset_errors,
		"total_transit_errors": run_total_transit_errors,
		"total_logic_errors": run_total_logic_errors,
		"total_closed_errors": run_total_closed_errors,
		"total_ambush_hits": run_total_ambush_hits,
		"finished_at_unix": int(Time.get_unix_time_from_system())
	}
	_save_json_log(summary, true)

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_content_layout_mode()
		_rebuild_graph_ui()
		_update_visuals()
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_OUT:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = true
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_IN:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = false

func _apply_content_layout_mode() -> void:
	content_split.vertical = get_viewport_rect().size.x < get_viewport_rect().size.y

func _setup_timer() -> void:
	var timer := Timer.new()
	timer.name = "ResearchTimer"
	timer.wait_time = 1.0
	timer.autostart = true
	timer.timeout.connect(_on_timer_tick)
	add_child(timer)

func _on_timer_tick() -> void:
	if is_game_over or stage_completed or level_data.is_empty():
		return
	real_time_sec += 1
	_update_timer_display()
	if real_time_sec > int(level_data.get("time_limit_sec", 140)):
		_recalculate_stability()

func _load_level_data(path_to_file: String) -> void:
	var file := FileAccess.open(path_to_file, FileAccess.READ)
	if file == null:
		push_error("Failed to open level data: %s" % path_to_file)
		return

	var raw_json := file.get_as_text()
	config_hash = raw_json.sha256_text()
	var parsed: Variant = JSON.parse_string(raw_json)
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid level JSON in %s" % path_to_file)
		return

	level_data = parsed
	node_defs.clear()
	adjacency.clear()
	must_visit_nodes.clear()
	blacklist_nodes.clear()
	xor_groups.clear()

	for node_var in level_data.get("nodes", []):
		var node: Dictionary = node_var
		node_defs[str(node.get("id", ""))] = node

	for must_var in level_data.get("constraints", {}).get("must_visit", []):
		must_visit_nodes.append(str(must_var))
	for blacklist_var in level_data.get("constraints", {}).get("blacklist_nodes", []):
		blacklist_nodes.append(str(blacklist_var))
	for xor_var in level_data.get("constraints", {}).get("xor_groups", []):
		xor_groups.append(xor_var)

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty():
			continue
		if not adjacency.has(from_id):
			adjacency[from_id] = {}
		adjacency[from_id][to_id] = edge

	input_regex = RegEx.new()
	var regex_pattern := "^[0-9]+$"
	if level_data.has("rules") and level_data.rules.has("input_regex"):
		regex_pattern = str(level_data.rules.input_regex)
	input_regex.compile(regex_pattern)

	min_sum = int(level_data.get("min_sum", -1))
	if min_sum < 0:
		min_sum = _calculate_min_sum_dynamic()

	if level_data.has("ui"):
		if level_data.ui.has("accent_color"):
			accent_color = Color(level_data.ui.accent_color)
		if level_data.ui.has("node_radius_px"):
			var raw_radius := float(level_data.ui.node_radius_px)
			node_radius_px = raw_radius * 0.5 if raw_radius > 32.0 else raw_radius
			node_radius_px = maxf(16.0, node_radius_px)

func _set_briefing() -> void:
	briefing_title.text = "ОКНО КОМЕНДАНТСКОГО ЧАСА"
	briefing_text.text = "Доберитесь до узла L в условиях динамических окон патруля. Рёбра ЗАКРЫТО заблокированы, рёбра ОПАСНО имеют повышенную стоимость."
	var constraint_text := "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО %s | НЕ БОЛЕЕ ОДНОГО ИЗ (E,G) | ИЗБЕГАТЬ %s" % [
		"-" if must_visit_nodes.is_empty() else ",".join(must_visit_nodes),
		"-" if blacklist_nodes.is_empty() else ",".join(blacklist_nodes)
	]
	briefing_constraint.text = constraint_text
	constraint_info_label.text = constraint_text
	footer_label.text = "РЕАЛЬНЫЙ таймер в заголовке. СИМ-время меняется только при успешном перемещении."

func _build_schedule_ui() -> void:
	for child in schedule_list.get_children():
		child.queue_free()

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		if not edge.has("schedule"):
			continue
		var parts: Array[String] = []
		for slot_var in edge.schedule:
			var slot: Dictionary = slot_var
			var state := str(slot.get("state", "open"))
			var w_text := "ЗАКРЫТО" if state == "closed" else str(slot.get("w", edge.get("w", 0)))
			parts.append("[%d-%d: %s]" % [int(slot.get("t_from", 0)), int(slot.get("t_to", 0)), w_text])

		var row := Label.new()
		row.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
		row.text = "%s->%s: %s" % [str(edge.get("from", "")), str(edge.get("to", "")), " ".join(parts)]
		schedule_list.add_child(row)

func _calculate_min_sum_dynamic() -> int:
	var start_node := str(level_data.get("start_node", ""))
	var end_node := str(level_data.get("end_node", ""))
	if start_node.is_empty() or end_node.is_empty():
		return 0

	var frontier: Array[Dictionary] = [{
		"node": start_node,
		"sim": 0,
		"cost": 0,
		"path": [start_node]
	}]
	var best := 1_000_000_000

	while not frontier.is_empty():
		var best_index := 0
		for i in range(1, frontier.size()):
			if int(frontier[i].cost) < int(frontier[best_index].cost):
				best_index = i
		var state: Dictionary = frontier.pop_at(best_index)

		var node_id := str(state.node)
		var sim := int(state.sim)
		var cost := int(state.cost)
		var path_local: Array = state.path
		if cost >= best:
			continue

		if node_id == end_node and _must_visit_ok(path_local) and not _is_xor_violation(path_local) and not _path_has_blacklist(path_local):
			best = min(best, cost)
			continue

		for next_id in adjacency.get(node_id, {}).keys():
			var edge: Dictionary = adjacency[node_id][next_id]
			var runtime := _edge_runtime_state(edge, sim)
			if runtime.state == "closed":
				continue

			var visits := 0
			for p in path_local:
				if str(p) == str(next_id):
					visits += 1
			if visits >= 2:
				continue

			var next_path := path_local + [str(next_id)]
			if _is_xor_violation(next_path):
				continue
			if _path_has_blacklist(next_path):
				continue

			frontier.append({
				"node": str(next_id),
				"sim": sim + int(runtime.weight),
				"cost": cost + int(runtime.weight),
				"path": next_path
			})

	return 0 if best >= 1_000_000_000 else best

func _on_graph_resized() -> void:
	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return
	_rebuild_graph_ui()
	_update_visuals()

func _rebuild_graph_ui() -> void:
	for child in edges_layer.get_children():
		child.queue_free()
	for child in nodes_layer.get_children():
		child.queue_free()
	edge_visuals.clear()
	node_buttons.clear()

	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty() or not node_defs.has(from_id) or not node_defs.has(to_id):
			continue

		var start_pos := _node_screen_pos(node_defs[from_id])
		var end_pos := _node_screen_pos(node_defs[to_id])
		var line := Line2D.new()
		line.width = 4.0
		line.points = PackedVector2Array([start_pos, end_pos])
		line.gradient = _build_gradient(Color(0.18, 0.22, 0.30, 0.28), Color(0.30, 0.38, 0.52, 0.48))
		edges_layer.add_child(line)

		var arrow := _create_arrow_polygon(start_pos, end_pos)
		edges_layer.add_child(arrow)

		var label := Label.new()
		label.text = str(edge.get("w", 0))
		label.add_theme_font_size_override("font_size", 15)
		label.position = _edge_label_pos(start_pos, end_pos)
		label.add_theme_color_override("font_color", Color(0.62, 0.74, 0.90))
		edges_layer.add_child(label)

		edge_visuals[_edge_key(from_id, to_id)] = {
			"line": line,
			"arrow": arrow,
			"label": label,
			"edge": edge
		}

	for node_id in node_defs.keys():
		var node: Dictionary = node_defs[node_id]
		var btn := Button.new()
		btn.text = str(node.get("label", node_id))
		var diameter := node_radius_px * 2.0
		btn.size = Vector2(diameter, diameter)
		btn.position = _node_screen_pos(node) - Vector2(node_radius_px, node_radius_px)
		btn.pressed.connect(_on_node_pressed.bind(node_id))
		nodes_layer.add_child(btn)
		node_buttons[node_id] = btn

func _edge_label_pos(start_pos: Vector2, end_pos: Vector2) -> Vector2:
	var dir := (end_pos - start_pos).normalized()
	var normal := Vector2(-dir.y, dir.x)
	return ((start_pos + end_pos) * 0.5) + (normal * 12.0) - Vector2(10.0, 10.0)

func _create_arrow_polygon(start_pos: Vector2, end_pos: Vector2) -> Polygon2D:
	var dir := (end_pos - start_pos).normalized()
	var tip := end_pos - dir * (node_radius_px + 4.0)
	var base := tip - dir * ARROW_LEN
	var side_len := ARROW_LEN * 0.65

	var polygon := Polygon2D.new()
	polygon.polygon = PackedVector2Array([
		tip,
		base + dir.rotated(ARROW_ANGLE_RAD) * side_len,
		base + dir.rotated(-ARROW_ANGLE_RAD) * side_len
	])
	polygon.color = Color(0.45, 0.66, 0.96, 0.95)
	return polygon

func _build_gradient(start_color: Color, end_color: Color) -> Gradient:
	var gradient := Gradient.new()
	gradient.set_color(0, start_color)
	gradient.set_color(1, end_color)
	return gradient

func _node_screen_pos(node_data: Dictionary) -> Vector2:
	var pos: Dictionary = node_data.get("pos", {})
	var x := float(pos.get("x", 0.0))
	var y := float(pos.get("y", 0.0))

	if x >= 0.0 and x <= 1.0 and y >= 0.0 and y <= 1.0:
		var padding := node_radius_px + 4.0
		var usable := graph_container.size - Vector2(padding * 2.0, padding * 2.0)
		usable.x = maxf(1.0, usable.x)
		usable.y = maxf(1.0, usable.y)
		return Vector2(padding + x * usable.x, padding + y * usable.y)

	return Vector2(x, y)

func _reset_round_state(full_reset: bool) -> void:
	current_node = str(level_data.get("start_node", "A"))
	path = [current_node]
	path_sum = 0
	step_weights.clear()
	sim_time_sec = 0
	backtrack_count = 0
	cycle_events = 0
	cycle_detected = false
	constraint_violations = 0
	closed_edge_attempts = 0
	ambush_hits = 0
	xor_violation = false
	dynamic_weight_awareness = true
	first_attempt_edge = ""
	first_action_ms = -1
	planning_time_ms = 0
	sum_input.clear()
	status_label.text = ""

	if full_reset:
		level_started_ms = Time.get_ticks_msec()
		real_time_sec = 0

	_update_visuals()

func _update_visuals() -> void:
	path_display.text = "ПУТЬ: %s" % " -> ".join(path)
	sim_time_label.text = "СИМ: %d" % sim_time_sec
	sum_live_label.text = "СУММА: %d" % path_sum

	if xor_violation:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: НАРУШЕНИЕ XOR"
	elif _path_has_blacklist(path):
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ВХОД В ЧЁРНЫЙ СПИСОК"
	elif closed_edge_attempts > 0:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ЗАКРЫТОЕ РЕБРО ЗАБЛОКИРОВАНО"
	elif cycle_detected:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ОБНАРУЖЕН ЦИКЛ"
	else:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: -"

	for node_id in node_buttons.keys():
		var btn: Button = node_buttons[node_id]
		var is_current: bool = node_id == current_node
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(node_id)
		btn.disabled = is_current or not is_available or _is_round_locked()
		if is_current:
			btn.modulate = Color(0.95, 0.86, 0.45)
		elif is_available:
			btn.modulate = Color(1, 1, 1)
		else:
			btn.modulate = Color(0.42, 0.46, 0.56)

	for key in edge_visuals.keys():
		var visual: Dictionary = edge_visuals[key]
		var edge: Dictionary = visual.edge
		var runtime := _edge_runtime_state(edge, sim_time_sec)
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(str(edge.get("to", ""))) and str(edge.get("from", "")) == current_node
		var is_traversed: bool = _path_contains_edge(str(edge.get("from", "")), str(edge.get("to", "")))

		var state := "dim"
		if is_traversed:
			state = "traversed"
		elif runtime.state == "closed":
			state = "closed"
		elif runtime.danger:
			state = "danger"
		elif is_available:
			state = "available"

		_apply_edge_style(key, state, runtime)

func _apply_edge_style(key: String, state: String, runtime: Dictionary) -> void:
	if not edge_visuals.has(key):
		return
	var visual: Dictionary = edge_visuals[key]
	var line: Line2D = visual.line
	var arrow: Polygon2D = visual.arrow
	var label: Label = visual.label

	var start_color := Color(0.18, 0.22, 0.30, 0.28)
	var end_color := Color(0.30, 0.38, 0.52, 0.48)
	var label_text := str(runtime.weight)

	match state:
		"available":
			start_color = Color(0.24, 0.40, 0.62, 0.48)
			end_color = accent_color
			end_color.a = 0.95
		"traversed":
			start_color = accent_color.lightened(0.10)
			start_color.a = 0.80
			end_color = Color(0.92, 0.97, 1.0, 1.0)
		"closed":
			start_color = Color(0.58, 0.14, 0.14, 0.55)
			end_color = Color(1.0, 0.25, 0.25, 1.0)
			label_text = "ЗАКРЫТО"
		"danger":
			start_color = Color(0.62, 0.35, 0.12, 0.60)
			end_color = Color(1.0, 0.62, 0.18, 1.0)
			label_text = "%d ОПАСНО" % int(runtime.weight)

	line.gradient = _build_gradient(start_color, end_color)
	arrow.color = end_color
	label.text = label_text
	label.add_theme_color_override("font_color", end_color.lightened(0.10))

func _path_contains_edge(from_id: String, to_id: String) -> bool:
	for i in range(path.size() - 1):
		if path[i] == from_id and path[i + 1] == to_id:
			return true
	return false

func _edge_key(from_id: String, to_id: String) -> String:
	return "%s->%s" % [from_id, to_id]

func _edge_runtime_state(edge: Dictionary, time_sec: int) -> Dictionary:
	var base_weight := int(edge.get("w", 0))
	var active_weight := base_weight
	var active_state := "open"

	if edge.has("schedule"):
		for slot_var in edge.schedule:
			var slot: Dictionary = slot_var
			var from_t := int(slot.get("t_from", 0))
			var to_t := int(slot.get("t_to", 0))
			if time_sec >= from_t and time_sec < to_t:
				active_state = str(slot.get("state", "open"))
				active_weight = int(slot.get("w", base_weight))
				break

	return {
		"weight": active_weight,
		"state": active_state,
		"danger": active_state != "closed" and active_weight > base_weight
	}

func _on_node_pressed(node_id: String) -> void:
	if _is_round_locked():
		return
	if not adjacency.has(current_node) or not adjacency[current_node].has(node_id):
		return

	if first_attempt_edge.is_empty():
		first_attempt_edge = _edge_key(current_node, node_id)
		first_action_ms = Time.get_ticks_msec() - level_started_ms
		planning_time_ms = first_action_ms

	if path.size() >= 2 and path[path.size() - 2] == node_id:
		backtrack_count += 1
	if path.has(node_id):
		cycle_events += 1
		cycle_detected = true

	var edge: Dictionary = adjacency[current_node][node_id]
	var runtime := _edge_runtime_state(edge, sim_time_sec)
	if runtime.state == "closed":
		closed_edge_attempts += 1
		n_closed += 1
		dynamic_weight_awareness = false
		status_label.text = "ЗАКРЫТОЕ РЕБРО: перемещение заблокировано"
		status_label.add_theme_color_override("font_color", Color(1.0, 0.35, 0.35))
		_recalculate_stability()
		_update_visuals()
		return

	if runtime.danger:
		dynamic_weight_awareness = false

	path_sum += int(runtime.weight)
	step_weights.append(int(runtime.weight))
	sim_time_sec += int(runtime.weight)
	path.append(node_id)
	current_node = node_id

	if blacklist_nodes.has(node_id):
		ambush_hits += 1
		constraint_violations += 1
		status_label.text = "ЗАСАДА: вход в узел чёрного списка"
		status_label.add_theme_color_override("font_color", Color(1.0, 0.42, 0.30))

	if _is_xor_violation(path) and not xor_violation:
		xor_violation = true
		n_logic += 1
		constraint_violations += 1
		status_label.text = "НАРУШЕНИЕ XOR: в группе допускается не более одного узла"
		status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.18))

	_recalculate_stability()
	_update_visuals()

func _on_reset_pressed() -> void:
	if _is_round_locked():
		return
	n_reset += 1
	_reset_round_state(false)
	_recalculate_stability()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_sum_input_changed(new_text: String) -> void:
	var digits := ""
	for ch in new_text:
		if ch >= "0" and ch <= "9":
			digits += ch
	if digits != new_text:
		sum_input.text = digits
		sum_input.caret_column = digits.length()

func _on_submit_pressed() -> void:
	if _is_round_locked():
		return

	attempt_in_sublevel += 1
	attempt_in_run += 1
	var verdict := _judge_solution(sum_input.text.strip_edges())
	_log_attempt(verdict)

	if verdict.result_code == "OK":
		status_label.text = "Маршрут принят. Динамические ограничения соблюдены."
		status_label.add_theme_color_override("font_color", Color(0.38, 1.0, 0.62))
		stage_completed = true
		levels_completed += 1
		run_total_time_seconds += real_time_sec
		run_total_calc_errors += n_calc
		run_total_opt_errors += n_opt
		run_total_parse_errors += n_parse
		run_total_reset_errors += n_reset
		run_total_transit_errors += n_transit
		run_total_logic_errors += n_logic
		run_total_closed_errors += n_closed
		run_total_ambush_hits += ambush_hits
		if attempt_in_sublevel == 1:
			levels_perfect += 1
		btn_next.visible = true
		btn_next.disabled = false
		_lock_input(true)
		_set_progress_ui()
		return

	status_label.text = _result_message(str(verdict.result_code))
	status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.28))
	_recalculate_stability()

func _result_message(result_code: String) -> String:
	match result_code:
		"ERR_INCOMPLETE":
			return "Дойдите до узла L перед отправкой."
		"ERR_MISSING_TRANSIT":
			return "Ограничение не выполнено: посетите обязательные транзитные узлы."
		"ERR_LOGIC_VIOLATION":
			return "Нарушено ограничение XOR."
		"ERR_AMBUSH":
			return "Посещён узел из чёрного списка."
		"ERR_PARSE":
			return "Вводите только цифры."
		"ERR_CALC":
			return "Введённая сумма не совпадает со смоделированной стоимостью пути."
		"ERR_NOT_OPT":
			return "Маршрут корректный, но не оптимальный."
		"ERR_PATH_INVALID":
			return "Маршрут недопустим для ориентированных рёбер."
		_:
			return "Необработанный результат: %s" % result_code

func _judge_solution(input_text: String) -> Dictionary:
	var sum_actual := _compute_path_sum()
	var sum_input_value: Variant = null
	var result_code := "OK"

	if sum_actual < 0:
		result_code = "ERR_PATH_INVALID"
	elif current_node != str(level_data.get("end_node", "L")):
		result_code = "ERR_INCOMPLETE"
	elif not _must_visit_ok(path):
		n_transit += 1
		constraint_violations += 1
		result_code = "ERR_MISSING_TRANSIT"
	elif _is_xor_violation(path):
		if not xor_violation:
			xor_violation = true
			n_logic += 1
		constraint_violations += 1
		result_code = "ERR_LOGIC_VIOLATION"
	elif _path_has_blacklist(path):
		result_code = "ERR_AMBUSH"
	elif input_regex.search(input_text) == null:
		n_parse += 1
		result_code = "ERR_PARSE"
	else:
		sum_input_value = int(input_text)
		if int(sum_input_value) != sum_actual:
			n_calc += 1
			result_code = "ERR_CALC"
		elif sum_actual != min_sum:
			n_opt += 1
			result_code = "ERR_NOT_OPT"

	return {
		"result_code": result_code,
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"must_visit_ok": _must_visit_ok(path)
	}

func _compute_path_sum() -> int:
	var total := 0
	for i in range(path.size() - 1):
		var from_id := path[i]
		var to_id := path[i + 1]
		if not adjacency.has(from_id) or not adjacency[from_id].has(to_id):
			return -1
		total += int(step_weights[i]) if i < step_weights.size() else 0
	return total

func _must_visit_ok(path_local: Array) -> bool:
	for node_id in must_visit_nodes:
		if not path_local.has(node_id):
			return false
	return true

func _path_has_blacklist(path_local: Array) -> bool:
	for node_id in blacklist_nodes:
		if path_local.has(node_id):
			return true
	return false

func _is_xor_violation(path_local: Array) -> bool:
	for group_var in xor_groups:
		var group: Dictionary = group_var
		if str(group.get("type", "")) != "AT_MOST_ONE":
			continue
		var count := 0
		for node_id_var in group.get("nodes", []):
			if path_local.has(str(node_id_var)):
				count += 1
		if count > 1:
			return true
	return false

func _recalculate_stability() -> void:
	var trust_cfg: Dictionary = level_data.get("trust", {})
	var overtime_div := int(trust_cfg.get("overtime_div", 2))
	overtime_div = maxi(1, overtime_div)
	var overtime: int = maxi(0, real_time_sec - int(level_data.get("time_limit_sec", 140)))
	var overtime_penalty := int(floor(float(overtime) / float(overtime_div)))

	var penalties := (
		n_calc * int(trust_cfg.get("penalty_calc", 25))
		+ n_opt * int(trust_cfg.get("penalty_opt", 25))
		+ n_parse * int(trust_cfg.get("penalty_parse", 5))
		+ n_reset * int(trust_cfg.get("penalty_reset", 5))
		+ n_transit * int(trust_cfg.get("penalty_transit", 25))
		+ n_logic * int(trust_cfg.get("penalty_logic_violation", 30))
		+ n_closed * int(trust_cfg.get("penalty_closed_edge", 8))
		+ overtime_penalty
	)

	var effective := float(trust_cfg.get("initial", 100)) - float(penalties)
	var ambush_multiplier := float(trust_cfg.get("ambush_multiplier", 0.5))
	for _i in range(ambush_hits):
		effective *= ambush_multiplier

	stability = clampf(effective, 0.0, 100.0)
	label_state.text = "СТАБИЛЬНОСТЬ: %d%%" % int(stability)

	var fail_threshold := float(trust_cfg.get("fail_threshold", 10))
	if stability <= fail_threshold and not is_game_over:
		is_game_over = true
		stage_completed = false
		status_label.text = "МИССИЯ ПРОВАЛЕНА: КРИТИЧЕСКАЯ СТАБИЛЬНОСТЬ."
		status_label.add_theme_color_override("font_color", Color(1.0, 0.30, 0.30))
		btn_next.visible = false
		btn_next.disabled = true
		_lock_input(true)

func _update_timer_display() -> void:
	var time_limit := int(level_data.get("time_limit_sec", 140))
	var remaining: int = maxi(0, time_limit - real_time_sec)
	var mm: int = remaining / 60
	var ss: int = remaining % 60
	label_timer.text = "ВРЕМЯ: %02d:%02d" % [mm, ss]
	if real_time_sec > time_limit:
		label_timer.add_theme_color_override("font_color", Color(1.0, 0.36, 0.36))
	else:
		label_timer.add_theme_color_override("font_color", Color(1, 1, 1))

func _log_attempt(verdict: Dictionary) -> void:
	var sum_actual := int(verdict.get("sum_actual", -1))
	var sum_input_value: Variant = verdict.get("sum_input", null)
	var result_code := str(verdict.get("result_code", "ERR_UNKNOWN"))
	var must_visit_ok := bool(verdict.get("must_visit_ok", false))
	var level_entry := _current_level_entry()
	var sublevel_id := str(level_entry.get("id", "6_3_%02d" % (level_index + 1)))
	var sublevel_path := str(level_entry.get("path", ""))
	var next_available := result_code == "OK" and level_index + 1 < level_total

	var attempt_no := GlobalMetrics.session_history.size() + 1
	var log_data := {
		"schema_version": "city_map.v2.2.0",
		"quest_id": "CITY_MAP",
		"stage": "C",
		"task_id": str(level_data.get("level_id", "6.3")),
		"run_id": run_id,
		"pack_id": pack_id,
		"sublevel_index": level_index + 1,
		"sublevel_total": level_total,
		"sublevel_id": sublevel_id,
		"sublevel_path": sublevel_path,
		"attempt_in_sublevel": attempt_in_sublevel,
		"attempt_in_run": attempt_in_run,
		"next_available": next_available,
		"match_key": "CITY_MAP|C|%s|v%s" % [str(level_data.get("level_id", "6.3")), config_hash.substr(0, 8)],
		"variant_hash": config_hash,
		"contract_version": str(level_data.get("contract_version", "city_map.v2.1.0")),
		"attempt_no": attempt_no,
		"result_code": result_code,
		"calc_ok": sum_input_value != null and int(sum_input_value) == sum_actual,
		"optimal_ok": sum_actual == min_sum and result_code == "OK" and must_visit_ok and not xor_violation and not _path_has_blacklist(path),
		"must_visit_ok": must_visit_ok,
		"first_attempt_edge": null if first_attempt_edge.is_empty() else first_attempt_edge,
		"t_elapsed_seconds": real_time_sec,
		"path": path.duplicate(),
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"min_sum": min_sum,
		"backtrack_count": backtrack_count,
		"cycle_events": cycle_events,
		"constraint_violations": constraint_violations,
		"planning_time_ms": planning_time_ms,
		"dynamic_weight_awareness": dynamic_weight_awareness,
		"closed_edge_attempts": closed_edge_attempts,
		"ambush_hits": ambush_hits,
		"xor_violation": xor_violation,
		"sim_time_sec": sim_time_sec,
		"stability_final": int(stability),
		"n_calc": n_calc,
		"n_opt": n_opt,
		"n_parse": n_parse,
		"n_reset": n_reset,
		"n_transit": n_transit,
		"n_logic": n_logic,
		"n_closed": n_closed,
		"is_correct": result_code == "OK",
		"is_fit": result_code == "OK",
		"stability_delta": 0,
		"elapsed_ms": real_time_sec * 1000,
		"duration": float(real_time_sec),
		"time_to_first_action_ms": first_action_ms if first_action_ms >= 0 else real_time_sec * 1000,
		"error_type": "NONE" if result_code == "OK" else result_code
	}

	GlobalMetrics.register_trial(log_data)
	_save_json_log(log_data)

func _save_json_log(data: Dictionary, is_summary: bool = false) -> void:
	var dir := DirAccess.open("user://")
	if dir == null:
		return
	if not dir.dir_exists("research_logs"):
		dir.make_dir("research_logs")

	var stamp_msec: int = Time.get_ticks_msec()
	var attempt_tag := ""
	if data.has("attempt_in_run"):
		attempt_tag = "_a%s" % str(data.get("attempt_in_run"))

	var filename := "user://research_logs/%s_%s_%d%s.json" % [LOG_PREFIX, run_id, stamp_msec, attempt_tag]
	if is_summary:
		filename = "user://research_logs/%s_run_%s_%d.json" % [LOG_PREFIX, run_id, stamp_msec]
	var file := FileAccess.open(filename, FileAccess.WRITE)
	if file != null:
		file.store_string(JSON.stringify(data, "\t"))
		file.close()
</file>

<file path="scenes/CityMapQuestC.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/CityMapQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_yik8x"]

[node name="CityMapQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_yik8x")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(56, 56)
layout_mode = 2
text = "<"

[node name="LabelCase" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО 6: КАРТА ГОРОДА"

[node name="LabelMode" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ: C"

[node name="LabelProgress" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ЗАДАНИЕ: 1/1"

[node name="Spacer" type="Control" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LabelState" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="LabelTimer" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ВРЕМЯ: 02:20"

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingMargin" type="MarginContainer" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BriefingVBox" type="VBoxContainer" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="BriefingTitle" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ОКНО КОМЕНДАНТСКОГО ЧАСА"

[node name="BriefingText" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
text = "Доберитесь до узла L в условиях динамических окон патруля. Рёбра ЗАКРЫТО заблокированы, рёбра ОПАСНО имеют повышенную стоимость."
autowrap_mode = 2

[node name="ConstraintLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО F | НЕ БОЛЕЕ ОДНОГО ИЗ (E,G) | ИЗБЕГАТЬ J"
autowrap_mode = 2

[node name="ContentSplit" type="BoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="GraphPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 2.0

[node name="GraphMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/GraphPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="GraphContainer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin"]
custom_minimum_size = Vector2(420, 320)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EdgesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="NodesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="InfoPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
custom_minimum_size = Vector2(340, 0)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="InfoMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="InfoVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ConstraintInfoLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО F"

[node name="PathDisplay" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ПУТЬ: A"
autowrap_mode = 2

[node name="SimTimeLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СИМ: 0"

[node name="SumLiveLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СУММА: 0"

[node name="WarningLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ПРЕДУПРЕЖДЕНИЯ: -"
autowrap_mode = 2

[node name="InputLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ВВЕДИТЕ ИТОГОВУЮ СУММУ"

[node name="SumInput" type="LineEdit" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
placeholder_text = "0"
max_length = 6

[node name="ButtonsRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnSubmit" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ОТПРАВИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
visible = false
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
disabled = true
text = "ДАЛЕЕ"

[node name="SchedulePanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScheduleMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="ScheduleVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="ScheduleTitle" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox"]
layout_mode = 2
text = "РАСПИСАНИЕ"

[node name="ScheduleScroll" type="ScrollContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScheduleList" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox/ScheduleScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
autowrap_mode = 2

[node name="Footer" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
theme_override_constants/separation = 8

[node name="FooterLabel" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3
text = "РЕАЛЬНЫЙ таймер в заголовке. СИМ-время меняется только при успешном перемещении."

[node name="FooterMeta" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
text = "КАРТА ГОРОДА / C"
</file>

<file path="scenes/DisarmQuestC.tscn">
[gd_scene load_steps=10 format=3]

[ext_resource type="Script" path="res://scripts/DisarmQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://scenes/ui/FixMenuC.tscn" id="3_fix_menu"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_2wosd"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="4_diag_panel"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="5_noir"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="6_1park"]
[ext_resource type="Script" path="res://scripts/ui/FixMenuC.gd" id="7_qsefb"]
[ext_resource type="Script" path="res://scripts/ui/DiagnosticsPanelC.gd" id="9_mc3vw"]

[node name="DisarmQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("5_noir")]
layer = 100
script = ExtResource("4_2wosd")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="HeaderRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/HeaderRow"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="SafeArea/MainLayout/HeaderRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 28
text = "Дело C: Разминирование"

[node name="LblSession" type="Label" parent="SafeArea/MainLayout/HeaderRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 22
text = "СЕССИЯ: C-01"
horizontal_alignment = 2

[node name="StatusMonitor" type="PanelContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 140)
layout_mode = 2

[node name="MonitorsRow" type="HBoxContainer" parent="SafeArea/MainLayout/StatusMonitor"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="ExpectedPanel" type="PanelContainer" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow"]
self_modulate = Color(0.92, 0.92, 0.9, 1)
layout_mode = 2
size_flags_horizontal = 3

[node name="ExpectedVBox" type="VBoxContainer" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblExpectedTitle" type="Label" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel/ExpectedVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ОЖИДАЕМОЕ"
horizontal_alignment = 1

[node name="LblExpectedValue" type="Label" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel/ExpectedVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 34
text = "s = 20"
horizontal_alignment = 1

[node name="ActualPanel" type="PanelContainer" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ActualVBox" type="VBoxContainer" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow/ActualPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblActualTitle" type="Label" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow/ActualPanel/ActualVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ФАКТ"
horizontal_alignment = 1

[node name="LblActualValue" type="Label" parent="SafeArea/MainLayout/StatusMonitor/MonitorsRow/ActualPanel/ActualVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 34
text = "s = 15"
horizontal_alignment = 1

[node name="BodyRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="CodeFrame" type="PanelContainer" parent="SafeArea/MainLayout/BodyRow"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CodeRoot" type="Control" parent="SafeArea/MainLayout/BodyRow/CodeFrame"]
layout_mode = 2
anchors_preset = 0
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="CodeView" type="CodeEdit" parent="SafeArea/MainLayout/BodyRow/CodeFrame/CodeRoot"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 8.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = -8.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 24

[node name="LineHighlight" type="ColorRect" parent="SafeArea/MainLayout/BodyRow/CodeFrame/CodeRoot"]
visible = false
layout_mode = 1
offset_left = 8.0
offset_top = 8.0
offset_right = 108.0
offset_bottom = 40.0
mouse_filter = 2
color = Color(0.93, 0.93, 0.91, 0.14)

[node name="SideInfo" type="VBoxContainer" parent="SafeArea/MainLayout/BodyRow"]
custom_minimum_size = Vector2(300, 0)
layout_mode = 2
theme_override_constants/separation = 12

[node name="LblHint" type="Label" parent="SafeArea/MainLayout/BodyRow/SideInfo"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/font_size = 22
text = "Найдите строку с ошибкой и выберите исправление."
autowrap_mode = 2

[node name="MisclickCounter" type="Label" parent="SafeArea/MainLayout/BodyRow/SideInfo"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ПРОМАХИ: 0"

[node name="ActionsRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="BtnAnalyze" type="Button" parent="SafeArea/MainLayout/ActionsRow"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="BtnVerify" type="Button" parent="SafeArea/MainLayout/ActionsRow"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРОВЕРИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/ActionsRow"]
visible = false
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="DiagnosticsBlocker" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.4)

[node name="FixMenuC" type="PopupPanel" parent="." instance=ExtResource("3_fix_menu")]
initial_position = 1
size = Vector2i(860, 420)
theme = ExtResource("6_1park")
script = ExtResource("7_qsefb")

[node name="DiagnosticsPanelC" type="PanelContainer" parent="." instance=ExtResource("4_diag_panel")]
visible = false
layout_mode = 1
anchors_preset = -1
anchor_left = 0.15
anchor_top = 0.2
anchor_right = 0.85
anchor_bottom = 0.8
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("6_1park")
script = ExtResource("9_mc3vw")
</file>

<file path="scenes/RestoreQuestB.tscn">
[gd_scene load_steps=9 format=3]

[ext_resource type="Script" path="res://scripts/RestoreQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelB.tscn" id="3_panel"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_0vmkb"]
[ext_resource type="Script" path="res://scripts/ui/DropZone.gd" id="4_dropzone"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="5_noir"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="7_mudek"]
[ext_resource type="Script" path="res://scripts/ui/DiagnosticsPanelB.gd" id="8_6p63x"]

[node name="RestoreQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("5_noir")]
layer = 100
script = ExtResource("4_0vmkb")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ВОССТАНОВЛЕНИЕ B-01"

[node name="LblSessionId" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "СЕССИЯ ИНИЦ."
horizontal_alignment = 2

[node name="BarsRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="DecryptBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="EnergyBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 100.0
show_percentage = false

[node name="TargetDisplay" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="LblTarget" type="Label" parent="SafeArea/MainLayout/TargetDisplay"]
layout_mode = 2
text = "ЦЕЛЬ: s = ?"
horizontal_alignment = 1

[node name="TerminalFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="CodeScroll" type="ScrollContainer" parent="SafeArea/MainLayout/TerminalFrame"]
layout_mode = 2

[node name="CodeDisplay" type="RichTextLabel" parent="SafeArea/MainLayout/TerminalFrame/CodeScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "Загрузка кода..."
fit_content = true

[node name="SlotRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="DropZone" type="PanelContainer" parent="SafeArea/MainLayout/SlotRow"]
custom_minimum_size = Vector2(240, 96)
layout_mode = 2
script = ExtResource("4_dropzone")

[node name="Label" type="Label" parent="SafeArea/MainLayout/SlotRow/DropZone"]
layout_mode = 2
text = "[СЛОТ]"
horizontal_alignment = 1
vertical_alignment = 1

[node name="LblSlotHint" type="Label" parent="SafeArea/MainLayout/SlotRow"]
layout_mode = 2
text = "<-- Перетащите блок сюда"

[node name="InventoryFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.5

[node name="InventoryMargin" type="MarginContainer" parent="SafeArea/MainLayout/InventoryFrame"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="InventoryScroll" type="ScrollContainer" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin"]
layout_mode = 2

[node name="BlocksContainer" type="HBoxContainer" parent="SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 14
alignment = 1

[node name="Actions" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnAnalyze" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="BtnSubmit" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРОВЕРИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/Actions"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="DiagnosticsBlocker" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.45)

[node name="DiagnosticsPanelB" type="PanelContainer" parent="." instance=ExtResource("3_panel")]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("7_mudek")
script = ExtResource("8_6p63x")
</file>

<file path="scenes/SuspectQuestA.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scripts/SuspectQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_cc18y"]

[node name="SuspectQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_cc18y")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="BtnQuestBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
text = "УЛИКА #A-01"
horizontal_alignment = 1

[node name="LblSessionId" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 10
text = "СЕССИЯ ИНИЦ."
horizontal_alignment = 2

[node name="SettingsRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="PaletteTitle" type="Label" parent="SafeArea/MainLayout/SettingsRow"]
layout_mode = 2
text = "ПАЛИТРА"

[node name="PaletteSelect" type="OptionButton" parent="SafeArea/MainLayout/SettingsRow"]
custom_minimum_size = Vector2(120, 0)
layout_mode = 2

[node name="FxTitle" type="Label" parent="SafeArea/MainLayout/SettingsRow"]
layout_mode = 2
text = "ЭФФЕКТЫ"

[node name="FxSelect" type="OptionButton" parent="SafeArea/MainLayout/SettingsRow"]
custom_minimum_size = Vector2(110, 0)
layout_mode = 2

[node name="BarsRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="DecryptBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="EnergyBar" type="ProgressBar" parent="SafeArea/MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 100.0
show_percentage = false

[node name="TerminalFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScrollContainer" type="ScrollContainer" parent="SafeArea/MainLayout/TerminalFrame"]
layout_mode = 2

[node name="CodeLabel" type="RichTextLabel" parent="SafeArea/MainLayout/TerminalFrame/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "[code]Инициализация...[/code]"

[node name="StatusRow" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
alignment = 1

[node name="LblStatus" type="Label" parent="SafeArea/MainLayout/StatusRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДОСТУП ОЖИДАЕТ"

[node name="LblAttempts" type="Label" parent="SafeArea/MainLayout/StatusRow"]
layout_mode = 2
text = "ОШ: 0/3"

[node name="InputFrame" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="InputDisplay" type="Label" parent="SafeArea/MainLayout/InputFrame"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "----"
horizontal_alignment = 1

[node name="Numpad" type="GridContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.6
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 3

[node name="Btn7" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "7"

[node name="Btn8" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "8"

[node name="Btn9" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "9"

[node name="Btn4" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "4"

[node name="Btn5" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "5"

[node name="Btn6" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "6"

[node name="Btn1" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "1"

[node name="Btn2" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "2"

[node name="Btn3" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "3"

[node name="BtnClr" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "СБР"

[node name="Btn0" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "0"

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "<-"

[node name="Actions" type="HBoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnAnalyze" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="BtnEnter" type="Button" parent="SafeArea/MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ВВОД"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/Actions"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ДАЛЕЕ"

[node name="DiagnosticsPanel" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="DiagnosticsPanel"]
layout_mode = 2
theme_override_constants/separation = 16

[node name="Label" type="Label" parent="DiagnosticsPanel/VBoxContainer"]
layout_mode = 2
text = "ДИАГНОСТИЧЕСКИЙ ТРЕЙС"
horizontal_alignment = 1

[node name="ExplainList" type="RichTextLabel" parent="DiagnosticsPanel/VBoxContainer"]
layout_mode = 2

[node name="TraceList" type="RichTextLabel" parent="DiagnosticsPanel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Журнал трассировки..."

[node name="BtnCloseDiag" type="Button" parent="DiagnosticsPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scripts/DisarmQuestC.gd">
extends Control

const LEVELS_PATH := "res://data/quest_c_levels.json"

enum State {
	INIT,
	LINE_SELECT,
	FIX_MENU,
	READY_TO_VERIFY,
	VERIFY,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	DIAGNOSTIC
}

@onready var lbl_clue_title: Label = $SafeArea/MainLayout/HeaderRow/LblClueTitle
@onready var lbl_session: Label = $SafeArea/MainLayout/HeaderRow/LblSession
@onready var btn_back: Button = $SafeArea/MainLayout/HeaderRow/BtnBack
@onready var expected_panel: PanelContainer = $SafeArea/MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel
@onready var actual_panel: PanelContainer = $SafeArea/MainLayout/StatusMonitor/MonitorsRow/ActualPanel
@onready var lbl_expected_value: Label = $SafeArea/MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel/ExpectedVBox/LblExpectedValue
@onready var lbl_actual_value: Label = $SafeArea/MainLayout/StatusMonitor/MonitorsRow/ActualPanel/ActualVBox/LblActualValue
@onready var code_view: CodeEdit = $SafeArea/MainLayout/BodyRow/CodeFrame/CodeRoot/CodeView
@onready var line_highlight: ColorRect = $SafeArea/MainLayout/BodyRow/CodeFrame/CodeRoot/LineHighlight
@onready var lbl_hint: Label = $SafeArea/MainLayout/BodyRow/SideInfo/LblHint
@onready var lbl_misclicks: Label = $SafeArea/MainLayout/BodyRow/SideInfo/MisclickCounter
@onready var btn_analyze: Button = $SafeArea/MainLayout/ActionsRow/BtnAnalyze
@onready var btn_verify: Button = $SafeArea/MainLayout/ActionsRow/BtnVerify
@onready var btn_next: Button = $SafeArea/MainLayout/ActionsRow/BtnNext
@onready var diagnostics_blocker: ColorRect = $DiagnosticsBlocker
@onready var fix_menu: PopupPanel = $FixMenuC
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanelC

var levels: Array = []
var current_level_idx := 0
var current_task: Dictionary = {}
var state: State = State.INIT
var variant_hash := ""
var task_started_ticks := 0
var paused_total_ms := 0
var pause_started_ticks := -1
var hint_open_ticks := 0
var hint_total_ms := 0
var selected_line_index := -1
var selected_option_id := ""
var misclicks_before_correct := 0
var wrong_fix_attempts_before_correct := 0
var has_selected_correct_line := false
var level_result_sent := false
var suppress_caret_event := false
var line_pick_armed := false
var highlight_tween: Tween
var task_session: Dictionary = {}
var cached_line_height := 26
var last_scroll_vertical := -1

func _ready() -> void:
	_configure_code_view()
	_connect_signals()
	_load_levels()
	if levels.is_empty():
		lbl_hint.text = "Данные уровня C не загружены."
		return

	var idx: int = int(GlobalMetrics.current_level_index)
	if idx < 0 or idx >= levels.size():
		idx = 0
	_start_level(idx)

func _configure_code_view() -> void:
	code_view.editable = false
	_try_set_control_property("wrap_mode", 0)
	_try_set_control_property("line_wrapping_mode", 0)
	_try_set_control_property("caret_draw_when_editable_disabled", true)
	_try_set_control_property("gutters_draw_line_numbers", true)
	_try_set_control_property("gutter_draw_line_numbers", true)
	_try_set_control_property("gutters_zero_pad_line_numbers", true)
	_try_set_control_property("gutter_zero_pad_line_numbers", true)

	line_highlight.visible = false
	line_highlight.color = Color(0.93, 0.93, 0.91, 0.14)
	if code_view.has_method("get_line_height"):
		cached_line_height = int(code_view.call("get_line_height"))

func _try_set_control_property(prop_name: String, value: Variant) -> void:
	for prop_var in code_view.get_property_list():
		if typeof(prop_var) != TYPE_DICTIONARY:
			continue
		var prop: Dictionary = prop_var
		if str(prop.get("name", "")) == prop_name:
			code_view.set(prop_name, value)
			return

func _connect_signals() -> void:
	code_view.caret_changed.connect(_on_code_caret_changed)
	code_view.gui_input.connect(_on_code_gui_input)
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_verify.pressed.connect(_on_verify_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	diagnostics_panel.visibility_changed.connect(_on_diagnostics_visibility_changed)
	var on_option_selected := Callable(self, "_on_fix_option_selected")
	var on_apply_requested := Callable(self, "_on_fix_apply_requested")
	var on_canceled := Callable(self, "_on_fix_menu_canceled")
	if not fix_menu.is_connected("option_selected", on_option_selected):
		fix_menu.connect("option_selected", on_option_selected)
	if not fix_menu.is_connected("apply_requested", on_apply_requested):
		fix_menu.connect("apply_requested", on_apply_requested)
	if not fix_menu.is_connected("canceled", on_canceled):
		fix_menu.connect("canceled", on_canceled)

func _load_levels() -> void:
	levels.clear()
	if not FileAccess.file_exists(LEVELS_PATH):
		push_error("DisarmQuestC levels file missing: " + LEVELS_PATH)
		return

	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		push_error("Unable to open " + LEVELS_PATH)
		return

	var json := JSON.new()
	if json.parse(file.get_as_text()) != OK:
		push_error("JSON parse error in quest_c_levels.json: " + json.get_error_message())
		return

	if typeof(json.data) != TYPE_ARRAY:
		push_error("quest_c_levels.json must be an array.")
		return

	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
		else:
			push_warning("Skipping invalid C level: " + str(level.get("id", "UNKNOWN")))

func _validate_level(level: Dictionary) -> bool:
	var required := [
		"id",
		"bucket",
		"briefing",
		"expected_s",
		"actual_s",
		"code_lines",
		"bug"
	]
	for key in required:
		if not level.has(key):
			return false

	if str(level.get("id", "")).strip_edges().is_empty():
		return false
	if str(level.get("bucket", "")).strip_edges().is_empty():
		return false
	if str(level.get("briefing", "")).strip_edges().is_empty():
		return false
	if not _is_numeric(level.get("expected_s", null)):
		return false
	if not _is_numeric(level.get("actual_s", null)):
		return false

	if typeof(level.get("code_lines", [])) != TYPE_ARRAY:
		return false
	var code_lines: Array = level.get("code_lines", [])
	if code_lines.is_empty():
		return false
	for code_line_var in code_lines:
		if typeof(code_line_var) != TYPE_STRING:
			return false
		if str(code_line_var).is_empty():
			return false

	var bug: Dictionary = level.get("bug", {})
	if typeof(bug) != TYPE_DICTIONARY:
		return false
	var correct_line_index := int(bug.get("correct_line_index", -1))
	if correct_line_index < 0 or correct_line_index >= code_lines.size():
		return false

	var fix_options: Array = bug.get("fix_options", [])
	if fix_options.size() != 3:
		return false

	var required_ids: Dictionary = {"A": true, "B": true, "C": true}
	var ids_seen: Dictionary = {}
	for fix_var in fix_options:
		if typeof(fix_var) != TYPE_DICTIONARY:
			return false
		var fix: Dictionary = fix_var
		var option_id := str(fix.get("option_id", "")).strip_edges().to_upper()
		if not required_ids.has(option_id):
			return false
		if ids_seen.has(option_id):
			return false
		if not fix.has("replace_line") or str(fix.get("replace_line", "")) == "":
			return false
		if not _is_numeric(fix.get("result_s", null)):
			return false
		ids_seen[option_id] = true

	var explain_short_raw: Variant = level.get("explain_short", [])
	if typeof(explain_short_raw) != TYPE_ARRAY:
		return false
	var explain_short: Array = explain_short_raw
	for line_var in explain_short:
		if typeof(line_var) != TYPE_STRING:
			return false

	var correct_option_id := str(bug.get("correct_option_id", "")).strip_edges().to_upper()
	return required_ids.has(correct_option_id) and ids_seen.has("A") and ids_seen.has("B") and ids_seen.has("C")

func _is_numeric(value: Variant) -> bool:
	var value_type := typeof(value)
	return value_type == TYPE_INT or value_type == TYPE_FLOAT

func build_variant_key(level: Dictionary) -> String:
	var bug: Dictionary = level.get("bug", {})
	var code_blob := "\n".join(level.get("code_lines", []))
	var fix_parts: Array[String] = []
	for fix_var in bug.get("fix_options", []):
		if typeof(fix_var) != TYPE_DICTIONARY:
			continue
		var fix: Dictionary = fix_var
		fix_parts.append("%s:%s:%s" % [
			str(fix.get("option_id", "")),
			str(fix.get("replace_line", "")),
			str(fix.get("result_s", ""))
		])
	fix_parts.sort()
	return "%s|exp:%s|act:%s|%s|line:%s|opts:%s" % [
		str(level.get("id", "")),
		str(level.get("expected_s", "")),
		str(level.get("actual_s", "")),
		code_blob,
		str(bug.get("correct_line_index", -1)),
		",".join(fix_parts)
	]

func _start_level(idx: int) -> void:
	if idx >= levels.size():
		idx = 0
	current_level_idx = idx
	current_task = (levels[idx] as Dictionary).duplicate(true)
	variant_hash = str(hash(build_variant_key(current_task)))
	task_started_ticks = Time.get_ticks_msec()
	paused_total_ms = 0
	pause_started_ticks = -1
	hint_open_ticks = 0
	hint_total_ms = 0
	selected_line_index = -1
	selected_option_id = ""
	misclicks_before_correct = 0
	wrong_fix_attempts_before_correct = 0
	has_selected_correct_line = false
	level_result_sent = false
	line_pick_armed = false
	last_scroll_vertical = -1
	state = State.LINE_SELECT

	task_session = {
		"task_id": str(current_task.get("id", "C-00")),
		"variant_hash": variant_hash,
		"started_at_ticks": task_started_ticks,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": [],
		"hint_total_ms": 0,
		"paused_total_ms": 0
	}

	lbl_clue_title.text = "ДЕЛО C: РАЗМИНИРОВАНИЕ"
	lbl_session.text = "СЕССИЯ: %s" % str(current_task.get("id", "C-00"))
	lbl_expected_value.text = "s = %s" % str(current_task.get("expected_s", "?"))
	lbl_actual_value.text = "s = %s" % str(current_task.get("actual_s", "?"))
	lbl_hint.text = "Нажмите на строку с ошибкой, затем выберите исправление."
	_update_misclick_label()

	btn_verify.disabled = true
	btn_next.visible = false
	diagnostics_blocker.visible = false
	diagnostics_panel.visible = false
	fix_menu.hide()
	_render_code()
	_set_actual_panel_error(true, false)
	_log_event("task_start", {"bucket": str(current_task.get("bucket", "unknown"))})

func _render_code(caret_line: int = 0) -> void:
	var base_lines: Array = current_task.get("code_lines", [])
	_set_code_lines(base_lines, caret_line)

func _set_code_lines(lines: Array, caret_line: int) -> void:
	suppress_caret_event = true
	code_view.text = "\n".join(lines)
	if lines.is_empty():
		code_view.set_caret_line(0)
	else:
		var safe_line: int = clampi(caret_line, 0, lines.size() - 1)
		code_view.set_caret_line(safe_line)
	code_view.set_caret_column(0)
	suppress_caret_event = false

func _get_fix_option(option_id: String) -> Dictionary:
	var normalized_option_id := option_id.strip_edges().to_upper()
	var fix_options: Array = current_task.get("bug", {}).get("fix_options", [])
	for fix_var in fix_options:
		if typeof(fix_var) != TYPE_DICTIONARY:
			continue
		var fix: Dictionary = fix_var
		if str(fix.get("option_id", "")).strip_edges().to_upper() == normalized_option_id:
			return fix
	return {}

func _apply_fix_preview() -> void:
	if selected_line_index < 0:
		return
	var base_lines: Array = current_task.get("code_lines", [])
	if selected_line_index >= base_lines.size():
		return
	var fix: Dictionary = _get_fix_option(selected_option_id)
	if fix.is_empty():
		return
	var preview_lines: Array = base_lines.duplicate()
	preview_lines[selected_line_index] = str(fix.get("replace_line", ""))
	_set_code_lines(preview_lines, selected_line_index)
	_update_line_highlight()

func _on_code_caret_changed() -> void:
	if suppress_caret_event:
		return
	if state == State.FEEDBACK_SUCCESS:
		return
	if not line_pick_armed:
		return
	line_pick_armed = false

	selected_line_index = code_view.get_caret_line()
	selected_option_id = ""
	btn_verify.disabled = true
	_render_code(selected_line_index)
	_log_event("line_clicked", {"line": selected_line_index})

	var correct_line := int(current_task.get("bug", {}).get("correct_line_index", -1))
	if selected_line_index == correct_line:
		has_selected_correct_line = true
	elif not has_selected_correct_line:
		misclicks_before_correct += 1
		_update_misclick_label()

	_update_line_highlight()
	_open_fix_menu()

func _on_code_gui_input(event: InputEvent) -> void:
	if state == State.FEEDBACK_SUCCESS:
		return
	if state == State.DIAGNOSTIC:
		return
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.pressed and mouse_event.button_index == MOUSE_BUTTON_LEFT:
			line_pick_armed = true
	elif event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			line_pick_armed = true

func _update_line_highlight(restart_animation: bool = true) -> void:
	if selected_line_index < 0:
		line_highlight.visible = false
		return

	var visible_line_index := selected_line_index - _get_scroll_vertical()
	line_highlight.position = Vector2(6, 6 + (visible_line_index * cached_line_height))
	line_highlight.size = Vector2(code_view.size.x - 12, float(cached_line_height))
	line_highlight.visible = true

	if restart_animation:
		if highlight_tween != null:
			highlight_tween.kill()
		highlight_tween = create_tween().set_loops()
		highlight_tween.tween_property(line_highlight, "modulate:a", 0.26, 0.28)
		highlight_tween.tween_property(line_highlight, "modulate:a", 0.12, 0.28)

func _get_scroll_vertical() -> int:
	if code_view.has_method("get_v_scroll"):
		return int(code_view.call("get_v_scroll"))
	if code_view.has_method("get_scroll_vertical"):
		return int(code_view.call("get_scroll_vertical"))
	for prop_var in code_view.get_property_list():
		if typeof(prop_var) != TYPE_DICTIONARY:
			continue
		var prop: Dictionary = prop_var
		var prop_name := str(prop.get("name", ""))
		if prop_name == "scroll_vertical" or prop_name == "v_scroll":
			return int(code_view.get(prop_name))
	return 0

func _process(_delta: float) -> void:
	if not line_highlight.visible:
		return
	var scroll_vertical := _get_scroll_vertical()
	if scroll_vertical != last_scroll_vertical:
		last_scroll_vertical = scroll_vertical
		_update_line_highlight(false)

func _open_fix_menu() -> void:
	if selected_line_index < 0:
		return

	var lines: Array = current_task.get("code_lines", [])
	var original_line := ""
	if selected_line_index >= 0 and selected_line_index < lines.size():
		original_line = str(lines[selected_line_index])

	fix_menu.call(
		"setup",
		selected_line_index + 1,
		original_line,
		current_task.get("bug", {}).get("fix_options", []),
		selected_option_id
	)
	state = State.FIX_MENU
	_log_event("fix_menu_open", {"line": selected_line_index})
	fix_menu.popup_centered_ratio(0.68)

func _on_fix_option_selected(option_id: String) -> void:
	selected_option_id = option_id.strip_edges().to_upper()
	_apply_fix_preview()
	_log_event("fix_selected", {"option_id": selected_option_id, "line": selected_line_index})

func _on_fix_apply_requested(option_id: String) -> void:
	selected_option_id = option_id.strip_edges().to_upper()
	btn_verify.disabled = selected_line_index < 0 or selected_option_id == ""
	_apply_fix_preview()
	lbl_hint.text = "Исправление применено. Нажмите ПРОВЕРИТЬ."
	state = State.READY_TO_VERIFY
	_log_event("fix_applied", {"option_id": selected_option_id, "line": selected_line_index})

func _on_fix_menu_canceled() -> void:
	if state != State.FEEDBACK_SUCCESS:
		selected_option_id = ""
		btn_verify.disabled = true
		if selected_line_index >= 0:
			_render_code(selected_line_index)
			_update_line_highlight()
		state = State.LINE_SELECT

func _on_verify_pressed() -> void:
	if btn_verify.disabled:
		return
	if selected_line_index < 0 or selected_option_id == "":
		return

	state = State.VERIFY
	_log_event("verify_pressed", {"line": selected_line_index, "option_id": selected_option_id})

	var bug: Dictionary = current_task.get("bug", {})
	var correct_line := int(bug.get("correct_line_index", -1))
	var correct_option := str(bug.get("correct_option_id", "")).strip_edges().to_upper()
	var is_correct := (selected_line_index == correct_line and selected_option_id == correct_option)
	var effective_time_ms := _effective_elapsed_ms(Time.get_ticks_msec())
	var paused_ms_snapshot := paused_total_ms
	var hint_ms_snapshot := hint_total_ms

	if selected_line_index == correct_line and selected_option_id != correct_option:
		wrong_fix_attempts_before_correct += 1

	var attempt := {
		"kind": "debugging",
		"level_id": str(current_task.get("id", "C-00")),
		"task_id": str(current_task.get("id", "C-00")),
		"variant_hash": variant_hash,
		"selected_line_index": selected_line_index,
		"fix_option_id": selected_option_id,
		"correct": is_correct,
		"effective_time_ms": effective_time_ms,
		"paused_total_ms": paused_ms_snapshot,
		"hint_total_ms": hint_ms_snapshot,
		"misclicks_before_correct": misclicks_before_correct,
		"wrong_fix_attempts_before_correct": wrong_fix_attempts_before_correct
	}
	(task_session["attempts"] as Array).append(attempt)

	if is_correct:
		_handle_success()
	else:
		_handle_fail(correct_line)

func _handle_success() -> void:
	state = State.FEEDBACK_SUCCESS
	lbl_actual_value.text = "s = %s" % str(current_task.get("expected_s", "?"))
	lbl_hint.text = "ДОСТУП РАЗРЕШЁН"
	btn_verify.disabled = true
	btn_next.visible = true
	_set_actual_panel_error(false)
	_register_result(true)

func _handle_fail(correct_line: int) -> void:
	state = State.FEEDBACK_FAIL
	_set_actual_panel_error(true)

	var selected_result: Variant = _get_selected_fix_result()
	if selected_line_index == correct_line and selected_result != null:
		lbl_actual_value.text = "s = %s" % str(selected_result)
		lbl_hint.text = "Неверное исправление: результат не совпадает."
	else:
		lbl_hint.text = "Выбрана неверная строка."

func _set_actual_panel_error(is_error: bool, pulse: bool = true) -> void:
	if is_error:
		actual_panel.modulate = Color(0.78, 0.78, 0.76, 1.0)
		if pulse:
			var tw := create_tween()
			tw.tween_property(actual_panel, "modulate", Color(0.9, 0.9, 0.88, 1.0), 0.12)
			tw.tween_property(actual_panel, "modulate", Color(0.78, 0.78, 0.76, 1.0), 0.14)
			tw.tween_property(actual_panel, "modulate", Color(0.9, 0.9, 0.88, 1.0), 0.14)
			tw.tween_property(actual_panel, "modulate", Color(0.78, 0.78, 0.76, 1.0), 0.16)
	else:
		actual_panel.modulate = Color(0.92, 0.92, 0.9, 1.0)

func _get_selected_fix_result() -> Variant:
	var fix_options: Array = current_task.get("bug", {}).get("fix_options", [])
	var normalized_option_id := selected_option_id.strip_edges().to_upper()
	for fix_var in fix_options:
		if typeof(fix_var) != TYPE_DICTIONARY:
			continue
		var fix: Dictionary = fix_var
		if str(fix.get("option_id", "")).strip_edges().to_upper() == normalized_option_id:
			return fix.get("result_s", null)
	return null

func _on_analyze_pressed() -> void:
	if diagnostics_panel.visible:
		return
	var analysis_lines: Array = []
	analysis_lines.append("Ожидаемое: s=%s" % str(current_task.get("expected_s", "?")))
	analysis_lines.append("Фактическое: s=%s" % str(current_task.get("actual_s", "?")))
	if selected_line_index >= 0:
		analysis_lines.append("Выбранная строка: %d" % (selected_line_index + 1))
	if selected_option_id != "":
		var fix_result: Variant = _get_selected_fix_result()
		var fix_line := ""
		var fix: Dictionary = _get_fix_option(selected_option_id)
		if not fix.is_empty():
			fix_line = str(fix.get("replace_line", ""))
		analysis_lines.append("Ваш вариант: %s -> s=%s" % [selected_option_id, str(fix_result)])
		if fix_line != "":
			analysis_lines.append("Заменить на: %s" % fix_line)
	analysis_lines.append("")
	for line_var in current_task.get("explain_short", []):
		analysis_lines.append(str(line_var))
	diagnostics_panel.call("setup", "ДИАГНОСТИКА: %s" % str(current_task.get("id", "C-00")), analysis_lines)
	diagnostics_panel.visible = true

func _on_diagnostics_visibility_changed() -> void:
	if diagnostics_panel.visible:
		diagnostics_blocker.visible = true
		if pause_started_ticks == -1 and hint_open_ticks == 0:
			hint_open_ticks = Time.get_ticks_msec()
		_log_event("analyze_open", {})
		state = State.DIAGNOSTIC
	else:
		diagnostics_blocker.visible = false
		if hint_open_ticks > 0:
			var delta := Time.get_ticks_msec() - hint_open_ticks
			hint_total_ms += delta
			task_session["hint_total_ms"] = hint_total_ms
			_log_event("analyze_close", {"duration_ms": delta})
			hint_open_ticks = 0
		if state != State.FEEDBACK_SUCCESS:
			state = State.LINE_SELECT

func _notification(what: int) -> void:
	if task_started_ticks <= 0:
		return

	if what == MainLoop.NOTIFICATION_APPLICATION_PAUSED:
		_on_app_paused()
	elif what == MainLoop.NOTIFICATION_APPLICATION_RESUMED:
		_on_app_resumed()

func _on_app_paused() -> void:
	# Debounce duplicate pause callbacks on some Android devices.
	if pause_started_ticks != -1:
		return

	var now_ticks := Time.get_ticks_msec()
	pause_started_ticks = now_ticks

	# If diagnostics is open, stop hint timer before pause window.
	if hint_open_ticks > 0:
		hint_total_ms += maxi(0, now_ticks - hint_open_ticks)
		task_session["hint_total_ms"] = hint_total_ms
		hint_open_ticks = 0

	_log_event("app_paused", {})

func _on_app_resumed() -> void:
	# Debounce duplicate resume callbacks.
	if pause_started_ticks == -1:
		return

	var now_ticks := Time.get_ticks_msec()
	var pause_delta := maxi(0, now_ticks - pause_started_ticks)
	paused_total_ms += pause_delta
	pause_started_ticks = -1
	task_session["paused_total_ms"] = paused_total_ms

	# If diagnostics is still visible, resume hint timer from now.
	if diagnostics_panel.visible:
		hint_open_ticks = now_ticks

	_log_event("app_resumed", {"paused_ms": pause_delta})

func _on_next_pressed() -> void:
	_log_event("task_end", {"status": "next_pressed"})
	_start_level(current_level_idx + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _register_result(is_correct: bool) -> void:
	if level_result_sent:
		return
	level_result_sent = true
	var end_ticks := Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_ticks
	task_session["hint_total_ms"] = hint_total_ms
	task_session["paused_total_ms"] = paused_total_ms
	task_session["is_correct"] = is_correct
	_log_event("task_end", {"status": "complete", "is_correct": is_correct})

	var elapsed_ms := _effective_elapsed_ms(end_ticks)
	var payload := {
		"match_key": "DISARM_C|%s" % str(current_task.get("id", "C-00")),
		"is_correct": is_correct,
		"is_fit": is_correct,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"task_id": str(current_task.get("id", "C-00")),
		"variant_hash": variant_hash,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _effective_elapsed_ms(now_ticks: int) -> int:
	var paused_ms := paused_total_ms
	if pause_started_ticks != -1:
		paused_ms += maxi(0, now_ticks - pause_started_ticks)

	var hint_ms := hint_total_ms
	if hint_open_ticks > 0:
		hint_ms += maxi(0, now_ticks - hint_open_ticks)

	return maxi(0, (now_ticks - task_started_ticks) - paused_ms - hint_ms)

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": _effective_elapsed_ms(Time.get_ticks_msec()),
		"payload": payload
	})
	task_session["events"] = events

func _update_misclick_label() -> void:
	lbl_misclicks.text = "ПРОМАХИ: %d" % misclicks_before_correct
</file>

<file path="scripts/RestoreQuestB.gd">
extends Control

const LEVELS_PATH := "res://data/quest_b_levels.json"
const CODE_BLOCK_SCENE := preload("res://scripts/ui/CodeBlock.gd")
const MAX_ATTEMPTS := 3

const AUDIO_CLICK := preload("res://audio/click.wav")
const AUDIO_ERROR := preload("res://audio/error.wav")
const AUDIO_RELAY := preload("res://audio/relay.wav")

enum State {
	INIT,
	SOLVING_EMPTY,
	SOLVING_FILLED,
	SUBMITTING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	DIAGNOSTIC,
	SAFE_MODE
}

@onready var lbl_clue_title: Label = $SafeArea/MainLayout/Header/LblClueTitle
@onready var lbl_session: Label = $SafeArea/MainLayout/Header/LblSessionId
@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack
@onready var decrypt_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/DecryptBar
@onready var energy_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/EnergyBar
@onready var lbl_target: Label = $SafeArea/MainLayout/TargetDisplay/LblTarget
@onready var code_display: RichTextLabel = $SafeArea/MainLayout/TerminalFrame/CodeScroll/CodeDisplay
@onready var drop_zone: PanelContainer = $SafeArea/MainLayout/SlotRow/DropZone
@onready var lbl_slot_hint: Label = $SafeArea/MainLayout/SlotRow/LblSlotHint
@onready var blocks_container: HBoxContainer = $SafeArea/MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/BlocksContainer
@onready var btn_analyze: Button = $SafeArea/MainLayout/Actions/BtnAnalyze
@onready var btn_submit: Button = $SafeArea/MainLayout/Actions/BtnSubmit
@onready var btn_next: Button = $SafeArea/MainLayout/Actions/BtnNext
@onready var diagnostics_blocker: ColorRect = $DiagnosticsBlocker
@onready var diag_panel: PanelContainer = $DiagnosticsPanelB

var levels: Array = []
var current_level_idx := 0
var current_task: Dictionary = {}
var state: State = State.INIT
var energy := 100.0
var wrong_count := 0
var task_started_at := 0
var t_start_ticks := 0
var paused_total_ms := 0
var pause_started_ticks := -1
var hint_total_ms := 0
var hint_open_time := 0
var switches_before_submit := 0
var is_safe_mode := false
var variant_hash := ""
var level_result_sent := false
var task_session: Dictionary = {}

func _ready() -> void:
	_load_levels_from_json()
	_connect_signals()

	diag_panel.mouse_filter = Control.MOUSE_FILTER_STOP
	diagnostics_blocker.mouse_filter = Control.MOUSE_FILTER_STOP
	diagnostics_blocker.visible = false
	diag_panel.visible = false

	current_level_idx = GlobalMetrics.current_level_index
	if current_level_idx < 0 or current_level_idx >= levels.size():
		current_level_idx = 0

	_start_level(current_level_idx)

func _load_levels_from_json() -> void:
	levels.clear()
	if not FileAccess.file_exists(LEVELS_PATH):
		push_error("Levels file not found: " + LEVELS_PATH)
		return

	var file := FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		push_error("Unable to open levels file: " + LEVELS_PATH)
		return

	var json := JSON.new()
	if json.parse(file.get_as_text()) != OK:
		push_error("JSON parse error in quest_b_levels.json: " + json.get_error_message())
		return

	if typeof(json.data) != TYPE_ARRAY:
		push_error("quest_b_levels.json root must be an array.")
		return

	for raw_level in json.data:
		if typeof(raw_level) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = raw_level
		if _validate_level(level):
			levels.append(level)
		else:
			push_warning("Skipping invalid RestoreQuestB level: " + str(level.get("id", "UNKNOWN")))

func _validate_level(level: Dictionary) -> bool:
	var slot: Dictionary = level.get("slot", {})
	var blocks: Array = level.get("blocks", [])
	var slot_type: String = str(slot.get("slot_type", ""))
	if slot_type != "INT" and slot_type != "OP":
		return false
	if blocks.is_empty():
		return false

	var has_correct := false
	var correct_id := str(level.get("correct_block_id", ""))
	for b in blocks:
		if typeof(b) != TYPE_DICTIONARY:
			return false
		var block: Dictionary = b
		if str(block.get("slot_type", "")) != slot_type:
			return false
		if str(block.get("block_id", "")) == correct_id:
			has_correct = true
	return has_correct

func _connect_signals() -> void:
	drop_zone.block_dropped.connect(_on_block_dropped)
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	diag_panel.visibility_changed.connect(_on_diag_visibility_changed)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func build_variant_key(task: Dictionary) -> String:
	var code: String = "\n".join(task.get("code_template", []))
	var target := str(task.get("target_s", ""))
	var slot: Dictionary = task.get("slot", {})
	var slot_type := str(slot.get("slot_type", ""))
	var ids: Array[String] = []
	for b in task.get("blocks", []):
		if typeof(b) == TYPE_DICTIONARY:
			ids.append(str((b as Dictionary).get("block_id", "")))
	ids.sort()
	return "%s|%s|%s|%s|%s" % [str(task.get("id", "")), code, target, slot_type, ",".join(ids)]

func _start_level(idx: int) -> void:
	if levels.is_empty():
		return
	if idx >= levels.size():
		idx = 0

	current_level_idx = idx
	current_task = (levels[idx] as Dictionary).duplicate(true)
	variant_hash = str(hash(build_variant_key(current_task)))
	t_start_ticks = Time.get_ticks_msec()
	task_started_at = t_start_ticks
	paused_total_ms = 0
	pause_started_ticks = -1
	level_result_sent = false

	task_session = {
		"task_id": str(current_task.get("id", "B-00")),
		"variant_hash": variant_hash,
		"started_at_ticks": t_start_ticks,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": [],
		"hint_total_ms": 0,
		"paused_total_ms": 0
	}

	state = State.SOLVING_EMPTY
	energy = 100.0
	wrong_count = 0
	hint_total_ms = 0
	hint_open_time = 0
	switches_before_submit = 0
	is_safe_mode = false

	lbl_clue_title.text = "ВОССТАНОВЛЕНИЕ " + str(current_task.get("id", "B-00"))
	lbl_session.text = "СЕСС " + str(randi() % 9000 + 1000)
	lbl_target.text = "ЦЕЛЬ: s = " + str(current_task.get("target_s", "?"))
	lbl_slot_hint.text = "<-- Перетащите блок сюда"

	_render_code()
	_render_inventory()
	drop_zone.call("setup", str(current_task.get("slot", {}).get("slot_type", "INT")))
	drop_zone.modulate = Color(1, 1, 1, 1)

	btn_submit.disabled = true
	btn_analyze.disabled = false
	btn_next.visible = false
	energy_bar.value = energy

	diagnostics_blocker.visible = false
	diag_panel.visible = false

	_log_event("task_start", {"bucket": str(current_task.get("bucket", "unknown"))})

func _render_code() -> void:
	var txt := ""
	for line in current_task.get("code_template", []):
		var processed := str(line).replace("[SLOT]", "[color=#EDECE8][SLOT][/color]")
		txt += processed + "\n"
	code_display.text = txt

func _render_inventory() -> void:
	for child in blocks_container.get_children():
		child.queue_free()

	for b_data in current_task.get("blocks", []):
		if typeof(b_data) != TYPE_DICTIONARY:
			continue
		var btn := Button.new()
		btn.set_script(CODE_BLOCK_SCENE)
		btn.call("setup", b_data)
		btn.custom_minimum_size = Vector2(160, 80)
		blocks_container.add_child(btn)

func _on_block_dropped(data: Dictionary) -> void:
	_play_sound(AUDIO_CLICK)

	var prev_id: Variant = drop_zone.call("get_last_prev_block_id")
	var new_id: Variant = data.get("block_id", null)
	if prev_id != null and new_id != null and str(prev_id) != str(new_id):
		switches_before_submit += 1

	state = State.SOLVING_FILLED
	btn_submit.disabled = false
	lbl_slot_hint.text = "Готово к проверке."

	_log_event("slot_changed", {"prev": prev_id, "new": new_id})

func _on_submit_pressed() -> void:
	if state != State.SOLVING_FILLED:
		return

	state = State.SUBMITTING
	btn_submit.disabled = true

	var selected_id: Variant = drop_zone.call("get_block_id")
	var correct_id: Variant = current_task.get("correct_block_id", null)
	var is_correct := str(selected_id) == str(correct_id)
	var end_ticks := Time.get_ticks_msec()
	var elapsed_input_ms := _effective_elapsed_ms(end_ticks)
	var is_terminal_fail := (not is_correct) and (wrong_count + 1 >= MAX_ATTEMPTS)
	var state_after := "FEEDBACK_SUCCESS" if is_correct else ("SAFE_MODE" if is_terminal_fail else "FEEDBACK_FAIL")

	var attempt := {
		"kind": "block_selection",
		"selected_block_id": selected_id,
		"correct_block_id": correct_id,
		"switches_before_submit": switches_before_submit,
		"duration_input_ms": elapsed_input_ms,
		"duration_input_ms_excluding_hint": elapsed_input_ms,
		"hint_open_at_submit": diag_panel.visible,
		"correct": is_correct,
		"state_after": state_after
	}
	(task_session["attempts"] as Array).append(attempt)
	_log_event("submit_pressed", {"correct": is_correct, "selected": selected_id})

	if is_correct:
		_handle_success(end_ticks)
	elif is_terminal_fail:
		wrong_count += 1
		_handle_fail_terminal(end_ticks)
	else:
		wrong_count += 1
		_handle_fail_retry(selected_id)

func _handle_success(end_ticks: int) -> void:
	state = State.FEEDBACK_SUCCESS
	_play_sound(AUDIO_RELAY)
	drop_zone.modulate = Color(0.96, 0.96, 0.94, 1.0)
	decrypt_bar.value += float(current_task.get("economy", {}).get("reward", 0))
	btn_analyze.disabled = true
	btn_submit.disabled = true
	btn_next.visible = true
	_register_result(true, end_ticks, "SUCCESS")

func _handle_fail_retry(selected_id) -> void:
	state = State.FEEDBACK_FAIL
	_play_sound(AUDIO_ERROR)
	energy = maxf(0.0, energy - float(current_task.get("economy", {}).get("wrong_penalty", 0)))
	energy_bar.value = energy
	drop_zone.call("reset")
	drop_zone.modulate = Color(0.88, 0.88, 0.86, 1.0)
	lbl_slot_hint.text = "Неверно. Попробуйте снова."
	state = State.SOLVING_EMPTY
	btn_submit.disabled = true
	_show_distractor_feedback(selected_id)

func _handle_fail_terminal(end_ticks: int) -> void:
	_play_sound(AUDIO_ERROR)
	energy = maxf(0.0, energy - float(current_task.get("economy", {}).get("wrong_penalty", 0)))
	energy_bar.value = energy
	_trigger_safe_mode(end_ticks)

func _trigger_safe_mode(end_ticks: int) -> void:
	state = State.SAFE_MODE
	is_safe_mode = true
	_on_analyze_pressed(true)
	btn_analyze.disabled = true
	btn_submit.disabled = true
	btn_next.visible = true
	_log_event("safe_mode_triggered", {})
	_register_result(false, end_ticks, "SAFE_MODE")

func _on_analyze_pressed(free := false) -> void:
	if diag_panel.visible:
		return

	if not free:
		var cost := int(current_task.get("economy", {}).get("analyze_cost", 0))
		if energy < float(cost):
			_play_sound(AUDIO_ERROR)
			return
		energy -= float(cost)
		energy_bar.value = energy

	diag_panel.call(
		"setup",
		current_task.get("explain_short", []),
		current_task.get("trace_correct", [])
	)
	diag_panel.visible = true

func _on_diag_visibility_changed() -> void:
	if diag_panel.visible:
		diagnostics_blocker.visible = true
		if pause_started_ticks == -1:
			hint_open_time = Time.get_ticks_msec()
		_log_event("analyze_open", {})
	else:
		diagnostics_blocker.visible = false
		var duration := _consume_open_hint_duration(Time.get_ticks_msec())
		if duration > 0:
			_log_event("analyze_close", {"duration_ms": duration})

func _notification(what: int) -> void:
	if t_start_ticks <= 0:
		return
	if what == MainLoop.NOTIFICATION_APPLICATION_PAUSED:
		_on_app_paused()
	elif what == MainLoop.NOTIFICATION_APPLICATION_RESUMED:
		_on_app_resumed()

func _on_app_paused() -> void:
	if pause_started_ticks != -1:
		return
	var now_ticks := Time.get_ticks_msec()
	pause_started_ticks = now_ticks
	_consume_open_hint_duration(now_ticks)
	_log_event("app_paused", {})

func _on_app_resumed() -> void:
	if pause_started_ticks == -1:
		return
	var now_ticks := Time.get_ticks_msec()
	var paused_ms := maxi(0, now_ticks - pause_started_ticks)
	paused_total_ms += paused_ms
	pause_started_ticks = -1
	task_session["paused_total_ms"] = paused_total_ms
	if diag_panel.visible:
		hint_open_time = now_ticks
	_log_event("app_resumed", {"paused_ms": paused_ms})

func _on_next_pressed() -> void:
	if diag_panel.visible:
		diag_panel.visible = false
	_log_event("next_pressed", {"from_task": str(current_task.get("id", "B-00"))})
	_start_level(current_level_idx + 1)

func _register_result(is_correct: bool, end_ticks: int, reason: String) -> void:
	if level_result_sent:
		return
	level_result_sent = true

	var elapsed_ms := _effective_elapsed_ms(end_ticks)
	task_session["ended_at_ticks"] = end_ticks
	task_session["hint_total_ms"] = hint_total_ms
	task_session["paused_total_ms"] = paused_total_ms
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	var payload := {
		"match_key": "RESTORE_B|%s" % str(current_task.get("id", "B-00")),
		"is_correct": is_correct,
		"is_fit": is_correct,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"task_id": str(current_task.get("id", "B-00")),
		"variant_hash": variant_hash,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": _effective_elapsed_ms(Time.get_ticks_msec()),
		"payload": payload
	})
	task_session["events"] = events

func _effective_elapsed_ms(now_ticks: int) -> int:
	return maxi(0, (now_ticks - t_start_ticks) - paused_total_ms - hint_total_ms)

func _consume_open_hint_duration(until_ticks: int) -> int:
	if hint_open_time <= 0:
		return 0
	var duration := maxi(0, until_ticks - hint_open_time)
	hint_total_ms += duration
	task_session["hint_total_ms"] = hint_total_ms
	hint_open_time = 0
	return duration

func _show_distractor_feedback(selected_id) -> void:
	var map: Variant = current_task.get("distractor_feedback", {})
	if typeof(map) != TYPE_DICTIONARY:
		return
	var key := str(selected_id)
	if not map.has(key):
		return
	var feedback: Variant = map[key]
	if typeof(feedback) != TYPE_DICTIONARY:
		return

	var s_final = str((feedback as Dictionary).get("s_final", "?"))
	var hint = str((feedback as Dictionary).get("hint", ""))
	var target = str(current_task.get("target_s", "?"))
	var explain_lines := [
		"Получилось s=%s, нужно s=%s." % [s_final, target],
		hint
	]
	diag_panel.call("setup", explain_lines, [])
	diag_panel.visible = true
	_log_event("distractor_feedback_shown", {"selected": key, "s_final": s_final})

func _play_sound(stream: AudioStream) -> void:
	var player := AudioStreamPlayer.new()
	player.stream = stream
	add_child(player)
	player.play()
	player.finished.connect(player.queue_free)
</file>

<file path="scripts/SuspectQuestA.gd">
extends Control

const THEME_NOIR: Theme = preload("res://ui/theme_noir_pencil.tres")

const AUDIO_CLICK: AudioStream = preload("res://audio/click.wav")
const AUDIO_ERROR: AudioStream = preload("res://audio/error.wav")
const AUDIO_RELAY: AudioStream = preload("res://audio/relay.wav")

const LEVELS_PATH := "res://data/suspect_a_levels.json"
const MAX_ATTEMPTS := 3
const PALETTE_ID_NOIR := 0
const FX_ID_LOW := 0
const FX_ID_HIGH := 1

const STATUS_COLOR_NEUTRAL := Color(0.72, 0.72, 0.7)
const STATUS_COLOR_READY := Color(0.93, 0.93, 0.91)
const STATUS_COLOR_FAIL := Color(0.82, 0.82, 0.8)
const STATUS_COLOR_WARN := Color(0.78, 0.78, 0.76)
const STATUS_COLOR_SUCCESS := Color(0.97, 0.97, 0.95)

enum State {
	INIT,
	BRIEFING,
	SOLVING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	SAFE_MODE,
	DIAGNOSTIC
}

@export_enum("noir") var terminal_palette: String = "noir"
@export_enum("low", "high") var fx_quality: String = "low"
@export var typewriter_delay_sec: float = 0.03

@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var noir_overlay: CanvasLayer = $NoirOverlay
@onready var code_label: RichTextLabel = $SafeArea/MainLayout/TerminalFrame/ScrollContainer/CodeLabel
@onready var code_scroll: ScrollContainer = $SafeArea/MainLayout/TerminalFrame/ScrollContainer
@onready var input_display: Label = $SafeArea/MainLayout/InputFrame/InputDisplay
@onready var lbl_status: Label = $SafeArea/MainLayout/StatusRow/LblStatus
@onready var lbl_attempts: Label = $SafeArea/MainLayout/StatusRow/LblAttempts
@onready var decrypt_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/DecryptBar
@onready var energy_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/EnergyBar
@onready var diag_panel: PanelContainer = $DiagnosticsPanel
@onready var diag_trace: RichTextLabel = $DiagnosticsPanel/VBoxContainer/TraceList
@onready var diag_explain: RichTextLabel = $DiagnosticsPanel/VBoxContainer/ExplainList
@onready var btn_enter: Button = $SafeArea/MainLayout/Actions/BtnEnter
@onready var btn_analyze: Button = $SafeArea/MainLayout/Actions/BtnAnalyze
@onready var btn_next: Button = $SafeArea/MainLayout/Actions/BtnNext
@onready var btn_close_diag: Button = $DiagnosticsPanel/VBoxContainer/BtnCloseDiag
@onready var btn_quest_back: Button = $SafeArea/MainLayout/Header/BtnQuestBack
@onready var lbl_clue_title: Label = $SafeArea/MainLayout/Header/LblClueTitle
@onready var lbl_session: Label = $SafeArea/MainLayout/Header/LblSessionId
@onready var palette_select: OptionButton = $SafeArea/MainLayout/SettingsRow/PaletteSelect
@onready var fx_select: OptionButton = $SafeArea/MainLayout/SettingsRow/FxSelect
@onready var numpad: GridContainer = $SafeArea/MainLayout/Numpad

var levels: Array = []
var current_level_idx := 0
var current_task: Dictionary = {}
var user_input := ""
var state: State = State.INIT
var energy := 100.0
var wrong_count := 0
var task_started_at := 0
var task_finished := false
var task_result_sent := false
var is_safe_mode := false
var is_code_ready := false
var variant_hash := ""
var task_session: Dictionary = {}

var sfx_player: AudioStreamPlayer

func _ready() -> void:
	_setup_runtime_controls()
	_apply_theme()
	_configure_overlay_shader()
	_init_audio_player()
	_connect_signals()
	_apply_mobile_min_sizes()

	if not _load_levels_from_json():
		_show_boot_error("Не удалось загрузить уровни подозреваемых.")
		return

	if levels.size() != 18:
		push_warning("Suspect levels expected 18, got %d" % levels.size())

	GlobalMetrics.current_level_index = 0
	_load_level(0)

func _apply_theme() -> void:
	theme = THEME_NOIR

func _setup_runtime_controls() -> void:
	palette_select.clear()
	palette_select.add_item("NOIR", PALETTE_ID_NOIR)
	palette_select.select(PALETTE_ID_NOIR)
	palette_select.disabled = true

	fx_select.clear()
	fx_select.add_item("НИЗКИЙ", FX_ID_LOW)
	fx_select.add_item("ВЫСОКИЙ", FX_ID_HIGH)
	fx_select.select(FX_ID_HIGH if fx_quality == "high" else FX_ID_LOW)

	palette_select.item_selected.connect(_on_palette_selected)
	fx_select.item_selected.connect(_on_fx_selected)

func _configure_overlay_shader() -> void:
	var crt_overlay := noir_overlay.get_node("CRT_Overlay") as ColorRect
	if crt_overlay == null:
		return
	var shader_mat := crt_overlay.material as ShaderMaterial
	if shader_mat == null:
		return
	var high_fx := fx_quality == "high"
	shader_mat.set_shader_parameter("fx_quality", 1 if high_fx else 0)
	shader_mat.set_shader_parameter("intensity", 0.34)
	shader_mat.set_shader_parameter("grain_strength", 0.35 if high_fx else 0.24)
	shader_mat.set_shader_parameter("hatch_strength", 0.30 if high_fx else 0.08)
	shader_mat.set_shader_parameter("vignette_strength", 0.45)
	shader_mat.set_shader_parameter("pulse", 0.0)
	shader_mat.set_shader_parameter("jitter_strength", 0.0)

func _init_audio_player() -> void:
	sfx_player = AudioStreamPlayer.new()
	sfx_player.name = "SfxPlayer"
	add_child(sfx_player)

func _connect_signals() -> void:
	for btn in numpad.get_children():
		if btn is Button:
			(btn as Button).pressed.connect(_on_numpad_pressed.bind(btn))

	btn_enter.pressed.connect(_on_enter_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	btn_close_diag.pressed.connect(_on_close_diag_pressed)
	btn_quest_back.pressed.connect(_on_back_pressed)

func _on_palette_selected(index: int) -> void:
	palette_select.get_item_id(index)
	terminal_palette = "noir"
	_apply_theme()
	_configure_overlay_shader()

func _on_fx_selected(index: int) -> void:
	var item_id: int = fx_select.get_item_id(index)
	fx_quality = "high" if item_id == FX_ID_HIGH else "low"
	_configure_overlay_shader()

func _apply_mobile_min_sizes() -> void:
	palette_select.custom_minimum_size = Vector2(120, 44)
	fx_select.custom_minimum_size = Vector2(110, 44)
	for btn in numpad.get_children():
		if btn is Button:
			(btn as Button).custom_minimum_size = Vector2(64, 64)
	btn_enter.custom_minimum_size = Vector2(0, 56)
	btn_analyze.custom_minimum_size = Vector2(0, 56)
	btn_next.custom_minimum_size = Vector2(0, 56)

func _load_levels_from_json() -> bool:
	var f := FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if f == null:
		push_error("Cannot open %s" % LEVELS_PATH)
		return false

	var parsed = JSON.parse_string(f.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		push_error("%s is not an array" % LEVELS_PATH)
		return false

	var loaded_levels: Array = parsed
	var valid_levels: Array = []
	for item in loaded_levels:
		if typeof(item) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = item
		if _validate_level(level):
			valid_levels.append(level)
		else:
			push_error("Invalid suspect level: %s" % str(level.get("id", "UNKNOWN")))

	levels = valid_levels
	return levels.size() > 0

func _validate_level(level: Dictionary) -> bool:
	var required_keys := ["id", "bucket", "briefing", "code", "expected", "trace", "explain", "economy"]
	for key in required_keys:
		if not level.has(key):
			return false

	if typeof(level.get("code")) != TYPE_ARRAY:
		return false
	if typeof(level.get("trace")) != TYPE_ARRAY:
		return false
	if typeof(level.get("explain")) != TYPE_ARRAY:
		return false
	if typeof(level.get("economy")) != TYPE_DICTIONARY:
		return false

	var trace: Array = level.get("trace", [])
	if trace.is_empty():
		return false

	for step in trace:
		if typeof(step) != TYPE_DICTIONARY:
			return false
		var d: Dictionary = step
		if not d.has("i") or not d.has("cond") or not d.has("s_before") or not d.has("s_after"):
			return false

	return true

func _show_boot_error(text: String) -> void:
	lbl_status.text = text
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_FAIL)
	btn_enter.disabled = true
	btn_analyze.disabled = true
	btn_next.disabled = true

func _load_level(idx: int) -> void:
	if levels.is_empty():
		return

	if idx >= levels.size():
		idx = 0
	current_level_idx = idx

	current_task = (levels[idx] as Dictionary).duplicate(true)
	variant_hash = str(hash(JSON.stringify(current_task)))
	task_started_at = Time.get_ticks_msec()

	task_session = {
		"task_id": str(current_task.get("id", "A-00")),
		"variant_hash": variant_hash,
		"started_at_ticks": task_started_at,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	state = State.BRIEFING
	wrong_count = 0
	energy = 100.0
	user_input = ""
	is_safe_mode = false
	is_code_ready = false
	task_finished = false
	task_result_sent = false

	lbl_clue_title.text = "УЛИКА #%s" % str(current_task.get("id", "A-00"))
	lbl_session.text = "СЕСС %04d" % (randi() % 10000)
	lbl_status.text = "ДЕШИФРОВКА..."
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_NEUTRAL)
	lbl_attempts.text = "ОШ: 0/%d" % MAX_ATTEMPTS
	decrypt_bar.value = float(current_level_idx) / maxf(1.0, float(levels.size() - 1)) * 100.0
	energy_bar.value = energy

	btn_enter.disabled = true
	btn_analyze.disabled = true
	btn_next.visible = false
	diag_panel.visible = false

	_update_input_display()
	_log_event("task_start", {"bucket": str(current_task.get("bucket", "unknown"))})

	var briefing := str(current_task.get("briefing", ""))
	code_label.text = "[color=#7A7A7A]%s[/color]\n\n" % briefing
	await _typewrite_code(current_task.get("code", []))

	is_code_ready = true
	state = State.SOLVING
	btn_enter.disabled = false
	btn_analyze.disabled = false
	lbl_status.text = "ВВОД ГОТОВ"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_READY)

func _typewrite_code(lines: Array) -> void:
	for line_variant in lines:
		var line := str(line_variant)
		code_label.append_text("[code]%s[/code]\n" % line)
		code_scroll.scroll_vertical = 1000000
		await get_tree().create_timer(typewriter_delay_sec).timeout
	_log_event("code_shown", {"line_count": lines.size()})

func _on_numpad_pressed(btn_node: Node) -> void:
	if state != State.SOLVING or not is_code_ready or task_finished:
		return

	var btn := btn_node as Button
	if btn == null:
		return

	_play_sfx(AUDIO_CLICK)
	var char := btn.text
	if char == "CLR" or char == "СБР":
		user_input = ""
	elif char == "<-":
		if user_input.length() > 0:
			user_input = user_input.left(user_input.length() - 1)
	elif user_input.length() < 4:
		user_input += char

	_update_input_display()

func _update_input_display() -> void:
	input_display.text = "----" if user_input.is_empty() else user_input

func _normalize(raw: String) -> Dictionary:
	var stripped := raw.strip_edges().replace(" ", "")
	if stripped.is_empty():
		return {"ok": false, "error": "EMPTY"}
	if not stripped.is_valid_int():
		return {"ok": false, "error": "NAN"}
	var value := int(stripped)
	if value < 0 or value > 9999:
		return {"ok": false, "error": "RANGE"}
	return {"ok": true, "val": value, "str": str(value)}

func _on_enter_pressed() -> void:
	if state != State.SOLVING or not is_code_ready or task_finished:
		return

	var now := Time.get_ticks_msec()
	var normalized := _normalize(user_input)
	if not bool(normalized.get("ok", false)):
		_play_sfx(AUDIO_ERROR)
		_trigger_glitch()
		_shake_screen()
		lbl_status.text = "НЕКОРРЕКТНЫЙ ВВОД"
		lbl_status.add_theme_color_override("font_color", STATUS_COLOR_FAIL)
		task_session["attempts"].append({
			"kind": "numpad",
			"raw": user_input,
			"norm": "",
			"duration_input_ms": now - task_started_at,
			"correct": false,
			"parse_error": str(normalized.get("error", "UNKNOWN")),
			"state_after": "INVALID_INPUT",
			"energy_after": energy,
			"wrong_count_after": wrong_count
		})
		return

	var expected := int(current_task.get("expected", 0))
	var is_correct := int(normalized.get("val", -1)) == expected
	var state_after := "SOLVING"

	if is_correct:
		_handle_success_feedback()
		state_after = "FEEDBACK_SUCCESS"
	else:
		_handle_fail_feedback()
		if is_safe_mode:
			state_after = "SAFE_MODE"
		elif state == State.FEEDBACK_FAIL:
			state_after = "FEEDBACK_FAIL"

	var attempt := {
		"kind": "numpad",
		"raw": user_input,
		"norm": str(normalized.get("str", "")),
		"duration_input_ms": now - task_started_at,
		"hint_open_at_enter": diag_panel.visible,
		"correct": is_correct,
		"state_after": state_after,
		"energy_after": energy,
		"wrong_count_after": wrong_count
	}
	task_session["attempts"].append(attempt)

	if is_correct:
		_finalize_task_result(true, "SUCCESS")
	elif is_safe_mode:
		_finalize_task_result(false, "SAFE_MODE")

	if not is_correct and not is_safe_mode:
		user_input = ""
		_update_input_display()

func _handle_success_feedback() -> void:
	state = State.FEEDBACK_SUCCESS
	lbl_status.text = "ДОСТУП РАЗРЕШЁН"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_SUCCESS)
	btn_enter.disabled = true
	btn_analyze.disabled = true
	btn_next.visible = true
	decrypt_bar.value = minf(100.0, decrypt_bar.value + float(current_task.get("economy", {}).get("reward", 0)))
	_play_sfx(AUDIO_RELAY)
	_play_success_clean_effect()

func _handle_fail_feedback() -> void:
	wrong_count += 1
	lbl_attempts.text = "ОШ: %d/%d" % [wrong_count, MAX_ATTEMPTS]
	lbl_status.text = "ДОСТУП ЗАПРЕЩЁН"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_FAIL)

	var wrong_penalty := int(current_task.get("economy", {}).get("wrong", 10))
	energy = maxf(0.0, energy - float(wrong_penalty))
	energy_bar.value = energy

	_play_sfx(AUDIO_ERROR)
	_trigger_glitch()
	_shake_screen()

	if wrong_count >= MAX_ATTEMPTS:
		_trigger_safe_mode()
	else:
		state = State.FEEDBACK_FAIL
		state = State.SOLVING

func _trigger_safe_mode() -> void:
	state = State.SAFE_MODE
	is_safe_mode = true
	btn_enter.disabled = true
	btn_next.visible = true
	lbl_status.text = "БЕЗОПАСНЫЙ РЕЖИМ АКТИВЕН"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_WARN)

	btn_analyze.disabled = false
	_on_analyze_pressed(true)
	btn_analyze.disabled = true
	_log_event("safe_mode_triggered", {})

func _on_analyze_pressed(free: bool = false) -> void:
	if not is_code_ready:
		return
	if state != State.SOLVING and state != State.SAFE_MODE:
		return

	if not free:
		var analyze_cost := int(current_task.get("economy", {}).get("analyze", 20))
		if energy < float(analyze_cost):
			lbl_status.text = "НЕДОСТАТОЧНО ЭНЕРГИИ"
			lbl_status.add_theme_color_override("font_color", STATUS_COLOR_WARN)
			_play_sfx(AUDIO_ERROR)
			return
		energy -= float(analyze_cost)
		energy_bar.value = energy

	diag_panel.visible = true
	_render_diagnostic()
	_log_event("analyze_open", {"free": free})
	state = State.DIAGNOSTIC if state == State.SOLVING else state

func _render_diagnostic() -> void:
	var explain_lines: Array = current_task.get("explain", [])
	var explain_text := "[b]ANALYSIS[/b]\n"
	for line_var in explain_lines:
		explain_text += "- %s\n" % str(line_var)
	diag_explain.text = explain_text

	var trace: Array = current_task.get("trace", [])
	var trace_text := ""
	for step_var in trace:
		var step: Dictionary = step_var
		trace_text += "i=%s | cond=%s | s: %s -> %s\n" % [
			str(step.get("i", "?")),
			str(step.get("cond", "?")),
			str(step.get("s_before", "?")),
			str(step.get("s_after", "?"))
		]
	diag_trace.text = trace_text

func _on_close_diag_pressed() -> void:
	if not diag_panel.visible:
		return
	diag_panel.visible = false
	_log_event("analyze_close", {})
	if state == State.DIAGNOSTIC and not is_safe_mode and not task_finished:
		state = State.SOLVING

func _on_next_pressed() -> void:
	if not task_finished:
		return
	_log_event("next_pressed", {"from_task": str(current_task.get("id", "A-00"))})
	_load_level(current_level_idx + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _finalize_task_result(is_correct: bool, reason: String) -> void:
	if task_result_sent:
		return

	task_result_sent = true
	task_finished = true
	var ended := Time.get_ticks_msec()
	task_session["ended_at_ticks"] = ended
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	var level_id := str(current_task.get("id", "A-00"))
	var bucket := str(current_task.get("bucket", "unknown"))
	var elapsed_ms := ended - task_started_at

	var result_data := {
		"quest": "suspect_script",
		"stage": "A",
		"match_key": "SUSPECT_A|%s" % level_id,
		"task_id": level_id,
		"bucket": bucket,
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"safe_mode": is_safe_mode,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"task_session": task_session
	}

	GlobalMetrics.register_trial(result_data)

func _play_sfx(stream: AudioStream) -> void:
	if sfx_player == null:
		return
	sfx_player.stop()
	sfx_player.stream = stream
	sfx_player.play()

func _trigger_glitch() -> void:
	var crt_overlay := noir_overlay.get_node("CRT_Overlay") as ColorRect
	if crt_overlay == null:
		return
	var shader_mat := crt_overlay.material as ShaderMaterial
	if shader_mat == null:
		return
	var is_high_fx := fx_quality == "high"
	var pulse_strength := 1.0 if is_high_fx else 0.65
	var jitter := 0.8 if is_high_fx else 0.35
	shader_mat.set_shader_parameter("pulse", pulse_strength)
	shader_mat.set_shader_parameter("jitter_strength", jitter)
	var tw := create_tween()
	tw.tween_method(func(v: float): shader_mat.set_shader_parameter("pulse", v), pulse_strength, 0.0, 0.26)
	tw.parallel().tween_method(func(v: float): shader_mat.set_shader_parameter("jitter_strength", v), jitter, 0.0, 0.22)

func _shake_screen() -> void:
	var original_pos := main_layout.position
	var tw := create_tween()
	for _i in range(4):
		tw.tween_property(main_layout, "position", original_pos + Vector2(randf_range(-2.0, 2.0), randf_range(-1.5, 1.5)), 0.04)
	tw.tween_property(main_layout, "position", original_pos, 0.05)

func _play_success_clean_effect() -> void:
	var crt_overlay := noir_overlay.get_node("CRT_Overlay") as ColorRect
	if crt_overlay == null:
		return
	var shader_mat := crt_overlay.material as ShaderMaterial
	if shader_mat == null:
		return
	var is_high_fx := fx_quality == "high"
	var base_grain := 0.35 if is_high_fx else 0.24
	var base_hatch := 0.30 if is_high_fx else 0.08
	var reduced_grain := base_grain * 0.42
	var reduced_hatch := base_hatch * 0.35
	var tw := create_tween()
	tw.tween_method(func(v: float): shader_mat.set_shader_parameter("grain_strength", v), base_grain, reduced_grain, 0.18)
	tw.parallel().tween_method(func(v: float): shader_mat.set_shader_parameter("hatch_strength", v), base_hatch, reduced_hatch, 0.18)
	tw.tween_interval(0.14)
	tw.tween_method(func(v: float): shader_mat.set_shader_parameter("grain_strength", v), reduced_grain, base_grain, 0.28)
	tw.parallel().tween_method(func(v: float): shader_mat.set_shader_parameter("hatch_strength", v), reduced_hatch, base_hatch, 0.28)

func _log_event(name: String, payload: Dictionary) -> void:
	var elapsed := Time.get_ticks_msec() - task_started_at
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": elapsed,
		"payload": payload
	})
	task_session["events"] = events
</file>

<file path="scenes/Decryptor.gd">
extends Control

@onready var btn_back = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnBack
@onready var mode_label = $UI/SafeArea/Main/HeaderBar/HeaderContent/ModeChip/ModeLabel
@onready var level_label = $UI/SafeArea/Main/HeaderBar/HeaderContent/LevelLabel
@onready var stability_text = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityText
@onready var stability_bar = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityBar
@onready var shield_freq = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldFreq
@onready var shield_lazy = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldLazy
@onready var btn_details = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnDetails
@onready var noir_overlay = $UI/NoirOverlay

@onready var target_panel = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel
@onready var target_title = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent/TargetTitle
@onready var target_value = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent/TargetValueBig
@onready var target_sub = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent/TargetSub

@onready var input_panel = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel
@onready var input_bin = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBin
@onready var input_dec = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow/InputDec
@onready var input_oct = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow/InputOct
@onready var input_hex = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow/InputHex

@onready var upper_bits = $UI/SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/UpperNibble/UpperBits
@onready var lower_bits = $UI/SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/LowerNibble/LowerBits
@onready var weights_row = $UI/SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/WeightsRow

@onready var rank_label = $UI/SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent/RankLabel
@onready var progress_label = $UI/SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent/ProgressLabel
@onready var reg_a_value = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow/RegAValue
@onready var reg_b_value = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow/RegBValue
@onready var op_value = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow/OpValue
@onready var shift_status = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/ShiftStatus
@onready var live_log_text = $UI/SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent/LiveLogText
@onready var hint_text = $UI/SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent/HintText

@onready var btn_hint = $UI/SafeArea/Main/BottomBar/Actions/BtnHint
@onready var btn_check = $UI/SafeArea/Main/BottomBar/Actions/BtnCheck
@onready var btn_reset = $UI/SafeArea/Main/BottomBar/Actions/BtnReset

@onready var toast_panel = $UI/ToastLayer/Toast
@onready var toast_label = $UI/ToastLayer/Toast/ToastLabel

@onready var details_sheet = $UI/DetailsSheet
@onready var btn_close_details = $UI/DetailsSheet/DetailsContent/DetailsHeader/BtnCloseDetails
@onready var details_text = $UI/DetailsSheet/DetailsContent/DetailsScroll/DetailsText

@onready var safe_overlay = $UI/SafeModeOverlay
@onready var safe_summary = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeSummary
@onready var safe_bits_row = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeBitsRow
@onready var btn_retry = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions/BtnRetry
@onready var btn_continue = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions/BtnContinue

const COLOR_OK = Color(0.2, 1.0, 0.6, 1)
const COLOR_WARN = Color(1.0, 0.75, 0.2, 1)
const COLOR_ERR = Color(1.0, 0.3, 0.3, 1)

const SWIPE_MIN: float = 60.0
const SWIPE_MAX_Y: float = 40.0
const DETAILS_SHEET_H: float = 380.0

var current_target: int = 0
var current_input: int = 0
var is_level_active: bool = false
var level_started_ms: int = 0
var first_action_ms: int = -1
var check_attempt_count: int = 0
var hint_used: bool = false

var bit_buttons: Array[Button] = []
var weight_labels: Array[Label] = []
var safe_bit_labels: Array[Label] = []

var log_lines: Array[String] = []
var last_hint_text: String = ""
var _shift_status_token: int = 0

var details_open: bool = false
var _swipe_start_pos: Vector2 = Vector2.ZERO
var _swipe_tracking: bool = false

func _ready():
	_build_bit_buttons()
	_build_weight_labels()
	_build_safe_bits()
	_wire_signals()
	_reset_shield_state()
	_hide_overlays()

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not GlobalMetrics.shield_triggered.is_connected(_on_shield_triggered):
		GlobalMetrics.shield_triggered.connect(_on_shield_triggered)

	await get_tree().process_frame
	_set_details_open(false, true)

	start_level(GlobalMetrics.current_level_index)

func _wire_signals() -> void:
	btn_back.pressed.connect(_on_menu_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_check.pressed.connect(_on_check_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_retry.pressed.connect(_on_retry_pressed)
	btn_continue.pressed.connect(_on_continue_pressed)

func _build_bit_buttons() -> void:
	bit_buttons.clear()
	bit_buttons.resize(8)
	for child in upper_bits.get_children():
		child.queue_free()
	for child in lower_bits.get_children():
		child.queue_free()

	for i in range(8):
		var bit_index = 7 - i
		var btn = Button.new()
		btn.toggle_mode = true
		btn.text = "0"
		btn.custom_minimum_size = Vector2(0, 64)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.toggled.connect(_on_bit_toggled.bind(bit_index))
		if i < 4:
			upper_bits.add_child(btn)
		else:
			lower_bits.add_child(btn)
		bit_buttons[bit_index] = btn

func _build_weight_labels() -> void:
	weight_labels.clear()
	for child in weights_row.get_children():
		child.queue_free()

	for _i in range(8):
		var lbl = Label.new()
		lbl.custom_minimum_size = Vector2(0, 18)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		weights_row.add_child(lbl)
		weight_labels.append(lbl)

func _build_safe_bits() -> void:
	safe_bit_labels.clear()
	for child in safe_bits_row.get_children():
		child.queue_free()

	for i in range(8):
		var lbl = Label.new()
		lbl.custom_minimum_size = Vector2(28, 28)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		lbl.text = "%d" % (7 - i)
		safe_bits_row.add_child(lbl)
		safe_bit_labels.append(lbl)

func start_level(level_idx: int) -> void:
	GlobalMetrics.start_level(level_idx)
	is_level_active = true
	current_target = GlobalMetrics.current_target_value
	current_input = 0
	last_hint_text = ""
	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	check_attempt_count = 0
	hint_used = false

	var mode = GlobalMetrics.current_mode
	mode_label.text = mode
	_update_level_label(level_idx)
	_update_rank_info()
	_update_weights_for_mode(mode)
	_update_target_display(level_idx, mode)
	_update_protocol_diagnostics()
	hint_text.text = "Диагностики пока нет."
	_reset_bit_buttons()
	_update_input_display()
	_log_message("Система инициализирована. Цель зафиксирована.", COLOR_OK)
	_on_stability_changed(100.0, 0.0)

func _update_level_label(level_idx: int) -> void:
	var protocol = "A" if level_idx < 15 else "B"
	level_label.text = "ПРОТОКОЛ %s-%d" % [protocol, level_idx + 1]

func _update_rank_info() -> void:
	var rank_info: Dictionary = GlobalMetrics.get_rank_info()
	rank_label.text = str(rank_info.get("name", "НОВИЧОК"))
	progress_label.text = "УРОВЕНЬ %d / %d" % [GlobalMetrics.current_level_index + 1, GlobalMetrics.MAX_LEVELS]
	if rank_info.has("color"):
		rank_label.add_theme_color_override("font_color", rank_info["color"])

func _update_target_display(level_idx: int, mode: String) -> void:
	if level_idx >= 15:
		target_title.text = "ПРИМЕР"
		target_value.text = _format_example(mode)
		target_sub.text = "РЕЖИМ: %s" % mode
	else:
		target_title.text = "ЦЕЛЬ"
		target_value.text = _format_value(current_target, mode)
		if mode == "DEC":
			target_sub.text = ""
		else:
			target_sub.text = "DEC: %d" % current_target

	_pulse_panel(target_panel, Color(0.55, 1.0, 0.65, 1.0))

func _update_protocol_diagnostics() -> void:
	if GlobalMetrics.current_level_index >= 15:
		reg_a_value.text = "A: %s" % _format_value(GlobalMetrics.current_reg_a, GlobalMetrics.current_mode)
		reg_b_value.text = "B: %s" % _format_value(GlobalMetrics.current_reg_b, GlobalMetrics.current_mode)
		op_value.text = "OP: %s" % _operator_to_text(GlobalMetrics.current_operator)
		_set_shift_status("СДВИГ: свайп влево для применения", Color(0.7, 0.9, 0.7, 1.0), false)
	else:
		reg_a_value.text = "A: --"
		reg_b_value.text = "B: --"
		op_value.text = "OP: --"
		_set_shift_status("СДВИГ: ожидание", Color(0.65, 0.65, 0.65, 1.0), false)

func _operator_to_text(op: int) -> String:
	if op == GlobalMetrics.Operator.ADD:
		return "+"
	if op == GlobalMetrics.Operator.SUB:
		return "-"
	return "<<"
func _update_weights_for_mode(mode: String) -> void:
	var weights: Array[int] = []
	if mode == "DEC":
		weights = [128, 64, 32, 16, 8, 4, 2, 1]
	elif mode == "OCT":
		weights = [2, 1, 4, 2, 1, 4, 2, 1]
	else:
		weights = [8, 4, 2, 1, 8, 4, 2, 1]

	for i in range(8):
		weight_labels[i].text = str(weights[i])

func _reset_bit_buttons() -> void:
	for i in range(8):
		var btn: Button = bit_buttons[i]
		btn.set_pressed_no_signal(false)
		btn.text = "0"
		btn.modulate = Color(1, 1, 1, 1)

func _update_input_display() -> void:
	var bin = String.num_int64(current_input, 2).pad_zeros(8)
	input_bin.text = "BIN: %s %s" % [bin.substr(0, 4), bin.substr(4, 4)]
	input_dec.text = "DEC: %d" % current_input
	input_oct.text = "OCT: %o" % current_input
	input_hex.text = "HEX: %X" % current_input

func _on_bit_toggled(pressed: bool, bit_index: int) -> void:
	_mark_first_action()
	AudioManager.play("click")
	if pressed:
		current_input |= (1 << bit_index)
		bit_buttons[bit_index].text = "1"
	else:
		current_input &= ~(1 << bit_index)
		bit_buttons[bit_index].text = "0"
	_clear_error_highlights()
	_animate_toggle(bit_buttons[bit_index])
	_update_input_display()

func _on_check_pressed() -> void:
	if not is_level_active:
		return

	_mark_first_action()
	check_attempt_count += 1
	var submitted_input := current_input
	var result: Dictionary = GlobalMetrics.check_solution(current_target, current_input)
	_register_trial(result, submitted_input)
	var error_code := str(result.get("error", ""))

	if error_code.begins_with("SHIELD"):
		var shield_message := str(result.get("message", "Shield active."))
		hint_text.text = shield_message
		if error_code == "SHIELD_ACTIVE":
			var now_sec := Time.get_ticks_msec() / 1000.0
			var cooldown_left := maxi(0.0, float(GlobalMetrics.blocked_until) - now_sec)
			_show_toast("SHIELD: COOLDOWN %.1fs" % cooldown_left, COLOR_WARN)
			_log_message("Shield cooldown %.1fs." % cooldown_left, COLOR_WARN)
		return

	if result.success:
		AudioManager.play("relay")
		_show_toast("УСПЕХ", COLOR_OK)
		_pulse_panel(input_panel, COLOR_OK)
		_overlay_glitch(0.15, 0.12)
		is_level_active = false
		await get_tree().create_timer(1.0).timeout
		if GlobalMetrics.current_level_index < GlobalMetrics.MAX_LEVELS - 1:
			start_level(GlobalMetrics.current_level_index + 1)
		else:
			_log_message("ВСЕ УРОВНИ ЗАВЕРШЕНЫ.", COLOR_OK)
	else:
		AudioManager.play("error")
		_pulse_panel(input_panel, COLOR_ERR)
		_overlay_glitch(0.6, 0.2)
		if result.has("hints"):
			var h = result.hints
			last_hint_text = "Диагноз: %s | Зона: %s" % [_translate_hint(h.diagnosis), _translate_hint(h.zone)]
			hint_text.text = "%s\nHD: %d" % [last_hint_text, int(result.get("hamming", 0))]
			_log_message(last_hint_text, COLOR_WARN)
		_show_toast("НЕВЕРНО", COLOR_ERR)
		_apply_error_highlight(current_input ^ current_target)
func _on_hint_pressed() -> void:
	hint_used = true
	if last_hint_text == "":
		hint_text.text = "Диагностика недоступна. Сначала запустите проверку."
		_show_toast("ПОДСКАЗКА НЕДОСТУПНА", COLOR_WARN)
		return
	hint_text.text = last_hint_text
	_log_message(last_hint_text, COLOR_WARN)
	_show_toast("ПОДСКАЗКА ПОКАЗАНА", COLOR_WARN)
func _on_reset_pressed() -> void:
	current_input = 0
	_reset_bit_buttons()
	_update_input_display()
	_clear_error_highlights()
	_set_shift_status("СДВИГ: ожидание", Color(0.65, 0.65, 0.65, 1.0), false)

func _apply_error_highlight(xor_val: int) -> void:
	for bit in range(8):
		var btn: Button = bit_buttons[bit]
		if (xor_val & (1 << bit)) != 0:
			btn.modulate = Color(1, 0.6, 0.6, 1)
		else:
			btn.modulate = Color(1, 1, 1, 1)

func _clear_error_highlights() -> void:
	for bit in range(8):
		bit_buttons[bit].modulate = Color(1, 1, 1, 1)

func _on_stability_changed(new_val: float, _change: float) -> void:
	stability_bar.value = new_val
	stability_text.text = "СТАБИЛЬНОСТЬ: %d%%" % int(new_val)
	if new_val <= 0:
		_show_safe_mode()

func _on_shield_triggered(name: String, duration: float) -> void:
	if name == "FREQUENCY":
		_flash_shield(shield_freq)
	elif name == "LAZY":
		_flash_shield(shield_lazy)

	btn_check.disabled = true
	_overlay_glitch(0.6, 0.2)
	_show_toast("ЩИТ АКТИВЕН", COLOR_WARN)
	await get_tree().create_timer(duration).timeout
	btn_check.disabled = false
func _flash_shield(label: Label) -> void:
	label.modulate = Color(1, 1, 1, 1)
	var tween = create_tween()
	tween.tween_property(label, "modulate", Color(1, 1, 1, 0.25), 0.6)

func _reset_shield_state() -> void:
	shield_freq.modulate = Color(1, 1, 1, 0.25)
	shield_lazy.modulate = Color(1, 1, 1, 0.25)

func _show_safe_mode() -> void:
	safe_overlay.visible = true
	btn_check.disabled = true
	btn_hint.disabled = true

	var xor_val = current_input ^ current_target
	var wrong_bits = 0
	for bit in range(8):
		if (xor_val & (1 << bit)) != 0:
			wrong_bits += 1

	safe_summary.text = "Цель: %s\nВвод: %s\nОшибочных битов: %d" % [
		_format_value(current_target, GlobalMetrics.current_mode),
		_format_value(current_input, GlobalMetrics.current_mode),
		wrong_bits
	]

	for i in range(8):
		var bit_index = 7 - i
		var lbl = safe_bit_labels[i]
		if (xor_val & (1 << bit_index)) != 0:
			lbl.modulate = Color(1, 0.3, 0.3, 1)
		else:
			lbl.modulate = Color(0.7, 0.7, 0.7, 1)
func _on_retry_pressed() -> void:
	GlobalMetrics.stability = 100.0
	GlobalMetrics.stability_changed.emit(100.0, 0.0)
	safe_overlay.visible = false
	btn_check.disabled = false
	btn_hint.disabled = false
	start_level(GlobalMetrics.current_level_index)

func _on_continue_pressed() -> void:
	GlobalMetrics.stability = 30.0
	GlobalMetrics.stability_changed.emit(30.0, 0.0)
	safe_overlay.visible = false
	btn_check.disabled = false
	btn_hint.disabled = false

func _on_menu_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_details_pressed() -> void:
	_set_details_open(not details_open, false)

func _set_details_open(open: bool, immediate: bool) -> void:
	details_open = open
	if open:
		details_sheet.visible = true

	var target_top := -DETAILS_SHEET_H if open else 0.0
	var target_bottom := 0.0 if open else DETAILS_SHEET_H
	if immediate:
		details_sheet.offset_top = target_top
		details_sheet.offset_bottom = target_bottom
		if not open:
			details_sheet.visible = false
		return

	var tween = create_tween()
	tween.tween_property(details_sheet, "offset_top", target_top, 0.22).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	tween.parallel().tween_property(details_sheet, "offset_bottom", target_bottom, 0.22).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	if not open:
		tween.tween_callback(func(): details_sheet.visible = false)
func _hide_overlays() -> void:
	toast_panel.visible = false
	safe_overlay.visible = false
	details_sheet.visible = false

func _show_toast(msg: String, color: Color) -> void:
	toast_label.text = msg
	toast_label.add_theme_color_override("font_color", color)
	toast_panel.visible = true
	toast_panel.modulate = Color(1, 1, 1, 0)
	var tween = create_tween()
	tween.tween_property(toast_panel, "modulate", Color(1, 1, 1, 1), 0.15)
	tween.tween_interval(0.9)
	tween.tween_property(toast_panel, "modulate", Color(1, 1, 1, 0), 0.25)
	tween.tween_callback(func(): toast_panel.visible = false)

func _animate_toggle(btn: Button) -> void:
	btn.scale = Vector2(0.96, 0.96)
	var tween = create_tween()
	tween.tween_property(btn, "scale", Vector2(1, 1), 0.1)

func _pulse_panel(panel: Control, color: Color) -> void:
	panel.modulate = color
	var tween = create_tween()
	tween.tween_property(panel, "modulate", Color(1, 1, 1, 1), 0.25)

func _translate_hint(code: String) -> String:
	match code:
		"VALUE_LOW": return "Значение ниже цели"
		"VALUE_HIGH": return "Значение выше цели"
		"BIT_ERROR": return "Несовпадение битов"
		"BOTH_NIBBLES": return "Ошибки в обеих тетрадах"
		"LOWER_NIBBLE": return "Ошибки в младшей тетраде (биты 0-3)"
		"UPPER_NIBBLE": return "Ошибки в старшей тетраде (биты 4-7)"
		"NONE": return "Несовпадений нет"
	return code

func _set_shift_status(text: String, color: Color, auto_reset: bool) -> void:
	shift_status.text = text
	shift_status.add_theme_color_override("font_color", color)
	if not auto_reset:
		return
	_shift_status_token += 1
	var token = _shift_status_token
	_reset_shift_status_later(token)

func _reset_shift_status_later(token: int) -> void:
	await get_tree().create_timer(0.9).timeout
	if token != _shift_status_token:
		return
	if GlobalMetrics.current_level_index >= 15:
		_set_shift_status("СДВИГ: свайп влево для применения", Color(0.7, 0.9, 0.7, 1.0), false)
	else:
		_set_shift_status("СДВИГ: ожидание", Color(0.65, 0.65, 0.65, 1.0), false)

func _overlay_glitch(strength: float, duration: float) -> void:
	if noir_overlay != null and noir_overlay.has_method("glitch_burst"):
		noir_overlay.call("glitch_burst", strength, duration)

func _log_message(msg: String, color: Color) -> void:
	var time_str = Time.get_time_string_from_system()
	var line = "[%s] %s" % [time_str, msg]
	log_lines.append(line)
	if log_lines.size() > 200:
		log_lines.remove_at(0)
	var combined_log = "\n".join(log_lines)
	details_text.text = combined_log
	var tail = log_lines.slice(maxi(0, log_lines.size() - 18), log_lines.size())
	live_log_text.text = "\n".join(tail)
	live_log_text.add_theme_color_override("default_color", color)

func _format_value(val: int, mode: String) -> String:
	if mode == "DEC":
		return "%d" % val
	elif mode == "OCT":
		return "%o" % val
	elif mode == "HEX":
		return "%X" % val
	return "%d" % val

func _format_example(mode: String) -> String:
	var a = GlobalMetrics.current_reg_a
	var b = GlobalMetrics.current_reg_b
	var op = GlobalMetrics.current_operator
	var a_txt = _format_value(a, mode)
	var b_txt = _format_value(b, mode)
	if op == GlobalMetrics.Operator.ADD:
		return "%s + %s" % [a_txt, b_txt]
	elif op == GlobalMetrics.Operator.SUB:
		return "%s - %s" % [a_txt, b_txt]
	else:
		return "%s << %s" % [a_txt, b_txt]

func _unhandled_input(event):
	if not _is_shift_swipe_allowed():
		_swipe_tracking = false
		return
	if event is InputEventScreenTouch:
		if event.pressed:
			if _is_in_switches(event.position):
				_swipe_start_pos = event.position
				_swipe_tracking = true
		else:
			if _swipe_tracking:
				var delta = event.position - _swipe_start_pos
				if abs(delta.x) >= SWIPE_MIN and abs(delta.y) <= SWIPE_MAX_Y:
					_apply_shift_left()
				_swipe_tracking = false
	elif event is InputEventMouseButton:
		if event.pressed:
			if _is_in_switches(event.position):
				_swipe_start_pos = event.position
				_swipe_tracking = true
		else:
			if _swipe_tracking:
				var delta_mouse = event.position - _swipe_start_pos
				if abs(delta_mouse.x) >= SWIPE_MIN and abs(delta_mouse.y) <= SWIPE_MAX_Y:
					_apply_shift_left()
				_swipe_tracking = false

func _is_in_switches(pos: Vector2) -> bool:
	return upper_bits.get_global_rect().has_point(pos) or lower_bits.get_global_rect().has_point(pos)

func _is_shift_swipe_allowed() -> bool:
	return GlobalMetrics.current_level_index >= 15 and GlobalMetrics.current_operator == GlobalMetrics.Operator.SHIFT_L

func _apply_shift_left() -> void:
	if not _is_shift_swipe_allowed():
		return
	_mark_first_action()
	current_input = (current_input << 1) & 0xFF
	_sync_switches_to_input()
	_update_input_display()
	_set_shift_status("СДВИГ: применён", COLOR_OK, true)
	_log_message("Применён жест сдвига влево.", COLOR_OK)

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _register_trial(result: Dictionary, submitted_input: int) -> void:
	var level_number := GlobalMetrics.current_level_index + 1
	var stage_id := "A" if GlobalMetrics.current_level_index < 15 else "B"
	var task_id := "%s_%02d" % [stage_id, level_number]
	var variant_source := "%s|%s|%d" % [GlobalMetrics.current_mode, stage_id, current_target]
	var payload := TrialV2.build("DECRYPTOR", stage_id, task_id, "NUMERIC_ENTRY", str(hash(variant_source)))
	var elapsed_ms: int = maxi(0, Time.get_ticks_msec() - level_started_ms)
	var is_success := bool(result.get("success", false))
	var error_code := str(result.get("error", "NONE"))
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_success
	payload["is_fit"] = is_success
	payload["stability_delta"] = 0
	payload["level_index"] = GlobalMetrics.current_level_index
	payload["mode"] = GlobalMetrics.current_mode
	payload["target_value"] = current_target
	payload["input_value"] = submitted_input
	payload["check_attempt_count"] = check_attempt_count
	payload["hint_used"] = hint_used
	payload["error_type"] = error_code
	payload["penalty_reported"] = float(result.get("penalty", 0.0))
	if result.has("hamming"):
		payload["hamming"] = int(result.get("hamming", 0))
	GlobalMetrics.register_trial(payload)

func _sync_switches_to_input() -> void:
	for bit in range(8):
		var pressed = ((current_input >> bit) & 1) == 1
		var btn: Button = bit_buttons[bit]
		btn.set_pressed_no_signal(pressed)
		btn.text = "1" if pressed else "0"
</file>

<file path="scenes/CityMapQuestA.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/CityMapQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_gy7cs"]

[node name="CityMapQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_gy7cs")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(56, 56)
layout_mode = 2
text = "<"

[node name="LabelCase" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО 6: КАРТА ГОРОДА"

[node name="LabelMode" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ: A"

[node name="LabelProgress" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ЗАДАНИЕ: 1/1"

[node name="Spacer" type="Control" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LabelState" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="LabelTimer" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ВРЕМЯ: 02:00"

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingMargin" type="MarginContainer" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BriefingVBox" type="VBoxContainer" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="BriefingTitle" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "АУДИТ МАРШРУТА"

[node name="BriefingText" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
text = "Доберитесь до узла E по направленным дорогам. Введите итоговую сумму пути и отправьте. Проходит только минимальный маршрут."
autowrap_mode = 2

[node name="ConstraintLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
visible = false
layout_mode = 2
autowrap_mode = 2

[node name="ContentSplit" type="SplitContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 800

[node name="GraphPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="GraphMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/GraphPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="GraphContainer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin"]
custom_minimum_size = Vector2(420, 320)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EdgesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="NodesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="InfoPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="InfoMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="InfoVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="PathDisplay" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ПУТЬ: A"
autowrap_mode = 2

[node name="SumLiveLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СУММА: 0"

[node name="InputLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ВВЕДИТЕ ИТОГОВУЮ СУММУ"

[node name="SumInput" type="LineEdit" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
placeholder_text = "0"
max_length = 6

[node name="ButtonsRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnSubmit" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ОТПРАВИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
visible = false
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
disabled = true
text = "ДАЛЕЕ"

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_vertical = 3
autowrap_mode = 2

[node name="Footer" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
theme_override_constants/separation = 8

[node name="FooterLabel" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Ориентированный граф: нажимать можно только исходящие дороги из текущего узла."

[node name="FooterMeta" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
text = "КАРТА ГОРОДА / A"
</file>

<file path="scripts/case_07/da7_cases_b.gd">
extends Node

const SCHEMA_VERSION = "DA7.B.v1"
const LEVEL = "B"

# --- F_REASON Constants (Ladder Priority) ---
const F_REASON_FILTER = [
	"EMPTY_SELECTION",
	"PURE_OPPOSITE",
	"INCLUDED_BOUNDARY",
	"OVERSELECT_DECOY",
	"FALSE_POSITIVE",
	"OMISSION",
	"NONE"
]

const F_REASON_RELATION = [
	"RELATION_CONFUSION_1TO1_1TOM",
	"RELATION_CONFUSION_1TOM_MTOM",
	"FK_DIRECTION_SWAP",
	"GUESS_FAST_CLICK",
	"CORRECT"
]

const CASES_B: Array = [
	# --- 1. FILTER_ROWS (Strict >) ---
	{
		"id": "DA7-B-01",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Терминал: выберите агентов с уровнем доступа строго больше 3.",
		"predicate": {
			"field_col_id": "c_access",
			"operator": ">",
			"value": "3",
			"value_type": "INT",
			"strict_expected": true
		},
		"table": {
			"columns": [
				{"col_id": "c_name", "title": "Имя"},
				{"col_id": "c_access", "title": "Доступ"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_name": "Альфа", "c_access": "2"}},
				{"row_id": "r2", "cells": {"c_name": "Бета", "c_access": "5"}},
				{"row_id": "r3", "cells": {"c_name": "Гамма", "c_access": "3"}},
				{"row_id": "r4", "cells": {"c_name": "Дельта", "c_access": "4"}}
			]
		},
		"answer_row_ids": ["r2", "r4"],
		"boundary_row_ids": ["r3"],
		"opposite_row_ids": ["r1"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["strict_inequality", "boundary_case"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 2. FILTER_ROWS (Non-Strict >=) ---
	{
		"id": "DA7-B-02",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Система: выберите инциденты с уровнем серьёзности >= 2.",
		"predicate": {
			"field_col_id": "c_sev",
			"operator": ">=",
			"value": "2",
			"value_type": "INT",
			"strict_expected": false
		},
		"table": {
			"columns": [
				{"col_id": "c_id", "title": "ID"},
				{"col_id": "c_sev", "title": "Серьёзн."}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_id": "101", "c_sev": "1"}},
				{"row_id": "r2", "cells": {"c_id": "102", "c_sev": "2"}},
				{"row_id": "r3", "cells": {"c_id": "103", "c_sev": "3"}},
				{"row_id": "r4", "cells": {"c_id": "104", "c_sev": "1"}}
			]
		},
		"answer_row_ids": ["r2", "r3"],
		"boundary_row_ids": ["r2"],
		"opposite_row_ids": ["r1", "r4"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["non_strict_inequality", "boundary_in_answer"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 3. FILTER_ROWS (String equality ==) ---
	{
		"id": "DA7-B-03",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Поиск: выберите все строки со статусом ОШИБКА.",
		"predicate": {
			"field_col_id": "c_stat",
			"operator": "==",
			"value": "ОШИБКА",
			"value_type": "TEXT",
			"strict_expected": true
		},
		"table": {
			"columns": [
				{"col_id": "c_ts", "title": "Время"},
				{"col_id": "c_stat", "title": "Статус"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_ts": "09:00", "c_stat": "НОРМА"}},
				{"row_id": "r2", "cells": {"c_ts": "09:05", "c_stat": "ОШИБКА"}},
				{"row_id": "r3", "cells": {"c_ts": "09:10", "c_stat": "ПРЕДУПРЕЖДЕНИЕ"}},
				{"row_id": "r4", "cells": {"c_ts": "09:15", "c_stat": "ОШИБКА"}}
			]
		},
		"answer_row_ids": ["r2", "r4"],
		"boundary_row_ids": [],
		"opposite_row_ids": ["r1", "r3"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["equality_filter"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 4. FILTER_ROWS (Strict <) ---
	{
		"id": "DA7-B-04",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Фильтр: найдите транзакции с суммой < 100.",
		"predicate": {
			"field_col_id": "c_sum",
			"operator": "<",
			"value": "100",
			"value_type": "INT",
			"strict_expected": true
		},
		"table": {
			"columns": [
				{"col_id": "c_id", "title": "TX_ID"},
				{"col_id": "c_sum", "title": "Сумма"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_id": "1", "c_sum": "50"}},
				{"row_id": "r2", "cells": {"c_id": "2", "c_sum": "100"}},
				{"row_id": "r3", "cells": {"c_id": "3", "c_sum": "150"}},
				{"row_id": "r4", "cells": {"c_id": "4", "c_sum": "99"}}
			]
		},
		"answer_row_ids": ["r1", "r4"],
		"boundary_row_ids": ["r2"],
		"opposite_row_ids": ["r3"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["strict_inequality", "boundary_case"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 5. RELATIONSHIP (1:M) ---
	{
		"id": "DA7-B-05",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_RELATIONSHIPS",
		"case_kind": "RELATION_TYPE",
		"interaction_type": "RELATIONSHIP_CHOICE",
		"prompt": "Схема: определите связь между Пользователи и Посты.",
		"schema_visual": {
			"left_table": {
				"title": "Пользователи",
				"columns": [{"col_id":"u_id","title":"ID"}, {"col_id":"u_name","title":"Имя"}],
				"rows_preview": [
					{"row_id":"u1", "cells":{"u_id":"1","u_name":"Алиса"}},
					{"row_id":"u2", "cells":{"u_id":"2","u_name":"Боб"}}
				]
			},
			"right_table": {
				"title": "Посты",
				"columns": [{"col_id":"p_id","title":"ID"}, {"col_id":"p_uid","title":"ID_пользователя"}, {"col_id":"p_txt","title":"Текст"}],
				"rows_preview": [
					{"row_id":"p1", "cells":{"p_id":"10","p_uid":"1","p_txt":"Привет"}},
					{"row_id":"p2", "cells":{"p_id":"11","p_uid":"1","p_txt":"Обновление"}},
					{"row_id":"p3", "cells":{"p_id":"12","p_uid":"2","p_txt":"Здравствуй"}}
				]
			},
			"link": {
				"hint_label": "Пользователи.ID -> Посты.ID_пользователя"
			}
		},
		"expected_relation": "1:M",
		"options": [
			{"id": "opt1", "text": "1:1 (Один-к-одному)", "f_reason": "RELATION_CONFUSION_1TO1_1TOM"},
			{"id": "opt2", "text": "1:M (Один-ко-многим)", "f_reason": null},
			{"id": "opt3", "text": "M:M (Многие-ко-многим)", "f_reason": "RELATION_CONFUSION_1TOM_MTOM"}
		],
		"answer_id": "opt2",
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120},
		"anti_cheat": {"shuffle_rows": false, "shuffle_options": true}
	},
	# --- 6. RELATIONSHIP (1:1) ---
	{
		"id": "DA7-B-06",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_RELATIONSHIPS",
		"case_kind": "RELATION_TYPE",
		"interaction_type": "RELATIONSHIP_CHOICE",
		"prompt": "Схема: определите связь между Сотрудники и Паспортные_данные (уникальный паспорт).",
		"schema_visual": {
			"left_table": {
				"title": "Сотрудники",
				"columns": [{"col_id":"e_id","title":"ID"}, {"col_id":"e_name","title":"Имя"}],
				"rows_preview": [
					{"row_id":"e1", "cells":{"e_id":"101","e_name":"Иван"}},
					{"row_id":"e2", "cells":{"e_id":"102","e_name":"Жанна"}}
				]
			},
			"right_table": {
				"title": "Паспортные_данные",
				"columns": [{"col_id":"pd_id","title":"ID_паспорта"}, {"col_id":"pd_eid","title":"ID_сотрудника"}, {"col_id":"pd_num","title":"Номер"}],
				"rows_preview": [
					{"row_id":"p1", "cells":{"pd_id":"55","pd_eid":"101","pd_num":"A-001"}},
					{"row_id":"p2", "cells":{"pd_id":"56","pd_eid":"102","pd_num":"B-002"}}
				]
			},
			"link": {
				"hint_label": "Сотрудники.ID -> Паспорт.ID_сотрудника (Уникально)"
			}
		},
		"expected_relation": "1:1",
		"options": [
			{"id": "opt1", "text": "1:1 (Один-к-одному)", "f_reason": null},
			{"id": "opt2", "text": "1:M (Один-ко-многим)", "f_reason": "RELATION_CONFUSION_1TO1_1TOM"},
			{"id": "opt3", "text": "M:M (Многие-ко-многим)", "f_reason": "RELATION_CONFUSION_1TOM_MTOM"}
		],
		"answer_id": "opt1",
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120},
		"anti_cheat": {"shuffle_rows": false, "shuffle_options": true}
	}
]

static func validate_case_b(c: Dictionary) -> bool:
	var case_id: String = str(c.get("id", "UNKNOWN"))
	if str(c.get("schema_version", "")) != SCHEMA_VERSION:
		push_error("Case %s bad schema" % case_id)
		return false

	if str(c.get("interaction_type", "")) == "MULTI_SELECT_ROWS":
		# Validation for disjoint sets (basic existence checks).
		if not c.has("answer_row_ids") or not c.has("boundary_row_ids") or not c.has("opposite_row_ids") or not c.has("unrelated_row_ids") or not c.has("decoy_row_ids"):
			push_error("Case %s missing sets" % case_id)
			return false
		if not c.has("predicate"):
			push_error("Case %s missing predicate" % case_id)
			return false
		if not c.has("table"):
			push_error("Case %s missing table" % case_id)
			return false
		var table: Dictionary = c.get("table", {}) as Dictionary
		var rows: Array = table.get("rows", []) as Array
		var all_row_ids: Dictionary = {}
		for row_v in rows:
			if typeof(row_v) != TYPE_DICTIONARY:
				continue
			var row_id: String = str((row_v as Dictionary).get("row_id", ""))
			if row_id == "":
				continue
			all_row_ids[row_id] = true
		var answer_ids: Array = c.get("answer_row_ids", []) as Array
		var boundary_ids: Array = c.get("boundary_row_ids", []) as Array
		var opposite_ids: Array = c.get("opposite_row_ids", []) as Array
		var unrelated_ids: Array = c.get("unrelated_row_ids", []) as Array
		var decoy_ids: Array = c.get("decoy_row_ids", []) as Array
		if not _all_exist_in(answer_ids, all_row_ids) or not _all_exist_in(boundary_ids, all_row_ids) or not _all_exist_in(opposite_ids, all_row_ids) or not _all_exist_in(unrelated_ids, all_row_ids) or not _all_exist_in(decoy_ids, all_row_ids):
			push_error("Case %s has unknown row ids in sets" % case_id)
			return false
		# Boundary rows may overlap with answer rows for non-strict predicates (e.g. >=).
		var predicate: Dictionary = c.get("predicate", {}) as Dictionary
		var strict_expected: bool = bool(predicate.get("strict_expected", false))
		if not _are_disjoint([answer_ids, opposite_ids, unrelated_ids, decoy_ids]):
			push_error("Case %s has intersecting sets (A/O/U/D)" % case_id)
			return false
		if _has_intersection(boundary_ids, opposite_ids) or _has_intersection(boundary_ids, unrelated_ids) or _has_intersection(boundary_ids, decoy_ids):
			push_error("Case %s has invalid boundary overlap with O/U/D sets" % case_id)
			return false
		if strict_expected and _has_intersection(boundary_ids, answer_ids):
			push_error("Case %s has strict predicate but boundary overlaps answer set" % case_id)
			return false

	elif str(c.get("interaction_type", "")) == "RELATIONSHIP_CHOICE":
		if not c.has("schema_visual"):
			push_error("Case %s missing schema_visual" % case_id)
			return false
		if not c.has("options"):
			push_error("Case %s missing options" % case_id)
			return false

	return true

static func _all_exist_in(ids: Array, allowed: Dictionary) -> bool:
	for id_v in ids:
		var row_id: String = str(id_v)
		if not allowed.has(row_id):
			return false
	return true

static func _are_disjoint(grouped_ids: Array) -> bool:
	var seen: Dictionary = {}
	for group_v in grouped_ids:
		if typeof(group_v) != TYPE_ARRAY:
			continue
		var group: Array = group_v
		for id_v in group:
			var key: String = str(id_v)
			if seen.has(key):
				return false
			seen[key] = true
	return true

static func _has_intersection(arr1: Array, arr2: Array) -> bool:
	var lookup: Dictionary = {}
	for id_v in arr2:
		lookup[str(id_v)] = true
	for id_v in arr1:
		if lookup.has(str(id_v)):
			return true
	return false
</file>

<file path="scripts/case_07/da7_data_archive_a.gd">
extends Control

const CasesHub = preload("res://scripts/case_07/da7_cases.gd")

const BREAKPOINT_PX := 800
const SESSION_CASE_COUNT := 6
const TYPEWRITER_INTERVAL_SEC := 0.03

var session_cases: Array = []
var current_case_index: int = -1
var current_case: Dictionary = {}
var case_started_ts: int = 0
var first_action_ts: int = -1
var trial_locked: bool = false
var scroll_used: bool = false
var table_has_scroll: bool = false
var exit_btn: Button

var inspect_count: int = 0
var unique_rows_inspected: Dictionary = {}
var answered_without_inspection: bool = false
var last_inspected_row_id: String = ""

var row_item_by_id: Dictionary = {}
var col_index_by_id: Dictionary = {}
var row_data_by_id: Dictionary = {}

var _typewriter_steps: Array[Dictionary] = []
var _typewriter_step_index: int = -1
var _typewriter_target: RichTextLabel
var _typewriter_source: String = ""
var _typewriter_cursor: int = 0

@onready var title_label: RichTextLabel = $SafeArea/RootLayout/Header/Margin/Title
@onready var btn_back: Button = $SafeArea/RootLayout/BackRow/BtnBack
@onready var desktop_layout: HSplitContainer = $SafeArea/RootLayout/Body/DesktopLayout
@onready var mobile_layout: VBoxContainer = $SafeArea/RootLayout/Body/MobileLayout
@onready var table_section: VBoxContainer = $SafeArea/RootLayout/Body/DesktopLayout/TableSection
@onready var task_section: VBoxContainer = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection
@onready var data_tree: Tree = $SafeArea/RootLayout/Body/DesktopLayout/TableSection/DataTree
@onready var inspect_label: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox/InspectLabel
@onready var scan_label: Label = $SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox/ScanLabel
@onready var case_title_label: Label = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox/CaseTitleLabel
@onready var briefing_label: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox/BriefingLabel
@onready var objective_label: Label = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox/ObjectiveLabel
@onready var prompt_label: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/PromptLabel
@onready var options_grid: GridContainer = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/OptionsGrid
@onready var explain_line: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/ExplainLine
@onready var stability_label: Label = $SafeArea/RootLayout/Footer/StabilityLabel
@onready var stability_bar: ProgressBar = $SafeArea/RootLayout/Footer/StabilityBar
@onready var sfx_click: AudioStreamPlayer = $Runtime/Audio/SfxClick
@onready var sfx_error: AudioStreamPlayer = $Runtime/Audio/SfxError
@onready var sfx_relay: AudioStreamPlayer = $Runtime/Audio/SfxRelay
@onready var result_stamp: Control = $ResultStamp
@onready var typewriter_timer: Timer = $Runtime/TypewriterTimer

func _ready() -> void:
	randomize()
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not btn_back.pressed.is_connected(_on_back_pressed):
		btn_back.pressed.connect(_on_back_pressed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	if not data_tree.gui_input.is_connected(_on_scroll_input):
		data_tree.gui_input.connect(_on_scroll_input)
	if not prompt_label.gui_input.is_connected(_on_scroll_input):
		prompt_label.gui_input.connect(_on_scroll_input)
	if not data_tree.item_selected.is_connected(_on_tree_item_selected):
		data_tree.item_selected.connect(_on_tree_item_selected)
	if not typewriter_timer.timeout.is_connected(_on_typewriter_tick):
		typewriter_timer.timeout.connect(_on_typewriter_tick)

	_init_session()
	call_deferred("_on_viewport_size_changed")
	_load_next_case()

func _init_session() -> void:
	var all_cases: Array = CasesHub.get_cases("A")
	if all_cases.is_empty():
		_show_fatal("Кейсы уровня A не найдены. Проверьте scripts/case_07/da7_cases_a.gd")
		return

	all_cases.shuffle()
	session_cases = all_cases.slice(0, mini(SESSION_CASE_COUNT, all_cases.size()))
	current_case_index = -1
	GlobalMetrics.stability = 100.0
	_update_stability_ui()

func _load_next_case() -> void:
	if session_cases.is_empty():
		return

	current_case_index += 1
	if current_case_index >= session_cases.size():
		_finish_session()
		return

	current_case = (session_cases[current_case_index] as Dictionary).duplicate(true)
	case_started_ts = Time.get_ticks_msec()
	first_action_ts = -1
	scroll_used = false
	table_has_scroll = false
	trial_locked = false
	inspect_count = 0
	unique_rows_inspected.clear()
	answered_without_inspection = false
	last_inspected_row_id = ""
	row_item_by_id.clear()
	col_index_by_id.clear()
	row_data_by_id.clear()
	typewriter_timer.stop()
	_render_case()

func _render_case() -> void:
	title_label.text = "ДЕЛО #7: СЕКРЕТНЫЙ АРХИВ [A %d/%d]" % [current_case_index + 1, session_cases.size()]

	case_title_label.text = "ФАЙЛ: %s" % str(current_case.get("case_title", current_case.get("id", "НЕИЗВЕСТНЫЙ_ФАЙЛ")))
	briefing_label.bbcode_enabled = false
	briefing_label.text = str(current_case.get("briefing", ""))
	objective_label.text = "ЦЕЛЬ: %s" % str(current_case.get("objective", ""))

	prompt_label.bbcode_enabled = false
	prompt_label.text = str(current_case.get("prompt", ""))
	explain_line.bbcode_enabled = false
	explain_line.text = ""

	inspect_label.bbcode_enabled = false
	inspect_label.text = "Выберите строку для проверки улики."
	scan_label.text = "СКАН: 0"

	_render_table(current_case.get("table", {}) as Dictionary)
	_render_options(current_case.get("options", []) as Array)
	_start_typewriter_sequence()
	call_deferred("_update_silent_reading_possible_flag")

func _start_typewriter_sequence() -> void:
	typewriter_timer.stop()
	_typewriter_steps.clear()
	_typewriter_step_index = -1
	_typewriter_steps.append({
		"target": briefing_label,
		"text": str(current_case.get("briefing", ""))
	})
	_typewriter_steps.append({
		"target": prompt_label,
		"text": str(current_case.get("prompt", ""))
	})
	_start_next_typewriter_step()

func _start_next_typewriter_step() -> void:
	_typewriter_step_index += 1
	if _typewriter_step_index >= _typewriter_steps.size():
		typewriter_timer.stop()
		return

	var step: Dictionary = _typewriter_steps[_typewriter_step_index]
	var target_v: Variant = step.get("target", null)
	if not (target_v is RichTextLabel):
		_start_next_typewriter_step()
		return

	_typewriter_target = target_v as RichTextLabel
	_typewriter_source = str(step.get("text", ""))
	_typewriter_cursor = 0
	_typewriter_target.bbcode_enabled = false
	_typewriter_target.text = ""

	if _typewriter_source.is_empty():
		_start_next_typewriter_step()
		return

	typewriter_timer.wait_time = TYPEWRITER_INTERVAL_SEC
	typewriter_timer.start()

func _on_typewriter_tick() -> void:
	if not is_instance_valid(_typewriter_target):
		return

	if _typewriter_cursor < _typewriter_source.length():
		_typewriter_cursor += 1
		_typewriter_target.text = _typewriter_source.substr(0, _typewriter_cursor)
		typewriter_timer.start()
	else:
		_start_next_typewriter_step()

func _render_table(table_def: Dictionary) -> void:
	data_tree.clear()
	row_item_by_id.clear()
	col_index_by_id.clear()
	row_data_by_id.clear()

	var root: TreeItem = data_tree.create_item()
	data_tree.hide_root = true
	data_tree.select_mode = Tree.SELECT_ROW

	var cols: Array = table_def.get("columns", []) as Array
	if cols.is_empty():
		data_tree.columns = 1
		data_tree.set_column_title(0, "Данные")
		data_tree.column_titles_visible = true
		return

	data_tree.columns = cols.size()
	for i in range(cols.size()):
		var col_data_v: Variant = cols[i]
		if typeof(col_data_v) != TYPE_DICTIONARY:
			continue
		var col: Dictionary = col_data_v as Dictionary
		var col_id: String = str(col.get("col_id", ""))
		col_index_by_id[col_id] = i
		data_tree.set_column_title(i, str(col.get("title", "СТОЛБЕЦ")))
	data_tree.column_titles_visible = true

	var rows: Array = table_def.get("rows", []) as Array
	for row_v in rows:
		if typeof(row_v) != TYPE_DICTIONARY:
			continue
		var row_data: Dictionary = row_v as Dictionary
		var row_id: String = str(row_data.get("row_id", ""))
		if row_id.is_empty():
			continue
		var row_item: TreeItem = data_tree.create_item(root)
		row_item.set_metadata(0, row_id)
		row_item_by_id[row_id] = row_item
		row_data_by_id[row_id] = row_data

		var cells: Dictionary = row_data.get("cells", {}) as Dictionary
		for i in range(cols.size()):
			var col_v: Variant = cols[i]
			if typeof(col_v) != TYPE_DICTIONARY:
				continue
			var col_def: Dictionary = col_v as Dictionary
			var col_id := str(col_def.get("col_id", ""))
			row_item.set_text(i, str(cells.get(col_id, "")))

func _render_options(options: Array) -> void:
	for child in options_grid.get_children():
		child.queue_free()

	for opt_v in options:
		if typeof(opt_v) != TYPE_DICTIONARY:
			continue
		var opt: Dictionary = opt_v as Dictionary
		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 56)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.text = str(opt.get("text", "Вариант"))
		btn.pressed.connect(_on_option_selected.bind(str(opt.get("id", ""))))
		options_grid.add_child(btn)

func _on_tree_item_selected() -> void:
	if trial_locked:
		return

	var item: TreeItem = data_tree.get_selected()
	if item == null:
		return
	var row_id: String = str(item.get_metadata(0))
	if row_id.is_empty() or not row_data_by_id.has(row_id):
		return

	_register_first_action()
	inspect_count += 1
	unique_rows_inspected[row_id] = true
	last_inspected_row_id = row_id
	scan_label.text = "СКАН: %d" % inspect_count
	inspect_label.text = _build_inspect_line(row_id)
	if is_instance_valid(sfx_click):
		sfx_click.play()

func _build_inspect_line(row_id: String) -> String:
	var row_data: Dictionary = row_data_by_id.get(row_id, {}) as Dictionary
	var table_def: Dictionary = current_case.get("table", {}) as Dictionary
	var cols: Array = table_def.get("columns", []) as Array
	var cells: Dictionary = row_data.get("cells", {}) as Dictionary

	var parts: Array[String] = []
	for col_v in cols:
		if typeof(col_v) != TYPE_DICTIONARY:
			continue
		var col_def: Dictionary = col_v as Dictionary
		var col_id: String = str(col_def.get("col_id", ""))
		var col_title: String = str(col_def.get("title", col_id.to_upper()))
		parts.append("%s=%s" % [col_title, str(cells.get(col_id, ""))])

	return "СТРОКА %s: %s" % [row_id, " | ".join(parts)]

func _on_option_selected(selected_id: String) -> void:
	if trial_locked:
		return

	_register_first_action()
	answered_without_inspection = inspect_count == 0
	trial_locked = true
	typewriter_timer.stop()
	briefing_label.text = str(current_case.get("briefing", ""))
	prompt_label.text = str(current_case.get("prompt", ""))

	if is_instance_valid(sfx_click):
		sfx_click.play()

	var answer_id: String = str(current_case.get("answer_id", ""))
	var selected_option: Dictionary = _find_option(selected_id)
	var is_correct: bool = selected_id == answer_id

	if is_correct:
		if sfx_relay != null:
			sfx_relay.play()
	else:
		if sfx_error != null:
			sfx_error.play()

	_set_options_locked(true)
	_apply_highlight(current_case.get("highlight", {}) as Dictionary)
	_show_explain_line(is_correct, selected_option)
	if is_instance_valid(result_stamp) and result_stamp.has_method("show_result"):
		result_stamp.call("show_result", is_correct)

	_log_trial(selected_id, answer_id, is_correct)
	_update_stability_ui()

	await get_tree().create_timer(0.9).timeout

	if GlobalMetrics.stability <= 0.0:
		_game_over()
	else:
		_load_next_case()

func _show_explain_line(is_correct: bool, selected_option: Dictionary) -> void:
	var reveal: Dictionary = current_case.get("reveal", {}) as Dictionary
	var line: String = ""
	if is_correct:
		line = str(reveal.get("on_correct", "Подтверждено."))
	else:
		var reason: String = str(selected_option.get("f_reason", "WRONG_OPTION_GENERIC"))
		var reason_map: Dictionary = reveal.get("on_wrong_by_reason", {}) as Dictionary
		line = str(reason_map.get(reason, "Проверьте выделенные улики и повторите попытку."))
	explain_line.text = line

func _apply_highlight(highlight: Dictionary) -> void:
	if highlight.is_empty():
		return

	var mode: String = str(highlight.get("mode", "")).to_upper()
	var bg: Color = Color(0.42, 0.30, 0.10, 0.55)
	var fg: Color = Color(1.0, 0.94, 0.78, 1.0)

	match mode:
		"ROWS":
			var target_rows: Array = highlight.get("target_row_ids", []) as Array
			for row_id_v in target_rows:
				var row_id: String = str(row_id_v)
				_highlight_row(row_id, bg, fg)
		"COLUMNS":
			var target_cols: Array = highlight.get("target_col_ids", []) as Array
			for col_id_v in target_cols:
				var col_id: String = str(col_id_v)
				if not col_index_by_id.has(col_id):
					continue
				var col_idx: int = int(col_index_by_id[col_id])
				for row_id_v in row_item_by_id.keys():
					var item: TreeItem = row_item_by_id[row_id_v] as TreeItem
					_highlight_cell(item, col_idx, bg, fg)
		"CELL":
			var target_cell: Dictionary = highlight.get("target_cell", {}) as Dictionary
			var row_id: String = str(target_cell.get("row_id", ""))
			var col_id: String = str(target_cell.get("col_id", ""))
			if row_item_by_id.has(row_id) and col_index_by_id.has(col_id):
				var row_item: TreeItem = row_item_by_id[row_id] as TreeItem
				var col_idx: int = int(col_index_by_id[col_id])
				_highlight_cell(row_item, col_idx, bg, fg)

func _highlight_row(row_id: String, bg: Color, fg: Color) -> void:
	if not row_item_by_id.has(row_id):
		return
	var item: TreeItem = row_item_by_id[row_id] as TreeItem
	for col_idx in range(data_tree.columns):
		_highlight_cell(item, col_idx, bg, fg)

func _highlight_cell(item: TreeItem, col_idx: int, bg: Color, fg: Color) -> void:
	if item == null:
		return
	item.set_custom_bg_color(col_idx, bg)
	item.set_custom_color(col_idx, fg)

func _log_trial(selected_id: String, answer_id: String, is_correct: bool) -> void:
	var now_ms: int = Time.get_ticks_msec()
	var elapsed_ms: int = now_ms - case_started_ts
	var first_action_ms: int = elapsed_ms
	if first_action_ts >= case_started_ts:
		first_action_ms = first_action_ts - case_started_ts
	var silent_reading_possible: bool = (not table_has_scroll and not scroll_used and first_action_ms >= 30000)
	var case_id: String = str(current_case.get("id", "DA7-A-00"))
	var selected_option: Dictionary = _find_option(selected_id)
	var f_reason: Variant = null if is_correct else selected_option.get("f_reason", "WRONG_OPTION_GENERIC")
	var payload: Dictionary = {
		"question_id": case_id,
		"case_id": case_id,
		"quest_id": "DA7",
		"quest": "data_archive",
		"stage": "A",
		"level": "A",
		"topic": str(current_case.get("topic", "DB_BASICS")),
		"interaction_type": "SINGLE_CHOICE",
		"schema_version": str(current_case.get("schema_version", "DA7.A.v1")),
		"match_key": "DA7_A|%s" % case_id,
		"is_correct": is_correct,
		"f_reason": f_reason,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"timing": {
			"effective_elapsed_ms": elapsed_ms,
			"time_to_first_action_ms": first_action_ms,
			"policy_mode": "LEARNING",
			"limit_sec": 120
		},
		"answer": {
			"selected_option_id": selected_id
		},
		"expected": {
			"answer_id": answer_id
		},
		"flags": {
			"silent_reading_possible": silent_reading_possible,
			"scroll_used": scroll_used,
			"answered_without_inspection": answered_without_inspection
		},
		"anti_cheat": current_case.get("anti_cheat", {}),
		"telemetry": {
			"time_to_first_action_ms": first_action_ms,
			"scroll_used": scroll_used,
			"inspect_count": inspect_count,
			"unique_rows_inspected": unique_rows_inspected.size(),
			"last_inspected_row_id": last_inspected_row_id
		}
	}
	GlobalMetrics.register_trial(payload)

func _find_option(selected_id: String) -> Dictionary:
	var options: Array = current_case.get("options", []) as Array
	for opt_v in options:
		if typeof(opt_v) != TYPE_DICTIONARY:
			continue
		var opt: Dictionary = opt_v as Dictionary
		if str(opt.get("id", "")) == selected_id:
			return opt
	return {}

func _register_first_action() -> void:
	if first_action_ts < 0:
		first_action_ts = Time.get_ticks_msec()

func _update_silent_reading_possible_flag() -> void:
	table_has_scroll = _tree_has_vertical_scroll(data_tree)

func _tree_has_vertical_scroll(tree: Tree) -> bool:
	if not is_instance_valid(tree):
		return false
	var stack: Array = [tree]
	while not stack.is_empty():
		var node: Node = stack.pop_back() as Node
		if node is VScrollBar:
			var bar: VScrollBar = node as VScrollBar
			return bar.max_value > 0.0 and bar.page < bar.max_value
		for child in node.get_children():
			stack.append(child)
	return false

func _on_scroll_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP or mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			scroll_used = true
	elif event is InputEventScreenDrag:
		scroll_used = true

func _set_options_locked(locked: bool) -> void:
	for child in options_grid.get_children():
		if child is Button:
			(child as Button).disabled = locked

func _finish_session() -> void:
	trial_locked = true
	typewriter_timer.stop()
	title_label.text = "СЕССИЯ ЗАВЕРШЕНА [A]"
	prompt_label.bbcode_enabled = true
	prompt_label.text = "[b]Тренировка архива завершена.[/b]"
	explain_line.text = ""
	_set_options_locked(true)
	_ensure_exit_button()

func _game_over() -> void:
	trial_locked = true
	typewriter_timer.stop()
	title_label.text = "МИССИЯ ПРОВАЛЕНА [A]"
	prompt_label.bbcode_enabled = true
	prompt_label.text = "[b]Стабильность упала до нуля.[/b]"
	explain_line.text = ""
	_set_options_locked(true)
	_ensure_exit_button()

func _ensure_exit_button() -> void:
	if exit_btn != null and is_instance_valid(exit_btn):
		return
	exit_btn = Button.new()
	exit_btn.text = "ВЫХОД"
	exit_btn.custom_minimum_size = Vector2(140, 48)
	exit_btn.pressed.connect(func() -> void:
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
	)
	$SafeArea/RootLayout/Footer.add_child(exit_btn)

func _show_fatal(text: String) -> void:
	prompt_label.bbcode_enabled = false
	prompt_label.text = text
	trial_locked = true

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_stability_changed(_new_val: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	if is_instance_valid(stability_bar):
		stability_bar.value = GlobalMetrics.stability
	if is_instance_valid(stability_label):
		stability_label.text = "СТАБИЛЬНОСТЬ: %d%%" % int(GlobalMetrics.stability)

func _on_viewport_size_changed() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var is_mobile: bool = viewport_size.x < BREAKPOINT_PX
	desktop_layout.split_offset = int(viewport_size.x * 0.48)
	options_grid.columns = 1 if is_mobile else 2

	if is_mobile:
		if table_section.get_parent() != mobile_layout:
			table_section.reparent(mobile_layout)
		if task_section.get_parent() != mobile_layout:
			task_section.reparent(mobile_layout)
		mobile_layout.move_child(table_section, 0)
		mobile_layout.move_child(task_section, 1)
		mobile_layout.visible = true
		desktop_layout.visible = false
	else:
		if table_section.get_parent() != desktop_layout:
			table_section.reparent(desktop_layout)
		if task_section.get_parent() != desktop_layout:
			task_section.reparent(desktop_layout)
		desktop_layout.move_child(table_section, 0)
		desktop_layout.move_child(task_section, 1)
		desktop_layout.visible = true
		mobile_layout.visible = false
</file>

<file path="scenes/case_07/da7_data_archive_a.tscn">
[gd_scene load_steps=8 format=3 uid="uid://da7archive001"]

[ext_resource type="Script" path="res://scripts/case_07/da7_data_archive_a.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="AudioStream" path="res://audio/error.wav" id="3_error"]
[ext_resource type="AudioStream" path="res://audio/relay.wav" id="4_relay"]
[ext_resource type="AudioStream" path="res://audio/click.wav" id="5_click"]
[ext_resource type="PackedScene" path="res://scenes/ui/ResultStamp.tscn" id="6_stamp"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="7_noir_overlay"]

[node name="DA7_DataArchiveQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="BG" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("7_noir_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 0.0
offset_top = 0.0
offset_right = 0.0
offset_bottom = 0.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 10

[node name="BackRow" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/RootLayout/BackRow"]
custom_minimum_size = Vector2(120, 48)
layout_mode = 2
text = "НАЗАД"

[node name="Header" type="PanelContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_vertical = 0
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="SafeArea/RootLayout/Header"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 5

[node name="Title" type="RichTextLabel" parent="SafeArea/RootLayout/Header/Margin"]
layout_mode = 2
text = "ДЕЛО #7: СЕКРЕТНЫЙ АРХИВ"
fit_content = true
scroll_active = false
autowrap_mode = 0

[node name="Body" type="MarginContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 6

[node name="DesktopLayout" type="HSplitContainer" parent="SafeArea/RootLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 400

[node name="TableSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="TableTitle" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection"]
layout_mode = 2
text = "РЕЖИМ ДАННЫХ // ТОЛЬКО ЧТЕНИЕ"

[node name="DataTree" type="Tree" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection"]
layout_mode = 2
size_flags_vertical = 3
columns = 3
hide_root = true
select_mode = 1

[node name="InspectPanel" type="PanelContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection"]
custom_minimum_size = Vector2(0, 108)
layout_mode = 2

[node name="InspectMargin" type="MarginContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="InspectVBox" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="InspectLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
fit_content = false
scroll_active = false
autowrap_mode = 2
text = "Выберите строку для проверки улики."

[node name="ScanLabel" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox"]
layout_mode = 2
text = "СКАН: 0"

[node name="TaskSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="DossierPanel" type="PanelContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
layout_mode = 2

[node name="DossierMargin" type="MarginContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="DossierVBox" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="CaseTitleLabel" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ФАЙЛ: ACCESS_LOG_07"

[node name="BriefingLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
fit_content = false
scroll_active = false
autowrap_mode = 2
text = "Брифинг..."

[node name="ObjectiveLabel" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ЦЕЛЬ"

[node name="PromptLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
custom_minimum_size = Vector2(0, 84)
layout_mode = 2
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "Загрузка параметров дела..."
fit_content = true

[node name="OptionsGrid" type="GridContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 10
columns = 2

[node name="ExplainLine" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
fit_content = false
scroll_active = false
autowrap_mode = 2
text = ""

[node name="MobileLayout" type="VBoxContainer" parent="SafeArea/RootLayout/Body"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Footer" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 20

[node name="StabilityLabel" type="Label" parent="SafeArea/RootLayout/Footer"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/RootLayout/Footer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 4
step = 1.0
value = 100.0

[node name="ResultStamp" parent="." instance=ExtResource("6_stamp")]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="Runtime" type="Node" parent="."]

[node name="Audio" type="Node" parent="Runtime"]

[node name="SfxClick" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("5_click")

[node name="SfxError" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("3_error")

[node name="SfxRelay" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("4_relay")

[node name="TypewriterTimer" type="Timer" parent="Runtime"]
one_shot = true
wait_time = 0.03

[node name="TelemetryTimer" type="Timer" parent="Runtime"]
</file>

<file path="scenes/LogicQuestA.gd">
extends Control

# --- CONSTANTS & CONFIG ---
const PHASE_TRAINING = "TRAINING"
const PHASE_TRANSLATION = "TRANSLATION"
const PHASE_DETECTION = "DETECTION"

const GATE_AND = "AND"
const GATE_OR = "OR"
const GATE_NOT = "NOT"
const GATE_XOR = "XOR"
const GATE_NAND = "NAND"
const GATE_NOR = "NOR"

const MAX_ATTEMPTS = 3
const VERDICT_LOCK_TIME = 2.0

# Cases Data
const CASES = [
	{
		"id": "A1_01", "phase": PHASE_TRAINING, "gate": GATE_AND,
		"a_text": "КЛЮЧ", "b_text": "СТАРТ",
		"witness_text": "Машина заведется, если есть КЛЮЧ и нажата кнопка СТАРТ.",
		"min_seen": 2, "hints": ["Нужны оба условия.", "Это AND (И)."]
	},
	{
		"id": "A1_02", "phase": PHASE_TRAINING, "gate": GATE_OR,
		"a_text": "ДОЖДЬ", "b_text": "СНЕГ",
		"witness_text": "Вы промокнете, если идет ДОЖДЬ или СНЕГ (зонта нет).",
		"min_seen": 2, "hints": ["Достаточно одного условия.", "Это OR (ИЛИ)."]
	},
	{
		"id": "A1_03", "phase": PHASE_TRAINING, "gate": GATE_AND,
		"a_text": "ПАРОЛЬ", "b_text": "ТЕЛЕФОН",
		"witness_text": "Вход в почту разрешен, если введен ПАРОЛЬ и пройден ТЕЛЕФОН.",
		"min_seen": 2, "hints": ["Нужны оба условия.", "Это AND (И)."]
	},
	{
		"id": "A1_04", "phase": PHASE_TRAINING, "gate": GATE_OR,
		"a_text": "ВЫКЛ_1", "b_text": "ВЫКЛ_2",
		"witness_text": "Свет в коридоре горит, если включен ВЫКЛ_1 или ВЫКЛ_2.",
		"min_seen": 2, "hints": ["Достаточно одного выключателя.", "Это OR (ИЛИ)."]
	},
	{
		"id": "A1_05", "phase": PHASE_TRAINING, "gate": GATE_NOT,
		"a_text": "СИГНАЛ", "b_text": "---",
		"witness_text": "Детектор лжи инвертирует сигнал: если на входе НЕТ, на выходе ДА.",
		"min_seen": 2, "hints": ["Инверсия: 1->0, 0->1.", "Это NOT (НЕ)."]
	},
	{
		"id": "A2_01", "phase": PHASE_TRANSLATION, "gate": GATE_AND,
		"a_text": "A", "b_text": "B",
		"witness_text": "Логическое И обозначается символом &. Найдите его.",
		"min_seen": 2, "hints": ["& это И.", "Конъюнкция."]
	},
	{
		"id": "A2_02", "phase": PHASE_TRANSLATION, "gate": GATE_OR,
		"a_text": "A", "b_text": "B",
		"witness_text": "Логическое ИЛИ обозначается символом ∨. Найдите его.",
		"min_seen": 2, "hints": ["∨ это ИЛИ.", "Дизъюнкция."]
	},
	{
		"id": "A2_03", "phase": PHASE_TRANSLATION, "gate": GATE_NOT,
		"a_text": "A", "b_text": "---",
		"witness_text": "Инверсия обозначается символом ¬. Найдите его.",
		"min_seen": 2, "hints": ["¬ это НЕ.", "Отрицание."]
	},
	{
		"id": "A2_04", "phase": PHASE_TRANSLATION, "gate": GATE_XOR,
		"a_text": "A", "b_text": "B",
		"witness_text": "Исключающее ИЛИ обозначается символом ⊕. Найдите его.",
		"min_seen": 2, "hints": ["⊕ это XOR.", "Истина при разных входах."]
	},
	{
		"id": "A2_05", "phase": PHASE_TRANSLATION, "gate": GATE_NOR,
		"a_text": "A", "b_text": "B",
		"witness_text": "Стрелка Пирса (ИЛИ-НЕ) обозначается символом ⊽.",
		"min_seen": 2, "hints": ["Это инверсия ИЛИ.", "NOR."]
	},
	{
		"id": "A3_01", "phase": PHASE_DETECTION, "gate": GATE_NOR,
		"a_text": "КОД_1", "b_text": "КОД_2",
		"witness_text": "Сейф открылся (1), когда оба кода были неверны (0,0).",
		"min_seen": 3, "hints": ["Выход 1 только при 0,0.", "Это NOR."]
	},
	{
		"id": "A3_02", "phase": PHASE_DETECTION, "gate": GATE_XOR,
		"a_text": "ДАТЧИК_1", "b_text": "ДАТЧИК_2",
		"witness_text": "Сигнализация молчит (0), только когда сигналы совпадают.",
		"min_seen": 3, "hints": ["Истина при разных входах.", "Это XOR."]
	},
	{
		"id": "A3_03", "phase": PHASE_DETECTION, "gate": GATE_NOR,
		"a_text": "РЫЧАГ_1", "b_text": "РЫЧАГ_2",
		"witness_text": "Замок заклинит (0), если нажать хотя бы один рычаг.",
		"min_seen": 3, "hints": ["Выход 1 только при 0,0.", "Это NOR."]
	},
	{
		"id": "A3_04", "phase": PHASE_DETECTION, "gate": GATE_XOR,
		"a_text": "ЧАСТОТА_1", "b_text": "ЧАСТОТА_2",
		"witness_text": "Перехват данных (1) идет только при разных частотах.",
		"min_seen": 3, "hints": ["Разные входы дают 1.", "Это XOR."]
	},
	{
		"id": "A3_05", "phase": PHASE_DETECTION, "gate": GATE_NAND,
		"a_text": "X", "b_text": "Y",
		"witness_text": "Нужен вентиль, дающий ЛОЖЬ только при двух ИСТИНАХ.",
		"min_seen": 3, "hints": ["0 только при 1,1.", "Это NAND."]
	}
]
# --- UI NODES ---
@onready var clue_title_label: Label = $SafeArea/MainLayout/Header/LblClueTitle
@onready var session_label: Label = $SafeArea/MainLayout/Header/LblSessionId
@onready var facts_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/FactsBar
@onready var energy_bar: ProgressBar = $SafeArea/MainLayout/BarsRow/EnergyBar
@onready var target_label: Label = $SafeArea/MainLayout/TargetDisplay/LblTarget
@onready var terminal_text: RichTextLabel = $SafeArea/MainLayout/ContentHSplit/LeftPane/TerminalFrame/TerminalScroll/TerminalRichText
@onready var stats_label: Label = $SafeArea/MainLayout/ContentHSplit/RightPane/StatusRow/StatsLabel
@onready var feedback_label: Label = $SafeArea/MainLayout/ContentHSplit/RightPane/StatusRow/FeedbackLabel

@onready var input_a_frame: PanelContainer = $SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputAFrame
@onready var input_b_frame: PanelContainer = $SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputBFrame
@onready var gate_slot_frame: PanelContainer = $SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/GateSlot
@onready var input_a_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputAFrame/InputAVBox/InputA_Btn
@onready var input_b_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/InputBFrame/InputBVBox/InputB_Btn
@onready var gate_label: Label = $SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/GateSlot/GateVBox/GateLabel
@onready var output_value_label: Label = $SafeArea/MainLayout/ContentHSplit/RightPane/InteractionRow/OutputSlot/OutputVBox/OutputValueLabel
@onready var inventory_frame: PanelContainer = $SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame

@onready var gate_and_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateAndBtn
@onready var gate_or_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateOrBtn
@onready var gate_not_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateNotBtn
@onready var gate_xor_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateXorBtn
@onready var gate_nand_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateNandBtn
@onready var gate_nor_btn: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/InventoryFrame/InventoryMargin/InventoryScroll/GatesContainer/GateNorBtn

@onready var btn_hint: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/Actions/BtnHint
@onready var btn_verdict: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/Actions/BtnVerdict
@onready var btn_next: Button = $SafeArea/MainLayout/ContentHSplit/RightPane/Actions/BtnNext
@onready var diagnostics_blocker: ColorRect = $DiagnosticsBlocker
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanelA
@onready var diagnostics_title: Label = $DiagnosticsPanelA/PopupMargin/PopupVBox/PopupTitle
@onready var diagnostics_text: RichTextLabel = $DiagnosticsPanelA/PopupMargin/PopupVBox/PopupText
@onready var diagnostics_next_button: Button = $DiagnosticsPanelA/PopupMargin/PopupVBox/PopupBtnNext
@onready var click_player: AudioStreamPlayer = $ClickPlayer

# --- STATE ---
var current_case_index: int = 0
var current_case: Dictionary = {}

var input_a: bool = false
var input_b: bool = false
var selected_gate_guess: String = ""

var seen_combinations: Dictionary = {}
var seen_trace_entries: Array[Dictionary] = []
var case_attempts: int = 0
var hints_used: int = 0
var start_time_msec: int = 0
var first_action_ms: int = -1
var verdict_count: int = 0

var last_verdict_time: float = 0.0
var verdict_timer: Timer = null
var is_safe_mode: bool = false
var gate_buttons: Dictionary = {}
var highlighted_step: int = -1

const COLOR_OUTPUT_ON = Color(0.95, 0.95, 0.90, 1.0)
const COLOR_OUTPUT_OFF = Color(0.55, 0.55, 0.55, 1.0)

func _ready() -> void:
	_setup_gate_buttons()
	_update_stability_ui(GlobalMetrics.stability, 0)
	if not GlobalMetrics.stability_changed.is_connected(_update_stability_ui):
		GlobalMetrics.stability_changed.connect(_update_stability_ui)
	if not GlobalMetrics.game_over.is_connected(_on_game_over):
		GlobalMetrics.game_over.connect(_on_game_over)

	verdict_timer = Timer.new()
	verdict_timer.one_shot = true
	verdict_timer.timeout.connect(_on_verdict_unlock)
	add_child(verdict_timer)

	load_case(0)

func _setup_gate_buttons() -> void:
	gate_buttons = {
		GATE_AND: gate_and_btn,
		GATE_OR: gate_or_btn,
		GATE_NOT: gate_not_btn,
		GATE_XOR: gate_xor_btn,
		GATE_NAND: gate_nand_btn,
		GATE_NOR: gate_nor_btn
	}
	_clear_gate_selection()

func load_case(idx: int) -> void:
	if idx >= CASES.size():
		idx = 0

	current_case_index = idx
	current_case = CASES[idx]

	input_a = false
	input_b = false
	selected_gate_guess = ""
	seen_combinations.clear()
	seen_trace_entries.clear()
	case_attempts = 0
	hints_used = 0
	start_time_msec = Time.get_ticks_msec()
	first_action_ms = -1
	verdict_count = 0
	last_verdict_time = 0.0
	is_safe_mode = false

	clue_title_label.text = "ДЕТЕКТОР ЛЖИ A-01"
	_update_stats_ui()
	_hide_diagnostics()

	input_a_btn.button_pressed = false
	input_b_btn.button_pressed = false
	input_a_btn.disabled = false
	input_b_btn.disabled = false
	btn_hint.disabled = false
	btn_verdict.visible = true
	btn_verdict.disabled = true
	btn_next.visible = false
	feedback_label.visible = false
	feedback_label.text = ""

	if current_case.gate == GATE_NOT:
		input_b_frame.visible = false
	else:
		input_b_frame.visible = true

	_set_gate_buttons_enabled(true)
	_clear_gate_selection()
	_update_input_labels()
	_update_circuit()
	_update_ui_state()

func _update_input_labels() -> void:
	input_a_btn.text = "%s\n[%s]" % [str(current_case.get("a_text", "A")), "1" if input_a else "0"]
	if current_case.gate != GATE_NOT:
		input_b_btn.text = "%s\n[%s]" % [str(current_case.get("b_text", "B")), "1" if input_b else "0"]

func _on_input_a_toggled(pressed: bool) -> void:
	_mark_first_action()
	input_a = pressed
	_play_click()
	_update_input_labels()
	_update_circuit()

func _on_input_b_toggled(pressed: bool) -> void:
	_mark_first_action()
	input_b = pressed
	_play_click()
	_update_input_labels()
	_update_circuit()

func _on_gate_button_toggled(arg1: Variant, arg2: Variant = null) -> void:
	var pressed := false
	var gate_id := ""
	if arg1 is bool:
		pressed = arg1
		gate_id = str(arg2)
	else:
		gate_id = str(arg1)
		pressed = bool(arg2)
	if gate_id.is_empty():
		return

	if is_safe_mode:
		return
	if gate_and_btn.disabled:
		return
	if not pressed:
		if selected_gate_guess == gate_id:
			selected_gate_guess = ""
			_update_gate_slot_label()
		return

	_mark_first_action()
	for key in gate_buttons.keys():
		if key != gate_id:
			var btn_other: Button = gate_buttons[key]
			btn_other.set_pressed_no_signal(false)

	selected_gate_guess = gate_id
	_play_click()
	_update_gate_slot_label()

func _update_circuit() -> void:
	var out_val := _calculate_gate_output(input_a, input_b, str(current_case.get("gate", "")))
	output_value_label.text = "F = %s" % ("1" if out_val else "0")
	output_value_label.add_theme_color_override("font_color", COLOR_OUTPUT_ON if out_val else COLOR_OUTPUT_OFF)

	var key := ""
	if current_case.gate == GATE_NOT:
		key = "A=%d" % [1 if input_a else 0]
	else:
		key = "A=%d B=%d" % [1 if input_a else 0, 1 if input_b else 0]

	if not seen_combinations.has(key):
		seen_combinations[key] = out_val
		seen_trace_entries.append({
			"a": 1 if input_a else 0,
			"b": -1 if current_case.gate == GATE_NOT else (1 if input_b else 0),
			"f": 1 if out_val else 0
		})
		_update_stats_ui()

	_update_target_and_bars()
	_update_terminal_text(out_val)
	_update_ui_state()

func _calculate_gate_output(a: bool, b: bool, type: String) -> bool:
	match type:
		GATE_AND:
			return a and b
		GATE_OR:
			return a or b
		GATE_NOT:
			return not a
		GATE_XOR:
			return a != b
		GATE_NAND:
			return not (a and b)
		GATE_NOR:
			return not (a or b)
	return false

func _update_terminal_text(out_val: bool) -> void:
	var lines: Array[String] = []
	lines.append("[b]БРИФИНГ[/b]")
	lines.append(str(current_case.get("witness_text", "")))
	lines.append("")
	lines.append("[b]ШАГИ[/b]")
	lines.append("1) Выставьте входы и соберите факты.")
	lines.append("2) Выберите вентиль в инвентаре.")
	lines.append("3) Нажмите ВЕРДИКТ.")
	lines.append("")
	lines.append("[b]FACTS LOG[/b]")

	if seen_trace_entries.is_empty():
		lines.append("• ЖУРНАЛ ПУСТ")
	else:
		for i in range(seen_trace_entries.size()):
			var entry: Dictionary = seen_trace_entries[i]
			var row := ""
			if int(entry.get("b", -1)) < 0:
				row = "• KEY=%d  =>  F=%d" % [int(entry.get("a", 0)), int(entry.get("f", 0))]
			else:
				row = "• KEY=%d  BTN=%d  =>  F=%d" % [int(entry.get("a", 0)), int(entry.get("b", 0)), int(entry.get("f", 0))]
			if i == seen_trace_entries.size() - 1:
				row = "[color=#f4f2e6]> %s[/color]" % row
			lines.append(row)

	lines.append("")
	lines.append("[b]CURRENT OUTPUT[/b]")
	lines.append("F = %s" % ("1" if out_val else "0"))

	terminal_text.text = "\n".join(lines)

func _update_gate_slot_label() -> void:
	if selected_gate_guess.is_empty():
		gate_label.text = "GATE: ?"
		return
	gate_label.text = "GATE: %s (%s)" % [_gate_symbol(selected_gate_guess), _gate_title(selected_gate_guess)]

func _gate_symbol(gate_id: String) -> String:
	match gate_id:
		GATE_AND:
			return "∧"
		GATE_OR:
			return "∨"
		GATE_NOT:
			return "¬"
		GATE_XOR:
			return "⊕"
		GATE_NAND:
			return "⊼"
		GATE_NOR:
			return "⊽"
		_:
			return "?"

func _gate_title(gate_id: String) -> String:
	match gate_id:
		GATE_AND:
			return "AND"
		GATE_OR:
			return "OR"
		GATE_NOT:
			return "NOT"
		GATE_XOR:
			return "XOR"
		GATE_NAND:
			return "NAND"
		GATE_NOR:
			return "NOR"
		_:
			return "UNKNOWN"

func _set_gate_buttons_enabled(enabled: bool) -> void:
	for gate_id in gate_buttons.keys():
		var gate_btn: Button = gate_buttons[gate_id]
		gate_btn.disabled = not enabled

func _clear_gate_selection() -> void:
	for gate_id in gate_buttons.keys():
		var gate_btn: Button = gate_buttons[gate_id]
		gate_btn.set_pressed_no_signal(false)
	selected_gate_guess = ""
	_update_gate_slot_label()

func _select_gate_button(gate_id: String) -> void:
	_clear_gate_selection()
	if not gate_buttons.has(gate_id):
		return
	var gate_btn: Button = gate_buttons[gate_id]
	gate_btn.set_pressed_no_signal(true)
	selected_gate_guess = gate_id
	_update_gate_slot_label()

func _update_target_and_bars() -> void:
	var min_seen: int = int(current_case.get("min_seen", 2))
	var seen_count: int = seen_combinations.size()
	var ratio := float(seen_count) / float(maxi(1, min_seen))
	facts_bar.value = clampf(ratio * 100.0, 0.0, 100.0)
	energy_bar.value = clampf(GlobalMetrics.stability, 0.0, 100.0)
 
func _update_ui_state() -> void:
	var min_seen: int = int(current_case.get("min_seen", 2))
	var seen_count: int = seen_combinations.size()
	var facts_ready := seen_count >= min_seen
	var gate_ready := not selected_gate_guess.is_empty()
	var has_result := is_safe_mode or not btn_verdict.visible

	if has_result:
		target_label.text = "ШАГ 3/3: анализ завершен, переходите далее"
		btn_verdict.disabled = true
		_set_gate_buttons_enabled(false)
		_pulse_step(3)
		return

	_set_gate_buttons_enabled(facts_ready)
	btn_verdict.disabled = not (facts_ready and gate_ready)

	if not facts_ready:
		target_label.text = "ШАГ 1/3: соберите факты %d/%d" % [seen_count, min_seen]
		_pulse_step(1)
	elif not gate_ready:
		target_label.text = "ШАГ 2/3: выберите вентиль"
		_pulse_step(2)
	else:
		target_label.text = "ШАГ 3/3: вынесите вердикт"
		_pulse_step(3)

func _pulse_step(step: int) -> void:
	if highlighted_step == step:
		return
	highlighted_step = step
	input_a_frame.modulate = Color(1, 1, 1, 1)
	input_b_frame.modulate = Color(1, 1, 1, 1)
	gate_slot_frame.modulate = Color(1, 1, 1, 1)
	inventory_frame.modulate = Color(1, 1, 1, 1)
	btn_verdict.modulate = Color(1, 1, 1, 1)

	var target: CanvasItem = input_a_frame
	if step == 2:
		target = inventory_frame
	elif step == 3:
		target = btn_verdict

	var tween := create_tween()
	tween.tween_property(target, "modulate", Color(1.08, 1.08, 1.04, 1.0), 0.18)
	tween.tween_property(target, "modulate", Color(1, 1, 1, 1), 0.22)

func _on_verdict_pressed() -> void:
	if is_safe_mode:
		return
	if btn_verdict.disabled:
		return
	_mark_first_action()
	verdict_count += 1

	var current_time: float = Time.get_ticks_msec() / 1000.0
	if current_time - last_verdict_time < 0.8:
		_show_feedback("Подождите перед следующим вердиктом.", Color(1.0, 0.62, 0.28))
		_lock_verdict(3.0)
		_register_trial("RATE_LIMITED", false)
		return
	last_verdict_time = current_time

	if selected_gate_guess.is_empty():
		_show_feedback("СНАЧАЛА ВЫБЕРИТЕ ВЕНТИЛЬ", Color(1.0, 0.86, 0.32))
		_register_trial("EMPTY_SELECTION", false)
		return

	if selected_gate_guess == current_case.gate:
		_show_feedback("ДОСТУП РАЗРЕШЁН", Color(0.45, 0.92, 0.62))
		btn_verdict.visible = false
		btn_next.visible = true
		_disable_controls()
		_register_trial("SUCCESS", true)
	else:
		case_attempts += 1
		_update_stats_ui()

		var penalty := 10.0
		if case_attempts == 2:
			penalty = 15.0
		elif case_attempts >= 3:
			penalty = 25.0

		_apply_penalty(penalty)
		_show_feedback("ДОСТУП ЗАПРЕЩЁН (-%d)" % int(penalty), Color(1.0, 0.35, 0.32))
		var verdict_code := "WRONG_GATE"
		if case_attempts >= MAX_ATTEMPTS:
			_enter_safe_mode()
			verdict_code = "SAFE_MODE_TRIGGERED"
		_register_trial(verdict_code, false)

func _lock_verdict(duration: float) -> void:
	if is_safe_mode:
		return
	btn_verdict.disabled = true
	verdict_timer.start(duration)

func _on_verdict_unlock() -> void:
	if is_safe_mode:
		return
	if GlobalMetrics.stability > 0.0:
		btn_verdict.disabled = false

func _enter_safe_mode() -> void:
	is_safe_mode = true
	_disable_controls()
	btn_verdict.disabled = true
	btn_next.visible = true

	_set_gate_buttons_enabled(false)
	_select_gate_button(str(current_case.get("gate", "")))

	var gate_symbol := _gate_symbol(str(current_case.get("gate", "")))
	var gate_title := _gate_title(str(current_case.get("gate", "")))
	var safe_msg := "БЕЗОПАСНЫЙ РЕЖИМ: правильный вентиль %s (%s)." % [gate_symbol, gate_title]
	_show_feedback(safe_msg, Color(1.0, 0.74, 0.32))
	_show_diagnostics("SAFE MODE", "%s\nВыполнен авторазбор, изучите журнал и переходите далее." % safe_msg)
	_update_ui_state()

func _show_diagnostics(title: String, message: String) -> void:
	diagnostics_title.text = title
	diagnostics_text.text = message
	diagnostics_blocker.visible = true
	diagnostics_panel.visible = true
	diagnostics_next_button.grab_focus()

func _hide_diagnostics() -> void:
	diagnostics_blocker.visible = false
	diagnostics_panel.visible = false

func _on_diagnostics_close_pressed() -> void:
	_hide_diagnostics()

func _show_feedback(msg: String, col: Color) -> void:
	feedback_label.text = msg
	feedback_label.add_theme_color_override("font_color", col)
	feedback_label.visible = true
	_update_ui_state()

func _apply_penalty(amount: float) -> void:
	GlobalMetrics.stability = max(0.0, GlobalMetrics.stability - amount)
	GlobalMetrics.stability_changed.emit(GlobalMetrics.stability, -amount)

func _update_stability_ui(val: float, _change: float) -> void:
	energy_bar.value = clampf(val, 0.0, 100.0)
	_update_stats_ui()
	_update_ui_state()

func _update_stats_ui() -> void:
	var min_seen: int = int(current_case.get("min_seen", 2))
	var case_id := str(current_case.get("id", "A_00"))
	session_label.text = "СЕССИЯ: %02d/%02d • CASE %s" % [current_case_index + 1, CASES.size(), case_id]
	stats_label.text = "ПОП: %d/%d • ФАКТЫ: %d/%d • СТАБ: %d%%" % [
		case_attempts,
		MAX_ATTEMPTS,
		seen_combinations.size(),
		min_seen,
		int(GlobalMetrics.stability)
	]
	_update_target_and_bars()
	_update_ui_state()

func _on_game_over() -> void:
	_enter_safe_mode()

func _on_back_button_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_next_button_pressed() -> void:
	_hide_diagnostics()
	load_case(current_case_index + 1)

func _on_hint_pressed() -> void:
	_mark_first_action()
	if hints_used < current_case.hints.size():
		var h := str(current_case.hints[hints_used])
		hints_used += 1
		_show_feedback("ПОДСКАЗКА: " + h, Color(0.56, 0.78, 0.96))
		_apply_penalty(5.0)
	else:
		_show_feedback("ПОДСКАЗОК БОЛЬШЕ НЕТ", Color(0.66, 0.66, 0.66))

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - start_time_msec

func _register_trial(verdict_code: String, is_correct: bool) -> void:
	var case_id := str(current_case.get("id", "A_00"))
	var payload := TrialV2.build("LOGIC_QUEST", "A", case_id, "GATE_IDENTIFY")
	var elapsed_ms: int = maxi(0, Time.get_ticks_msec() - start_time_msec)
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_correct
	payload["is_fit"] = is_correct
	payload["stability_delta"] = 0
	payload["verdict_code"] = verdict_code
	payload["selected_gate_id"] = selected_gate_guess
	payload["correct_gate_id"] = str(current_case.get("gate", ""))
	payload["seen_combinations"] = seen_combinations.size()
	payload["hints_used"] = hints_used
	payload["attempts"] = case_attempts
	payload["verdict_count"] = verdict_count
	GlobalMetrics.register_trial(payload)

func _play_click() -> void:
	if click_player.stream:
		click_player.play()

func _disable_controls() -> void:
	input_a_btn.disabled = true
	input_b_btn.disabled = true
	_set_gate_buttons_enabled(false)
	btn_hint.disabled = true
</file>

<file path="scenes/case_07/da7_data_archive_b.tscn">
[gd_scene load_steps=7 format=3 uid="uid://da7archive002"]

[ext_resource type="Script" path="res://scripts/case_07/da7_data_archive_b.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="AudioStream" path="res://audio/error.wav" id="3_error"]
[ext_resource type="AudioStream" path="res://audio/relay.wav" id="4_relay"]
[ext_resource type="Script" path="res://scripts/ui/ConnectorOverlay.gd" id="5_connector"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="6_noir_overlay"]

[node name="DA7_DataArchiveQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="BG" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("6_noir_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 0.0
offset_top = 0.0
offset_right = 0.0
offset_bottom = 0.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 10

[node name="BackRow" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/RootLayout/BackRow"]
custom_minimum_size = Vector2(120, 48)
layout_mode = 2
text = "НАЗАД"

[node name="Header" type="PanelContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_vertical = 0
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="SafeArea/RootLayout/Header"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 5

[node name="Title" type="RichTextLabel" parent="SafeArea/RootLayout/Header/Margin"]
layout_mode = 2
text = "ДЕЛО #7: СЕКРЕТНЫЙ АРХИВ [УРОВЕНЬ B]"
fit_content = true
scroll_active = false
autowrap_mode = 0

[node name="Body" type="VBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 0

[node name="FilterModeRoot" type="HSplitContainer" parent="SafeArea/RootLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 400

[node name="TableSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/FilterModeRoot"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="TableTitle" type="Label" parent="SafeArea/RootLayout/Body/FilterModeRoot/TableSection"]
layout_mode = 2
text = "РЕЖИМ ФИЛЬТРА // МУЛЬТИВЫБОР"

[node name="DataTree" type="Tree" parent="SafeArea/RootLayout/Body/FilterModeRoot/TableSection"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
columns = 3
hide_root = true
select_mode = 1

[node name="TaskSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/FilterModeRoot"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PromptLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "Загрузка параметров дела..."
fit_content = true

[node name="ControlRow" type="HBoxContainer" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 1

[node name="BtnClear" type="Button" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow"]
custom_minimum_size = Vector2(140, 56)
layout_mode = 2
text = "ОЧИСТИТЬ [X]"

[node name="BtnSubmit" type="Button" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
text = "ОТПРАВИТЬ [ВВОД]"

[node name="RelationModeRoot" type="VBoxContainer" parent="SafeArea/RootLayout/Body"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PromptLabelRel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
text = "Анализ связи..."
fit_content = true

[node name="SchemaContainer" type="HBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
alignment = 1

[node name="LeftTable" type="VBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable"]
layout_mode = 2
text = "Таблица A"
horizontal_alignment = 1

[node name="TreeL" type="Tree" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
hide_root = true

[node name="CenterConnector" type="VBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer"]
layout_mode = 2
alignment = 1

[node name="ArrowLabel" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector"]
layout_mode = 2
horizontal_alignment = 1
text = ""

[node name="ArrowLine" type="ColorRect" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector"]
custom_minimum_size = Vector2(96, 3)
layout_mode = 2
color = Color(0.88, 0.64, 0.16, 1)

[node name="HintLabel" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector"]
layout_mode = 2
theme_override_colors/font_color = Color(0.6, 0.6, 0.6, 1)
text = "FK ссылка"

[node name="RightTable" type="VBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable"]
layout_mode = 2
text = "Таблица B"
horizontal_alignment = 1

[node name="TreeR" type="Tree" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
hide_root = true

[node name="OptionsRow" type="HBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 1

[node name="ConnectorOverlay" type="Control" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("5_connector")

[node name="Footer" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 20

[node name="StabilityLabel" type="Label" parent="SafeArea/RootLayout/Footer"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/RootLayout/Footer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 4
step = 1.0
value = 100.0

[node name="Runtime" type="Node" parent="."]

[node name="Audio" type="Node" parent="Runtime"]

[node name="SfxClick" type="AudioStreamPlayer" parent="Runtime/Audio"]

[node name="SfxError" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("3_error")

[node name="SfxRelay" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("4_relay")

[node name="TypewriterTimer" type="Timer" parent="Runtime"]
wait_time = 0.06

[node name="TelemetryTimer" type="Timer" parent="Runtime"]
</file>

<file path="scenes/CityMapQuestA.gd">
extends Control

const PACK_PATH := "res://data/city_map/pack_6_1_A.json"
const LOG_PREFIX := "case_6_1"
const DEFAULT_ACCENT := Color(0.40, 0.72, 1.0, 1.0)
const ARROW_ANGLE_RAD := 0.52
const ARROW_LEN := 16.0

@onready var content_split: SplitContainer = $SafeArea/MainVBox/ContentSplit
@onready var graph_container: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer
@onready var edges_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/EdgesLayer
@onready var nodes_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/NodesLayer
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack
@onready var label_progress: Label = $SafeArea/MainVBox/Header/LabelProgress
@onready var btn_reset: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnReset
@onready var btn_submit: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnSubmit
@onready var btn_next: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnNext
@onready var sum_input: LineEdit = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumInput
@onready var path_display: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/PathDisplay
@onready var sum_live_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumLiveLabel
@onready var status_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/StatusLabel
@onready var label_state: Label = $SafeArea/MainVBox/Header/LabelState
@onready var label_timer: Label = $SafeArea/MainVBox/Header/LabelTimer
@onready var footer_label: Label = $SafeArea/MainVBox/Footer/FooterLabel
@onready var briefing_title: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingTitle
@onready var briefing_text: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingText

var level_data: Dictionary = {}
var pack_data: Dictionary = {}
var pack_levels: Array = []
var node_defs: Dictionary = {}
var adjacency: Dictionary = {}
var edge_visuals: Dictionary = {}
var node_buttons: Dictionary = {}
var config_hash: String = ""
var input_regex := RegEx.new()
var pack_id: String = "CITY_MAP_A_PACK_01"
var level_index: int = 0
var level_total: int = 0
var run_id: String = ""
var run_started_unix: int = 0
var attempt_in_sublevel: int = 0
var attempt_in_run: int = 0
var levels_completed: int = 0
var levels_perfect: int = 0
var run_total_time_seconds: int = 0
var run_total_calc_errors: int = 0
var run_total_opt_errors: int = 0
var run_total_parse_errors: int = 0
var run_total_resets: int = 0

var min_sum: int = 0
var accent_color: Color = DEFAULT_ACCENT
var node_radius_px: float = 25.0

var current_node: String = ""
var path: Array[String] = []
var path_sum: int = 0
var stability: float = 100.0
var t_elapsed_seconds: int = 0
var is_game_over: bool = false
var stage_completed: bool = false
var input_locked: bool = false
var first_attempt_edge: String = ""
var level_started_ms: int = 0
var first_action_ms: int = -1

var n_calc: int = 0
var n_opt: int = 0
var n_parse: int = 0
var n_reset: int = 0

func _ready() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	sum_input.text_changed.connect(_on_sum_input_changed)
	graph_container.resized.connect(_on_graph_resized)

	_load_pack(PACK_PATH)
	_apply_content_layout_mode()
	_setup_timer()
	call_deferred("_start_pack_run")

func _start_pack_run() -> void:
	run_started_unix = int(Time.get_unix_time_from_system())
	run_id = "CITYMAP_%s_%d" % ["A", run_started_unix]
	level_index = 0
	attempt_in_run = 0
	levels_completed = 0
	levels_perfect = 0
	run_total_time_seconds = 0
	run_total_calc_errors = 0
	run_total_opt_errors = 0
	run_total_parse_errors = 0
	run_total_resets = 0
	_load_sublevel(level_index)

func _load_pack(pack_path: String) -> void:
	pack_data.clear()
	pack_levels.clear()
	level_total = 0

	var file := FileAccess.open(pack_path, FileAccess.READ)
	if file == null:
		push_error("Failed to open pack data: %s" % pack_path)
		pack_levels = [{"id": "6_1_01", "path": "res://data/city_map/level_6_1.json"}]
		level_total = pack_levels.size()
		return

	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid pack JSON in %s" % pack_path)
		pack_levels = [{"id": "6_1_01", "path": "res://data/city_map/level_6_1.json"}]
		level_total = pack_levels.size()
		return

	pack_data = parsed
	pack_id = str(pack_data.get("pack_id", "CITY_MAP_A_PACK_01"))
	var raw_levels: Array = pack_data.get("levels", [])
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_entry: Dictionary = level_var
		if str(level_entry.get("path", "")).is_empty():
			continue
		pack_levels.append(level_entry)

	if pack_levels.is_empty():
		pack_levels = [{"id": "6_1_01", "path": "res://data/city_map/level_6_1.json"}]
	level_total = pack_levels.size()

func _load_sublevel(index: int) -> void:
	if index < 0 or index >= pack_levels.size():
		return

	level_index = index
	var level_entry := _current_level_entry()
	var level_path := str(level_entry.get("path", ""))
	if level_path.is_empty():
		push_error("Missing level path in pack entry at index %d" % index)
		return

	_load_level_data(level_path)
	attempt_in_sublevel = 0
	is_game_over = false
	stage_completed = false
	input_locked = false
	n_calc = 0
	n_opt = 0
	n_parse = 0
	n_reset = 0
	t_elapsed_seconds = 0

	_set_briefing()
	_rebuild_graph_ui()
	_reset_round_state(true)
	_lock_input(false)
	_update_timer_display()
	_recalculate_stability()
	if is_game_over:
		return
	btn_next.visible = false
	btn_next.disabled = true
	_set_progress_ui()

func _current_level_entry() -> Dictionary:
	if level_index < 0 or level_index >= pack_levels.size():
		return {}
	var level_var: Variant = pack_levels[level_index]
	if typeof(level_var) != TYPE_DICTIONARY:
		return {}
	return level_var

func _set_progress_ui() -> void:
	var shown_index := maxi(1, level_index + 1)
	var total := maxi(1, level_total)
	var level_entry := _current_level_entry()
	var sub_id := str(level_entry.get("id", ""))
	label_progress.text = "ЗАДАНИЕ: %d/%d%s" % [shown_index, total, ("" if sub_id.is_empty() else " • " + sub_id)]
	if level_index >= total - 1:
		btn_next.text = "ЗАВЕРШИТЬ"
	else:
		btn_next.text = "ДАЛЕЕ"

func _is_round_locked() -> bool:
	return is_game_over or stage_completed or input_locked

func _lock_input(locked: bool) -> void:
	input_locked = locked
	sum_input.editable = not locked and not is_game_over and not stage_completed
	btn_submit.disabled = locked or is_game_over or stage_completed
	btn_reset.disabled = locked or is_game_over or stage_completed
	_update_visuals()

func _on_next_pressed() -> void:
	if not stage_completed:
		return
	if level_index + 1 >= level_total:
		_finalize_pack_run()
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return
	_load_sublevel(level_index + 1)

func _finalize_pack_run() -> void:
	var summary := {
		"schema_version": "city_map.run.v1",
		"quest_id": "CITY_MAP",
		"mode": "A",
		"run_id": run_id,
		"pack_id": pack_id,
		"levels_total": level_total,
		"levels_completed": levels_completed,
		"levels_perfect": levels_perfect,
		"total_time_seconds": run_total_time_seconds,
		"total_calc_errors": run_total_calc_errors,
		"total_opt_errors": run_total_opt_errors,
		"total_parse_errors": run_total_parse_errors,
		"total_reset_errors": run_total_resets,
		"finished_at_unix": int(Time.get_unix_time_from_system())
	}
	_save_json_log(summary, true)

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_content_layout_mode()
		_rebuild_graph_ui()
		_update_visuals()
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_OUT:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = true
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_IN:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = false

func _apply_content_layout_mode() -> void:
	content_split.vertical = get_viewport_rect().size.x < get_viewport_rect().size.y

func _setup_timer() -> void:
	var timer := Timer.new()
	timer.name = "ResearchTimer"
	timer.wait_time = 1.0
	timer.autostart = true
	timer.timeout.connect(_on_timer_tick)
	add_child(timer)

func _on_timer_tick() -> void:
	if is_game_over or stage_completed or level_data.is_empty():
		return
	t_elapsed_seconds += 1
	_update_timer_display()
	if t_elapsed_seconds > int(level_data.get("time_limit_sec", 120)):
		_recalculate_stability()

func _load_level_data(path_to_file: String) -> void:
	var file := FileAccess.open(path_to_file, FileAccess.READ)
	if file == null:
		push_error("Failed to open level data: %s" % path_to_file)
		return

	var raw_json := file.get_as_text()
	config_hash = raw_json.sha256_text()
	var parsed: Variant = JSON.parse_string(raw_json)
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid level JSON in %s" % path_to_file)
		return

	level_data = parsed
	node_defs.clear()
	adjacency.clear()

	for node_var in level_data.get("nodes", []):
		var node: Dictionary = node_var
		node_defs[str(node.get("id", ""))] = node

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty():
			continue
		if not adjacency.has(from_id):
			adjacency[from_id] = {}
		adjacency[from_id][to_id] = int(edge.get("w", 0))

	input_regex = RegEx.new()
	var regex_pattern := "^[0-9]+$"
	if level_data.has("rules") and level_data.rules.has("input_regex"):
		regex_pattern = str(level_data.rules.input_regex)
	input_regex.compile(regex_pattern)

	min_sum = int(level_data.get("min_sum", -1))
	if min_sum < 0:
		min_sum = _calculate_min_sum()

	if level_data.has("ui"):
		if level_data.ui.has("accent_color"):
			accent_color = Color(level_data.ui.accent_color)
		if level_data.ui.has("node_radius_px"):
			var raw_radius := float(level_data.ui.node_radius_px)
			node_radius_px = raw_radius * 0.5 if raw_radius > 32.0 else raw_radius
			node_radius_px = maxf(16.0, node_radius_px)

func _set_briefing() -> void:
	briefing_title.text = "АУДИТ МАРШРУТА"
	briefing_text.text = "Доберитесь до узла E по направленным дорогам. Введите итоговую сумму пути и отправьте. Проходит только минимальный маршрут."
	footer_label.text = "Ориентированный граф: нажимать можно только исходящие дороги из текущего узла."

func _calculate_min_sum() -> int:
	var start_node := str(level_data.get("start_node", ""))
	var end_node := str(level_data.get("end_node", ""))
	if start_node.is_empty() or end_node.is_empty():
		return 0

	var dist: Dictionary = {}
	var unvisited: Array[String] = []
	for node_id in node_defs.keys():
		dist[node_id] = 1_000_000_000
		unvisited.append(node_id)
	dist[start_node] = 0

	while not unvisited.is_empty():
		var current := ""
		var best := 1_000_000_000
		for node_id in unvisited:
			var value := int(dist.get(node_id, 1_000_000_000))
			if value < best:
				best = value
				current = node_id

		if current.is_empty() or current == end_node:
			break
		unvisited.erase(current)

		var neighbors: Dictionary = adjacency.get(current, {})
		for next_id in neighbors.keys():
			var alt := best + int(neighbors[next_id])
			if alt < int(dist.get(next_id, 1_000_000_000)):
				dist[next_id] = alt

	var result := int(dist.get(end_node, 1_000_000_000))
	return 0 if result >= 1_000_000_000 else result

func _on_graph_resized() -> void:
	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return
	_rebuild_graph_ui()
	_update_visuals()

func _rebuild_graph_ui() -> void:
	for child in edges_layer.get_children():
		child.queue_free()
	for child in nodes_layer.get_children():
		child.queue_free()
	edge_visuals.clear()
	node_buttons.clear()

	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty() or not node_defs.has(from_id) or not node_defs.has(to_id):
			continue

		var start_pos := _node_screen_pos(node_defs[from_id])
		var end_pos := _node_screen_pos(node_defs[to_id])

		var line := Line2D.new()
		line.width = 4.0
		line.points = PackedVector2Array([start_pos, end_pos])
		line.gradient = _build_gradient(Color(0.18, 0.22, 0.30, 0.28), Color(0.30, 0.38, 0.52, 0.48))
		edges_layer.add_child(line)

		var arrow := _create_arrow_polygon(start_pos, end_pos)
		edges_layer.add_child(arrow)

		var label := Label.new()
		label.text = str(edge.get("w", 0))
		label.add_theme_font_size_override("font_size", 15)
		label.position = _edge_label_pos(start_pos, end_pos)
		label.add_theme_color_override("font_color", Color(0.62, 0.74, 0.90))
		edges_layer.add_child(label)

		var key := _edge_key(from_id, to_id)
		edge_visuals[key] = {
			"line": line,
			"arrow": arrow,
			"label": label
		}

	for node_id in node_defs.keys():
		var node: Dictionary = node_defs[node_id]
		var btn := Button.new()
		btn.text = str(node.get("label", node_id))
		var diameter := node_radius_px * 2.0
		btn.size = Vector2(diameter, diameter)
		btn.position = _node_screen_pos(node) - Vector2(node_radius_px, node_radius_px)
		btn.pressed.connect(_on_node_pressed.bind(node_id))
		nodes_layer.add_child(btn)
		node_buttons[node_id] = btn

func _edge_label_pos(start_pos: Vector2, end_pos: Vector2) -> Vector2:
	var dir := (end_pos - start_pos).normalized()
	var normal := Vector2(-dir.y, dir.x)
	return ((start_pos + end_pos) * 0.5) + (normal * 12.0) - Vector2(10.0, 10.0)

func _create_arrow_polygon(start_pos: Vector2, end_pos: Vector2) -> Polygon2D:
	var dir := (end_pos - start_pos).normalized()
	var tip := end_pos - dir * (node_radius_px + 4.0)
	var base := tip - dir * ARROW_LEN
	var side_len := ARROW_LEN * 0.65

	var polygon := Polygon2D.new()
	polygon.polygon = PackedVector2Array([
		tip,
		base + dir.rotated(ARROW_ANGLE_RAD) * side_len,
		base + dir.rotated(-ARROW_ANGLE_RAD) * side_len
	])
	polygon.color = Color(0.45, 0.66, 0.96, 0.95)
	return polygon

func _build_gradient(start_color: Color, end_color: Color) -> Gradient:
	var gradient := Gradient.new()
	gradient.set_color(0, start_color)
	gradient.set_color(1, end_color)
	return gradient

func _node_screen_pos(node_data: Dictionary) -> Vector2:
	var pos: Dictionary = node_data.get("pos", {})
	var x := float(pos.get("x", 0.0))
	var y := float(pos.get("y", 0.0))

	if x >= 0.0 and x <= 1.0 and y >= 0.0 and y <= 1.0:
		var padding := node_radius_px + 4.0
		var usable := graph_container.size - Vector2(padding * 2.0, padding * 2.0)
		usable.x = maxf(1.0, usable.x)
		usable.y = maxf(1.0, usable.y)
		return Vector2(padding + x * usable.x, padding + y * usable.y)

	return Vector2(x, y)

func _reset_round_state(full_reset: bool) -> void:
	current_node = str(level_data.get("start_node", "A"))
	path = [current_node]
	path_sum = 0
	sum_input.clear()
	status_label.text = ""
	first_action_ms = -1
	first_attempt_edge = ""

	if full_reset:
		level_started_ms = Time.get_ticks_msec()

	_update_visuals()

func _update_visuals() -> void:
	path_display.text = "ПУТЬ: %s" % " -> ".join(path)
	sum_live_label.text = "СУММА: %d" % path_sum

	for node_id in node_buttons.keys():
		var btn: Button = node_buttons[node_id]
		var is_current: bool = node_id == current_node
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(node_id)
		btn.disabled = is_current or not is_available or _is_round_locked()
		if is_current:
			btn.modulate = Color(0.95, 0.86, 0.45)
		elif is_available:
			btn.modulate = Color(1, 1, 1)
		else:
			btn.modulate = Color(0.42, 0.46, 0.56)

	for key in edge_visuals.keys():
		_set_edge_style(key, "dim")

	if adjacency.has(current_node):
		for next_id in adjacency[current_node].keys():
			_set_edge_style(_edge_key(current_node, str(next_id)), "available")

	for i in range(path.size() - 1):
		_set_edge_style(_edge_key(path[i], path[i + 1]), "traversed")

func _set_edge_style(key: String, state: String) -> void:
	if not edge_visuals.has(key):
		return

	var visual: Dictionary = edge_visuals[key]
	var line: Line2D = visual["line"]
	var arrow: Polygon2D = visual["arrow"]
	var label: Label = visual["label"]

	var start_color := Color(0.18, 0.22, 0.30, 0.28)
	var end_color := Color(0.30, 0.38, 0.52, 0.48)

	if state == "available":
		start_color = Color(0.24, 0.40, 0.62, 0.48)
		end_color = accent_color
		end_color.a = 0.95
	elif state == "traversed":
		start_color = accent_color.lightened(0.10)
		start_color.a = 0.80
		end_color = Color(0.92, 0.97, 1.0, 1.0)

	line.gradient = _build_gradient(start_color, end_color)
	arrow.color = end_color
	label.add_theme_color_override("font_color", end_color.lightened(0.10))

func _edge_key(from_id: String, to_id: String) -> String:
	return "%s->%s" % [from_id, to_id]

func _on_node_pressed(node_id: String) -> void:
	if _is_round_locked():
		return
	if not adjacency.has(current_node) or not adjacency[current_node].has(node_id):
		return

	if first_attempt_edge.is_empty():
		first_attempt_edge = _edge_key(current_node, node_id)
		first_action_ms = Time.get_ticks_msec() - level_started_ms

	path_sum += int(adjacency[current_node][node_id])
	path.append(node_id)
	current_node = node_id
	_update_visuals()

func _on_reset_pressed() -> void:
	if _is_round_locked():
		return
	n_reset += 1
	_reset_round_state(false)
	_recalculate_stability()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_sum_input_changed(new_text: String) -> void:
	var digits := ""
	for ch in new_text:
		if ch >= "0" and ch <= "9":
			digits += ch
	if digits != new_text:
		sum_input.text = digits
		sum_input.caret_column = digits.length()

func _on_submit_pressed() -> void:
	if _is_round_locked():
		return

	attempt_in_sublevel += 1
	attempt_in_run += 1
	var verdict := _judge_solution(sum_input.text.strip_edges())
	_log_attempt(verdict)

	if verdict.result_code == "OK":
		status_label.text = "Маршрут принят. Оптимальная сумма подтверждена."
		status_label.add_theme_color_override("font_color", Color(0.38, 1.0, 0.62))
		stage_completed = true
		levels_completed += 1
		run_total_time_seconds += t_elapsed_seconds
		run_total_calc_errors += n_calc
		run_total_opt_errors += n_opt
		run_total_parse_errors += n_parse
		run_total_resets += n_reset
		if attempt_in_sublevel == 1:
			levels_perfect += 1
		btn_next.visible = true
		btn_next.disabled = false
		_lock_input(true)
		_set_progress_ui()
		return

	status_label.text = _result_message(str(verdict.result_code))
	status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.28))
	_recalculate_stability()

func _result_message(result_code: String) -> String:
	match result_code:
		"ERR_INCOMPLETE":
			return "Дойдите до узла E перед отправкой."
		"ERR_PARSE":
			return "Вводите только цифры."
		"ERR_CALC":
			return "Введённая сумма не совпадает с выбранным маршрутом."
		"ERR_NOT_OPT":
			return "Маршрут корректный, но не оптимальный."
		"ERR_PATH_INVALID":
			return "Маршрут недопустим для ориентированных рёбер."
		_:
			return "Необработанный результат: %s" % result_code

func _judge_solution(input_text: String) -> Dictionary:
	var sum_actual := _compute_path_sum()
	var sum_input_value: Variant = null
	var result_code := "OK"

	if sum_actual < 0:
		result_code = "ERR_PATH_INVALID"
	elif current_node != str(level_data.get("end_node", "E")):
		result_code = "ERR_INCOMPLETE"
	elif input_regex.search(input_text) == null:
		n_parse += 1
		result_code = "ERR_PARSE"
	else:
		sum_input_value = int(input_text)
		if int(sum_input_value) != sum_actual:
			n_calc += 1
			result_code = "ERR_CALC"
		elif sum_actual != min_sum:
			n_opt += 1
			result_code = "ERR_NOT_OPT"

	return {
		"result_code": result_code,
		"sum_actual": sum_actual,
		"sum_input": sum_input_value
	}

func _compute_path_sum() -> int:
	var total := 0
	for i in range(path.size() - 1):
		var from_id := path[i]
		var to_id := path[i + 1]
		if not adjacency.has(from_id) or not adjacency[from_id].has(to_id):
			return -1
		total += int(adjacency[from_id][to_id])
	return total

func _recalculate_stability() -> void:
	var trust_cfg: Dictionary = level_data.get("trust", {})
	var overtime_div := int(trust_cfg.get("overtime_div", 2))
	overtime_div = maxi(1, overtime_div)
	var overtime: int = maxi(0, t_elapsed_seconds - int(level_data.get("time_limit_sec", 120)))
	var overtime_penalty := int(floor(float(overtime) / float(overtime_div)))

	var penalties := (
		n_calc * int(trust_cfg.get("penalty_calc", 25))
		+ n_opt * int(trust_cfg.get("penalty_opt", 25))
		+ n_parse * int(trust_cfg.get("penalty_parse", 5))
		+ n_reset * int(trust_cfg.get("penalty_reset", 5))
		+ overtime_penalty
	)

	stability = clampf(float(trust_cfg.get("initial", 100)) - float(penalties), 0.0, 100.0)
	label_state.text = "СТАБИЛЬНОСТЬ: %d%%" % int(stability)

	if stability <= 10.0 and not is_game_over:
		is_game_over = true
		stage_completed = false
		status_label.text = "МИССИЯ ПРОВАЛЕНА: КРИТИЧЕСКАЯ СТАБИЛЬНОСТЬ."
		status_label.add_theme_color_override("font_color", Color(1.0, 0.30, 0.30))
		btn_next.visible = false
		btn_next.disabled = true
		_lock_input(true)

func _update_timer_display() -> void:
	var time_limit := int(level_data.get("time_limit_sec", 120))
	var remaining: int = maxi(0, time_limit - t_elapsed_seconds)
	var mm: int = remaining / 60
	var ss: int = remaining % 60
	label_timer.text = "ВРЕМЯ: %02d:%02d" % [mm, ss]
	if t_elapsed_seconds > time_limit:
		label_timer.add_theme_color_override("font_color", Color(1.0, 0.36, 0.36))
	else:
		label_timer.add_theme_color_override("font_color", Color(1, 1, 1))

func _log_attempt(verdict: Dictionary) -> void:
	var sum_actual := int(verdict.get("sum_actual", -1))
	var sum_input_value: Variant = verdict.get("sum_input", null)
	var result_code := str(verdict.get("result_code", "ERR_UNKNOWN"))
	var level_entry := _current_level_entry()
	var sublevel_id := str(level_entry.get("id", "6_1_%02d" % (level_index + 1)))
	var sublevel_path := str(level_entry.get("path", ""))
	var next_available := result_code == "OK" and level_index + 1 < level_total

	var attempt_no := GlobalMetrics.session_history.size() + 1
	var log_data := {
		"schema_version": "city_map.v2.2.0",
		"quest_id": "CITY_MAP",
		"stage": "A",
		"task_id": str(level_data.get("level_id", "6_1")),
		"run_id": run_id,
		"pack_id": pack_id,
		"sublevel_index": level_index + 1,
		"sublevel_total": level_total,
		"sublevel_id": sublevel_id,
		"sublevel_path": sublevel_path,
		"attempt_in_sublevel": attempt_in_sublevel,
		"attempt_in_run": attempt_in_run,
		"next_available": next_available,
		"match_key": "CITY_MAP|A|%s|v%s" % [str(level_data.get("level_id", "6_1")), config_hash.substr(0, 8)],
		"variant_hash": config_hash,
		"contract_version": str(level_data.get("contract_version", "city_map.v2.1.0")),
		"attempt_no": attempt_no,
		"result_code": result_code,
		"calc_ok": sum_input_value != null and int(sum_input_value) == sum_actual,
		"optimal_ok": sum_actual == min_sum and result_code == "OK",
		"first_attempt_edge": null if first_attempt_edge.is_empty() else first_attempt_edge,
		"t_elapsed_seconds": t_elapsed_seconds,
		"path": path.duplicate(),
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"min_sum": min_sum,
		"stability_final": int(stability),
		"n_calc": n_calc,
		"n_opt": n_opt,
		"n_parse": n_parse,
		"n_reset": n_reset,
		"is_correct": result_code == "OK",
		"is_fit": result_code == "OK",
		"stability_delta": 0,
		"elapsed_ms": t_elapsed_seconds * 1000,
		"duration": float(t_elapsed_seconds),
		"time_to_first_action_ms": first_action_ms if first_action_ms >= 0 else t_elapsed_seconds * 1000,
		"error_type": "NONE" if result_code == "OK" else result_code
	}

	GlobalMetrics.register_trial(log_data)
	_save_json_log(log_data)

func _save_json_log(data: Dictionary, is_summary: bool = false) -> void:
	var dir := DirAccess.open("user://")
	if dir == null:
		return
	if not dir.dir_exists("research_logs"):
		dir.make_dir("research_logs")

	var stamp_msec: int = Time.get_ticks_msec()
	var attempt_tag := ""
	if data.has("attempt_in_run"):
		attempt_tag = "_a%s" % str(data.get("attempt_in_run"))

	var filename := "user://research_logs/%s_%s_%d%s.json" % [LOG_PREFIX, run_id, stamp_msec, attempt_tag]
	if is_summary:
		filename = "user://research_logs/%s_run_%s_%d.json" % [LOG_PREFIX, run_id, stamp_msec]
	var file := FileAccess.open(filename, FileAccess.WRITE)
	if file != null:
		file.store_string(JSON.stringify(data, "\t"))
		file.close()
</file>

<file path="scenes/RadioQuestA.gd">
extends Control

const ANCHOR_POOL: Array[int] = [100, 500, 1000]
const POWERS_OF_2: Array[int] = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096]
const TRAPS: Array[int] = [10, 50, 2000]
const SAMPLE_SLOTS: int = 7
const ANALYZE_REVEAL_SECONDS: float = 1.8
const PHONE_LANDSCAPE_MAX_HEIGHT: float = 520.0

const COLOR_IDLE: Color = Color(0.18, 0.18, 0.18, 1.0)
const COLOR_GOOD: Color = Color(0.20, 0.90, 0.30, 1.0)
const COLOR_WARN: Color = Color(0.95, 0.75, 0.20, 1.0)
const COLOR_BAD: Color = Color(0.95, 0.25, 0.25, 1.0)

const TXT_TITLE: String = "\u0420\u0410\u0414\u0418\u041e\u041f\u0415\u0420\u0415\u0425\u0412\u0410\u0422 | A"
const TXT_BACK: String = "\u041d\u0410\u0417\u0410\u0414"
const TXT_MISSION: String = "\u0417\u0410\u0414\u0410\u041d\u0418\u0415"
const TXT_RULE: String = "\u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 i, \u0433\u0434\u0435 2^i >= N"
const TXT_DECODER: String = "\u0414\u0415\u041a\u041e\u0414\u0415\u0420"
const TXT_KNOB_HINT: String = "\u041f\u043e\u0432\u0435\u0440\u043d\u0438\u0442\u0435 \u0440\u0443\u0447\u043a\u0443, \u0437\u0430\u0442\u0435\u043c \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0410\u041d\u0410\u041b\u0418\u0417\u00bb"
const TXT_BTN_HINT: String = "\u041f\u041e\u0414\u0421\u041a\u0410\u0417\u041a\u0410"
const TXT_BTN_ANALYZE: String = "\u0410\u041d\u0410\u041b\u0418\u0417"
const TXT_BTN_CAPTURE: String = "\u0417\u0410\u0425\u0412\u0410\u0422"
const TXT_BTN_NEXT: String = "\u0414\u0410\u041b\u0415\u0415"
const TXT_BTN_DETAILS_CLOSED: String = "\u041f\u041e\u0414\u0420\u041e\u0411\u041d\u0415\u0415 \u25be"
const TXT_BTN_DETAILS_OPEN: String = "\u0421\u041a\u0420\u042b\u0422\u042c \u25b4"
const TXT_DETAILS_TITLE: String = "\u041f\u041e\u042f\u0421\u041d\u0415\u041d\u0418\u0415"
const TXT_DETAILS_CLOSE: String = "\u0417\u0410\u041a\u0420\u042b\u0422\u042c"

const TXT_STATUS_PLAN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 i, \u0437\u0430\u0442\u0435\u043c \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0410\u041d\u0410\u041b\u0418\u0417\u00bb."
const TXT_STATUS_HINT: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u043e 2^i >= N \u0438 \u043c\u0438\u043d\u0438\u043c\u0443\u043c i."
const TXT_ANALYZE_UNDERFIT: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0435 \u043f\u043e\u043c\u0435\u0449\u0430\u0435\u0442\u0441\u044f. \u0423\u0432\u0435\u043b\u0438\u0447\u044c\u0442\u0435 i."
const TXT_ANALYZE_OVERKILL: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u043e\u043c\u0435\u0449\u0430\u0435\u0442\u0441\u044f, \u043d\u043e \u0435\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u0440\u0430\u0441\u0445\u043e\u0434 \u0431\u0438\u0442."
const TXT_ANALYZE_OK: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435."
const TXT_ANALYZE_DONE: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0410\u043d\u0430\u043b\u0438\u0437 \u0437\u0430\u0432\u0435\u0440\u0448\u0451\u043d. \u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0417\u0410\u0425\u0412\u0410\u0422\u00bb."
const TXT_RESULT_BAD: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0435\u0432\u0435\u0440\u043d\u043e. \u041f\u0430\u043a\u0435\u0442 \u043d\u0435 \u043f\u043e\u043c\u0435\u0441\u0442\u0438\u043b\u0441\u044f."
const TXT_RESULT_GOOD: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041e\u0442\u043b\u0438\u0447\u043d\u043e. \u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435."
const TXT_RESULT_WARN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0412\u0435\u0440\u043d\u043e, \u043d\u043e \u0441 \u043f\u0435\u0440\u0435\u0440\u0430\u0441\u0445\u043e\u0434\u043e\u043c."

@onready var safe_area: MarginContainer = $SafeArea
@onready var root_vbox: VBoxContainer = $SafeArea/RootVBox
@onready var body_split: HSplitContainer = $SafeArea/RootVBox/BodyHSplit
@onready var mission_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard
@onready var scope_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard
@onready var right_vbox: VBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox

@onready var btn_back: Button = $SafeArea/RootVBox/Header/HeaderHBox/BtnBack
@onready var title_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/TitleLabel
@onready var meta_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/MetaLabel

@onready var mission_title: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox/MissionTitle
@onready var target_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox/TargetLabel
@onready var rule_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox/RuleLabel
@onready var wave_layer: Control = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin/ScopeLayer
@onready var wave_line: Line2D = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin/ScopeLayer/WaveLine
@onready var bits_value_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow/BitsValueLabel
@onready var fit_value_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow/FitValueLabel

@onready var decoder_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/DecoderTitle
@onready var bit_knob: Control = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/BitKnob
@onready var knob_hint: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/KnobHint
@onready var btn_hint: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnHint
@onready var btn_analyze: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnAnalyze
@onready var btn_capture: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnCapture
@onready var btn_next: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnNext
@onready var sample_strip: HBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip
@onready var status_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/StatusLabel
@onready var btn_details: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/BtnDetails
@onready var footer_label: Label = $SafeArea/RootVBox/Footer/FooterMargin/FooterLabel

@onready var dimmer: ColorRect = $Dimmer
@onready var details_sheet: PanelContainer = $DetailsSheet
@onready var details_title: Label = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsTitle
@onready var details_text: RichTextLabel = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsText
@onready var btn_close_details: Button = $DetailsSheet/DetailsMargin/DetailsVBox/BtnCloseDetails

var target_n: int = 0
var target_bits: int = 0
var current_bits: int = 1
var pool_type: String = "NORMAL"

var trial_active: bool = false
var hint_used: bool = false
var forced_sampling: bool = false
var is_timed_mode: bool = false
var trial_duration: float = 30.0
var time_remaining: float = 0.0

var start_time: float = 0.0
var first_action_timestamp: float = -1.0
var prev_time_to_first_action: float = 0.0

var analyze_count: int = 0
var knob_change_count: int = 0
var direction_change_count: int = 0
var cross_target_count: int = 0
var last_diff_sign: int = 0

var current_trial_idx: int = 0
var anchor_countdown: int = 0
var sample_refs: Array[Dictionary] = []

var analysis_committed: bool = false
var analyze_reveal_until: float = 0.0
var last_analysis_fit: bool = false
var last_analysis_minimal: bool = false
var last_analysis_overkill: bool = false

var osc_phase: float = 0.0
var _ui_ready: bool = false
var _current_stability: float = 100.0

func _ready() -> void:
	randomize()
	_apply_static_texts()
	_connect_signals()
	_collect_sample_refs()
	_reset_sample_strip()
	_set_details_visible(false)
	_apply_safe_area_padding()
	_configure_layout()

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	_on_stability_changed(GlobalMetrics.stability, 0.0)

	anchor_countdown = randi_range(7, 10)
	_start_trial()
	_ui_ready = true

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and _ui_ready:
		_apply_safe_area_padding()
		_configure_layout()

func _process(delta: float) -> void:
	osc_phase += delta * 2.6

	if trial_active and is_timed_mode:
		time_remaining = maxf(0.0, time_remaining - delta)
		if time_remaining <= 0.0:
			_finish_trial(true)

	if trial_active and analysis_committed and btn_capture.disabled:
		var now_sec: float = Time.get_ticks_msec() / 1000.0
		if now_sec >= analyze_reveal_until:
			btn_capture.disabled = false
			status_label.text = TXT_ANALYZE_DONE
			status_label.add_theme_color_override("font_color", COLOR_GOOD)

	_update_header_meta()
	_update_waveform()

func _apply_static_texts() -> void:
	title_label.text = TXT_TITLE
	btn_back.text = TXT_BACK
	mission_title.text = TXT_MISSION
	rule_label.text = TXT_RULE
	decoder_title.text = TXT_DECODER
	knob_hint.text = TXT_KNOB_HINT
	btn_hint.text = TXT_BTN_HINT
	btn_analyze.text = TXT_BTN_ANALYZE
	btn_capture.text = TXT_BTN_CAPTURE
	btn_next.text = TXT_BTN_NEXT
	btn_details.text = TXT_BTN_DETAILS_CLOSED
	details_title.text = TXT_DETAILS_TITLE
	btn_close_details.text = TXT_DETAILS_CLOSE

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_capture.pressed.connect(_on_capture_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_close_pressed)
	dimmer.gui_input.connect(_on_dimmer_gui_input)

	var knob_callback: Callable = Callable(self, "_on_knob_value_changed")
	if not bit_knob.is_connected("value_changed", knob_callback):
		bit_knob.connect("value_changed", knob_callback)

func _collect_sample_refs() -> void:
	sample_refs.clear()
	for child_var in sample_strip.get_children():
		var child_node: Node = child_var as Node
		var bg_node: ColorRect = child_node.get_node_or_null("BG") as ColorRect
		var mark_node: Label = child_node.get_node_or_null("AnchorMark") as Label
		if bg_node != null and mark_node != null:
			sample_refs.append({"bg": bg_node, "mark": mark_node})

func _reset_sample_strip() -> void:
	for slot_var in sample_refs:
		var slot: Dictionary = slot_var as Dictionary
		var bg: ColorRect = slot["bg"] as ColorRect
		var mark: Label = slot["mark"] as Label
		bg.color = COLOR_IDLE
		mark.visible = false
	current_trial_idx = 0

func _start_trial() -> void:
	trial_active = true
	hint_used = false
	start_time = Time.get_ticks_msec() / 1000.0
	first_action_timestamp = -1.0

	analyze_count = 0
	knob_change_count = 0
	direction_change_count = 0
	cross_target_count = 0
	last_diff_sign = 0

	analysis_committed = false
	analyze_reveal_until = 0.0
	last_analysis_fit = false
	last_analysis_minimal = false
	last_analysis_overkill = false

	btn_capture.visible = true
	btn_capture.disabled = true
	btn_analyze.disabled = false
	btn_next.visible = false
	btn_hint.disabled = false
	bit_knob.mouse_filter = Control.MOUSE_FILTER_STOP

	forced_sampling = prev_time_to_first_action > 10.0
	is_timed_mode = forced_sampling
	time_remaining = trial_duration if is_timed_mode else 0.0

	if anchor_countdown <= 0:
		target_n = ANCHOR_POOL.pick_random()
		pool_type = "ANCHOR"
		anchor_countdown = randi_range(7, 10)
	else:
		pool_type = "NORMAL"
		anchor_countdown -= 1
		var pool: Array[int] = []
		pool.append_array(POWERS_OF_2)
		pool.append_array(TRAPS)
		target_n = pool.pick_random()

	target_bits = int(ceil(log(float(target_n)) / log(2.0)))
	target_label.text = "N = %d" % target_n

	current_bits = 1
	bit_knob.set("value", 1)
	_apply_user_bits(1, false)

	status_label.text = TXT_STATUS_PLAN
	status_label.add_theme_color_override("font_color", Color(0.85, 0.85, 0.85, 1.0))
	footer_label.text = ""
	_update_header_meta()
	_update_details_text()

func _mark_first_action() -> void:
	if first_action_timestamp < 0.0:
		first_action_timestamp = Time.get_ticks_msec() / 1000.0

func _on_knob_value_changed(new_value: int) -> void:
	if not trial_active or analysis_committed:
		return
	_apply_user_bits(new_value, true)

func _apply_user_bits(i_value: int, from_user: bool) -> void:
	if from_user:
		_mark_first_action()

	current_bits = clampi(i_value, 1, 12)
	var pow_val: int = int(pow(2.0, current_bits))
	var is_fit: bool = pow_val >= target_n

	if from_user:
		knob_change_count += 1
		var diff_sign: int = signi(target_bits - current_bits)
		if last_diff_sign != 0 and diff_sign != 0 and diff_sign != last_diff_sign:
			direction_change_count += 1
			cross_target_count += 1
		last_diff_sign = diff_sign

	bits_value_label.text = "i = %d \u0431\u0438\u0442" % current_bits
	fit_value_label.text = "\u041f\u041e\u041c\u0415\u0429\u0410\u0415\u0422\u0421\u042f: %s" % ("\u0414\u0410" if is_fit else "\u041d\u0415\u0422")
	fit_value_label.add_theme_color_override("font_color", COLOR_GOOD if is_fit else COLOR_BAD)
	_update_details_text()

func _on_hint_pressed() -> void:
	if not trial_active:
		return
	_mark_first_action()
	hint_used = true
	status_label.text = TXT_STATUS_HINT
	status_label.add_theme_color_override("font_color", Color(0.55, 0.85, 1.0, 1.0))
	_update_details_text()

func _on_analyze_pressed() -> void:
	if not trial_active or analysis_committed:
		return

	_mark_first_action()
	analyze_count += 1
	analysis_committed = true
	btn_analyze.disabled = true
	btn_capture.disabled = true
	bit_knob.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var capacity: int = int(pow(2.0, current_bits))
	last_analysis_fit = capacity >= target_n
	last_analysis_minimal = current_bits == target_bits
	last_analysis_overkill = last_analysis_fit and not last_analysis_minimal

	if not last_analysis_fit:
		status_label.text = TXT_ANALYZE_UNDERFIT
		status_label.add_theme_color_override("font_color", COLOR_WARN)
	elif last_analysis_overkill:
		status_label.text = TXT_ANALYZE_OVERKILL
		status_label.add_theme_color_override("font_color", COLOR_WARN)
	else:
		status_label.text = TXT_ANALYZE_OK
		status_label.add_theme_color_override("font_color", COLOR_GOOD)

	analyze_reveal_until = Time.get_ticks_msec() / 1000.0 + ANALYZE_REVEAL_SECONDS
	_update_details_text()

func _on_capture_pressed() -> void:
	if not trial_active or btn_capture.disabled:
		return
	_mark_first_action()
	_finish_trial(false)

func _finish_trial(is_timeout: bool) -> void:
	if not trial_active:
		return

	trial_active = false
	btn_capture.visible = false
	btn_analyze.disabled = true
	btn_next.visible = true
	btn_hint.disabled = true
	bit_knob.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var end_time: float = Time.get_ticks_msec() / 1000.0
	var duration: float = end_time - start_time
	var capacity: int = int(pow(2.0, current_bits))

	var is_fit: bool = capacity >= target_n
	var is_minimal: bool = current_bits == target_bits
	var is_overkill: bool = is_fit and not is_minimal

	if is_timeout:
		is_fit = false
		is_minimal = false
		is_overkill = false

	if not is_fit:
		status_label.text = TXT_RESULT_BAD
		status_label.add_theme_color_override("font_color", COLOR_BAD)
	elif is_minimal:
		status_label.text = TXT_RESULT_GOOD
		status_label.add_theme_color_override("font_color", COLOR_GOOD)
	else:
		status_label.text = TXT_RESULT_WARN
		status_label.add_theme_color_override("font_color", COLOR_WARN)

	_update_sample_slot(is_fit, is_minimal)

	if first_action_timestamp > 0.0:
		prev_time_to_first_action = first_action_timestamp - start_time
	else:
		prev_time_to_first_action = duration

	var payload: Dictionary = {
		"quest_id": "radio_intercept",
		"stage_id": "A",
		"match_key": "RI_A_%s_%s_N%d" % ["TIMED" if is_timed_mode else "UNTIMED", pool_type, target_n],
		"pool_type": pool_type,
		"N": target_n,
		"i_min": target_bits,
		"chosen_i": current_bits,
		"capacity": capacity,
		"is_fit": is_fit,
		"is_correct": is_fit,
		"is_minimal": is_minimal,
		"is_overkill": is_overkill,
		"used_hint": hint_used,
		"forced_sampling": forced_sampling,
		"analyze_count": analyze_count,
		"knob_change_count": knob_change_count,
		"direction_change_count": direction_change_count,
		"cross_target_count": cross_target_count,
		"elapsed_ms": duration * 1000.0
	}
	GlobalMetrics.register_trial(payload)
	_update_details_text()

func _update_sample_slot(is_fit: bool, is_minimal: bool) -> void:
	if sample_refs.is_empty():
		return
	var slot: Dictionary = sample_refs[current_trial_idx] as Dictionary
	var bg: ColorRect = slot["bg"] as ColorRect
	var mark: Label = slot["mark"] as Label
	if not is_fit:
		bg.color = COLOR_BAD
	elif is_minimal:
		bg.color = COLOR_GOOD
	else:
		bg.color = COLOR_WARN
	mark.visible = pool_type == "ANCHOR"
	current_trial_idx = (current_trial_idx + 1) % min(SAMPLE_SLOTS, sample_refs.size())

func _on_next_pressed() -> void:
	_start_trial()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_details_pressed() -> void:
	_set_details_visible(true)

func _on_details_close_pressed() -> void:
	_set_details_visible(false)

func _on_dimmer_gui_input(event: InputEvent) -> void:
	if (event is InputEventMouseButton and event.pressed) or (event is InputEventScreenTouch and event.pressed):
		_set_details_visible(false)

func _set_details_visible(visible: bool) -> void:
	details_sheet.visible = visible
	dimmer.visible = visible
	btn_details.text = TXT_BTN_DETAILS_OPEN if visible else TXT_BTN_DETAILS_CLOSED

func _update_details_text() -> void:
	var capacity: int = int(pow(2.0, current_bits))
	var lines: Array[String] = []
	lines.append("N: %d" % target_n)
	lines.append("i_min: %d" % target_bits)
	lines.append("i_selected: %d" % current_bits)
	lines.append("2^i: %d" % capacity)
	lines.append("mode: %s" % ("TIMED" if is_timed_mode else "UNTIMED"))
	lines.append("pool: %s" % pool_type)
	if hint_used:
		lines.append("hint: used")
	if analysis_committed:
		lines.append("analysis: done")
	details_text.text = "\n".join(lines)

func _update_header_meta() -> void:
	var mode_text: String = "\u0421 \u0422\u0410\u0419\u041c\u0415\u0420\u041e\u041c" if is_timed_mode else "\u0411\u0415\u0417 \u0422\u0410\u0419\u041c\u0415\u0420\u0410"
	var timer_text: String = ""
	if is_timed_mode:
		timer_text = " | T: %.1f\u0441" % time_remaining
	meta_label.text = "\u0420\u0415\u0416\u0418\u041c: %s | \u0421\u0422\u0410\u0411: %d%%%s" % [mode_text, int(_current_stability), timer_text]

func _on_stability_changed(new_value: float, _delta: float) -> void:
	_current_stability = new_value
	_update_header_meta()

func _apply_safe_area_padding() -> void:
	var left: float = 16.0
	var top: float = 12.0
	var right: float = 16.0
	var bottom: float = 12.0

	var safe_rect: Rect2i = DisplayServer.get_display_safe_area()
	if safe_rect.size.x > 0 and safe_rect.size.y > 0:
		var viewport_size: Vector2 = get_viewport_rect().size
		left = maxf(left, float(safe_rect.position.x))
		top = maxf(top, float(safe_rect.position.y))
		right = maxf(right, viewport_size.x - float(safe_rect.position.x + safe_rect.size.x))
		bottom = maxf(bottom, viewport_size.y - float(safe_rect.position.y + safe_rect.size.y))

	safe_area.add_theme_constant_override("margin_left", int(round(left)))
	safe_area.add_theme_constant_override("margin_top", int(round(top)))
	safe_area.add_theme_constant_override("margin_right", int(round(right)))
	safe_area.add_theme_constant_override("margin_bottom", int(round(bottom)))

func _configure_layout() -> void:
	var size: Vector2 = get_viewport_rect().size
	var phone_landscape: bool = size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

	if phone_landscape:
		body_split.split_offset = int(size.x * 0.54)
		root_vbox.add_theme_constant_override("separation", 8)
		bit_knob.custom_minimum_size = Vector2(180, 180)
		mission_card.custom_minimum_size.y = 110
		scope_card.custom_minimum_size.y = 170
		bits_value_label.add_theme_font_size_override("font_size", 28)
		fit_value_label.add_theme_font_size_override("font_size", 20)
		status_label.add_theme_font_size_override("font_size", 16)
		meta_label.add_theme_font_size_override("font_size", 16)
		for btn in [btn_back, btn_hint, btn_analyze, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 56
	elif size.x < 1280.0:
		body_split.split_offset = int(size.x * 0.55)
		root_vbox.add_theme_constant_override("separation", 10)
		bit_knob.custom_minimum_size = Vector2(200, 200)
		mission_card.custom_minimum_size.y = 122
		scope_card.custom_minimum_size.y = 220
		bits_value_label.add_theme_font_size_override("font_size", 32)
		fit_value_label.add_theme_font_size_override("font_size", 22)
		status_label.add_theme_font_size_override("font_size", 18)
		meta_label.add_theme_font_size_override("font_size", 17)
		for btn in [btn_back, btn_hint, btn_analyze, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58
	else:
		body_split.split_offset = int(size.x * 0.56)
		root_vbox.add_theme_constant_override("separation", 10)
		bit_knob.custom_minimum_size = Vector2(220, 220)
		mission_card.custom_minimum_size.y = 130
		scope_card.custom_minimum_size.y = 260
		bits_value_label.add_theme_font_size_override("font_size", 34)
		fit_value_label.add_theme_font_size_override("font_size", 24)
		status_label.add_theme_font_size_override("font_size", 18)
		meta_label.add_theme_font_size_override("font_size", 18)
		for btn in [btn_back, btn_hint, btn_analyze, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58

func _update_waveform() -> void:
	if wave_layer.size.x <= 1.0 or wave_layer.size.y <= 1.0:
		return

	if analysis_committed:
		_draw_analysis_wave(wave_layer.size)
	else:
		_draw_idle_wave(wave_layer.size)

func _draw_idle_wave(draw_size: Vector2) -> void:
	var points: PackedVector2Array = PackedVector2Array()
	var center_y: float = draw_size.y * 0.5
	for x in range(0, int(draw_size.x) + 1, 6):
		var t: float = float(x) / maxf(1.0, draw_size.x)
		var y: float = center_y
		y += sin(t * TAU * 2.2 + 0.7) * draw_size.y * 0.12
		y += sin(t * TAU * 9.0 + 1.1) * draw_size.y * 0.05
		y += cos(t * TAU * 18.0 + 0.4) * draw_size.y * 0.03
		points.append(Vector2(x, y))
	wave_line.points = points

func _draw_analysis_wave(draw_size: Vector2) -> void:
	var points: PackedVector2Array = PackedVector2Array()
	var center_y: float = draw_size.y * 0.5
	var main_amp: float = draw_size.y * 0.22
	var noise_amp: float = 0.0

	if not last_analysis_fit:
		noise_amp = draw_size.y * 0.24
	elif last_analysis_overkill:
		noise_amp = draw_size.y * 0.08
		main_amp = draw_size.y * 0.16
	else:
		noise_amp = draw_size.y * 0.02
		main_amp = draw_size.y * 0.20

	for x in range(0, int(draw_size.x) + 1, 6):
		var t: float = float(x) / maxf(1.0, draw_size.x)
		var y: float = center_y + sin((t * TAU * 2.0) + osc_phase) * main_amp
		if noise_amp > 0.0:
			y += sin((t * TAU * 13.0) + osc_phase * 1.7) * noise_amp * 0.5
			y += cos((t * TAU * 29.0) + osc_phase * 0.9) * noise_amp * 0.4
		points.append(Vector2(x, y))
	wave_line.points = points
</file>

<file path="scripts/case_07/da7_data_archive_b.gd">
extends Control

# Data & Config
const CasesHub = preload("res://scripts/case_07/da7_cases.gd")
const CasesModuleB = preload("res://scripts/case_07/da7_cases_b.gd")
const BREAKPOINT_PX = 800
const SESSION_CASE_COUNT = 6
const LAYOUT_MOBILE = "mobile"
const LAYOUT_DESKTOP = "desktop"
const TYPEWRITER_INTERVAL_SEC := 0.06
const SUBMIT_BASE_TEXT := "SUBMIT [ENTER]"

# State
var session_cases: Array = []
var current_case_index: int = 0
var current_case: Dictionary = {}
var is_trial_active: bool = false
var is_game_over: bool = false
var mode: String = "" # "FILTER" or "RELATION"

# Telemetry State
var stability_start: float = 0.0
var ui_ready_ts: int = 0
var time_to_first_action_ms: int = -1
var time_to_first_toggle_ms: int = -1
var scroll_used: bool = false
var table_has_scroll: bool = false
var clear_used: bool = false
var clear_count: int = 0
var toggle_count: int = 0
var unique_rows_toggled: Dictionary = {} # row_id -> bool
var click_timestamps: Array[float] = []
var lag_compensation_ms: float = 0.0
var current_layout_mode: String = LAYOUT_DESKTOP
var _suppress_tree_edited: bool = false
var _typewriter_active: bool = false
var _typewriter_accum: float = 0.0

# Nodes
@onready var filter_mode_root: HSplitContainer = $SafeArea/RootLayout/Body/FilterModeRoot
@onready var relation_mode_root: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot
@onready var body_container: VBoxContainer = $SafeArea/RootLayout/Body

# Filter Mode Nodes
@onready var data_tree: Tree = $SafeArea/RootLayout/Body/FilterModeRoot/TableSection/DataTree
@onready var prompt_label: RichTextLabel = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/PromptLabel
@onready var btn_submit: Button = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow/BtnSubmit
@onready var btn_clear: Button = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow/BtnClear
@onready var filter_table_section: VBoxContainer = $SafeArea/RootLayout/Body/FilterModeRoot/TableSection
@onready var filter_task_section: VBoxContainer = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection
var filter_mobile_layout: VBoxContainer

# Relation Mode Nodes
@onready var rel_prompt: RichTextLabel = $SafeArea/RootLayout/Body/RelationModeRoot/PromptLabelRel
@onready var relation_schema_container: HBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer
@onready var rel_tree_l: Tree = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable/TreeL
@onready var rel_tree_r: Tree = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable/TreeR
@onready var rel_title_l: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable/Title
@onready var rel_title_r: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable/Title
@onready var rel_link_label: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector/HintLabel
@onready var rel_arrow_label: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector/ArrowLabel
@onready var rel_left_table: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable
@onready var rel_center_connector: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector
@onready var rel_right_table: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable
@onready var rel_options_row: HBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/OptionsRow
@onready var connector_overlay: Control = $SafeArea/RootLayout/Body/RelationModeRoot/ConnectorOverlay
var relation_mobile_schema: VBoxContainer

# Common Nodes
@onready var stability_bar: ProgressBar = get_node_or_null("SafeArea/RootLayout/Footer/StabilityBar")
@onready var stability_label: Label = get_node_or_null("SafeArea/RootLayout/Footer/StabilityLabel")
@onready var title_label: RichTextLabel = $SafeArea/RootLayout/Header/Margin/Title
@onready var btn_back: Button = $SafeArea/RootLayout/BackRow/BtnBack
@onready var sfx_error: AudioStreamPlayer = $Runtime/Audio/SfxError
@onready var sfx_relay: AudioStreamPlayer = $Runtime/Audio/SfxRelay

func _ready():
	randomize()
	_build_mobile_containers()
	# Connect Filter Buttons
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_submit.pressed.connect(_register_interaction)
	btn_clear.pressed.connect(_on_clear_pressed)
	btn_clear.pressed.connect(_register_interaction)
	btn_back.pressed.connect(_on_back_pressed)

	_init_session()

	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	call_deferred("_on_viewport_size_changed")

	_load_next_case()

func _process(delta):
	if is_trial_active:
		if delta > 0.25:
			lag_compensation_ms += delta * 1000.0
	if _typewriter_active:
		_typewriter_accum += delta
		while _typewriter_accum >= TYPEWRITER_INTERVAL_SEC and _typewriter_active:
			_typewriter_accum -= TYPEWRITER_INTERVAL_SEC
			var lbl: RichTextLabel = _get_active_prompt_label()
			if lbl.visible_characters < lbl.get_total_character_count():
				lbl.visible_characters += 1
			else:
				lbl.visible_characters = -1
				_typewriter_active = false

func _init_session():
	var all_cases: Array = CasesHub.get_cases("B")
	var valid_cases: Array = []
	for c_v in all_cases:
		if typeof(c_v) != TYPE_DICTIONARY:
			continue
		var c: Dictionary = c_v as Dictionary
		if CasesModuleB.validate_case_b(c):
			valid_cases.append(c)

	valid_cases.shuffle()
	session_cases = valid_cases.slice(0, min(SESSION_CASE_COUNT, valid_cases.size()))
	current_case_index = -1

	GlobalMetrics.stability = 100.0
	_update_stability_ui()

func _load_next_case():
	current_case_index += 1
	if current_case_index >= session_cases.size():
		_finish_session()
		return

	current_case = session_cases[current_case_index] as Dictionary
	is_trial_active = true

	# Reset Telemetry
	ui_ready_ts = Time.get_ticks_msec()
	time_to_first_action_ms = -1
	time_to_first_toggle_ms = -1
	scroll_used = false
	table_has_scroll = false
	clear_used = false
	clear_count = 0
	toggle_count = 0
	unique_rows_toggled.clear()
	click_timestamps.clear()
	lag_compensation_ms = 0.0
	stability_start = GlobalMetrics.stability
	_suppress_tree_edited = false

	var interaction_type: String = str(current_case.get("interaction_type", ""))
	if interaction_type == "MULTI_SELECT_ROWS":
		mode = "FILTER"
		filter_mode_root.visible = true
		relation_mode_root.visible = false
		_set_filter_input_locked(false)
		_render_filter_ui()
	elif interaction_type == "RELATIONSHIP_CHOICE":
		mode = "RELATION"
		filter_mode_root.visible = false
		relation_mode_root.visible = true
		_render_relation_ui()

	_on_viewport_size_changed()
	_start_typewriter()

# --- Render Logic ---

func _render_filter_ui():
	data_tree.clear()
	var root: TreeItem = data_tree.create_item()
	data_tree.hide_root = true

	var table_data: Dictionary = current_case.get("table", {}) as Dictionary
	var cols: Array = table_data.get("columns", []) as Array
	data_tree.columns = cols.size() + 1 # +1 for Checkbox
	data_tree.set_column_title(0, "SEL")
	for i in range(cols.size()):
		var col_def: Dictionary = cols[i]
		data_tree.set_column_title(i+1, str(col_def.get("title", "COL")))
	data_tree.column_titles_visible = true

	# Connect item_edited only once? No, signals are per object.
	# Tree signals are on the Tree.
	if not data_tree.item_edited.is_connected(_on_tree_item_edited):
		data_tree.item_edited.connect(_on_tree_item_edited)
	if not data_tree.item_selected.is_connected(_on_tree_item_selected):
		data_tree.item_selected.connect(_on_tree_item_selected)
	if not data_tree.gui_input.is_connected(_on_data_tree_gui_input):
		data_tree.gui_input.connect(_on_data_tree_gui_input)

	var rows: Array = (table_data.get("rows", []) as Array).duplicate()
	var anti_cheat: Dictionary = current_case.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_rows", false)):
		rows.shuffle()

	for row_data in rows:
		if typeof(row_data) != TYPE_DICTIONARY:
			continue
		var row_dict: Dictionary = row_data as Dictionary
		var item: TreeItem = data_tree.create_item(root)
		item.set_metadata(0, str(row_dict.get("row_id", "")))

		# Checkbox setup
		item.set_cell_mode(0, TreeItem.CELL_MODE_CHECK)
		item.set_checked(0, false)
		item.set_editable(0, true)
		item.set_text(0, "") # No text next to checkbox

		for i in range(cols.size()):
			var col_def: Dictionary = cols[i]
			var col_id: String = str(col_def.get("col_id", ""))
			var cells: Dictionary = row_dict.get("cells", {}) as Dictionary
			item.set_text(i+1, str(cells.get(col_id, "")))
			# Only column 0 is editable (checkbox)

	prompt_label.text = str(current_case.get("prompt", ""))
	prompt_label.visible_characters = 0
	_refresh_submit_enabled()
	call_deferred("_update_table_scroll_flag")

func _render_relation_ui():
	# Clear previous options
	for child in rel_options_row.get_children():
		child.queue_free()

	var schema: Dictionary = current_case.get("schema_visual", {}) as Dictionary
	var left_table: Dictionary = schema.get("left_table", {}) as Dictionary
	var right_table: Dictionary = schema.get("right_table", {}) as Dictionary
	var link: Dictionary = schema.get("link", {}) as Dictionary

	_fill_mini_tree(rel_tree_l, left_table)
	rel_title_l.text = str(left_table.get("title", "Левая"))

	_fill_mini_tree(rel_tree_r, right_table)
	rel_title_r.text = str(right_table.get("title", "Правая"))

	rel_link_label.text = str(link.get("hint_label", "FK ссылка"))
	rel_arrow_label.text = ""
	rel_prompt.text = str(current_case.get("prompt", ""))
	rel_prompt.visible_characters = 0
	_update_relation_connector()

	# Options
	var opts: Array = (current_case.get("options", []) as Array).duplicate()
	var anti_cheat: Dictionary = current_case.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_options", false)):
		opts.shuffle()

	for opt in opts:
		if typeof(opt) != TYPE_DICTIONARY:
			continue
		var opt_data: Dictionary = opt as Dictionary
		var btn: Button = Button.new()
		btn.text = str(opt_data.get("text", "ВАРИАНТ"))
		btn.name = "Btn_" + str(opt_data.get("id", ""))
		btn.custom_minimum_size = Vector2(0, 56)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.pressed.connect(_register_interaction)
		btn.pressed.connect(_on_relation_option_selected.bind(opt_data))
		rel_options_row.add_child(btn)

func _fill_mini_tree(tree: Tree, table_def: Dictionary):
	tree.clear()
	var root: TreeItem = tree.create_item()
	tree.hide_root = true

	var cols: Array = table_def.get("columns", []) as Array
	tree.columns = cols.size()
	for i in range(cols.size()):
		var col_def: Dictionary = cols[i]
		tree.set_column_title(i, str(col_def.get("title", "COL")))
	tree.column_titles_visible = true

	var preview_rows: Array = table_def.get("rows_preview", []) as Array
	# Limit preview? Spec says 6.
	for i in range(min(preview_rows.size(), 6)):
		if typeof(preview_rows[i]) != TYPE_DICTIONARY:
			continue
		var row_data: Dictionary = preview_rows[i] as Dictionary
		var item: TreeItem = tree.create_item(root)
		for j in range(cols.size()):
			var col_def: Dictionary = cols[j]
			var col_id: String = str(col_def.get("col_id", ""))
			var row_cells: Dictionary = row_data.get("cells", {}) as Dictionary
			item.set_text(j, str(row_cells.get(col_id, "")))

# --- Interactions ---

func _register_interaction():
	if not is_trial_active: return
	if time_to_first_action_ms < 0:
		time_to_first_action_ms = Time.get_ticks_msec() - ui_ready_ts

	var now: float = float(Time.get_ticks_msec())
	click_timestamps.append(now)
	while click_timestamps.size() > 5:
		click_timestamps.pop_front()

func _on_tree_item_edited():
	# Fired when checkbox is toggled
	if not is_trial_active:
		return
	if _suppress_tree_edited:
		return
	var edited_column: int = data_tree.get_edited_column()
	if edited_column != 0:
		return

	var item: TreeItem = data_tree.get_edited()
	if not item:
		return
	_register_interaction()

	# Detect toggle
	toggle_count += 1
	var row_id: String = str(item.get_metadata(0))
	unique_rows_toggled[row_id] = true

	if time_to_first_toggle_ms < 0:
		time_to_first_toggle_ms = Time.get_ticks_msec() - ui_ready_ts
	_refresh_submit_enabled()

func _on_tree_item_selected():
	pass

func _on_data_tree_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP or mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			scroll_used = true
	elif event is InputEventScreenDrag:
		scroll_used = true

func _on_clear_pressed():
	if not is_trial_active:
		return
	var cleared_any: bool = false
	_suppress_tree_edited = true
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			if item.is_checked(0):
				cleared_any = true
				item.set_checked(0, false)
			item = item.get_next()
	_suppress_tree_edited = false
	if cleared_any:
		clear_used = true
		clear_count += 1
	_refresh_submit_enabled()

func _on_submit_pressed():
	if not is_trial_active:
		return
	is_trial_active = false
	_set_filter_input_locked(true)
	_stop_typewriter()

	var selected_ids: Array = []
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			if item.is_checked(0):
				selected_ids.append(str(item.get_metadata(0)))
			item = item.get_next()

	var analysis: Dictionary = _calculate_f_reason_filter(selected_ids)
	analysis["selected_row_ids"] = selected_ids
	var is_correct: bool = str(analysis.get("reason", "MIXED_ERROR")) == "NONE"
	var reason_value: Variant = null if is_correct else str(analysis.get("reason", "MIXED_ERROR"))
	_handle_result(is_correct, reason_value, analysis)

func _on_relation_option_selected(opt: Dictionary):
	if not is_trial_active:
		return
	is_trial_active = false
	_stop_typewriter()

	var selected_option_id: String = str(opt.get("id", ""))
	var answer_id: String = str(current_case.get("answer_id", ""))
	var is_correct: bool = selected_option_id == answer_id
	var reason: Variant = null
	if not is_correct:
		reason = str(opt.get("f_reason", "WRONG_RELATION"))

	# Disable buttons
	for child in rel_options_row.get_children():
		if child is Button:
			(child as Button).disabled = true

	_handle_result(is_correct, reason, {"selected_option_id": selected_option_id})

func _handle_result(is_correct: bool, reason: Variant, extra_data: Dictionary):
	if not is_correct:
		if sfx_error:
			sfx_error.play()
	else:
		if sfx_relay:
			sfx_relay.play()

	_log_trial(is_correct, reason, extra_data)
	_update_stability_ui()

	await get_tree().create_timer(1.0).timeout

	if GlobalMetrics.stability <= 0:
		_game_over()
	else:
		_load_next_case()

# --- Logic Ladder ---

func _calculate_f_reason_filter(selected: Array) -> Dictionary:
	var S: Array = selected.duplicate()
	var A: Array = current_case.get("answer_row_ids", []) as Array
	var B: Array = current_case.get("boundary_row_ids", []) as Array
	var O: Array = current_case.get("opposite_row_ids", []) as Array
	var U: Array = current_case.get("unrelated_row_ids", []) as Array
	var D: Array = current_case.get("decoy_row_ids", []) as Array
	var predicate: Dictionary = current_case.get("predicate", {}) as Dictionary
	var strict_expected: bool = bool(predicate.get("strict_expected", false))

	var missing_ids: Array = _array_diff(A, S)
	var extra_ids: Array = _array_diff(S, A)
	var boundary_selected: Array = _array_intersection(S, B)
	var opposite_selected: Array = _array_intersection(S, O)
	var decoy_selected: Array = _array_intersection(S, D)
	var unrelated_selected: Array = _array_intersection(S, U)
	var extra_outside_main: Array = _array_diff(_array_diff(_array_diff(_array_diff(S, A), B), O), D)

	var has_omission: bool = missing_ids.size() > 0
	var reason: String = "NONE"

	if S.is_empty():
		reason = "EMPTY_SELECTION"
	elif _is_subset(S, O):
		reason = "PURE_OPPOSITE"
	elif strict_expected and boundary_selected.size() > 0:
		reason = "INCLUDED_BOUNDARY"
	elif decoy_selected.size() > 0:
		reason = "OVERSELECT_DECOY"
	elif unrelated_selected.size() > 0 or extra_outside_main.size() > 0:
		reason = "FALSE_POSITIVE"
	elif has_omission:
		reason = "OMISSION"
	elif _sets_equal(S, A):
		reason = "NONE"

	return {
		"reason": reason,
		"sets": {
			"missing_ids": missing_ids,
			"extra_ids": extra_ids,
			"boundary_selected": boundary_selected,
			"opposite_selected": opposite_selected,
			"decoy_selected": decoy_selected,
			"unrelated_selected": unrelated_selected,
			"extra_outside_main": extra_outside_main
		}
	}

# --- Telemetry ---

func _log_trial(is_correct: bool, f_reason: Variant, data: Dictionary):
	var now_ms: int = Time.get_ticks_msec()
	var raw_elapsed_ms: int = now_ms - ui_ready_ts
	var effective_elapsed_ms: int = int(max(0.0, raw_elapsed_ms - lag_compensation_ms))
	var timing_policy: Dictionary = current_case.get("timing_policy", {}) as Dictionary
	var limit_sec: int = int(timing_policy.get("limit_sec", 120))
	var over_soft: bool = effective_elapsed_ms > (limit_sec * 1000)

	var burst: bool = false
	if click_timestamps.size() >= 4 and (click_timestamps[-1] - click_timestamps[0]) <= 700.0:
		burst = true

	var case_id: String = str(current_case.get("id", "DA7-B-00"))
	var schema_version: String = str(current_case.get("schema_version", "DA7.B.v1"))
	var estimated_end_stability: float = stability_start if is_correct else max(0.0, stability_start - 10.0)
	var payload: Dictionary = {
		"question_id": case_id,
		"case_id": case_id,
		"quest_id": "DA7",
		"quest": "data_archive",
		"stage": "B",
		"level": str(current_case.get("level", "B")),
		"schema_version": schema_version,
		"topic": str(current_case.get("topic", "DB_FILTERING")),
		"case_kind": str(current_case.get("case_kind", "")),
		"interaction_type": str(current_case.get("interaction_type", "")),
		"match_key": "DA7_B|%s|%s" % [case_id, mode],
		"is_correct": is_correct,
		"f_reason": f_reason,
		"elapsed_ms": effective_elapsed_ms,
		"duration": float(effective_elapsed_ms) / 1000.0,
		"timing": {
			"effective_elapsed_ms": effective_elapsed_ms,
			"time_to_first_action_ms": time_to_first_action_ms,
			"time_to_first_toggle_ms": time_to_first_toggle_ms,
			"policy_mode": str(timing_policy.get("mode", "LEARNING")),
			"limit_sec": limit_sec
		},
		"answer": {},
		"expected": {},
		"flags": {
			"silent_reading_possible": (time_to_first_action_ms >= 30000 and not scroll_used and not table_has_scroll),
			"had_scroll": scroll_used,
			"table_has_scroll": table_has_scroll
		},
		"anti_cheat": current_case.get("anti_cheat", {}),
		"layout_mode": current_layout_mode,
		"telemetry": {
			"time_to_first_action_ms": time_to_first_action_ms,
			"time_to_first_toggle_ms": time_to_first_toggle_ms,
			"time_to_submit_ms": raw_elapsed_ms,
			"raw_elapsed_ms": raw_elapsed_ms,
			"lag_compensation_ms": lag_compensation_ms,
			"effective_elapsed_ms": effective_elapsed_ms,
			"toggle_count": toggle_count,
			"unique_rows_toggled_count": unique_rows_toggled.size(),
			"clear_used": clear_used,
			"clear_count": clear_count,
			"scroll_used": scroll_used,
			"rapid_toggle_burst": burst,
			"over_soft_limit": over_soft
		},
		"stability": {
			"start": stability_start,
			"end": estimated_end_stability,
			"delta": estimated_end_stability - stability_start
		}
	}

	if mode == "FILTER":
		var sets: Dictionary = data.get("sets", {}) as Dictionary
		var selected_ids: Array = data.get("selected_row_ids", []) as Array
		payload["task"] = {"predicate": current_case.get("predicate", {})}
		payload["answer"] = {
			"selected_row_ids": selected_ids,
			"diagnostic_sets": sets,
			"missing_ids": sets.get("missing_ids", []),
			"extra_ids": sets.get("extra_ids", []),
			"boundary_selected": sets.get("boundary_selected", []),
			"opposite_selected": sets.get("opposite_selected", []),
			"decoy_selected": sets.get("decoy_selected", []),
			"unrelated_selected": sets.get("unrelated_selected", []),
			"extra_outside_main": sets.get("extra_outside_main", [])
		}
		payload["expected"] = {
			"answer_row_ids": current_case.get("answer_row_ids", []),
			"boundary_row_ids": current_case.get("boundary_row_ids", []),
			"opposite_row_ids": current_case.get("opposite_row_ids", []),
			"unrelated_row_ids": current_case.get("unrelated_row_ids", []),
			"decoy_row_ids": current_case.get("decoy_row_ids", [])
		}

	elif mode == "RELATION":
		var schema_visual: Dictionary = current_case.get("schema_visual", {}) as Dictionary
		payload["schema_visual"] = {"link": schema_visual.get("link", {})}
		payload["answer"] = {
			"selected_option_id": str(data.get("selected_option_id", ""))
		}
		payload["expected"] = {
			"answer_id": str(current_case.get("answer_id", "")),
			"expected_relation": str(current_case.get("expected_relation", ""))
		}

	GlobalMetrics.register_trial(payload)

# --- Utils ---
func _update_stability_ui():
	if is_instance_valid(stability_bar):
		stability_bar.value = GlobalMetrics.stability
	if is_instance_valid(stability_label):
		stability_label.text = "СТАБИЛЬНОСТЬ: %d%%" % int(GlobalMetrics.stability)

func _start_typewriter():
	var lbl: RichTextLabel = _get_active_prompt_label()
	lbl.visible_characters = 0
	_typewriter_accum = 0.0
	_typewriter_active = true

func _stop_typewriter() -> void:
	_typewriter_active = false
	_typewriter_accum = 0.0
	var lbl: RichTextLabel = _get_active_prompt_label()
	lbl.visible_characters = -1

func _get_active_prompt_label() -> RichTextLabel:
	return prompt_label if mode == "FILTER" else rel_prompt

func _on_viewport_size_changed():
	var win_size: Vector2 = get_viewport_rect().size
	var is_mobile: bool = win_size.x < BREAKPOINT_PX
	current_layout_mode = LAYOUT_MOBILE if is_mobile else LAYOUT_DESKTOP
	filter_mode_root.split_offset = int(win_size.x * 0.48)
	filter_mode_root.dragger_visibility = SplitContainer.DRAGGER_HIDDEN if is_mobile else SplitContainer.DRAGGER_VISIBLE
	_apply_filter_layout_mode(is_mobile)
	_apply_relation_layout_mode(is_mobile)
	if mode == "FILTER":
		call_deferred("_update_table_scroll_flag")

func _finish_session():
	is_game_over = true
	title_label.text = "СЕССИЯ ЗАВЕРШЕНА [B]"
	prompt_label.text = "Архивы защищены."
	rel_prompt.text = "Архивы защищены."

	# Remove controls
	if mode == "FILTER":
		$SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow.queue_free()
	else:
		rel_options_row.queue_free()

	var btn_exit: Button = Button.new()
	btn_exit.text = "ВЫХОД"
	btn_exit.pressed.connect(func(): get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn"))

	# Add exit button somewhere visible
	$SafeArea/RootLayout/Footer.add_child(btn_exit)

func _game_over():
	is_game_over = true
	title_label.text = "МИССИЯ ПРОВАЛЕНА"
	var btn_exit: Button = Button.new()
	btn_exit.text = "ВЫХОД"
	btn_exit.pressed.connect(func(): get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn"))
	$SafeArea/RootLayout/Footer.add_child(btn_exit)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _build_mobile_containers() -> void:
	filter_mobile_layout = VBoxContainer.new()
	filter_mobile_layout.name = "FilterMobileLayout"
	filter_mobile_layout.visible = false
	filter_mobile_layout.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	filter_mobile_layout.size_flags_vertical = Control.SIZE_EXPAND_FILL
	filter_mobile_layout.set("theme_override_constants/separation", 10)
	body_container.add_child(filter_mobile_layout)

	relation_mobile_schema = VBoxContainer.new()
	relation_mobile_schema.name = "RelationMobileSchema"
	relation_mobile_schema.visible = false
	relation_mobile_schema.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	relation_mobile_schema.size_flags_vertical = Control.SIZE_EXPAND_FILL
	relation_mobile_schema.set("theme_override_constants/separation", 8)
	relation_mode_root.add_child(relation_mobile_schema)
	relation_mode_root.move_child(relation_mobile_schema, 1)

func _apply_filter_layout_mode(is_mobile: bool) -> void:
	if is_mobile:
		if filter_table_section.get_parent() != filter_mobile_layout:
			filter_table_section.reparent(filter_mobile_layout)
		if filter_task_section.get_parent() != filter_mobile_layout:
			filter_task_section.reparent(filter_mobile_layout)
		filter_mobile_layout.move_child(filter_table_section, 0)
		filter_mobile_layout.move_child(filter_task_section, 1)
		filter_mode_root.visible = false
		filter_mobile_layout.visible = (mode == "FILTER")
	else:
		if filter_table_section.get_parent() != filter_mode_root:
			filter_table_section.reparent(filter_mode_root)
		if filter_task_section.get_parent() != filter_mode_root:
			filter_task_section.reparent(filter_mode_root)
		filter_mode_root.move_child(filter_table_section, 0)
		filter_mode_root.move_child(filter_task_section, 1)
		filter_mode_root.visible = (mode == "FILTER")
		filter_mobile_layout.visible = false

func _apply_relation_layout_mode(is_mobile: bool) -> void:
	if is_mobile:
		if rel_left_table.get_parent() != relation_mobile_schema:
			rel_left_table.reparent(relation_mobile_schema)
		if rel_center_connector.get_parent() != relation_mobile_schema:
			rel_center_connector.reparent(relation_mobile_schema)
		if rel_right_table.get_parent() != relation_mobile_schema:
			rel_right_table.reparent(relation_mobile_schema)
		relation_mobile_schema.move_child(rel_left_table, 0)
		relation_mobile_schema.move_child(rel_center_connector, 1)
		relation_mobile_schema.move_child(rel_right_table, 2)
		relation_schema_container.visible = false
		relation_mobile_schema.visible = (mode == "RELATION")
	else:
		if rel_left_table.get_parent() != relation_schema_container:
			rel_left_table.reparent(relation_schema_container)
		if rel_center_connector.get_parent() != relation_schema_container:
			rel_center_connector.reparent(relation_schema_container)
		if rel_right_table.get_parent() != relation_schema_container:
			rel_right_table.reparent(relation_schema_container)
		relation_schema_container.move_child(rel_left_table, 0)
		relation_schema_container.move_child(rel_center_connector, 1)
		relation_schema_container.move_child(rel_right_table, 2)
		relation_schema_container.visible = (mode == "RELATION")
		relation_mobile_schema.visible = false
	_update_relation_connector()

func _update_relation_connector() -> void:
	if not is_instance_valid(connector_overlay):
		return
	if mode != "RELATION":
		connector_overlay.visible = false
		return
	connector_overlay.visible = true
	var orientation: String = "vertical" if current_layout_mode == LAYOUT_MOBILE else "horizontal"
	var schema_visual: Dictionary = current_case.get("schema_visual", {}) as Dictionary
	var links_config: Array = schema_visual.get("links", []) as Array
	if links_config.size() > 0 and connector_overlay.has_method("set_links"):
		var overlay_links: Array = []
		for _link in links_config:
			overlay_links.append({"from": rel_left_table, "to": rel_right_table})
		connector_overlay.call_deferred("set_links", overlay_links, relation_mode_root, "edge", orientation)
	elif connector_overlay.has_method("set_endpoints"):
		if connector_overlay.has_method("set_anchor_mode"):
			connector_overlay.call("set_anchor_mode", "edge", orientation)
		connector_overlay.call_deferred("set_endpoints", rel_left_table, rel_right_table, relation_mode_root)

func _set_filter_input_locked(locked: bool) -> void:
	if locked:
		btn_submit.disabled = true
	else:
		_refresh_submit_enabled()
	btn_clear.disabled = locked
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			item.set_editable(0, not locked)
			item = item.get_next()

func _refresh_submit_enabled() -> void:
	if mode != "FILTER" or not is_trial_active:
		btn_submit.disabled = true
		btn_submit.text = SUBMIT_BASE_TEXT
		return
	var selected_count: int = _selected_count()
	btn_submit.disabled = selected_count == 0
	btn_submit.text = "%s (%d)" % [SUBMIT_BASE_TEXT, selected_count]

func _selected_count() -> int:
	var count: int = 0
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			if item.is_checked(0):
				count += 1
			item = item.get_next()
	return count

func _update_table_scroll_flag() -> void:
	table_has_scroll = _tree_has_vertical_scroll(data_tree)

func _tree_has_vertical_scroll(tree: Tree) -> bool:
	if not is_instance_valid(tree):
		return false
	var stack: Array = [tree]
	while not stack.is_empty():
		var node: Node = stack.pop_back() as Node
		if node is VScrollBar:
			var bar: VScrollBar = node as VScrollBar
			return bar.max_value > 0.0 and bar.page < bar.max_value
		for child in node.get_children():
			stack.append(child)
	return false

func _array_intersection(arr1: Array, arr2: Array) -> Array:
	var lookup: Dictionary = {}
	for x in arr2:
		lookup[x] = true
	var out: Array = []
	for x in arr1:
		if lookup.has(x):
			out.append(x)
	return out

func _array_diff(arr1: Array, arr2: Array) -> Array:
	var lookup: Dictionary = {}
	for x in arr2:
		lookup[x] = true
	var out: Array = []
	for x in arr1:
		if not lookup.has(x):
			out.append(x)
	return out

func _is_subset(subset_arr: Array, set_arr: Array) -> bool:
	var lookup: Dictionary = {}
	for x in set_arr:
		lookup[x] = true
	for x in subset_arr:
		if not lookup.has(x):
			return false
	return true

func _sets_equal(arr1: Array, arr2: Array) -> bool:
	if arr1.size() != arr2.size():
		return false
	return _is_subset(arr1, arr2) and _is_subset(arr2, arr1)
</file>

<file path="scripts/GlobalMetrics.gd">
extends Node

# LogicEngine v6.2 Specification

signal stability_changed(new_value, change)
signal shield_triggered(shield_name, penalty)
signal hint_unlocked(level, text)
signal game_over

# Core Resources
var _stability: float = 100.0
var stability: float:
	get:
		return _stability
	set(value):
		_stability = clamp(value, 0.0, 100.0)
		if _stability <= 0.0:
			game_over.emit()
var current_level_index: int = 0
var current_mode: String = "DEC"
var current_target_value: int = 0

# Analysis History
var session_history: Array = []

func register_trial(data: Dictionary):
	session_history.append(data)

	var match_key = data.get("match_key", "UNKNOWN")
	var is_correct = data.get("is_correct", false)

	var duration = data.get("duration", data.get("elapsed_ms", 0.0) / 1000.0)
	print("MATCH: ", match_key, " | Correct: ", is_correct, " | Time: ", duration)

	var stability_delta = data.get("stability_delta", null)

	if stability_delta != null:
		stability = max(0.0, stability + float(stability_delta))
		emit_signal("stability_changed", stability, float(stability_delta))
	else:
		var is_fit = data.get("is_fit", null)
		var penalty_condition = false

		if is_fit != null:
			penalty_condition = (is_fit == false)
		else:

			penalty_condition = (is_correct == false)

		if penalty_condition:
			stability = max(0.0, stability - 10.0)
			emit_signal("stability_changed", stability, -10.0)

const MATRIX_SIZE := 6
const MATRIX_WEIGHTS := [32, 16, 8, 4, 2, 1]
var matrix_quest: Dictionary = {}
var matrix_target: Array = []
var matrix_row_constraints: Array = []
var matrix_col_constraints: Array = []
var matrix_current: Array = []
var matrix_changed_cells: Dictionary = {}
var _solver_row_constraints: Array = []
var _solver_col_targets: Array = []
var _solver_col_parity: Array = []
var _solver_visibility: Array = []
var _solver_col_sums: Array = []
var _solver_solutions: int = 0

enum Operator { ADD, SUB, SHIFT_L }
var current_reg_a: int = 0
var current_reg_b: int = 0
var current_operator: Operator = Operator.ADD

# Anti-Spam / Shields
var check_timestamps: Array[float] = []
var last_checked_bits: Array = [] # History of bit arrays
var blocked_until: float = 0.0

# Level Configuration (Complexity A)
# 15 Levels: 1-5 DEC, 6-10 OCT, 11-15 HEX
const MAX_LEVELS = 30

func _ready():
	randomize()
	reset_engine()

func reset_engine():
	stability = 100.0
	current_level_index = 0
	current_target_value = 0
	current_reg_a = 0
	current_reg_b = 0
	current_operator = Operator.ADD
	check_timestamps.clear()
	last_checked_bits.clear()
	blocked_until = 0.0
	matrix_quest.clear()
	matrix_target.clear()
	matrix_row_constraints.clear()
	matrix_col_constraints.clear()
	matrix_current.clear()
	matrix_changed_cells.clear()

func start_level(index: int):
	current_level_index = index
	# Determine mode based on level index (0-based)
	if index < 5:
		current_mode = "DEC"
	elif index < 10:
		current_mode = "OCT"
	elif index < 15:
		current_mode = "HEX"
	else:
		# Complexity B uses a single system (HEX) for arithmetic focus
		current_mode = "HEX"

	# Reset shields for the new level/attempt if desired,
	# but typically stability persists or resets per level depending on design.
	# TDD says: "Stability begins with 100% on each level"
	stability = 100.0
	emit_signal("stability_changed", stability, 0)
	check_timestamps.clear()
	last_checked_bits.clear()

	if index >= 15:
		_generate_arithmetic_example()
	else:
		current_target_value = randi_range(1, 255)

# Returns (success: bool, info: Dictionary)
func check_solution(target_val: int, input_val: int) -> Dictionary:
	var current_time = Time.get_ticks_msec() / 1000.0

	if current_time < blocked_until:
		return {
			"success": false,
			"error": "SHIELD_ACTIVE",
			"message": "Щит активен. Дождитесь перезарядки.",
			"penalty": 0
		}

	# 1. Frequency Shield
	_update_frequency_log(current_time)
	if check_timestamps.size() > 4:
		blocked_until = current_time + 5.0 # Block for 5 seconds
		emit_signal("shield_triggered", "FREQUENCY", 5.0)
		return {
			"success": false,
			"error": "SHIELD_FREQ",
			"message": "Сработал частотный щит: слишком много проверок.",
			"penalty": 0
		}

	# 2. Logic Check
	var hd = _calculate_hamming_distance(target_val, input_val)

	# Lazy Search Shield Check (if HD > 2 and user is making small changes)
	# (Simplified implementation: check if input changed little from last time)
	if _check_lazy_search(input_val, hd):
		blocked_until = current_time + 3.0
		emit_signal("shield_triggered", "LAZY", 3.0)
		_record_input_history(input_val)
		return {
			"success": false,
			"error": "SHIELD_LAZY",
			"message": "Blocked: lazy search detected. Change input in larger steps.",
			"penalty": 0
		}

	_record_input_history(input_val)

	if hd == 0:
		return {
			"success": true,
			"message": "Доступ разрешён. Ввод совпадает с целью.",
			"stability": stability
		}
	else:
		# Calculate Penalty
		var penalty = 0.0
		if hd == 1: penalty = 10.0
		elif hd == 2: penalty = 15.0
		elif hd == 3: penalty = 25.0
		elif hd == 4: penalty = 35.0
		elif hd >= 5: penalty = 50.0 # Chaos
		else: penalty = 50.0 # Fallback

		stability = max(0.0, stability - penalty)
		emit_signal("stability_changed", stability, -penalty)

		# Generate Hints
		var hints = _generate_hints(target_val, input_val, hd)

		return {
			"success": false,
			"error": "INCORRECT",
			"hamming": hd,
			"penalty": penalty,
			"hints": hints,
			"message": "Неверный ввод. Расстояние Хэмминга: %d" % hd
		}

func _calculate_hamming_distance(a: int, b: int) -> int:
	var x = a ^ b
	var dist = 0
	while x > 0:
		dist += 1
		x &= x - 1
	return dist

func _update_frequency_log(time_sec: float):
	check_timestamps.append(time_sec)
	# Remove checks older than 15 seconds
	var cutoff = time_sec - 15.0
	while check_timestamps.size() > 0 and check_timestamps[0] < cutoff:
		check_timestamps.pop_front()

func _check_lazy_search(current_input: int, current_hd: int) -> bool:
	if current_hd <= 2: return false

	var inputs = last_checked_bits.duplicate()
	inputs.append(current_input)
	# Need at least 4 inputs to analyze 3 transitions
	if inputs.size() < 4:
		return false

	var unique_changed: Dictionary = {}
	var start = inputs.size() - 4
	for i in range(start, inputs.size() - 1):
		var diff = inputs[i] ^ inputs[i + 1]
		for bit in range(8):
			if (diff & (1 << bit)) != 0:
				unique_changed[bit] = true

	return unique_changed.size() < 3

func _generate_arithmetic_example():
	# Pick an operator for Complexity B
	var op_pick = randi() % 3
	current_operator = Operator.ADD if op_pick == 0 else Operator.SUB if op_pick == 1 else Operator.SHIFT_L

	if current_operator == Operator.ADD:
		current_reg_a = randi_range(0, 255)
		current_reg_b = randi_range(0, 255 - current_reg_a)
		current_target_value = current_reg_a + current_reg_b
	elif current_operator == Operator.SUB:
		current_reg_a = randi_range(0, 255)
		current_reg_b = randi_range(0, current_reg_a)
		current_target_value = current_reg_a - current_reg_b
	else:
		# SHIFT_L by 1..3, ensure result <= 255
		current_reg_b = randi_range(1, 3)
		var max_a = 255 >> current_reg_b
		current_reg_a = randi_range(0, max_a)
		current_target_value = current_reg_a << current_reg_b

func _record_input_history(val: int):
	last_checked_bits.append(val)
	if last_checked_bits.size() > 10:
		last_checked_bits.pop_front()

func _generate_hints(target: int, input: int, hd: int) -> Dictionary:
	# Level 1: Diagnosis
	var diagnosis = "BIT_ERROR"
	if target > input: diagnosis = "VALUE_LOW"
	elif target < input: diagnosis = "VALUE_HIGH"

	# Level 2: Nibble (Zone)
	# Check lower 4 bits (0-3) vs upper 4 bits (4-7)
	var x = target ^ input
	var low_err = (x & 0x0F) != 0
	var high_err = (x & 0xF0) != 0
	var zone = "NONE"
	if low_err and high_err: zone = "BOTH_NIBBLES"
	elif low_err: zone = "LOWER_NIBBLE"
	elif high_err: zone = "UPPER_NIBBLE"

	return {
		"diagnosis": diagnosis,
		"zone": zone
	}

func get_rank_info() -> Dictionary:
	var idx = current_level_index
	if idx < 5:
		return {"name": "СТАЖЁР", "color": Color("888888")}
	if idx < 10:
		return {"name": "СИГНАЛИСТ", "color": Color("33ff33")}
	if idx < 15:
		return {"name": "КРИПТОАНАЛИТИК", "color": Color("33aaff")}
	if idx < 30:
		return {"name": "СИСТЕМНЫЙ ИНЖЕНЕР", "color": Color("ffcc00")}
	return {"name": "МАСТЕР МОНОЛИТА", "color": Color("ff33ff")}

# --- Matrix (Complexity C) ---
func start_matrix_quest():
	# Reset shields and stability for a new matrix quest
	stability = 100.0
	emit_signal("stability_changed", stability, 0)
	check_timestamps.clear()
	last_checked_bits.clear()
	blocked_until = 0.0
	_generate_matrix_quest()
	_init_matrix_current()
	_clear_matrix_changes()

func record_matrix_change(row: int, col: int):
	var key = "%d,%d" % [row, col]
	matrix_changed_cells[key] = true

func validate_matrix_logic() -> Dictionary:
	var hd_result = _calculate_matrix_hd()
	return {
		"hd": hd_result.hd,
		"row_ok": hd_result.row_ok,
		"col_ok": hd_result.col_ok
	}

func check_matrix_solution() -> Dictionary:
	var current_time = Time.get_ticks_msec() / 1000.0

	if current_time < blocked_until:
		return {
			"success": false,
			"error": "SHIELD_ACTIVE",
			"message": "Щит активен. Дождитесь перезарядки.",
			"penalty": 0
		}

	# 1. Frequency Shield
	_update_frequency_log(current_time)
	if check_timestamps.size() > 4:
		blocked_until = current_time + 5.0
		emit_signal("shield_triggered", "FREQUENCY", 5.0)
		_clear_matrix_changes()
		return {
			"success": false,
			"error": "SHIELD_FREQ",
			"message": "Сработал частотный щит: слишком много проверок.",
			"penalty": 0
		}

	# 2. Matrix HD
	var hd_result = _calculate_matrix_hd()
	var hd = hd_result.hd

	# Lazy Search Shield (matrix)
	if _check_lazy_search_matrix(hd):
		blocked_until = current_time + 5.0
		emit_signal("shield_triggered", "LAZY", 5.0)
		_clear_matrix_changes()
		return {
			"success": false,
			"error": "SHIELD_LAZY",
			"message": "Блокировка: недостаточно проверки вариантов.",
			"penalty": 0
		}

	_clear_matrix_changes()

	if hd == 0:
		return {
			"success": true,
			"message": "Доступ разрешён. Ввод совпадает с целью.",
			"stability": stability
		}

	var penalty = 0.0
	if hd == 1:
		penalty = 15.0
	elif hd == 2:
		penalty = 25.0
	else:
		penalty = 40.0

	stability = max(0.0, stability - penalty)
	emit_signal("stability_changed", stability, -penalty)

	return {
		"success": false,
		"error": "INCORRECT",
		"hamming": hd,
		"penalty": penalty,
		"message": "Неверный ввод. Расстояние Хэмминга: %d" % hd
	}

func _check_lazy_search_matrix(hd: int) -> bool:
	if hd <= 2:
		return false
	return matrix_changed_cells.size() < 3

func _calculate_matrix_hd() -> Dictionary:
	var row_ok: Array = []
	var col_ok: Array = []
	var hd = 0

	# Row checks (visible only)
	for r in range(MATRIX_SIZE):
		var row_constraint = matrix_row_constraints[r]
		var visible = row_constraint.is_hex_visible
		var row_has_unset = false
		var row_value = 0
		for c in range(MATRIX_SIZE):
			var cell = matrix_current[r][c]
			if cell == -1:
				row_has_unset = true
			elif cell == 1:
				row_value += MATRIX_WEIGHTS[c]
		var is_ok = false
		if visible and not row_has_unset and row_value == row_constraint.hex_value:
			is_ok = true
		row_ok.append(is_ok)
		if visible:
			if row_has_unset or row_value != row_constraint.hex_value:
				hd += 1

	# Column checks (always visible)
	for c in range(MATRIX_SIZE):
		var col_constraint = matrix_col_constraints[c]
		var col_has_unset = false
		var ones = 0
		for r in range(MATRIX_SIZE):
			var cell = matrix_current[r][c]
			if cell == -1:
				col_has_unset = true
			elif cell == 1:
				ones += 1
		var parity = ones % 2
		var is_ok = (not col_has_unset
			and ones == col_constraint.ones_count
			and parity == col_constraint.parity)
		col_ok.append(is_ok)
		if col_has_unset or ones != col_constraint.ones_count:
			hd += 1

	return {
		"hd": hd,
		"row_ok": row_ok,
		"col_ok": col_ok
	}

func _init_matrix_current():
	matrix_current.clear()
	for r in range(MATRIX_SIZE):
		var row: Array = []
		for _c in range(MATRIX_SIZE):
			row.append(-1)
		matrix_current.append(row)

func _clear_matrix_changes():
	matrix_changed_cells.clear()

func _generate_matrix_quest():
	var attempts = 0
	while attempts < 200:
		attempts += 1
		var target = _random_matrix()
		var row_constraints = _build_row_constraints(target)
		var col_constraints = _build_col_constraints(target)

		var visibility = _pick_row_visibility(row_constraints, col_constraints)
		if visibility.size() == MATRIX_SIZE:
			for r in range(MATRIX_SIZE):
				row_constraints[r].is_hex_visible = visibility[r]

			matrix_target = target
			matrix_row_constraints = row_constraints
			matrix_col_constraints = col_constraints
			matrix_quest = {
				"target_matrix": matrix_target,
				"row_constraints": matrix_row_constraints,
				"col_constraints": matrix_col_constraints
			}
			return

	# Fallback: all rows visible
	matrix_target = _random_matrix()
	matrix_row_constraints = _build_row_constraints(matrix_target)
	matrix_col_constraints = _build_col_constraints(matrix_target)
	matrix_quest = {
		"target_matrix": matrix_target,
		"row_constraints": matrix_row_constraints,
		"col_constraints": matrix_col_constraints
	}

func _random_matrix() -> Array:
	var matrix: Array = []
	for _r in range(MATRIX_SIZE):
		var row: Array = []
		for _c in range(MATRIX_SIZE):
			row.append(randi() % 2)
		matrix.append(row)
	return matrix

func _build_row_constraints(target: Array) -> Array:
	var constraints: Array = []
	for r in range(MATRIX_SIZE):
		var row_value = _row_value_from_bits(target[r])
		constraints.append({
			"hex_value": row_value,
			"is_hex_visible": true
		})
	return constraints

func _build_col_constraints(target: Array) -> Array:
	var constraints: Array = []
	for c in range(MATRIX_SIZE):
		var ones = 0
		for r in range(MATRIX_SIZE):
			ones += target[r][c]
		var parity = ones % 2
		constraints.append({
			"ones_count": ones,
			"parity": parity
		})
	return constraints

func _row_value_from_bits(bits: Array) -> int:
	var sum = 0
	for c in range(MATRIX_SIZE):
		if bits[c] == 1:
			sum += MATRIX_WEIGHTS[c]
	return sum

func _row_bits_from_value(value: int) -> Array:
	var bits: Array = []
	for c in range(MATRIX_SIZE):
		bits.append(1 if (value & MATRIX_WEIGHTS[c]) != 0 else 0)
	return bits

func _pick_row_visibility(row_constraints: Array, col_constraints: Array) -> Array:
	var rows: Array = []
	for i in range(MATRIX_SIZE):
		rows.append(i)
	for hide_count in [2, 1]:
		var combos = _combinations(rows, hide_count)
		combos.shuffle()
		for combo in combos:
			var visibility: Array = []
			for r in rows:
				visibility.append(not combo.has(r))
			if _count_matrix_solutions(row_constraints, col_constraints, visibility) == 1:
				return visibility
	return []

func _count_matrix_solutions(row_constraints: Array, col_constraints: Array, visibility: Array) -> int:
	_solver_row_constraints = row_constraints
	_solver_col_targets = []
	_solver_col_parity = []
	for c in range(MATRIX_SIZE):
		_solver_col_targets.append(col_constraints[c].ones_count)
		_solver_col_parity.append(col_constraints[c].parity)
	_solver_visibility = visibility
	_solver_col_sums = []
	for _i in range(MATRIX_SIZE):
		_solver_col_sums.append(0)
	_solver_solutions = 0

	_solver_backtrack(0)
	return _solver_solutions

func _solver_row_fits(bits: Array, row_idx: int) -> bool:
	var remaining = MATRIX_SIZE - (row_idx + 1)
	for c in range(MATRIX_SIZE):
		var new_sum = _solver_col_sums[c] + bits[c]
		if new_sum > _solver_col_targets[c]:
			return false
		if new_sum + remaining < _solver_col_targets[c]:
			return false
	return true

func _solver_backtrack(row_idx: int) -> void:
	if _solver_solutions > 1:
		return
	if row_idx >= MATRIX_SIZE:
		for c in range(MATRIX_SIZE):
			if _solver_col_sums[c] != _solver_col_targets[c]:
				return
			if (_solver_col_sums[c] % 2) != _solver_col_parity[c]:
				return
		_solver_solutions += 1
		return

	if _solver_visibility[row_idx]:
		var bits = _row_bits_from_value(_solver_row_constraints[row_idx].hex_value)
		if _solver_row_fits(bits, row_idx):
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] += bits[c]
			_solver_backtrack(row_idx + 1)
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] -= bits[c]
	else:
		for mask in range(1 << MATRIX_SIZE):
			var bits: Array = []
			for c in range(MATRIX_SIZE):
				var bit = 1 if (mask & MATRIX_WEIGHTS[c]) != 0 else 0
				bits.append(bit)
			if not _solver_row_fits(bits, row_idx):
				continue
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] += bits[c]
			_solver_backtrack(row_idx + 1)
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] -= bits[c]

func _combinations(items: Array, count: int) -> Array:
	var results: Array = []
	if count == 1:
		for item in items:
			results.append([item])
		return results
	if count == 2:
		for i in range(items.size()):
			for j in range(i + 1, items.size()):
				results.append([items[i], items[j]])
		return results
	return results
</file>

<file path="scenes/RadioQuestA.tscn">
[gd_scene load_steps=6 format=3]

[ext_resource type="Script" path="res://scenes/RadioQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]
[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="4_5mfhd"]
[ext_resource type="Script" path="res://scenes/BitKnob.gd" id="4_knob_script"]

[node name="RadioQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" type="CanvasLayer" parent="." instance=ExtResource("3_noir")]
layer = 100
script = ExtResource("4_5mfhd")
intensity = 0.18
fx_quality = 1
tint_color = Color(0.93, 0.93, 0.93, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Header" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2

[node name="HeaderHBox" type="HBoxContainer" parent="SafeArea/RootVBox/Header"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "BACK"

[node name="TitleLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 28
text = "RADIO INTERCEPT | A"

[node name="MetaLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(360, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "MODE | STABILITY"
horizontal_alignment = 2

[node name="BodyHSplit" type="HSplitContainer" parent="SafeArea/RootVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 900

[node name="LeftPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LeftMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="LeftVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="MissionCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
custom_minimum_size = Vector2(0, 130)
layout_mode = 2

[node name="MissionMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="MissionVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="MissionTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "MISSION"

[node name="TargetLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 26
text = "N = 128"

[node name="RuleLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Find minimal i where 2^i >= N"
autowrap_mode = 2

[node name="ScopeCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScopeMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="ScopeLayer" type="Control" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="WaveLine" type="Line2D" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin/ScopeLayer"]
width = 3.0
default_color = Color(0.2, 1, 0.2, 1)

[node name="ReadoutRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_constants/separation = 12

[node name="BitsValueLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 34
text = "i = 1"

[node name="FitValueLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "FIT: NO"

[node name="RightPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RightMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="RightVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="DecoderTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "DECODER"

[node name="BitKnob" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(220, 220)
layout_mode = 2
size_flags_horizontal = 4
script = ExtResource("4_knob_script")
min_value = 1
max_value = 12
value = 1
min_angle_deg = -135.0
max_angle_deg = 135.0

[node name="KnobHint" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Turn knob, then ANALYZE"
autowrap_mode = 2

[node name="ActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 10

[node name="BtnHint" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "HINT"

[node name="BtnAnalyze" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "ANALYZE"

[node name="BtnCapture" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "CAPTURE"

[node name="BtnNext" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
visible = false
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "NEXT"

[node name="SampleStrip" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 32)
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Sample1" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample2" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample3" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample4" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample5" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample6" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample7" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 20
theme_override_colors/font_color = Color(0, 0, 0, 1)
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StatusLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 88)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Status"
autowrap_mode = 2

[node name="BtnDetails" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "DETAILS"

[node name="Footer" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2

[node name="FooterMargin" type="MarginContainer" parent="SafeArea/RootVBox/Footer"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="FooterLabel" type="Label" parent="SafeArea/RootVBox/Footer/FooterMargin"]
layout_mode = 2
theme_override_font_sizes/font_size = 18

[node name="Dimmer" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
color = Color(0, 0, 0, 0.6)

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -320.0
grow_horizontal = 2
grow_vertical = 0

[node name="DetailsMargin" type="MarginContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="DetailsVBox" type="VBoxContainer" parent="DetailsSheet/DetailsMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "DETAILS"

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_vertical = 3

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "CLOSE"
</file>

<file path="scenes/QuestSelect.gd">
extends Control

const PHONE_LANDSCAPE_MAX_HEIGHT := 520.0
const MOBILE_BREAKPOINT := 840.0
const TABLET_BREAKPOINT := 1300.0

@onready var safe_area: MarginContainer = $SafeArea
@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var title_label: Label = $SafeArea/MainLayout/Title
@onready var quest_grid: GridContainer = $SafeArea/MainLayout/QuestGrid
@onready var modal: Panel = $ModalLayer/ModeSelectionModal
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel

@onready var btn_clues: Button = $SafeArea/MainLayout/QuestGrid/CluesButton
@onready var btn_radio: Button = $SafeArea/MainLayout/QuestGrid/RadioButton
@onready var btn_decryptor: Button = $SafeArea/MainLayout/QuestGrid/DecryptorButton
@onready var btn_lie: Button = $SafeArea/MainLayout/QuestGrid/LieDetectorButton
@onready var btn_script: Button = $SafeArea/MainLayout/QuestGrid/SuspectScriptButton
@onready var btn_city: Button = $SafeArea/MainLayout/QuestGrid/CityMapButton
@onready var btn_archive: Button = $SafeArea/MainLayout/QuestGrid/DataArchiveButton
@onready var btn_report: Button = $SafeArea/MainLayout/QuestGrid/FinalReportButton
@onready var btn_network_trace: Button = $SafeArea/MainLayout/QuestGrid/NetworkTraceButton

@onready var btn_complexity_a: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnComplexityA
@onready var btn_complexity_b: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnComplexityB
@onready var btn_complexity_c: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnComplexityC
@onready var btn_close: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnClose
@onready var modal_title: Label = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/ModalTitle
@onready var modal_box: VBoxContainer = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer

const COLOR_READY := Color(0.88, 0.88, 0.88, 1.0)
const COLOR_LOCKED := Color(0.92, 0.36, 0.4, 1.0)

enum QuestType { DECRYPTOR, LOGIC_GATE, RADIO, SUSPECT, CITY_MAP, DATA_ARCHIVE, FINAL_REPORT, NETWORK_TRACE, CLUES }
var selected_quest_type := QuestType.DECRYPTOR

const TITLE_TEXT := "ВЫБОР КВЕСТА"
const STATUS_READY := "Выберите квест"
const STATUS_LOCKED := "Этот квест пока не готов"

const BTN_CLUES_TEXT := "Цифровая реанимация"
const BTN_RADIO_TEXT := "Радиоперехват"
const BTN_DECRYPTOR_TEXT := "Дешифрование"
const BTN_LIE_TEXT := "Детектор лжи"
const BTN_SCRIPT_TEXT := "Скрипт подозреваемого"
const BTN_CITY_TEXT := "Карта города"
const BTN_ARCHIVE_TEXT := "Архив данных"
const BTN_REPORT_TEXT := "Финальный отчет"
const BTN_NETWORK_TRACE_TEXT := "Сетевой след"

const MODAL_TITLE_TEXT := "ВЫБОР СЛОЖНОСТИ"
const COMPLEXITY_A_TEXT := "СЛОЖНОСТЬ A"
const COMPLEXITY_B_TEXT := "СЛОЖНОСТЬ B"
const COMPLEXITY_C_TEXT := "СЛОЖНОСТЬ C"
const BTN_CLOSE_TEXT := "НАЗАД"

func _ready() -> void:
	modal.visible = false
	title_label.text = TITLE_TEXT
	status_label.text = STATUS_READY
	status_label.modulate = COLOR_READY

	_set_button_labels()
	_set_modal_labels()
	_connect_buttons()
	_disable_unready()
	_on_viewport_size_changed()
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)
	call_deferred("_animate_intro")

func _set_button_labels() -> void:
	btn_clues.text = BTN_CLUES_TEXT
	btn_radio.text = BTN_RADIO_TEXT
	btn_decryptor.text = BTN_DECRYPTOR_TEXT
	btn_lie.text = BTN_LIE_TEXT
	btn_script.text = BTN_SCRIPT_TEXT
	btn_city.text = BTN_CITY_TEXT
	btn_archive.text = BTN_ARCHIVE_TEXT
	btn_report.text = BTN_REPORT_TEXT
	btn_network_trace.text = BTN_NETWORK_TRACE_TEXT

func _set_modal_labels() -> void:
	modal_title.text = MODAL_TITLE_TEXT
	btn_complexity_a.text = COMPLEXITY_A_TEXT
	btn_complexity_b.text = COMPLEXITY_B_TEXT
	btn_complexity_c.text = COMPLEXITY_C_TEXT
	btn_close.text = BTN_CLOSE_TEXT

func _connect_buttons() -> void:
	btn_decryptor.pressed.connect(_on_decryptor_pressed)
	btn_lie.pressed.connect(_on_lie_detector_pressed)
	btn_radio.pressed.connect(_on_radio_pressed)
	btn_clues.pressed.connect(_on_clues_pressed)
	btn_script.pressed.connect(_on_script_pressed)
	btn_city.pressed.connect(_on_city_pressed)
	btn_archive.pressed.connect(_on_archive_pressed)
	btn_report.pressed.connect(_on_report_pressed)
	btn_network_trace.pressed.connect(_on_network_trace_pressed)

	btn_complexity_a.pressed.connect(_on_complexity_a_pressed)
	btn_complexity_b.pressed.connect(_on_complexity_b_pressed)
	btn_complexity_c.pressed.connect(_on_complexity_c_pressed)
	btn_close.pressed.connect(_on_close_modal_pressed)

func _disable_unready() -> void:
	btn_clues.disabled = false
	btn_radio.disabled = false
	btn_script.disabled = false
	btn_city.disabled = false
	btn_archive.disabled = false
	btn_report.disabled = false
	btn_network_trace.disabled = false
	btn_complexity_c.disabled = true

func _on_decryptor_pressed() -> void:
	selected_quest_type = QuestType.DECRYPTOR
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_lie_detector_pressed() -> void:
	selected_quest_type = QuestType.LOGIC_GATE
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_radio_pressed() -> void:
	selected_quest_type = QuestType.RADIO
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_clues_pressed() -> void:
	selected_quest_type = QuestType.CLUES
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_script_pressed() -> void:
	selected_quest_type = QuestType.SUSPECT
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_city_pressed() -> void:
	selected_quest_type = QuestType.CITY_MAP
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_archive_pressed() -> void:
	selected_quest_type = QuestType.DATA_ARCHIVE
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_report_pressed() -> void:
	selected_quest_type = QuestType.FINAL_REPORT
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_network_trace_pressed() -> void:
	selected_quest_type = QuestType.NETWORK_TRACE
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_complexity_a_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	match selected_quest_type:
		QuestType.DECRYPTOR:
			get_tree().change_scene_to_file("res://scenes/Decryptor.tscn")
		QuestType.LOGIC_GATE:
			get_tree().change_scene_to_file("res://scenes/LogicQuestA.tscn")
		QuestType.RADIO:
			get_tree().change_scene_to_file("res://scenes/RadioQuestA.tscn")
		QuestType.SUSPECT:
			get_tree().change_scene_to_file("res://scenes/SuspectQuestA.tscn")
		QuestType.CITY_MAP:
			get_tree().change_scene_to_file("res://scenes/CityMapQuestA.tscn")
		QuestType.DATA_ARCHIVE:
			get_tree().change_scene_to_file("res://scenes/case_07/da7_data_archive_a.tscn")
		QuestType.FINAL_REPORT:
			get_tree().change_scene_to_file("res://scenes/case_08/fr8_final_report_a.tscn")
		QuestType.NETWORK_TRACE:
			get_tree().change_scene_to_file("res://scenes/NetworkTraceQuestA.tscn")
		QuestType.CLUES:
			get_tree().change_scene_to_file("res://scenes/case_01/DigitalResusQuestA.tscn")

func _on_complexity_b_pressed() -> void:
	if selected_quest_type == QuestType.FINAL_REPORT:
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/case_08/fr8_final_report_b.tscn")
		return
	if selected_quest_type == QuestType.DECRYPTOR:
		GlobalMetrics.current_level_index = 15
		get_tree().change_scene_to_file("res://scenes/Decryptor.tscn")
	elif selected_quest_type == QuestType.LOGIC_GATE:
		get_tree().change_scene_to_file("res://scenes/LogicQuestB.tscn")
	elif selected_quest_type == QuestType.RADIO:
		get_tree().change_scene_to_file("res://scenes/RadioQuestB.tscn")
	elif selected_quest_type == QuestType.SUSPECT:
		get_tree().change_scene_to_file("res://scenes/RestoreQuestB.tscn")
	elif selected_quest_type == QuestType.CITY_MAP:
		get_tree().change_scene_to_file("res://scenes/CityMapQuestB.tscn")
	elif selected_quest_type == QuestType.DATA_ARCHIVE:
		get_tree().change_scene_to_file("res://scenes/case_07/da7_data_archive_b.tscn")
	elif selected_quest_type == QuestType.NETWORK_TRACE:
		get_tree().change_scene_to_file("res://scenes/NetworkTraceQuestB.tscn")
	elif selected_quest_type == QuestType.CLUES:
		get_tree().change_scene_to_file("res://scenes/case_01/DigitalResusQuestB.tscn")

func _on_complexity_c_pressed() -> void:
	if selected_quest_type == QuestType.FINAL_REPORT:
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/case_08/fr8_final_report_c.tscn")
		return
	if selected_quest_type == QuestType.DECRYPTOR:
		get_tree().change_scene_to_file("res://scenes/MatrixDecryptor.tscn")
	elif selected_quest_type == QuestType.LOGIC_GATE:
		get_tree().change_scene_to_file("res://scenes/LogicQuestC.tscn")
	elif selected_quest_type == QuestType.RADIO:
		get_tree().change_scene_to_file("res://scenes/RadioQuestC.tscn")
	elif selected_quest_type == QuestType.SUSPECT:
		get_tree().change_scene_to_file("res://scenes/DisarmQuestC.tscn")
	elif selected_quest_type == QuestType.CITY_MAP:
		get_tree().change_scene_to_file("res://scenes/CityMapQuestC.tscn")
	elif selected_quest_type == QuestType.DATA_ARCHIVE:
		get_tree().change_scene_to_file("res://scenes/case_07/da7_data_archive_c.tscn")
	elif selected_quest_type == QuestType.NETWORK_TRACE:
		get_tree().change_scene_to_file("res://scenes/NetworkTraceQuestC.tscn")
	elif selected_quest_type == QuestType.CLUES:
		get_tree().change_scene_to_file("res://scenes/case_01/DigitalResusQuestC.tscn")

func _on_close_modal_pressed() -> void:
	modal.visible = false

func _set_complexity_enabled(enable_b: bool, enable_c: bool) -> void:
	btn_complexity_b.disabled = not enable_b
	btn_complexity_c.disabled = not enable_c

func _on_viewport_size_changed() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var width: float = viewport_size.x
	if _is_phone_landscape(viewport_size):
		quest_grid.columns = 3
		_apply_layout_profile(38, 15, 70, 8, 10, 6)
		_apply_modal_profile(28, 19, clampf(viewport_size.x - 40.0, 320.0, 480.0), clampf(viewport_size.y - 24.0, 220.0, 320.0))
	elif width < MOBILE_BREAKPOINT:
		quest_grid.columns = 1
		_apply_layout_profile(48, 18, 100, 12, 16, 12)
		_apply_modal_profile(36, 24, clampf(viewport_size.x - 40.0, 320.0, 560.0), clampf(viewport_size.y - 60.0, 260.0, 420.0))
	elif width < TABLET_BREAKPOINT:
		quest_grid.columns = 2
		_apply_layout_profile(54, 19, 108, 14, 20, 14)
		_apply_modal_profile(40, 27, 560.0, 400.0)
	else:
		quest_grid.columns = 3
		_apply_layout_profile(58, 20, 118, 14, 24, 16)
		_apply_modal_profile(44, 30, 620.0, 420.0)

func _is_phone_landscape(size: Vector2) -> bool:
	return size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

func _apply_layout_profile(title_size: int, info_size: int, button_height: float, gap: int, margin_side: int, margin_vertical: int) -> void:
	title_label.add_theme_font_size_override("font_size", title_size)
	status_label.add_theme_font_size_override("font_size", info_size)
	status_label.custom_minimum_size.y = max(32.0, button_height * 0.4)
	main_layout.add_theme_constant_override("separation", gap + 6)
	quest_grid.add_theme_constant_override("h_separation", gap)
	quest_grid.add_theme_constant_override("v_separation", gap)
	safe_area.add_theme_constant_override("margin_left", margin_side)
	safe_area.add_theme_constant_override("margin_right", margin_side)
	safe_area.add_theme_constant_override("margin_top", margin_vertical)
	safe_area.add_theme_constant_override("margin_bottom", margin_vertical)
	for btn in _all_quest_buttons():
		btn.custom_minimum_size = Vector2(0.0, button_height)
		btn.add_theme_font_size_override("font_size", clamp(info_size + 1, 16, 20))

func _apply_modal_profile(modal_title_size: int, button_font_size: int, min_width: float, min_height: float) -> void:
	modal_box.custom_minimum_size = Vector2(min_width, min_height)
	modal_title.add_theme_font_size_override("font_size", modal_title_size)
	btn_complexity_a.add_theme_font_size_override("font_size", button_font_size)
	btn_complexity_b.add_theme_font_size_override("font_size", button_font_size)
	btn_complexity_c.add_theme_font_size_override("font_size", button_font_size)
	btn_complexity_a.custom_minimum_size.y = max(56.0, float(button_font_size) * 2.25)
	btn_complexity_b.custom_minimum_size.y = max(56.0, float(button_font_size) * 2.25)
	btn_complexity_c.custom_minimum_size.y = max(56.0, float(button_font_size) * 2.25)
	btn_close.add_theme_font_size_override("font_size", max(18, button_font_size - 5))
	btn_close.custom_minimum_size.y = max(48.0, float(button_font_size) * 2.0)

func _animate_intro() -> void:
	title_label.modulate.a = 0.0
	var tween: Tween = create_tween()
	tween.tween_property(title_label, "modulate:a", 1.0, 0.3)

	for i in range(_all_quest_buttons().size()):
		var btn: Button = _all_quest_buttons()[i]
		btn.modulate.a = 0.0
		btn.scale = Vector2(0.97, 0.97)
		btn.pivot_offset = btn.size * 0.5
		var item_tween: Tween = create_tween()
		var delay: float = 0.06 * float(i)
		item_tween.tween_property(btn, "modulate:a", 1.0, 0.2).set_delay(delay)
		item_tween.parallel().tween_property(btn, "scale", Vector2.ONE, 0.24).set_delay(delay).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)

func _all_quest_buttons() -> Array[Button]:
	return [
		btn_clues,
		btn_radio,
		btn_decryptor,
		btn_lie,
		btn_script,
		btn_city,
		btn_archive,
		btn_report,
		btn_network_trace
	]
</file>

</files>
