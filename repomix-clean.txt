This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: text_copies/**, **/package-lock.json, addon/godot-plugin/**, addon/mcp-server/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.editorconfig
.gitattributes
.gitignore
addon/.gitignore
addon/claude_desktop_config.json
addon/LICENSE
addon/PROJECT_PLAN.md
addon/README.md
addon/SUMMARY.md
addon/VISUAL_TREE_ROADMAP.md
audio/click.wav.import
audio/error.wav.import
audio/relay.wav.import
claude_desktop_config.json
data/city_map/level_6_1.json
data/city_map/level_6_2.json
data/city_map/level_6_3.json
data/clues_levels.json
data/final_report_a_levels.json
data/final_report_b_levels.json
data/final_report_c_levels.json
data/network_trace_a_levels.json
data/network_trace_b_levels.json
data/network_trace_c_levels.json
data/quest_b_levels.json
data/quest_c_levels.json
data/suspect_a_levels.json
export_presets.cfg
godot-plugin/addons/godot_mcp/mcp_client.gd
godot-plugin/addons/godot_mcp/plugin.cfg
godot-plugin/addons/godot_mcp/plugin.gd
godot-plugin/addons/godot_mcp/tool_executor.gd
godot-plugin/addons/godot_mcp/tools/asset_tools.gd
godot-plugin/addons/godot_mcp/tools/file_tools.gd
godot-plugin/addons/godot_mcp/tools/project_tools.gd
godot-plugin/addons/godot_mcp/tools/scene_tools.gd
godot-plugin/addons/godot_mcp/tools/script_tools.gd
godot-plugin/addons/godot_mcp/tools/visualizer_tools.gd
godot-plugin/project.godot
godot-plugin/scripts/enemy.gd
godot-plugin/scripts/player.gd
icon.svg
icon.svg.import
LICENSE
mcp-server/package.json
mcp-server/README.md
mcp-server/scripts/build-visualizer.js
mcp-server/src/godot-bridge.ts
mcp-server/src/index.ts
mcp-server/src/tools/asset-tools.ts
mcp-server/src/tools/file-tools.ts
mcp-server/src/tools/index.ts
mcp-server/src/tools/project-tools.ts
mcp-server/src/tools/scene-tools.ts
mcp-server/src/tools/script-tools.ts
mcp-server/src/tools/visualizer-tools.ts
mcp-server/src/types.ts
mcp-server/src/visualizer-server.ts
mcp-server/src/visualizer/canvas.js
mcp-server/src/visualizer/events.js
mcp-server/src/visualizer/layout.js
mcp-server/src/visualizer/main.js
mcp-server/src/visualizer/modals.js
mcp-server/src/visualizer/panel.js
mcp-server/src/visualizer/state.js
mcp-server/src/visualizer/syntax.js
mcp-server/src/visualizer/template.html
mcp-server/src/visualizer/usages.js
mcp-server/src/visualizer/visualizer.css
mcp-server/src/visualizer/websocket.js
mcp-server/tsconfig.json
PROJECT_PLAN.md
project.godot
README.md
scenes/BitKnob.gd
scenes/Blur.gdshader
scenes/Blur.gdshader.uid
scenes/case_01/CluesQuestA.gd
scenes/case_01/CluesQuestA.tscn
scenes/case_01/DigitalResusQuestA.gd
scenes/case_01/DigitalResusQuestA.tscn
scenes/case_01/DigitalResusQuestB.gd
scenes/case_01/DigitalResusQuestB.tscn
scenes/case_01/DigitalResusQuestC.gd
scenes/case_01/DigitalResusQuestC.tscn
scenes/case_07/da7_data_archive_a.tscn
scenes/case_07/da7_data_archive_b.tscn
scenes/case_07/da7_data_archive_c.tscn
scenes/case_08/fr8_final_report_a.tscn
scenes/case_08/fr8_final_report_b.tscn
scenes/case_08/fr8_final_report_c.tscn
scenes/CityMapQuestA.gd
scenes/CityMapQuestA.tscn
scenes/CityMapQuestB.gd
scenes/CityMapQuestB.tscn
scenes/CityMapQuestC.gd
scenes/CityMapQuestC.tscn
scenes/Decryptor.gd
scenes/Decryptor.gd.uid
scenes/Decryptor.tscn
scenes/decryptor/DecryptorUI.tscn
scenes/decryptor/MatrixDecryptorUI.tscn
scenes/DisarmQuestC.tscn
scenes/LearnSelect.gd
scenes/LearnSelect.tscn
scenes/LogicQuestA.gd
scenes/LogicQuestA.gd.uid
scenes/LogicQuestA.tscn
scenes/LogicQuestB.gd
scenes/LogicQuestB.tscn
scenes/LogicQuestC.gd
scenes/LogicQuestC.tscn
scenes/MainMenu.gd
scenes/MainMenu.gd.uid
scenes/MainMenu.tscn
scenes/MatrixDecryptor.gd
scenes/MatrixDecryptor.gd.uid
scenes/MatrixDecryptor.tscn
scenes/NetworkTraceQuest.gd
scenes/NetworkTraceQuestA.tscn
scenes/NetworkTraceQuestB.tscn
scenes/NetworkTraceQuestC.tscn
scenes/QuestSelect.gd
scenes/QuestSelect.gd.uid
scenes/QuestSelect.tscn
scenes/radio_intercept/RadioQuestA.tscn
scenes/RadioQuestA.gd
scenes/RadioQuestA.tscn
scenes/RadioQuestB.gd
scenes/RadioQuestB.tscn
scenes/RadioQuestC.gd
scenes/RadioQuestC.tscn
scenes/RestoreQuestB.tscn
scenes/SuspectQuestA.tscn
scenes/TimeKnob.gd
scenes/ui/ClueItem.tscn
scenes/ui/ConfigCard.tscn
scenes/ui/DiagnosticsPanelB.tscn
scenes/ui/DiagnosticsPanelC.tscn
scenes/ui/FixMenuC.tscn
scenes/ui/InspectBadge.tscn
scenes/ui/InspectorPopup.tscn
scenes/ui/NetItem.tscn
scenes/ui/NetSlot.tscn
scenes/ui/network_trace/NetworkTraceDeviceCard.tscn
scenes/ui/pipeline/ModuleCard.tscn
scenes/ui/pipeline/PipelineSlot.tscn
scenes/ui/ResultStamp.tscn
scenes/ui/ResusPartItem.tscn
scenes/ui/subnet/BitCell.tscn
scenes/ui/subnet/LockIndicator.tscn
scenes/ui/subnet/MaskOverlay.tscn
scenes/ui/subnet/SubnetRuler.tscn
scenes/ui/TagFragmentItem.tscn
scenes/ui/TagPileZone.tscn
scenes/ui/TagSlotZone.tscn
scenes/ui/TimelineCard.tscn
scripts/AudioManager.gd
scripts/case_01/ResusData.gd
scripts/case_01/ResusScoring.gd
scripts/case_07/da7_cases_a.gd
scripts/case_07/da7_cases_b.gd
scripts/case_07/da7_cases_c.gd
scripts/case_07/da7_cases.gd
scripts/case_07/da7_data_archive_a.gd
scripts/case_07/da7_data_archive_b.gd
scripts/case_07/da7_data_archive_c.gd
scripts/case_08/fr8_data.gd
scripts/case_08/fr8_final_report_a.gd
scripts/case_08/fr8_final_report_b.gd
scripts/case_08/fr8_final_report_c.gd
scripts/case_08/fr8_scoring.gd
scripts/case_08/fr8b_data.gd
scripts/case_08/fr8b_scoring.gd
scripts/case_08/fr8c_data.gd
scripts/case_08/fr8c_scoring.gd
scripts/DisarmQuestC.gd
scripts/GlobalMetrics.gd
scripts/GlobalMetrics.gd.uid
scripts/quests/network_trace/NetworkTraceQuestA.gd
scripts/quests/network_trace/NetworkTraceQuestB.gd
scripts/quests/network_trace/NetworkTraceQuestC.gd
scripts/radio_intercept/RadioQuestA.gd
scripts/RestoreQuestB.gd
scripts/sign.py
scripts/ssot/network_trace_errors.gd
scripts/SuspectQuestA.gd
scripts/TrialV2.gd
scripts/ui/ClueBucketZone.gd
scripts/ui/ClueItem.gd
scripts/ui/CodeBlock.gd
scripts/ui/ConfigCard.gd
scripts/ui/ConnectorOverlay.gd
scripts/ui/DiagnosticsPanelB.gd
scripts/ui/DiagnosticsPanelC.gd
scripts/ui/DropZone.gd
scripts/ui/FixMenuC.gd
scripts/ui/InspectorPopup.gd
scripts/ui/NetItem.gd
scripts/ui/NetSlot.gd
scripts/ui/network_trace/network_trace_device_card.gd
scripts/ui/network_trace/topology_board_a.gd
scripts/ui/pipeline/ModuleCard.gd
scripts/ui/pipeline/PipelineSlot.gd
scripts/ui/ResultStamp.gd
scripts/ui/ResusDropZone.gd
scripts/ui/ResusPartItem.gd
scripts/ui/ResusPileZone.gd
scripts/ui/subnet/BitCell.gd
scripts/ui/subnet/LockIndicator.gd
scripts/ui/subnet/MaskDropTarget.gd
scripts/ui/subnet/MaskOverlay.gd
scripts/ui/subnet/SubnetRuler.gd
scripts/ui/TagFragmentItem.gd
scripts/ui/TagPileZone.gd
scripts/ui/TagSlotZone.gd
scripts/ui/TimelineCard.gd
shaders/blur.gdshader
shaders/blur.gdshader.uid
SUMMARY.md
ui/overlays/NoirOverlay.gd
ui/overlays/NoirOverlay.tscn
ui/shaders/crt_overlay.gdshader
ui/shaders/noir_pencil_overlay.gdshader
ui/theme_noir_detective.tres
ui/theme_noir_pencil.tres
ui/theme_terminal_amber.tres
ui/theme_terminal_green.tres
ui/theme_untformatic.tres
VISUAL_TREE_ROADMAP.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".editorconfig">
root = true

[*]
charset = utf-8
</file>

<file path=".gitattributes">
# Normalize EOL for all files that Git considers text files.
* text=auto eol=lf
</file>

<file path=".gitignore">
# Godot 4+ specific ignores
.godot/
/android/
</file>

<file path="audio/click.wav.import">
[remap]

importer="wav"
type="AudioStreamWAV"
uid="uid://c2ft5g74r8cei"
path="res://.godot/imported/click.wav-fd13f10d6f727710e39f04648321cf68.sample"

[deps]

source_file="res://audio/click.wav"
dest_files=["res://.godot/imported/click.wav-fd13f10d6f727710e39f04648321cf68.sample"]

[params]

force/8_bit=false
force/mono=false
force/max_rate=false
force/max_rate_hz=44100
edit/trim=false
edit/normalize=false
edit/loop_mode=0
edit/loop_begin=0
edit/loop_end=-1
compress/mode=0
</file>

<file path="audio/error.wav.import">
[remap]

importer="wav"
type="AudioStreamWAV"
uid="uid://c4se3pomlhl5s"
path="res://.godot/imported/error.wav-7758481f0b630740b3553187f425c005.sample"

[deps]

source_file="res://audio/error.wav"
dest_files=["res://.godot/imported/error.wav-7758481f0b630740b3553187f425c005.sample"]

[params]

force/8_bit=false
force/mono=false
force/max_rate=false
force/max_rate_hz=44100
edit/trim=false
edit/normalize=false
edit/loop_mode=0
edit/loop_begin=0
edit/loop_end=-1
compress/mode=0
</file>

<file path="audio/relay.wav.import">
[remap]

importer="wav"
type="AudioStreamWAV"
uid="uid://b7yubqykijwtw"
path="res://.godot/imported/relay.wav-116b448ac11417a04cb15209b9a5dfbb.sample"

[deps]

source_file="res://audio/relay.wav"
dest_files=["res://.godot/imported/relay.wav-116b448ac11417a04cb15209b9a5dfbb.sample"]

[params]

force/8_bit=false
force/mono=false
force/max_rate=false
force/max_rate_hz=44100
edit/trim=false
edit/normalize=false
edit/loop_mode=0
edit/loop_begin=0
edit/loop_end=-1
compress/mode=0
</file>

<file path="export_presets.cfg">
[preset.0]

name="Android"
platform="Android"
runnable=true
advanced_options=false
dedicated_server=false
custom_features=""
export_filter="all_resources"
include_filter=""
exclude_filter=""
export_path="../UNTformatic.apk"
encryption_include_filters=""
encryption_exclude_filters=""
encrypt_pck=false
encrypt_directory=false
script_export_mode=2

[preset.0.options]

custom_template/debug=""
custom_template/release=""
gradle_build/use_gradle_build=false
gradle_build/gradle_build_directory=""
gradle_build/android_source_template=""
gradle_build/compress_native_libraries=false
gradle_build/export_format=0
gradle_build/min_sdk=""
gradle_build/target_sdk=""
architectures/armeabi-v7a=false
architectures/arm64-v8a=true
architectures/x86=false
architectures/x86_64=false
version/code=1
version/name=""
package/unique_name="kz.enu.ent_informatics"
package/name=""
package/signed=true
package/app_category=2
package/retain_data_on_uninstall=false
package/exclude_from_recents=false
package/show_in_android_tv=false
package/show_in_app_library=true
package/show_as_launcher_app=false
launcher_icons/main_192x192=""
launcher_icons/adaptive_foreground_432x432=""
launcher_icons/adaptive_background_432x432=""
graphics/opengl_debug=false
xr_features/xr_mode=0
screen/immersive_mode=true
screen/support_small=true
screen/support_normal=true
screen/support_large=true
screen/support_xlarge=true
user_data_backup/allow=false
command_line/extra_args=""
apk_expansion/enable=false
apk_expansion/SALT=""
apk_expansion/public_key=""
permissions/custom_permissions=PackedStringArray()
permissions/access_checkin_properties=false
permissions/access_coarse_location=false
permissions/access_fine_location=false
permissions/access_location_extra_commands=false
permissions/access_mock_location=false
permissions/access_network_state=false
permissions/access_surface_flinger=false
permissions/access_wifi_state=false
permissions/account_manager=false
permissions/add_voicemail=false
permissions/authenticate_accounts=false
permissions/battery_stats=false
permissions/bind_accessibility_service=false
permissions/bind_appwidget=false
permissions/bind_device_admin=false
permissions/bind_input_method=false
permissions/bind_nfc_service=false
permissions/bind_notification_listener_service=false
permissions/bind_print_service=false
permissions/bind_remoteviews=false
permissions/bind_text_service=false
permissions/bind_vpn_service=false
permissions/bind_wallpaper=false
permissions/bluetooth=false
permissions/bluetooth_admin=false
permissions/bluetooth_privileged=false
permissions/brick=false
permissions/broadcast_package_removed=false
permissions/broadcast_sms=false
permissions/broadcast_sticky=false
permissions/broadcast_wap_push=false
permissions/call_phone=false
permissions/call_privileged=false
permissions/camera=false
permissions/capture_audio_output=false
permissions/capture_secure_video_output=false
permissions/capture_video_output=false
permissions/change_component_enabled_state=false
permissions/change_configuration=false
permissions/change_network_state=false
permissions/change_wifi_multicast_state=false
permissions/change_wifi_state=false
permissions/clear_app_cache=false
permissions/clear_app_user_data=false
permissions/control_location_updates=false
permissions/delete_cache_files=false
permissions/delete_packages=false
permissions/device_power=false
permissions/diagnostic=false
permissions/disable_keyguard=false
permissions/dump=false
permissions/expand_status_bar=false
permissions/factory_test=false
permissions/flashlight=false
permissions/force_back=false
permissions/get_accounts=false
permissions/get_package_size=false
permissions/get_tasks=false
permissions/get_top_activity_info=false
permissions/global_search=false
permissions/hardware_test=false
permissions/inject_events=false
permissions/install_location_provider=false
permissions/install_packages=false
permissions/install_shortcut=false
permissions/internal_system_window=false
permissions/internet=false
permissions/kill_background_processes=false
permissions/location_hardware=false
permissions/manage_accounts=false
permissions/manage_app_tokens=false
permissions/manage_documents=false
permissions/manage_external_storage=false
permissions/master_clear=false
permissions/media_content_control=false
permissions/modify_audio_settings=false
permissions/modify_phone_state=false
permissions/mount_format_filesystems=false
permissions/mount_unmount_filesystems=false
permissions/nfc=false
permissions/persistent_activity=false
permissions/post_notifications=false
permissions/process_outgoing_calls=false
permissions/read_calendar=false
permissions/read_call_log=false
permissions/read_contacts=false
permissions/read_external_storage=false
permissions/read_frame_buffer=false
permissions/read_history_bookmarks=false
permissions/read_input_state=false
permissions/read_logs=false
permissions/read_phone_state=false
permissions/read_profile=false
permissions/read_sms=false
permissions/read_social_stream=false
permissions/read_sync_settings=false
permissions/read_sync_stats=false
permissions/read_user_dictionary=false
permissions/reboot=false
permissions/receive_boot_completed=false
permissions/receive_mms=false
permissions/receive_sms=false
permissions/receive_wap_push=false
permissions/record_audio=false
permissions/reorder_tasks=false
permissions/restart_packages=false
permissions/send_respond_via_message=false
permissions/send_sms=false
permissions/set_activity_watcher=false
permissions/set_alarm=false
permissions/set_always_finish=false
permissions/set_animation_scale=false
permissions/set_debug_app=false
permissions/set_orientation=false
permissions/set_pointer_speed=false
permissions/set_preferred_applications=false
permissions/set_process_limit=false
permissions/set_time=false
permissions/set_time_zone=false
permissions/set_wallpaper=false
permissions/set_wallpaper_hints=false
permissions/signal_persistent_processes=false
permissions/status_bar=false
permissions/subscribed_feeds_read=false
permissions/subscribed_feeds_write=false
permissions/system_alert_window=false
permissions/transmit_ir=false
permissions/uninstall_shortcut=false
permissions/update_device_stats=false
permissions/use_credentials=false
permissions/use_sip=false
permissions/vibrate=false
permissions/wake_lock=false
permissions/write_apn_settings=false
permissions/write_calendar=false
permissions/write_call_log=false
permissions/write_contacts=false
permissions/write_external_storage=false
permissions/write_gservices=false
permissions/write_history_bookmarks=false
permissions/write_profile=false
permissions/write_secure_settings=false
permissions/write_settings=false
permissions/write_sms=false
permissions/write_social_stream=false
permissions/write_sync_settings=false
permissions/write_user_dictionary=false
</file>

<file path="icon.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128"><rect width="124" height="124" x="2" y="2" fill="#363d52" stroke="#212532" stroke-width="4" rx="14"/><g fill="#fff" transform="translate(12.322 12.322)scale(.101)"><path d="M105 673v33q407 354 814 0v-33z"/><path fill="#478cbf" d="m105 673 152 14q12 1 15 14l4 67 132 10 8-61q2-11 15-15h162q13 4 15 15l8 61 132-10 4-67q3-13 15-14l152-14V427q30-39 56-81-35-59-83-108-43 20-82 47-40-37-88-64 7-51 8-102-59-28-123-42-26 43-46 89-49-7-98 0-20-46-46-89-64 14-123 42 1 51 8 102-48 27-88 64-39-27-82-47-48 49-83 108 26 42 56 81zm0 33v39c0 276 813 276 814 0v-39l-134 12-5 69q-2 10-14 13l-162 11q-12 0-16-11l-10-65H446l-10 65q-4 11-16 11l-162-11q-12-3-14-13l-5-69z"/><path d="M483 600c0 34 58 34 58 0v-86c0-34-58-34-58 0z"/><circle cx="725" cy="526" r="90"/><circle cx="299" cy="526" r="90"/></g><g fill="#414042" transform="translate(12.322 12.322)scale(.101)"><circle cx="307" cy="532" r="60"/><circle cx="717" cy="532" r="60"/></g></svg>
</file>

<file path="scenes/Blur.gdshader">
shader_type canvas_item;

uniform float lod: hint_range(0.0, 5.0) = 0.0;
uniform vec4 modulate: source_color = vec4(0.0, 0.0, 0.0, 0.8);

void fragment() {
	vec4 color = texture(TEXTURE, UV, lod);
	COLOR = color * modulate;
}
</file>

<file path="scenes/Blur.gdshader.uid">
uid://cfcttjjhg0ff6
</file>

<file path="scenes/Decryptor.gd.uid">
uid://bhtu3gcydl223
</file>

<file path="scenes/LogicQuestA.gd.uid">
uid://halel5kevhfj
</file>

<file path="scenes/MainMenu.gd.uid">
uid://dbkn8k0aa003
</file>

<file path="scenes/MatrixDecryptor.gd.uid">
uid://pmdbb6uujm4h
</file>

<file path="scenes/QuestSelect.gd.uid">
uid://bdwp1mh211r68
</file>

<file path="scripts/GlobalMetrics.gd.uid">
uid://bwe0if03e7s1m
</file>

<file path="scripts/sign.py">
import wave
import struct
import math
import random

def generate_wav(filename, duration, volume=0.5, func=None):
    # Параметры звука
    sample_rate = 44100.0  # Частота дискретизации (Гц)
    num_samples = int(duration * sample_rate)
    
    # Открываем файл на запись
    with wave.open(filename, 'w') as wav_file:
        # Устанавливаем параметры: 1 канал (моно), 2 байта на семпл (16 бит), частота
        wav_file.setparams((1, 2, int(sample_rate), num_samples, 'NONE', 'not compressed'))
        
        for i in range(num_samples):
            t = i / sample_rate
            # Генерируем значение амплитуды через переданную функцию
            value = func(t, duration, volume)
            
            # Ограничиваем амплитуду и переводим в 16-битное целое число
            sample = int(max(-1, min(1, value)) * 32767)
            wav_file.writeframes(struct.pack('<h', sample))

# 1. Механический клик (короткий импульс с затуханием)
def click_sound(t, duration, volume):
    # Высокочастотный синус с очень быстрым экспоненциальным затуханием
    freq = 1500
    decay = math.exp(-t * 100)
    return volume * math.sin(2 * math.pi * freq * t) * decay

# 2. Звук реле (двойной щелчок с небольшим шумом)
def relay_sound(t, duration, volume):
    # Два коротких щелчка
    click1 = math.exp(-t * 80) * math.sin(2 * math.pi * 1200 * t)
    click2 = 0
    if t > 0.05:
        click2 = math.exp(-(t-0.05) * 80) * math.sin(2 * math.pi * 1000 * (t-0.05))
    
    # Добавляем немного механического шума
    noise = (random.random() * 2 - 1) * math.exp(-t * 40) * 0.2
    return volume * (click1 + click2 + noise)

# 3. Звук ошибки (низкочастотный "баззер")
def error_sound(t, duration, volume):
    # Прямоугольная волна (дает характерный "игровой" звук ошибки)
    freq = 120
    if math.sin(2 * math.pi * freq * t) > 0:
        return volume * 0.5
    else:
        return -volume * 0.5

# Генерация файлов
print("Генерация звуковых эффектов...")

# Краткий клик (0.05 сек)
generate_wav("click.wav", 0.05, volume=0.6, func=click_sound)

# Реле (0.15 сек)
generate_wav("relay.wav", 0.15, volume=0.5, func=relay_sound)

# Ошибка (0.3 сек)
generate_wav("error.wav", 0.3, volume=0.4, func=error_sound)

print("Готово! Файлы click.wav, relay.wav и error.wav созданы.")
</file>

<file path="shaders/blur.gdshader.uid">
uid://de5yrwj0keuus
</file>

<file path="ui/shaders/noir_pencil_overlay.gdshader">
shader_type canvas_item;

uniform sampler2D screen_tex : hint_screen_texture, repeat_disable, filter_linear_mipmap;

uniform float intensity : hint_range(0.0, 1.0) = 0.34;
uniform float grain_strength : hint_range(0.0, 1.5) = 0.35;
uniform float hatch_strength : hint_range(0.0, 1.5) = 0.3;
uniform float vignette_strength : hint_range(0.0, 1.5) = 0.45;
uniform int fx_quality = 1;
uniform float pulse : hint_range(0.0, 1.0) = 0.0;
uniform float jitter_strength : hint_range(0.0, 2.0) = 0.0;

float hash12(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * 0.1031);
	p3 += dot(p3, p3.yzx + 33.33);
	return fract((p3.x + p3.y) * p3.z);
}

float noise2d(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);
	float a = hash12(i);
	float b = hash12(i + vec2(1.0, 0.0));
	float c = hash12(i + vec2(0.0, 1.0));
	float d = hash12(i + vec2(1.0, 1.0));
	vec2 u = f * f * (3.0 - 2.0 * f);
	return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

void fragment() {
	vec2 uv = SCREEN_UV;
	vec2 sample_uv = uv;

	if (fx_quality > 0) {
		float j = (noise2d(vec2(TIME * 24.0, uv.y * 420.0)) - 0.5) * 0.0045;
		sample_uv.x += j * (jitter_strength + pulse * 1.5);
	}

	vec3 src = texture(screen_tex, sample_uv).rgb;
	float luma = dot(src, vec3(0.299, 0.587, 0.114));

	float grain = noise2d(uv * vec2(1100.0, 760.0) + TIME * 8.0) - 0.5;

	float hatch = 0.0;
	if (fx_quality > 0) {
		vec2 p = uv * vec2(1100.0, 680.0);
		float line_a = abs(sin((p.x + p.y) * 0.048));
		float line_b = abs(sin((p.x - p.y) * 0.062 + 1.2));
		hatch = smoothstep(0.78, 1.0, mix(line_a, line_b, 0.5)) * (1.0 - luma);
	}

	float vignette = smoothstep(0.92, 0.22, length(uv - vec2(0.5)));

	float scratch = 0.0;
	if (pulse > 0.001) {
		float scratch_mask = step(0.988, noise2d(vec2(uv.y * 1400.0, TIME * 28.0)));
		scratch = scratch_mask * pulse;
	}

	float mono = luma;
	mono += grain * grain_strength * 0.18;
	mono -= hatch * hatch_strength * 0.22;
	mono -= scratch * 0.2;
	mono = clamp(mono, 0.0, 1.0);

	float blend_strength = clamp(intensity * vignette * vignette_strength + pulse * 0.16, 0.0, 1.0);
	vec3 noir = vec3(mono);
	vec3 out_col = mix(src, noir, blend_strength);

	COLOR = vec4(out_col, 1.0);
}
</file>

<file path="ui/theme_noir_pencil.tres">
[gd_resource type="Theme" load_steps=10 format=3 uid="uid://hk6g2qwetvdn"]

[ext_resource type="FontFile" uid="uid://b6l43b80tas2q" path="res://fonts/IBMPlexMono-Medium.ttf" id="1_font"]

[sub_resource type="StyleBoxFlat" id="sb_button_disabled"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.0941176, 0.0941176, 0.0941176, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.713726, 0.713726, 0.690196, 0.35)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_button_hover"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.117647, 0.117647, 0.117647, 0.98)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.929412, 0.92549, 0.909804, 0.75)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_button_normal"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.105882, 0.105882, 0.105882, 0.98)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.45)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_button_pressed"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.133333, 0.133333, 0.133333, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.929412, 0.92549, 0.909804, 0.85)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.0784314, 0.0784314, 0.0784314, 0.96)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.45)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_popup_panel"]
content_margin_left = 12.0
content_margin_top = 12.0
content_margin_right = 12.0
content_margin_bottom = 12.0
bg_color = Color(0.0862745, 0.0862745, 0.0862745, 0.98)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.6)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.0705882, 0.0705882, 0.0705882, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.929412, 0.92549, 0.909804, 0.35)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0.866667, 0.866667, 0.854902, 0.95)
corner_radius_top_left = 2
corner_radius_top_right = 2
corner_radius_bottom_right = 2
corner_radius_bottom_left = 2

[resource]
default_font = ExtResource("1_font")
default_font_size = 19
Button/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
Button/colors/font_disabled_color = Color(0.713726, 0.713726, 0.690196, 0.75)
Button/colors/font_hover_color = Color(0.968627, 0.964706, 0.952941, 1)
Button/colors/font_pressed_color = Color(1, 1, 1, 1)
Button/styles/disabled = SubResource("sb_button_disabled")
Button/styles/hover = SubResource("sb_button_hover")
Button/styles/normal = SubResource("sb_button_normal")
Button/styles/pressed = SubResource("sb_button_pressed")
Label/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
LineEdit/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
Panel/styles/panel = SubResource("sb_panel")
PanelContainer/styles/panel = SubResource("sb_panel")
PopupPanel/styles/panel = SubResource("sb_popup_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0.929412, 0.92549, 0.909804, 1)
TextEdit/colors/background_color = Color(0.054902, 0.054902, 0.054902, 1)
TextEdit/colors/caret_color = Color(0.929412, 0.92549, 0.909804, 1)
TextEdit/colors/current_line_color = Color(0.929412, 0.92549, 0.909804, 0.07)
TextEdit/colors/font_color = Color(0.929412, 0.92549, 0.909804, 1)
TextEdit/colors/line_number_color = Color(0.713726, 0.713726, 0.690196, 0.85)
</file>

<file path="addon/.gitignore">
# Dependencies
node_modules/

# Build output
dist/

# OS files
.DS_Store
.DS_Store?
._*

# IDE
.vscode/
.idea/

# Claude
.claude/

# Environment
.env
.env.local
</file>

<file path="addon/claude_desktop_config.json">
{
  "mcpServers": {
    "godot": {
      "command": "node",
      "args": ["/Users/tomeryud/godot-mcp/mcp-server/dist/index.js"]
    }
  }
}
</file>

<file path="addon/LICENSE">
MIT License

Copyright (c) 2025-2026 Tomer Yud

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="addon/PROJECT_PLAN.md">
# Godot MCP Server - Complete Project Plan

## Overview

This document contains everything needed to build a **Godot MCP Server** that integrates Godot game engine tools with the RAGy application via the Model Context Protocol (MCP).

**Goal:** Create a clean, modular MCP server that exposes Godot editor functionality (scene manipulation, script editing, file operations) to any MCP-compatible AI client, with RAGy as the primary client.

---

## Project Paths

```
/Users/tomeryud/
├── projects/RAGy/                    # RAGy app (MCP client) - REFERENCE
├── godot-ai-assistant/               # Old Godot app - REFERENCE (do not modify)
└── godot-mcp/                        # NEW PROJECT (build here)
    ├── mcp-server/                   # Node.js MCP server
    └── godot-plugin/                 # Minimal GDScript plugin
```

---

## Part 1: Understanding RAGy (The MCP Client)

### What is RAGy?

RAGy is an Electron desktop app for building RAG (Retrieval-Augmented Generation) systems. It allows users to:
- Upload documents and chunk them
- Generate embeddings and build vector databases
- Chat with AI using RAG context
- Use MCP tools for extended functionality

### RAGy's MCP Architecture

RAGy already has MCP infrastructure. Key files to study:

#### MCP Client Manager
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`

This manages connections to MCP servers. Key code pattern:

```javascript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

class MCPClientManager {
  constructor() {
    this.clients = new Map(); // serverName -> { client, transport }
    this.initialized = false;
  }

  async initialize() {
    // Connect to each MCP server as a child process
    await this.connectToServer('memory', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/memory-server.js')],
    });

    await this.connectToServer('rag', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/rag-server.js')],
    });

    // TODO: Add godot server here
    // await this.connectToServer('godot', {
    //   command: 'node',
    //   args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
    // });
  }

  async connectToServer(serverName, config) {
    const client = new Client({ name: 'ragy-chat-client', version: '1.0.0' }, { capabilities: {} });
    const transport = new StdioClientTransport({ command: config.command, args: config.args });
    await client.connect(transport);
    this.clients.set(serverName, { client, transport, config });
  }

  async getAllTools() {
    // Collects tools from all connected servers
    const allTools = [];
    for (const [serverName, { client }] of this.clients) {
      const response = await client.listTools();
      const toolsWithServer = response.tools.map(tool => ({ ...tool, _mcpServer: serverName }));
      allTools.push(...toolsWithServer);
    }
    return allTools;
  }

  async callTool(toolName, args, serverName) {
    const serverInfo = this.clients.get(serverName);
    return await serverInfo.client.callTool({ name: toolName, arguments: args });
  }
}
```

#### Example MCP Server (RAG Server)
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp-servers/rag-server.js`

This shows the pattern for building MCP servers:

```javascript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';

const server = new Server(
  { name: 'ragy-rag-server', version: '1.0.0' },
  { capabilities: { tools: {} } }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'search_documents',
        description: 'Semantic search across the knowledge base',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: 'Search query' },
            top_k: { type: 'number', description: 'Number of results' }
          },
          required: ['query']
        }
      }
    ]
  };
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === 'search_documents') {
    // Execute the tool and return result
    const results = await doSearch(args.query, args.top_k);
    return {
      content: [{ type: 'text', text: JSON.stringify(results) }]
    };
  }
});

// Start server
const transport = new StdioServerTransport();
await server.connect(transport);
```

#### AI Service with Tools
**Path:** `/Users/tomeryud/projects/RAGy/server/services/ai-with-tools.service.js`

This shows how RAGy uses MCP tools with AI providers. Key points:
- Gets tools via `mcpClientManager.getToolsForOpenAI()` or `getToolsForAnthropic()`
- Sends tools to AI provider
- When AI returns tool_call, executes via `mcpClientManager.callTool()`
- Returns result to AI for final response

### RAGy Tech Stack
- **Frontend:** React 18 + Vite
- **Backend:** Express.js (port 3001)
- **Desktop:** Electron
- **MCP SDK:** `@modelcontextprotocol/sdk`

---

## Part 2: Understanding the Old Godot AI Assistant (Reference)

### What is it?

The old Godot AI Assistant is a standalone app with:
- Express.js server with AI integration (multiple providers)
- React frontend for chat UI
- Godot plugin that polls server for tool invocations
- 33 tools for Godot manipulation

**Important:** Do NOT modify this project. Use it only as reference for tool implementations.

### Key Files to Reference

#### Tool Schemas (Copy tool definitions from here)
**Path:** `/Users/tomeryud/godot-ai-assistant/tool_schemas/`

Files:
- `openaiTools.js` - Tool definitions in OpenAI format
- `geminiTools.js` - Tool definitions in Gemini format
- `anthropicTools.js` - Tool definitions in Anthropic format

These contain the 33+ tool definitions with names, descriptions, and parameter schemas. Convert these to MCP format.

#### Tool Implementations in Godot Plugin
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/`

This contains GDScript implementations for each tool:
- `file_operations/` - read_file, list_dir, search_project
- `scene_operations/` - read_scene, create_scene, add_node, modify_node
- `script_operations/` - create_script, apply_diff_preview

Study these to understand what each tool does and how to implement in the new plugin.

#### Tool Registry (Tool routing logic)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/tool_registry.gd`

Shows how tools are registered and routed to handlers.

#### External App Communicator (HTTP polling - replace with WebSocket)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/external_app_communicator.gd`

This uses HTTP polling (bad). Replace with WebSocket in new implementation.

### Complete Tool List (33 Tools)

**File System (6 tools):**
1. `list_dir` - List files/folders in a directory
2. `read_file` - Read text file contents
3. `search_project` - Regex/substring search across project
4. `list_scripts` - List all GDScript files
5. `create_script` - Create new GDScript file
6. `open_in_godot` - Open file at specific line in editor

**Scene Operations (10 tools):**
7. `scene_tree_dump` - Get current scene tree structure
8. `read_scene` - Parse .tscn file to get node structure
9. `create_scene` - Create new .tscn file with nodes
10. `add_node` - Add node to existing scene
11. `remove_node` - Remove node from scene
12. `rename_node` - Rename a node
13. `move_node` - Reorder node in hierarchy
14. `modify_node_property` - Change node properties
15. `get_node_properties` - Discover properties for node type
16. `set_collision_shape` - Configure collision shape

**Script Operations (4 tools):**
17. `apply_diff_preview` - Apply surgical code edits (1-10 lines)
18. `validate_script` - Check script syntax
19. `attach_script` - Attach script to node
20. `detach_script` - Remove script from node

**Project Configuration (4 tools):**
21. `get_project_settings` - Access window size, physics settings
22. `get_input_map` - Query input actions and bindings
23. `get_collision_layers` - Access collision layer names
24. `get_render_settings` - Graphics/render configuration

**Debugging (3 tools):**
25. `get_console_log` - Access Godot editor output
26. `get_errors` - Get structured error data
27. `clear_console_log` - Clear console

**Asset Operations (3 tools):**
28. `set_sprite_texture` - Set texture on Sprite2D
29. `generate_2d_asset` - Generate 2D graphics
30. `customize_and_run_workflow` - Run asset workflows

**Workflow (3 tools):**
31. `inspect_runninghub_workflow` - Inspect workflows
32. `search_comfyui_nodes` - Search node library
33. `manage_task_list` - Task management

---

## Part 3: New Architecture

### High-Level Design

```
┌─────────────────────────────────────────────────────────────┐
│  RAGy (or any MCP client)                                   │
│      │                                                      │
│      │ stdio (MCP protocol)                                 │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  godot-mcp-server (Node.js)                         │    │
│  │  - Speaks MCP via stdio                             │    │
│  │  - Speaks WebSocket to Godot plugin                 │    │
│  │  - Defines all Godot tools                          │    │
│  │  - Routes tool calls to Godot                       │    │
│  └──────────────────────┬──────────────────────────────┘    │
│                         │                                   │
│                         │ WebSocket (port 6505)             │
│                         │ (bidirectional, real-time)        │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  Godot Plugin (minimal)                             │    │
│  │  - Connects via WebSocket                           │    │
│  │  - Receives tool invocation requests                │    │
│  │  - Executes tools in Godot context                  │    │
│  │  - Returns results immediately                      │    │
│  │  - Shows connection status (minimal UI)             │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### WebSocket Protocol

Messages between MCP server and Godot plugin:

**Tool Invocation (Server → Godot):**
```json
{
  "type": "tool_invoke",
  "id": "unique-request-id",
  "tool": "read_scene",
  "args": {
    "scene_path": "res://scenes/player.tscn"
  }
}
```

**Tool Result (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": true,
  "result": { "nodes": [...] }
}
```

**Error (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": false,
  "error": "Scene file not found"
}
```

**Connection Status:**
```json
{ "type": "ping" }
{ "type": "pong" }
{ "type": "godot_ready", "project_path": "/path/to/project" }
```

---

## Part 4: Directory Structure

```
/Users/tomeryud/godot-mcp/
├── PROJECT_PLAN.md                   # This file
│
├── mcp-server/                       # Node.js MCP server
│   ├── package.json
│   ├── src/
│   │   ├── index.js                  # Main entry point
│   │   ├── godot-bridge.js           # WebSocket connection to Godot
│   │   ├── tools/
│   │   │   ├── index.js              # Exports all tools
│   │   │   ├── file-tools.js         # list_dir, read_file, etc.
│   │   │   ├── scene-tools.js        # read_scene, create_scene, etc.
│   │   │   ├── script-tools.js       # apply_diff, validate_script, etc.
│   │   │   ├── project-tools.js      # get_project_settings, etc.
│   │   │   └── debug-tools.js        # get_console_log, get_errors, etc.
│   │   └── utils/
│   │       └── logger.js             # Logging utility
│   └── README.md
│
└── godot-plugin/                     # Godot 4.x plugin
    ├── addons/
    │   └── godot_mcp/
    │       ├── plugin.cfg            # Plugin configuration
    │       ├── plugin.gd             # Main plugin script
    │       ├── mcp_client.gd         # WebSocket client
    │       ├── tool_executor.gd      # Routes and executes tools
    │       ├── tools/
    │       │   ├── file_tools.gd
    │       │   ├── scene_tools.gd
    │       │   ├── script_tools.gd
    │       │   └── project_tools.gd
    │       └── ui/
    │           └── status_indicator.gd  # Minimal connection status
    └── project.godot                 # Test project for development
```

---

## Part 5: Implementation Phases

### Phase 1: Skeleton MCP Server

**Goal:** Working MCP server that RAGy can connect to, with mock tools.

**Files to create:**

1. `mcp-server/package.json`:
```json
{
  "name": "godot-mcp-server",
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "ws": "^8.18.0"
  }
}
```

2. `mcp-server/src/index.js`:
- Create MCP server using `@modelcontextprotocol/sdk`
- Register 3 mock tools: `list_dir`, `read_file`, `read_scene`
- Return fake data for testing
- NO WebSocket yet (Phase 2)

**Test:**
1. Add to RAGy's mcp-client.js
2. Start RAGy
3. Ask AI: "List the files in my Godot project"
4. Verify mock response received

---

### Phase 2: WebSocket Bridge

**Goal:** MCP server can communicate with Godot via WebSocket.

**Files to create/modify:**

1. `mcp-server/src/godot-bridge.js`:
```javascript
import { WebSocketServer } from 'ws';

class GodotBridge {
  constructor(port = 6505) {
    this.port = port;
    this.godotConnection = null;
    this.pendingRequests = new Map(); // id -> { resolve, reject, timeout }
  }

  start() {
    this.wss = new WebSocketServer({ port: this.port });
    this.wss.on('connection', (ws) => this.handleConnection(ws));
  }

  handleConnection(ws) {
    this.godotConnection = ws;
    ws.on('message', (data) => this.handleMessage(JSON.parse(data)));
    ws.on('close', () => { this.godotConnection = null; });
  }

  async invokeTool(toolName, args) {
    if (!this.godotConnection) {
      throw new Error('Godot not connected');
    }

    const id = crypto.randomUUID();

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(id);
        reject(new Error('Tool execution timeout'));
      }, 30000);

      this.pendingRequests.set(id, { resolve, reject, timeout });

      this.godotConnection.send(JSON.stringify({
        type: 'tool_invoke',
        id,
        tool: toolName,
        args
      }));
    });
  }

  handleMessage(message) {
    if (message.type === 'tool_result') {
      const pending = this.pendingRequests.get(message.id);
      if (pending) {
        clearTimeout(pending.timeout);
        this.pendingRequests.delete(message.id);
        if (message.success) {
          pending.resolve(message.result);
        } else {
          pending.reject(new Error(message.error));
        }
      }
    }
  }

  isConnected() {
    return this.godotConnection !== null;
  }
}
```

2. Update `mcp-server/src/index.js`:
- Import GodotBridge
- Start WebSocket server on startup
- Route tool calls through bridge (if connected) or return "not connected" error

**Test:**
1. Start MCP server
2. Connect with `wscat -c ws://localhost:6505`
3. Verify connection established
4. Send fake tool_result, verify handling

---

### Phase 3: Minimal Godot Plugin

**Goal:** Godot plugin connects to MCP server via WebSocket.

**Files to create:**

1. `godot-plugin/addons/godot_mcp/plugin.cfg`:
```ini
[plugin]
name="Godot MCP"
description="MCP server integration for AI assistants"
author="Your Name"
version="0.1.0"
script="plugin.gd"
```

2. `godot-plugin/addons/godot_mcp/plugin.gd`:
```gdscript
@tool
extends EditorPlugin

var mcp_client: MCPClient

func _enter_tree():
    mcp_client = MCPClient.new()
    add_child(mcp_client)
    mcp_client.connect_to_server()

func _exit_tree():
    if mcp_client:
        mcp_client.disconnect_from_server()
        mcp_client.queue_free()
```

3. `godot-plugin/addons/godot_mcp/mcp_client.gd`:
```gdscript
extends Node
class_name MCPClient

signal connected
signal disconnected
signal tool_invoked(id: String, tool_name: String, args: Dictionary)

var socket: WebSocketPeer
var server_url := "ws://localhost:6505"
var is_connected := false

func _ready():
    socket = WebSocketPeer.new()

func _process(_delta):
    if socket.get_ready_state() == WebSocketPeer.STATE_OPEN:
        socket.poll()
        while socket.get_available_packet_count() > 0:
            var packet = socket.get_packet()
            _handle_message(packet.get_string_from_utf8())

func connect_to_server():
    var err = socket.connect_to_url(server_url)
    if err != OK:
        push_error("Failed to connect to MCP server")

func _handle_message(json_string: String):
    var message = JSON.parse_string(json_string)
    if message.type == "tool_invoke":
        tool_invoked.emit(message.id, message.tool, message.args)

func send_result(id: String, success: bool, result = null, error: String = ""):
    var response = {
        "type": "tool_result",
        "id": id,
        "success": success
    }
    if success:
        response["result"] = result
    else:
        response["error"] = error
    socket.send_text(JSON.stringify(response))
```

**Test:**
1. Start MCP server
2. Open Godot project with plugin enabled
3. Verify "Connected" in Godot output
4. Verify MCP server logs connection

---

### Phase 4: First Real Tools (File Operations)

**Goal:** Implement file tools end-to-end.

**Tools to implement:**
- `list_dir` - List directory contents
- `read_file` - Read file contents

**MCP Server side (`mcp-server/src/tools/file-tools.js`):**
```javascript
export const fileTools = [
  {
    name: 'list_dir',
    description: 'List files and folders in a Godot project directory',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Directory path (e.g., "res://", "res://scenes/")'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'read_file',
    description: 'Read contents of a file in the Godot project',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'File path (e.g., "res://scripts/player.gd")'
        },
        start_line: {
          type: 'number',
          description: 'Optional start line (1-indexed)'
        },
        end_line: {
          type: 'number',
          description: 'Optional end line (1-indexed)'
        }
      },
      required: ['path']
    }
  }
];
```

**Godot side (`godot-plugin/addons/godot_mcp/tools/file_tools.gd`):**
```gdscript
extends Node
class_name FileTools

func list_dir(args: Dictionary) -> Dictionary:
    var path = args.get("path", "res://")
    var dir = DirAccess.open(path)
    if dir == null:
        return {"error": "Cannot open directory: " + path}

    var files = []
    var folders = []

    dir.list_dir_begin()
    var file_name = dir.get_next()
    while file_name != "":
        if dir.current_is_dir():
            folders.append(file_name)
        else:
            files.append(file_name)
        file_name = dir.get_next()
    dir.list_dir_end()

    return {"files": files, "folders": folders}

func read_file(args: Dictionary) -> Dictionary:
    var path = args.get("path", "")
    if not FileAccess.file_exists(path):
        return {"error": "File not found: " + path}

    var file = FileAccess.open(path, FileAccess.READ)
    var content = file.get_as_text()
    file.close()

    return {"content": content, "path": path}
```

**Test:**
1. Start MCP server
2. Open Godot with plugin
3. In RAGy, ask: "List the files in my Godot project's root directory"
4. Verify real file listing returned

---

### Phase 5: Scene Tools

**Tools to implement:**
- `read_scene` - Parse .tscn file structure
- `create_scene` - Create new scene
- `add_node` - Add node to scene
- `modify_node_property` - Change node property

Reference the old implementations:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/scene_operations/`

---

### Phase 6: Script Tools

**Tools to implement:**
- `create_script` - Create new GDScript
- `apply_diff_preview` - Apply code edits
- `validate_script` - Check syntax

Reference:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/script_operations/`

---

### Phase 7: All Remaining Tools

Port remaining tools from old project:
- Project settings tools
- Debug tools
- Asset tools

---

### Phase 8: RAGy Integration

**Goal:** Add Godot MCP server to RAGy with settings UI.

**Files to modify in RAGy:**

1. `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`:
```javascript
// Add in initialize():
if (settings.godotEnabled) {
  await this.connectToServer('godot', {
    command: 'node',
    args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
  });
}
```

2. Add settings for enabling/disabling Godot tools
3. Add UI indicator for Godot connection status

---

## Part 6: Testing Checklist

### Phase 1 Tests
- [ ] MCP server starts without errors
- [ ] RAGy connects to MCP server
- [ ] Mock tools appear in AI tool list
- [ ] AI can call mock tools and get responses

### Phase 2 Tests
- [ ] WebSocket server starts on port 6505
- [ ] External WebSocket client can connect
- [ ] Messages sent/received correctly
- [ ] Timeout handling works

### Phase 3 Tests
- [ ] Plugin loads in Godot without errors
- [ ] Plugin connects to MCP server
- [ ] Connection status updates correctly
- [ ] Reconnection works after disconnect

### Phase 4 Tests
- [ ] `list_dir` returns real directory contents
- [ ] `read_file` returns real file contents
- [ ] Errors handled gracefully
- [ ] Full flow works: RAGy → AI → MCP → Godot → result

### Phase 5-7 Tests
- [ ] Each tool works individually
- [ ] Complex workflows work (create scene, add nodes, add script)
- [ ] Error handling for all edge cases

### Phase 8 Tests
- [ ] Godot tools can be enabled/disabled in RAGy
- [ ] Connection status shows in RAGy UI
- [ ] Graceful handling when Godot not connected

---

## Part 7: Key Technical Details

### MCP Protocol Basics

MCP uses JSON-RPC over stdio (stdin/stdout). The SDK handles this.

**Tool definition format:**
```javascript
{
  name: 'tool_name',
  description: 'What the tool does',
  inputSchema: {
    type: 'object',
    properties: {
      param1: { type: 'string', description: '...' },
      param2: { type: 'number', description: '...' }
    },
    required: ['param1']
  }
}
```

**Tool result format:**
```javascript
{
  content: [
    { type: 'text', text: 'Result as string or JSON' }
  ]
}
```

### Godot 4.x WebSocket API

```gdscript
var socket = WebSocketPeer.new()
socket.connect_to_url("ws://localhost:6505")

# In _process:
socket.poll()
while socket.get_available_packet_count() > 0:
    var data = socket.get_packet().get_string_from_utf8()
    # Handle data

# Send:
socket.send_text(JSON.stringify(message))
```

### Error Handling Strategy

1. **MCP Server errors:** Return error in content with `isError: true`
2. **Godot not connected:** Return clear error message
3. **Tool execution timeout:** 30 second timeout with clear error
4. **Invalid arguments:** Validate and return specific error

---

## Part 8: Commands Reference

### Development Commands

```bash
# Navigate to project
cd /Users/tomeryud/godot-mcp

# Install MCP server dependencies
cd mcp-server && npm install

# Start MCP server standalone (for testing)
cd mcp-server && npm start

# Test WebSocket connection
npx wscat -c ws://localhost:6505
```

### RAGy Commands

```bash
# Navigate to RAGy
cd /Users/tomeryud/projects/RAGy

# Start RAGy (includes MCP servers)
npm run dev
```

---

## Summary

This project creates a clean, modular bridge between Godot and RAGy:

1. **MCP Server (Node.js):** Speaks MCP to RAGy, WebSocket to Godot
2. **Godot Plugin (GDScript):** Minimal, focused on tool execution
3. **Architecture:** Clean separation, reusable, testable

Follow the phases in order, testing each before moving to the next. Use the old godot-ai-assistant as reference for tool implementations but don't modify it.

Start with Phase 1: Create the skeleton MCP server with mock tools.
</file>

<file path="addon/README.md">
# Godot MCP

**Give your AI assistant full access to the Godot editor.**

Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching. AI reads, writes, and manipulates your scenes, scripts, nodes, and project settings directly.

> Godot 4.x · 32 tools · Interactive project visualizer · MIT license

---

## Quick Start

### 1. Add the MCP server to your AI client

The server is hosted on npm — no cloning or building required.

**Claude Desktop** — edit `~/Library/Application Support/Claude/claude_desktop_config.json`:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**Cursor** — add to MCP settings (Settings → MCP → Add Server):
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

Works with any MCP-compatible client.

### 2. Install the Godot plugin

Copy the `godot-plugin/addons/godot_mcp/` folder into your Godot project's `addons/` directory. Then enable it: Project → Project Settings → Plugins → **Godot MCP** → Enable.

### 3. Restart Godot

Check the **top-right corner** of the editor. You should see **MCP Connected** in green. You're ready to go — start talking to your AI about your game.

---

## What Can It Do?

### 32 Tools Across 6 Categories

| Category | Tools | Examples |
|----------|-------|---------|
| **File Operations** | 4 | Browse directories, read files, search project, create scripts |
| **Scene Operations** | 11 | Create scenes, add/remove/move nodes, set properties, attach scripts, assign collision shapes and textures |
| **Script Operations** | 6 | Apply code edits, validate syntax, rename/move files with reference updates |
| **Project Tools** | 9 | Read project settings, input map, collision layers, console errors, scene tree dumps |
| **Asset Generation** | 4 | Generate 2D sprites from SVG, ComfyUI node search, RunningHub workflow execution |
| **Visualization** | 1 | Interactive browser-based project map |

### Interactive Visualizer

Run `map_project` and get a browser-based explorer at `localhost:6510`:
- Force-directed graph of all scripts and their relationships
- Click any script to see variables, functions, signals, and connections
- Edit code directly in the visualizer — changes sync to Godot in real time
- Scene view with node property editing
- Find usages before refactoring

### What Developers Are Saying AI + Godot Is Missing

| Problem | Godot MCP |
|---------|-----------|
| AI can't see my project — constant copy-pasting | **Solved** — AI reads/writes directly |
| `.tscn` files are unreadable to AI | **Solved** — structured scene tools |
| "What properties does this node have?" | **Solved** — full property discovery |
| Debugging is slow — digging through console | **Solved** — AI reads errors and dumps scene tree |
| Can't see the big picture of my project | **Solved** — interactive visualizer |
| Need placeholder art to prototype | **Solved** — SVG generation + AI art pipelines |
| Refactoring breaks things | **Partially solved** — rename with references + find usages |
| AI hallucinates wrong Godot APIs | **Partially solved** — AI sees your actual project context |

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — runs on localhost, no remote connections
- **Single connection** — one Godot instance at a time
- **Editor only** — works in the editor, not in exported games
- **No undo** — changes save directly (use version control)
- **No runtime control** — can't press play or simulate input
- **AI is still limited in Godot knowledge** — it can't create 100% of the game alone, but it can help debug, write scripts, and tag along for the journey

---

## Full Documentation

See [SUMMARY.md](SUMMARY.md) for the complete tool reference, feature list, and detailed pain point analysis.

---

## Development

To build from source instead of using npm:

```bash
cd mcp-server
npm install
npm run build
```

Then point your AI client at `mcp-server/dist/index.js` instead of using `npx`.

---

## License

MIT

---

**[npm package](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="addon/SUMMARY.md">
# Godot MCP — AI-Powered Godot Development

**Give your AI assistant full access to the Godot editor.** Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching, no friction.

> Works with Godot 4.x · Open source (MIT) · 32 tools · Visual project explorer included

---

## What Is This?

Godot MCP is a bridge between AI assistants and the Godot editor. It lets AI read, write, and manipulate your project directly — scenes, scripts, nodes, assets, settings — all through natural conversation.

```
You ↔ AI Assistant ↔ MCP Server ↔ Godot Editor
         (Claude, Cursor, etc.)    (WebSocket)     (Plugin)
```

Install the Godot plugin, point your AI client at the MCP server, and start building.

---

## Tools (32)

### File Operations (4 tools)
| Tool | What it does |
|------|-------------|
| `list_dir` | Browse project directories (`res://` paths) |
| `read_file` | Read any text file with optional line ranges |
| `search_project` | Full-text search across the project with glob filtering |
| `create_script` | Scaffold new GDScript files |

### Scene Operations (11 tools)
| Tool | What it does |
|------|-------------|
| `create_scene` | Create `.tscn` files with a node hierarchy |
| `read_scene` | Parse and inspect scene structure |
| `add_node` | Add nodes to existing scenes |
| `remove_node` | Remove nodes from scenes |
| `modify_node_property` | Set any node property (transforms, colors, physics, etc.) |
| `rename_node` | Rename nodes |
| `move_node` | Reparent nodes in the scene tree |
| `attach_script` | Attach a GDScript to a node |
| `detach_script` | Remove a script from a node |
| `set_collision_shape` | Assign collision shapes (Circle, Rectangle, Capsule, etc.) |
| `set_sprite_texture` | Assign textures to sprites (image, placeholder, gradient, noise) |

### Script Operations (6 tools)
| Tool | What it does |
|------|-------------|
| `apply_diff_preview` | Apply targeted code edits to GDScript files |
| `validate_script` | Check GDScript syntax without running |
| `list_scripts` | List all `.gd` files in the project |
| `create_folder` | Create directories |
| `delete_file` | Delete files (with safety checks) |
| `rename_file` | Rename/move files with optional reference updates |

### Project Tools (9 tools)
| Tool | What it does |
|------|-------------|
| `get_project_settings` | Read project configuration (window size, renderer, physics) |
| `get_input_map` | Inspect all input actions and their bindings |
| `get_collision_layers` | Read physics collision layer names |
| `get_node_properties` | Discover every property a node type supports |
| `get_console_log` | Read the editor output log |
| `get_errors` | Extract only errors from the console |
| `clear_console_log` | Clear the console |
| `open_in_godot` | Open a file in the editor (jumps to line for scripts) |
| `scene_tree_dump` | Dump the running scene tree for debugging |

### Asset Generation (4 tools)
| Tool | What it does |
|------|-------------|
| `generate_2d_asset` | Generate 2D sprites from SVG code |
| `search_comfyui_nodes` | Search 10,500+ ComfyUI nodes for AI art pipelines |
| `inspect_runninghub_workflow` | Inspect RunningHub workflow parameters |
| `customize_and_run_workflow` | Execute RunningHub workflows for asset generation |

### Visualization (1 tool)
| Tool | What it does |
|------|-------------|
| `map_project` | Build an interactive visual map of your entire project |

---

## Features

### Core
- **Live editor connection** — WebSocket bridge between MCP server and Godot editor. Changes happen in real time.
- **Works with any MCP client** — Claude Desktop, Cursor, RAGy, or anything that speaks MCP.
- **Mock mode** — Test and develop without Godot running.
- **Auto-reconnect** — Plugin reconnects automatically if the connection drops.

### Scene Manipulation
- Create scenes from scratch with full node hierarchies
- Add, remove, rename, move, and reparent nodes
- Set any node property with automatic type parsing (Vector2, Color, etc.)
- Attach/detach scripts, assign collision shapes and textures
- Read and inspect existing scene structures

### Script Intelligence
- Apply surgical code edits with snippet matching
- Validate GDScript syntax before saving
- Full project-wide text search
- Scaffold new scripts from templates
- Rename/move files with reference tracking

### Project Awareness
- AI can read your project settings, input map, and collision layers
- Console log and error access for debugging
- Scene tree dumps of the running game
- Property discovery — AI can look up what properties any node type supports

### Asset Pipeline
- Generate 2D placeholder sprites from SVG descriptions
- ComfyUI node search for AI art workflow building
- RunningHub integration for automated asset generation

### Interactive Visualizer
- **Browser-based project explorer** served at `localhost:6510`
- Force-directed graph of all scripts and their relationships
- Color-coded by folder, searchable, zoomable
- Click any script to inspect variables, functions, signals, and connections
- **Inline editing** — edit variables, function bodies, and signals directly in the visualizer
- **Scene view** — browse scene hierarchies and edit node properties
- **Find usages** — check where a function or variable is used before changing it
- Changes sync back to Godot in real time

---

## Godot Developer Pain Points

| Pain Point | Status | How |
|-----------|--------|-----|
| **"AI can't see my project"** — context switching between AI chat and editor | **Solved** | AI reads/writes your project directly through 32 tools |
| **"Scene files are unreadable"** — `.tscn` is a custom text format AI struggles with | **Solved** | Structured scene tools abstract away the format |
| **"I have to copy-paste code back and forth"** — manual AI workflow | **Solved** | AI edits scripts in-place, validates syntax, and opens files in editor |
| **"I don't know what properties a node has"** — memorizing the API | **Solved** | `get_node_properties` lets AI discover any node's full property list |
| **"Debugging is slow"** — checking console, finding errors | **Solved** | AI reads console logs, extracts errors, dumps the scene tree |
| **"I can't visualize my project structure"** — hard to see the big picture | **Solved** | Interactive visualizer maps scripts, scenes, and their connections |
| **"Setting up input maps / collision layers is tedious"** | **Solved** | AI reads and understands your input map and collision layers |
| **"I need placeholder art to prototype"** | **Solved** | SVG-based 2D asset generation, ComfyUI/RunningHub integration |
| **"Refactoring is scary"** — renaming breaks things | **Partially solved** | File rename with reference updates + find usages in visualizer |
| **"GDScript has no LSP-quality AI support"** | **Partially solved** | Syntax validation + property discovery, but no autocomplete or go-to-definition |
| **"AI generates code for the wrong Godot version"** | **Partially solved** | AI sees your actual project settings and node types, reducing hallucination |
| **"I need AI to playtest / run my game"** | **Not yet** | Scene tree dump works, but no automated play/test/input simulation |
| **"Shader editing is painful"** | **Not yet** | No shader-specific tools (files can be read/written as text) |
| **"Managing exports and builds"** | **Not yet** | No export/build pipeline tools |
| **"Tilemap and level design"** | **Not yet** | No tilemap-specific tools |
| **"Animation editing"** | **Not yet** | No AnimationPlayer/AnimationTree tools |
| **"Version control integration"** | **Not yet** | No built-in git tools (use your AI client's native git support) |
| **"Multi-file refactoring"** | **Not yet** | Single-file edits only; no cross-file rename symbol |

---

## Quick Start

**1. Add the MCP server to your AI client**

No installation needed — the server is on npm. Add to your AI client config:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**2. Install the Godot plugin**
Copy `godot-plugin/addons/godot_mcp/` into your project's `addons/` folder. Enable it in Project → Project Settings → Plugins.

**3. Restart Godot.** Check the top-right corner of the editor — you should see **MCP Connected** in green. You're ready to go.

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — WebSocket runs on localhost, no remote connections or auth
- **Single connection** — One Godot instance at a time
- **Editor only** — Plugin runs in `@tool` mode, not in exported games
- **No undo** — Changes are saved directly (use version control)
- **Regex-based parsing** — Script analysis may miss edge cases in complex GDScript
- **No runtime control** — Can't press play, simulate input, or automate testing
- **All AI is limited in Godot knowledge** - scene editing, GDScript, editing node properties, building and placing UI elements. It cant create 100% of the game alone but it can help debug, write scripts, and tag along for the journey :)
---

## What's Next (maybe)

- Animation tools (AnimationPlayer, tweens)
- Tilemap and level design tools  
- Shader editing support
- Automated playtesting and input simulation
- Multi-file refactoring
- Plugin marketplace / asset library integration
- improvements to current tools

---

## License

MIT — use it however you want.

**[GitHub](https://github.com/tomyud1/godot-mcp)** · **[npm](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="addon/VISUAL_TREE_ROADMAP.md">
# Visual Tree Roadmap

## Completed
- [x] Inline variable/signal editing
- [x] @onready toggle
- [x] Function code editing with syntax highlighting
- [x] Usage detection before delete
- [x] Floating usage panel with navigation
- [x] Right-click context menu
- [x] New script creation
- [x] Draggable/resizable panels
- [x] Scene View tab (Phase 4 - Core)
  - Scene overview with cards showing scene info
  - Click scene → expand to full node hierarchy tree
  - Visual node tree with parent-child connections
  - Sibling order indicators (for 2D draw order)
  - Click node → dynamic properties panel
  - Inline editing of all node properties
  - Property controls: toggles, sliders, vectors, colors, enums
  - Back navigation to scene overview

## In Progress
- [ ] Function deletion with usage check

## Planned

### Phase 2: Visual Connections
- Drag from signal → function to create `.connect()` code
- Visual ports on node edges when hovering

### Phase 3: Script Management
- Right click to add a new node (script)
- Script templates (Node2D, State Machine, Singleton, etc.)
- Delete/rename scripts

### Phase 4: Scene View (Enhancements)
- Drag to reorder siblings (change draw order)
- Right-click context menu on scene nodes (add child, delete, rename)
- Drag scripts onto scene nodes to attach
- Cross-scene signal visualization

### Phase 5: Advanced
- Minimap
- Node grouping
- Full-text search in function bodies
- Refactoring (rename across files)
- Undo/redo
- Git integration (modified files indicator)

### Phase 6: Polish
- Documentation generation
- Dependency analysis (circular deps, unused scripts)
- Code snippets library
</file>

<file path="claude_desktop_config.json">
{
  "mcpServers": {
    "godot": {
      "command": "node",
      "args": ["/Users/tomeryud/godot-mcp/mcp-server/dist/index.js"]
    }
  }
}
</file>

<file path="godot-plugin/addons/godot_mcp/mcp_client.gd">
@tool
extends Node
class_name MCPClient
## WebSocket client for communication with the MCP server.
## Handles connection, reconnection, and message routing.

signal connected
signal disconnected
signal tool_requested(request_id: String, tool_name: String, args: Dictionary)

const DEFAULT_URL := "ws://localhost:6505"
const RECONNECT_DELAY := 3.0  # seconds
const MAX_RECONNECT_DELAY := 30.0  # max backoff

var socket: WebSocketPeer = WebSocketPeer.new()
var server_url: String = DEFAULT_URL
var _is_connected := false
var _reconnect_timer: Timer
var _current_reconnect_delay := RECONNECT_DELAY
var _should_reconnect := true
var _project_path: String
var _initialized := false

func _ready() -> void:
	_project_path = ProjectSettings.globalize_path("res://")

	# Create reconnect timer
	_reconnect_timer = Timer.new()
	_reconnect_timer.one_shot = true
	_reconnect_timer.timeout.connect(_on_reconnect_timer)
	add_child(_reconnect_timer)
	_initialized = true

func _process(_delta: float) -> void:
	if not _initialized:
		return
	if socket.get_ready_state() == WebSocketPeer.STATE_CLOSED:
		if _is_connected:
			_handle_disconnect()
		return

	socket.poll()

	match socket.get_ready_state():
		WebSocketPeer.STATE_OPEN:
			if not _is_connected:
				_handle_connect()
			# Process incoming messages
			while socket.get_available_packet_count() > 0:
				var packet := socket.get_packet()
				_handle_message(packet.get_string_from_utf8())

		WebSocketPeer.STATE_CLOSING:
			pass  # Wait for close

		WebSocketPeer.STATE_CLOSED:
			if _is_connected:
				_handle_disconnect()

func connect_to_server(url: String = DEFAULT_URL) -> void:
	server_url = url
	_should_reconnect = true
	_current_reconnect_delay = RECONNECT_DELAY
	_attempt_connection()

func disconnect_from_server() -> void:
	_should_reconnect = false
	if _reconnect_timer:
		_reconnect_timer.stop()
	if socket.get_ready_state() == WebSocketPeer.STATE_OPEN:
		socket.close()
	_is_connected = false

func _attempt_connection() -> void:
	if socket.get_ready_state() != WebSocketPeer.STATE_CLOSED:
		socket.close()

	print("[MCP] Connecting to ", server_url, "...")
	var err := socket.connect_to_url(server_url)
	if err != OK:
		push_error("[MCP] Failed to connect: ", err)
		_schedule_reconnect()

func _handle_connect() -> void:
	_is_connected = true
	_current_reconnect_delay = RECONNECT_DELAY  # Reset backoff
	print("[MCP] Connected to server")

	# Send godot_ready message with project info
	_send_message({
		"type": "godot_ready",
		"project_path": _project_path
	})

	connected.emit()

func _handle_disconnect() -> void:
	_is_connected = false
	print("[MCP] Disconnected from server")
	disconnected.emit()

	if _should_reconnect:
		_schedule_reconnect()

func _schedule_reconnect() -> void:
	if not _reconnect_timer:
		return
	print("[MCP] Reconnecting in ", _current_reconnect_delay, " seconds...")
	_reconnect_timer.start(_current_reconnect_delay)
	# Exponential backoff
	_current_reconnect_delay = min(_current_reconnect_delay * 2, MAX_RECONNECT_DELAY)

func _on_reconnect_timer() -> void:
	_attempt_connection()

func _handle_message(json_string: String) -> void:
	var message = JSON.parse_string(json_string)
	if message == null:
		push_error("[MCP] Failed to parse message: ", json_string)
		return

	match message.get("type", ""):
		"ping":
			_send_message({"type": "pong"})

		"tool_invoke":
			var request_id: String = message.get("id", "")
			var tool_name: String = message.get("tool", "")
			var args: Dictionary = message.get("args", {})
			print("[MCP] Tool request: ", tool_name, " (", request_id, ")")
			tool_requested.emit(request_id, tool_name, args)

		_:
			print("[MCP] Unknown message type: ", message.get("type", "unknown"))

func send_tool_result(request_id: String, success: bool, result = null, error: String = "") -> void:
	var response := {
		"type": "tool_result",
		"id": request_id,
		"success": success
	}

	if success:
		response["result"] = result
	else:
		response["error"] = error

	_send_message(response)
	print("[MCP] Sent result for ", request_id, " (success=", success, ")")

func _send_message(message: Dictionary) -> void:
	if socket.get_ready_state() == WebSocketPeer.STATE_OPEN:
		socket.send_text(JSON.stringify(message))

func is_connected_to_server() -> bool:
	return _is_connected
</file>

<file path="godot-plugin/addons/godot_mcp/plugin.cfg">
[plugin]

name="Godot MCP"
description="MCP server integration for AI assistants. Connects to the godot-mcp-server via WebSocket."
author="Godot MCP"
version="0.1.0"
script="plugin.gd"
</file>

<file path="godot-plugin/addons/godot_mcp/plugin.gd">
@tool
extends EditorPlugin
## Godot MCP Plugin
## Connects to the godot-mcp-server via WebSocket and executes tools.

const MCPClientScript = preload("res://addons/godot_mcp/mcp_client.gd")
const ToolExecutorScript = preload("res://addons/godot_mcp/tool_executor.gd")

var _mcp_client: Node  # MCPClient
var _tool_executor: Node  # ToolExecutor
var _status_label: Label

func _enter_tree() -> void:
	print("[Godot MCP] Plugin loading...")

	# Create MCP client
	_mcp_client = MCPClientScript.new()
	_mcp_client.name = "MCPClient"
	add_child(_mcp_client)

	# Create tool executor
	_tool_executor = ToolExecutorScript.new()
	_tool_executor.name = "ToolExecutor"
	add_child(_tool_executor)  # _ready() runs here, creating child tools
	_tool_executor.set_editor_plugin(self)  # Now _visualizer_tools exists

	# Connect signals
	_mcp_client.connected.connect(_on_connected)
	_mcp_client.disconnected.connect(_on_disconnected)
	_mcp_client.tool_requested.connect(_on_tool_requested)

	# Add status indicator to editor
	_setup_status_indicator()

	# Start connection
	_mcp_client.connect_to_server()

	print("[Godot MCP] Plugin loaded - connecting to MCP server...")

func _exit_tree() -> void:
	print("[Godot MCP] Plugin unloading...")

	if _mcp_client:
		_mcp_client.disconnect_from_server()
		_mcp_client.queue_free()

	if _tool_executor:
		_tool_executor.queue_free()

	if _status_label:
		remove_control_from_container(EditorPlugin.CONTAINER_TOOLBAR, _status_label)
		_status_label.queue_free()

	print("[Godot MCP] Plugin unloaded")

func _setup_status_indicator() -> void:
	"""Add a small status label to the editor toolbar."""
	_status_label = Label.new()
	_status_label.text = "MCP: Connecting..."
	_status_label.add_theme_color_override("font_color", Color.YELLOW)
	_status_label.add_theme_font_size_override("font_size", 12)
	add_control_to_container(EditorPlugin.CONTAINER_TOOLBAR, _status_label)

func _on_connected() -> void:
	print("[Godot MCP] Connected to MCP server")
	if _status_label:
		_status_label.text = "MCP: Connected"
		_status_label.add_theme_color_override("font_color", Color.GREEN)

func _on_disconnected() -> void:
	print("[Godot MCP] Disconnected from MCP server")
	if _status_label:
		_status_label.text = "MCP: Disconnected"
		_status_label.add_theme_color_override("font_color", Color.RED)

func _on_tool_requested(request_id: String, tool_name: String, args: Dictionary) -> void:
	"""Handle incoming tool request from MCP server."""
	print("[Godot MCP] Executing tool: ", tool_name)

	# Execute the tool
	var result: Dictionary = _tool_executor.execute_tool(tool_name, args)

	# Send result back
	var success: bool = result.get("ok", false)
	if success:
		# Remove 'ok' key from result before sending
		result.erase("ok")
		_mcp_client.send_tool_result(request_id, true, result)
	else:
		var error: String = result.get("error", "Unknown error")
		_mcp_client.send_tool_result(request_id, false, null, error)
</file>

<file path="godot-plugin/addons/godot_mcp/tool_executor.gd">
@tool
extends Node
class_name ToolExecutor
## Routes tool invocations to the appropriate handler.

var _editor_plugin: EditorPlugin = null

var _file_tools: Node
var _scene_tools: Node
var _script_tools: Node
var _project_tools: Node
var _asset_tools: Node
var _visualizer_tools: Node

# Tool name → [handler_node, method_name]
var _tool_map: Dictionary = {}

var _initialized := false

func _init_tools() -> void:
	"""Initialize all tool handlers. Called from set_editor_plugin."""
	if _initialized:
		return
	_initialized = true
	
	_file_tools = preload("res://addons/godot_mcp/tools/file_tools.gd").new()
	_file_tools.name = "FileTools"
	add_child(_file_tools)

	_scene_tools = preload("res://addons/godot_mcp/tools/scene_tools.gd").new()
	_scene_tools.name = "SceneTools"
	add_child(_scene_tools)

	_script_tools = preload("res://addons/godot_mcp/tools/script_tools.gd").new()
	_script_tools.name = "ScriptTools"
	add_child(_script_tools)

	_project_tools = preload("res://addons/godot_mcp/tools/project_tools.gd").new()
	_project_tools.name = "ProjectTools"
	add_child(_project_tools)

	_asset_tools = preload("res://addons/godot_mcp/tools/asset_tools.gd").new()
	_asset_tools.name = "AssetTools"
	add_child(_asset_tools)

	_visualizer_tools = preload("res://addons/godot_mcp/tools/visualizer_tools.gd").new()
	_visualizer_tools.name = "VisualizerTools"
	add_child(_visualizer_tools)

	# Build tool routing map
	_tool_map = {
		# File tools
		"list_dir": [_file_tools, "list_dir"],
		"read_file": [_file_tools, "read_file"],
		"search_project": [_file_tools, "search_project"],
		"create_script": [_file_tools, "create_script"],

		# Scene tools
		"create_scene": [_scene_tools, "create_scene"],
		"read_scene": [_scene_tools, "read_scene"],
		"add_node": [_scene_tools, "add_node"],
		"remove_node": [_scene_tools, "remove_node"],
		"modify_node_property": [_scene_tools, "modify_node_property"],
		"rename_node": [_scene_tools, "rename_node"],
		"move_node": [_scene_tools, "move_node"],
		"attach_script": [_scene_tools, "attach_script"],
		"detach_script": [_scene_tools, "detach_script"],
		"set_collision_shape": [_scene_tools, "set_collision_shape"],
		"set_sprite_texture": [_scene_tools, "set_sprite_texture"],
		"get_scene_hierarchy": [_scene_tools, "get_scene_hierarchy"],
		"get_scene_node_properties": [_scene_tools, "get_scene_node_properties"],
		"set_scene_node_property": [_scene_tools, "set_scene_node_property"],

		# Script/file management tools
		"apply_diff_preview": [_script_tools, "apply_diff_preview"],
		"validate_script": [_script_tools, "validate_script"],
		"list_scripts": [_script_tools, "list_scripts"],
		"create_folder": [_script_tools, "create_folder"],
		"delete_file": [_script_tools, "delete_file"],
		"rename_file": [_script_tools, "rename_file"],

		# Project/debug tools
		"get_project_settings": [_project_tools, "get_project_settings"],
		"get_input_map": [_project_tools, "get_input_map"],
		"get_collision_layers": [_project_tools, "get_collision_layers"],
		"get_node_properties": [_project_tools, "get_node_properties"],
		"get_console_log": [_project_tools, "get_console_log"],
		"get_errors": [_project_tools, "get_errors"],
		"clear_console_log": [_project_tools, "clear_console_log"],
		"open_in_godot": [_project_tools, "open_in_godot"],
		"scene_tree_dump": [_project_tools, "scene_tree_dump"],

		# Asset generation tools
		"generate_2d_asset": [_asset_tools, "generate_2d_asset"],
		"search_comfyui_nodes": [_asset_tools, "search_comfyui_nodes"],
		"inspect_runninghub_workflow": [_asset_tools, "inspect_runninghub_workflow"],
		"customize_and_run_workflow": [_asset_tools, "customize_and_run_workflow"],

		# Visualizer tools
		"map_project": [_visualizer_tools, "map_project"],
		"map_scenes": [_visualizer_tools, "map_scenes"],
	}

func set_editor_plugin(plugin: EditorPlugin) -> void:
	_editor_plugin = plugin
	
	# Initialize tools first (must be done synchronously)
	_init_tools()
	
	# Pass editor plugin reference to all tool handlers
	if _file_tools: _file_tools.set_editor_plugin(plugin)
	if _scene_tools: _scene_tools.set_editor_plugin(plugin)
	if _script_tools: _script_tools.set_editor_plugin(plugin)
	if _project_tools: _project_tools.set_editor_plugin(plugin)
	if _asset_tools: _asset_tools.set_editor_plugin(plugin)
	if _visualizer_tools:
		_visualizer_tools.set_editor_plugin(plugin)
		# Pass scene_tools reference for visualizer internal scene functions
		_visualizer_tools.set_scene_tools_ref(_scene_tools)

func execute_tool(tool_name: String, args: Dictionary) -> Dictionary:
	"""Execute a tool by name with the given arguments."""
	
	# Handle internal visualizer commands (not exposed as MCP tools)
	if tool_name.begins_with("visualizer._internal_"):
		var method: String = tool_name.replace("visualizer.", "")
		if _visualizer_tools and _visualizer_tools.has_method(method):
			return _visualizer_tools.call(method, args)
		else:
			return {"ok": false, "error": "Internal method not found: " + method}
	
	if not _tool_map.has(tool_name):
		return {
			"ok": false,
			"error": "Unknown tool: %s. Available: %s" % [tool_name, ", ".join(_tool_map.keys())]
		}

	var handler: Array = _tool_map[tool_name]
	var node: Node = handler[0]
	var method: String = handler[1]

	if not node.has_method(method):
		return {"ok": false, "error": "Tool handler not found: %s.%s" % [node.name, method]}

	return node.call(method, args)

func get_available_tools() -> Array:
	"""Return list of available tool names."""
	return _tool_map.keys()
</file>

<file path="godot-plugin/addons/godot_mcp/tools/asset_tools.gd">
@tool
extends Node
class_name AssetTools
## Asset generation tools for MCP.
## Handles: generate_2d_asset, search_comfyui_nodes,
##          inspect_runninghub_workflow, customize_and_run_workflow

var _editor_plugin: EditorPlugin = null

func set_editor_plugin(plugin: EditorPlugin) -> void:
	_editor_plugin = plugin

func _refresh_filesystem() -> void:
	if _editor_plugin:
		_editor_plugin.get_editor_interface().get_resource_filesystem().scan()

# =============================================================================
# generate_2d_asset - Generate PNG from SVG code
# =============================================================================
func generate_2d_asset(args: Dictionary) -> Dictionary:
	var svg_code: String = str(args.get("svg_code", ""))
	var filename: String = str(args.get("filename", ""))
	var save_path: String = str(args.get("save_path", "res://assets/generated/"))

	if svg_code.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'svg_code'"}
	if filename.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'filename'"}

	# Ensure .png extension
	if not filename.ends_with(".png"):
		filename += ".png"

	# Ensure save path
	if not save_path.begins_with("res://"):
		save_path = "res://" + save_path
	if not save_path.ends_with("/"):
		save_path += "/"

	# Create directory if needed
	if not DirAccess.dir_exists_absolute(save_path):
		DirAccess.make_dir_recursive_absolute(save_path)

	# Parse SVG dimensions from the svg_code
	var width := 64
	var height := 64

	# Simple regex-free parsing for width/height
	var w_start := svg_code.find("width=\"")
	if w_start != -1:
		var w_val := svg_code.substr(w_start + 7)
		var w_end := w_val.find("\"")
		if w_end != -1:
			width = int(w_val.substr(0, w_end))

	var h_start := svg_code.find("height=\"")
	if h_start != -1:
		var h_val := svg_code.substr(h_start + 8)
		var h_end := h_val.find("\"")
		if h_end != -1:
			height = int(h_val.substr(0, h_end))

	# Create Image from SVG
	var image := Image.new()

	# Save SVG to temp file, then load as image
	var temp_svg_path := "user://temp_asset.svg"
	var svg_file := FileAccess.open(temp_svg_path, FileAccess.WRITE)
	if not svg_file:
		return {"ok": false, "error": "Failed to create temp SVG file"}
	svg_file.store_string(svg_code)
	svg_file.close()

	# Load SVG as image
	var err := image.load(temp_svg_path)
	if err != OK:
		# Fallback: try loading SVG data directly
		image = Image.create(width, height, false, Image.FORMAT_RGBA8)
		image.fill(Color(1, 0, 1, 1))  # Magenta fallback = something went wrong
		print("[MCP] Warning: Could not render SVG, created fallback image")

	# Clean up temp file
	DirAccess.remove_absolute(temp_svg_path)

	# Save as PNG
	var full_path := save_path + filename
	var global_path := ProjectSettings.globalize_path(full_path)
	err = image.save_png(global_path)
	if err != OK:
		return {"ok": false, "error": "Failed to save PNG: " + str(err)}

	_refresh_filesystem()

	return {
		"ok": true,
		"resource_path": full_path,
		"dimensions": {"width": width, "height": height},
		"message": "Generated %s (%dx%d)" % [full_path, width, height]
	}

# =============================================================================
# search_comfyui_nodes - Stub (requires external database)
# =============================================================================
func search_comfyui_nodes(args: Dictionary) -> Dictionary:
	# This tool requires the ComfyUI node database which was bundled with the old plugin
	# For now, return a message indicating it needs setup
	return {
		"ok": true,
		"results": [],
		"count": 0,
		"message": "ComfyUI node search requires the node database. This feature will be available in a future update."
	}

# =============================================================================
# inspect_runninghub_workflow - Stub (requires API key)
# =============================================================================
func inspect_runninghub_workflow(args: Dictionary) -> Dictionary:
	var workflow_id: String = str(args.get("workflow_id", ""))
	if workflow_id.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'workflow_id'"}

	return {
		"ok": true,
		"workflow_id": workflow_id,
		"message": "RunningHub workflow inspection requires API configuration. This feature will be available in a future update."
	}

# =============================================================================
# customize_and_run_workflow - Stub (requires API key)
# =============================================================================
func customize_and_run_workflow(args: Dictionary) -> Dictionary:
	return {
		"ok": true,
		"message": "RunningHub workflow execution requires API configuration. This feature will be available in a future update."
	}
</file>

<file path="godot-plugin/addons/godot_mcp/tools/file_tools.gd">
@tool
extends Node
class_name FileTools
## File operation tools for MCP.
## Handles: list_dir, read_file, search_project, create_script

const DEFAULT_MAX_BYTES := 200_000
const DEFAULT_MAX_RESULTS := 200
const SKIP_EXTENSIONS := [".import", ".png", ".jpg", ".jpeg", ".webp", ".svg",
	".ogg", ".wav", ".mp3", ".escn", ".glb", ".gltf", ".uid"]

var _editor_plugin: EditorPlugin = null

func set_editor_plugin(plugin: EditorPlugin) -> void:
	_editor_plugin = plugin

# =============================================================================
# list_dir - List files and folders in a directory
# =============================================================================
func list_dir(args: Dictionary) -> Dictionary:
	var root: String = str(args.get("root", "res://"))
	var include_hidden: bool = bool(args.get("include_hidden", false))

	if not root.begins_with("res://"):
		root = "res://" + root

	var dir := DirAccess.open(root)
	if dir == null:
		return {"ok": false, "error": "Cannot open directory: " + root}

	var files: Array = []
	var folders: Array = []

	dir.list_dir_begin()
	var name := dir.get_next()
	while name != "":
		# Skip hidden files unless requested
		if not include_hidden and name.begins_with("."):
			name = dir.get_next()
			continue

		# Skip .uid files
		if name.to_lower().ends_with(".uid"):
			name = dir.get_next()
			continue

		var full_path := root.path_join(name)
		if dir.current_is_dir():
			folders.append(name)
		else:
			files.append(name)

		name = dir.get_next()
	dir.list_dir_end()

	# Sort alphabetically
	files.sort()
	folders.sort()

	return {
		"ok": true,
		"path": root,
		"files": files,
		"folders": folders,
		"total": files.size() + folders.size()
	}

# =============================================================================
# read_file - Read contents of a file
# =============================================================================
func read_file(args: Dictionary) -> Dictionary:
	var path: String = str(args.get("path", ""))
	var start_line: int = int(args.get("start_line", 1))
	var end_line: int = int(args.get("end_line", 0))
	var max_bytes: int = int(args.get("max_bytes", DEFAULT_MAX_BYTES))

	if path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'path' parameter"}

	if not path.begins_with("res://"):
		path = "res://" + path

	if not FileAccess.file_exists(path):
		return {"ok": false, "error": "File not found: " + path}

	var file := FileAccess.open(path, FileAccess.READ)
	if file == null:
		return {"ok": false, "error": "Cannot open file: " + path}

	var content: String
	var line_count: int = 0

	# If no line range specified, read up to max_bytes
	if end_line <= 0 and start_line <= 1:
		var size := mini(max_bytes, file.get_length())
		content = file.get_buffer(size).get_string_from_utf8()
		# Count lines
		line_count = content.count("\n") + 1
	else:
		# Read specific line range
		var lines: Array = []
		var current_line := 0
		var total_bytes := 0

		while not file.eof_reached():
			var line := file.get_line()
			current_line += 1

			if current_line < start_line:
				continue
			if end_line > 0 and current_line > end_line:
				break

			lines.append(line)
			total_bytes += line.length() + 1  # +1 for newline

			if total_bytes > max_bytes:
				break

		content = "\n".join(lines)
		line_count = lines.size()

	file.close()

	return {
		"ok": true,
		"path": path,
		"content": content,
		"line_count": line_count,
		"range": [start_line, end_line] if end_line > 0 else null
	}

# =============================================================================
# search_project - Search for text in project files
# =============================================================================
func search_project(args: Dictionary) -> Dictionary:
	var query: String = str(args.get("query", ""))
	var glob_filter: String = str(args.get("glob", ""))
	var max_results: int = int(args.get("max_results", DEFAULT_MAX_RESULTS))
	var case_sensitive: bool = bool(args.get("case_sensitive", false))

	if query.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'query' parameter"}

	var search_query := query if case_sensitive else query.to_lower()
	var files := _collect_files("res://", glob_filter)
	var matches: Array = []

	for file_path in files:
		if matches.size() >= max_results:
			break

		var file := FileAccess.open(file_path, FileAccess.READ)
		if file == null:
			continue

		var line_num := 0
		while not file.eof_reached():
			var line := file.get_line()
			line_num += 1

			var search_line := line if case_sensitive else line.to_lower()
			if search_line.find(search_query) != -1:
				matches.append({
					"file": file_path,
					"line": line_num,
					"content": line.strip_edges()
				})

				if matches.size() >= max_results:
					break

		file.close()

	return {
		"ok": true,
		"query": query,
		"matches": matches,
		"total_matches": matches.size(),
		"truncated": matches.size() >= max_results
	}

func _collect_files(path: String, glob_filter: String) -> Array:
	"""Recursively collect all searchable files."""
	var result: Array = []
	_collect_files_recursive(path, glob_filter, result)
	return result

func _collect_files_recursive(path: String, glob_filter: String, out: Array) -> void:
	var dir := DirAccess.open(path)
	if dir == null:
		return

	dir.list_dir_begin()
	var name := dir.get_next()
	while name != "":
		# Skip hidden
		if name.begins_with("."):
			name = dir.get_next()
			continue

		var full_path := path.path_join(name)

		if dir.current_is_dir():
			_collect_files_recursive(full_path, glob_filter, out)
		else:
			# Skip binary files
			var skip := false
			for ext in SKIP_EXTENSIONS:
				if name.to_lower().ends_with(ext):
					skip = true
					break

			if not skip:
				# Apply glob filter if specified
				if glob_filter.is_empty() or _matches_glob(full_path, glob_filter):
					out.append(full_path)

		name = dir.get_next()
	dir.list_dir_end()

func _matches_glob(path: String, pattern: String) -> bool:
	"""Simple glob matching: *.gd, **/*.tscn, etc."""
	# Handle **/*.ext pattern
	if pattern.begins_with("**/"):
		var ext := pattern.substr(3)  # Remove **/
		return path.ends_with(ext.replace("*", ""))

	# Handle *.ext pattern
	if pattern.begins_with("*."):
		return path.ends_with(pattern.substr(1))

	# Simple contains check
	return path.find(pattern) != -1

# =============================================================================
# create_script - Create a new GDScript file
# =============================================================================
func create_script(args: Dictionary) -> Dictionary:
	var path: String = str(args.get("path", ""))
	var content: String = str(args.get("content", ""))

	if path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'path' parameter"}

	if not path.begins_with("res://"):
		path = "res://" + path

	# Add .gd extension if missing
	if not "." in path.get_file():
		path += ".gd"

	# Check if file already exists
	if FileAccess.file_exists(path):
		return {"ok": false, "error": "File already exists: " + path}

	# Ensure parent directory exists
	var dir_path := path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		var err := DirAccess.make_dir_recursive_absolute(dir_path)
		if err != OK:
			return {"ok": false, "error": "Could not create directory: " + dir_path}

	# Write file
	var file := FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		return {"ok": false, "error": "Could not create file: " + path}

	file.store_string(content)
	file.close()

	# Refresh filesystem so Godot sees the new file
	_refresh_filesystem()

	return {
		"ok": true,
		"path": path,
		"size_bytes": content.length(),
		"message": "Script created successfully"
	}

func _refresh_filesystem() -> void:
	"""Tell Godot to rescan the filesystem."""
	if _editor_plugin != null:
		_editor_plugin.get_editor_interface().get_resource_filesystem().scan()
	elif Engine.is_editor_hint():
		# Fallback if no plugin reference
		var editor_interface = Engine.get_singleton("EditorInterface")
		if editor_interface:
			editor_interface.get_resource_filesystem().scan()
</file>

<file path="godot-plugin/addons/godot_mcp/tools/project_tools.gd">
@tool
extends Node
class_name ProjectTools
## Project configuration and debug tools for MCP.
## Handles: get_project_settings, get_input_map, get_collision_layers,
##          get_node_properties, get_console_log, get_errors, clear_console_log,
##          open_in_godot, scene_tree_dump

var _editor_plugin: EditorPlugin = null

# Buffer for capturing console output
var _console_buffer: Array = []
const MAX_CONSOLE_LINES := 500

func set_editor_plugin(plugin: EditorPlugin) -> void:
	_editor_plugin = plugin

# =============================================================================
# get_project_settings
# =============================================================================
func get_project_settings(args: Dictionary) -> Dictionary:
	var include_render: bool = bool(args.get("include_render", true))
	var include_physics: bool = bool(args.get("include_physics", true))

	var out: Dictionary = {}
	out["main_scene"] = str(ProjectSettings.get_setting("application/run/main_scene", ""))

	# Window size
	var width = ProjectSettings.get_setting("display/window/size/viewport_width", null)
	var height = ProjectSettings.get_setting("display/window/size/viewport_height", null)
	if width != null: out["window_width"] = int(width)
	if height != null: out["window_height"] = int(height)

	# Stretch
	var stretch_mode = ProjectSettings.get_setting("display/window/stretch/mode", null)
	var stretch_aspect = ProjectSettings.get_setting("display/window/stretch/aspect", null)
	if stretch_mode != null: out["stretch_mode"] = str(stretch_mode)
	if stretch_aspect != null: out["stretch_aspect"] = str(stretch_aspect)

	if include_physics:
		var pps = ProjectSettings.get_setting("physics/common/physics_ticks_per_second", null)
		if pps != null: out["physics_ticks_per_second"] = int(pps)

	if include_render:
		var method = ProjectSettings.get_setting("rendering/renderer/rendering_method", null)
		if method != null: out["rendering_method"] = str(method)
		var vsync = ProjectSettings.get_setting("display/window/vsync/vsync_mode", null)
		if vsync != null: out["vsync"] = str(vsync)

	return {"ok": true, "settings": out}

# =============================================================================
# get_input_map
# =============================================================================
func get_input_map(args: Dictionary) -> Dictionary:
	var include_deadzones: bool = bool(args.get("include_deadzones", true))
	var actions: Array = InputMap.get_actions()
	actions.sort()

	var result: Dictionary = {}
	for action in actions:
		var events: Array = []
		for e in InputMap.action_get_events(action):
			var item := {"type": e.get_class()}

			if e is InputEventKey:
				var keycode = e.physical_keycode if e.physical_keycode != 0 else e.keycode
				item["keycode"] = keycode
				item["key_label"] = OS.get_keycode_string(keycode) if keycode != 0 else ""
			elif e is InputEventMouseButton:
				item["button_index"] = e.button_index
			elif e is InputEventJoypadButton:
				item["button_index"] = e.button_index
			elif e is InputEventJoypadMotion:
				item["axis"] = e.axis
				if include_deadzones:
					item["axis_value"] = e.axis_value

			events.append(item)
		result[action] = events

	return {"ok": true, "actions": result, "count": result.size()}

# =============================================================================
# get_collision_layers
# =============================================================================
func get_collision_layers(_args: Dictionary) -> Dictionary:
	var layers_2d: Array = _collect_layers("layer_names/2d_physics")
	var layers_3d: Array = _collect_layers("layer_names/3d_physics")
	return {"ok": true, "layers_2d": layers_2d, "layers_3d": layers_3d}

func _collect_layers(prefix: String) -> Array:
	var out: Array = []
	for i in range(1, 33):
		var key := "%s/layer_%d" % [prefix, i]
		var layer_name := str(ProjectSettings.get_setting(key, ""))
		if not layer_name.is_empty():
			out.append({"index": i, "name": layer_name})
	return out

# =============================================================================
# get_node_properties
# =============================================================================
const ENUM_HINTS = {
	"anchors_preset": "0:Top Left,1:Top Right,2:Bottom Right,3:Bottom Left,4:Center Left,5:Center Top,6:Center Right,7:Center Bottom,8:Center,9:Left Wide,10:Top Wide,11:Right Wide,12:Bottom Wide,13:VCenter Wide,14:HCenter Wide,15:Full Rect",
	"grow_horizontal": "0:Begin,1:End,2:Both",
	"grow_vertical": "0:Begin,1:End,2:Both",
	"horizontal_alignment": "0:Left,1:Center,2:Right,3:Fill",
	"vertical_alignment": "0:Top,1:Center,2:Bottom,3:Fill"
}

func get_node_properties(args: Dictionary) -> Dictionary:
	var node_type: String = str(args.get("node_type", ""))
	if node_type.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'node_type'"}
	if not ClassDB.class_exists(node_type):
		return {"ok": false, "error": "Unknown node type: " + node_type}

	var temp = ClassDB.instantiate(node_type)
	if not temp:
		return {"ok": false, "error": "Cannot instantiate: " + node_type}

	var properties: Array = []
	for prop in temp.get_property_list():
		var prop_name: String = prop["name"]
		if prop_name.begins_with("_"):
			continue
		if prop_name in ["script", "owner", "scene_file_path", "unique_name_in_owner"]:
			continue
		if not (prop.get("usage", 0) & PROPERTY_USAGE_EDITOR):
			continue

		var info := {
			"name": prop_name,
			"type": _type_to_string(prop["type"]),
			"default": _serialize_value(temp.get(prop_name))
		}

		# Enum hints
		if prop.has("hint") and prop["hint"] == PROPERTY_HINT_ENUM and prop.has("hint_string"):
			info["enum_values"] = prop["hint_string"]
		if prop_name in ENUM_HINTS:
			info["enum_values"] = ENUM_HINTS[prop_name]

		properties.append(info)

	temp.queue_free()

	# Inheritance chain
	var chain: Array = []
	var cls: String = node_type
	while cls != "":
		chain.append(cls)
		cls = ClassDB.get_parent_class(cls)

	return {"ok": true, "node_type": node_type, "inheritance_chain": chain,
		"property_count": properties.size(), "properties": properties}

func _type_to_string(type_id: int) -> String:
	match type_id:
		TYPE_BOOL: return "bool"
		TYPE_INT: return "int"
		TYPE_FLOAT: return "float"
		TYPE_STRING: return "String"
		TYPE_VECTOR2: return "Vector2"
		TYPE_VECTOR3: return "Vector3"
		TYPE_VECTOR2I: return "Vector2i"
		TYPE_VECTOR3I: return "Vector3i"
		TYPE_COLOR: return "Color"
		TYPE_RECT2: return "Rect2"
		TYPE_OBJECT: return "Resource"
		TYPE_ARRAY: return "Array"
		TYPE_DICTIONARY: return "Dictionary"
		_: return "Variant"

func _serialize_value(value) -> Variant:
	match typeof(value):
		TYPE_VECTOR2: return {"type": "Vector2", "x": value.x, "y": value.y}
		TYPE_VECTOR3: return {"type": "Vector3", "x": value.x, "y": value.y, "z": value.z}
		TYPE_COLOR: return {"type": "Color", "r": value.r, "g": value.g, "b": value.b, "a": value.a}
		TYPE_VECTOR2I: return {"type": "Vector2i", "x": value.x, "y": value.y}
		TYPE_VECTOR3I: return {"type": "Vector3i", "x": value.x, "y": value.y, "z": value.z}
		TYPE_OBJECT:
			if value and value is Resource and value.resource_path:
				return {"type": "Resource", "path": value.resource_path}
			return null
		_: return value

# =============================================================================
# get_console_log
# =============================================================================
func get_console_log(args: Dictionary) -> Dictionary:
	var max_lines: int = int(args.get("max_lines", 50))

	# Try to read the editor log file
	var log_path := _get_editor_log_path()
	if log_path.is_empty() or not FileAccess.file_exists(log_path):
		return {"ok": true, "lines": [], "line_count": 0,
			"message": "Console log not available. Check Godot editor output panel."}

	var file := FileAccess.open(log_path, FileAccess.READ)
	if not file:
		return {"ok": false, "error": "Cannot read log file"}

	# Read all lines and return the last max_lines
	var all_lines: Array = []
	while not file.eof_reached():
		all_lines.append(file.get_line())
	file.close()

	var start := maxi(0, all_lines.size() - max_lines)
	var lines := all_lines.slice(start)

	return {"ok": true, "lines": lines, "line_count": lines.size(),
		"content": "\n".join(lines)}

func _get_editor_log_path() -> String:
	# Godot stores editor logs in user data directory
	var log_dir := OS.get_user_data_dir().get_base_dir()
	var log_path := log_dir.path_join("godot/editor_logs/godot.log")
	if FileAccess.file_exists(log_path):
		return log_path
	# Alternative location
	log_path = OS.get_user_data_dir().path_join("logs/godot.log")
	if FileAccess.file_exists(log_path):
		return log_path
	return ""

# =============================================================================
# get_errors
# =============================================================================
func get_errors(args: Dictionary) -> Dictionary:
	var max_errors: int = int(args.get("max_errors", 50))

	var log_path := _get_editor_log_path()
	if log_path.is_empty() or not FileAccess.file_exists(log_path):
		return {"ok": true, "errors": [], "error_count": 0,
			"message": "Error log not available"}

	var file := FileAccess.open(log_path, FileAccess.READ)
	if not file:
		return {"ok": false, "error": "Cannot read log file"}

	var errors: Array = []
	while not file.eof_reached() and errors.size() < max_errors:
		var line := file.get_line()
		# Look for error patterns
		if "ERROR" in line or "error" in line.to_lower():
			var error_info := {"message": line.strip_edges()}

			# Try to extract file:line info
			var regex_match := _extract_file_line(line)
			if not regex_match.is_empty():
				error_info["file"] = regex_match.get("file", "")
				error_info["line"] = regex_match.get("line", 0)

			errors.append(error_info)

	file.close()

	return {"ok": true, "errors": errors, "error_count": errors.size(),
		"summary": "%d error(s) found" % errors.size()}

func _extract_file_line(text: String) -> Dictionary:
	"""Try to extract file path and line number from an error message."""
	# Pattern: res://path/file.gd:123
	var idx := text.find("res://")
	if idx == -1:
		return {}

	var rest := text.substr(idx)
	var colon_idx := rest.find(":", 6)  # Skip "res://"
	if colon_idx == -1:
		return {"file": rest.strip_edges()}

	var file_path := rest.substr(0, colon_idx)
	var after_colon := rest.substr(colon_idx + 1)

	# Try to parse line number
	var line_str := ""
	for c in after_colon:
		if c.is_valid_int():
			line_str += c
		else:
			break

	if not line_str.is_empty():
		return {"file": file_path, "line": int(line_str)}
	return {"file": file_path}

# =============================================================================
# clear_console_log
# =============================================================================
func clear_console_log(_args: Dictionary) -> Dictionary:
	var log_path := _get_editor_log_path()
	if log_path.is_empty():
		return {"ok": true, "message": "No log file to clear"}

	# We can't actually clear the editor log while Godot is running
	# But we can note the current position to ignore previous entries
	return {"ok": true, "message": "Console log clear acknowledged. New errors will be tracked from this point."}

# =============================================================================
# open_in_godot
# =============================================================================
func open_in_godot(args: Dictionary) -> Dictionary:
	var path: String = str(args.get("path", ""))
	var line: int = int(args.get("line", 0))

	if path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'path'"}

	if not path.begins_with("res://"):
		path = "res://" + path

	if not _editor_plugin:
		return {"ok": false, "error": "Editor plugin not available"}

	var ei = _editor_plugin.get_editor_interface()

	if path.ends_with(".gd") or path.ends_with(".shader"):
		var script = load(path)
		if script:
			ei.edit_resource(script)
			if line > 0:
				ei.get_script_editor().goto_line(line - 1)
		else:
			return {"ok": false, "error": "Could not load: " + path}
	elif path.ends_with(".tscn") or path.ends_with(".scn"):
		ei.open_scene_from_path(path)
	else:
		var res = load(path)
		if res:
			ei.edit_resource(res)

	return {"ok": true, "message": "Opened %s%s" % [path, " at line %d" % line if line > 0 else ""]}

# =============================================================================
# scene_tree_dump
# =============================================================================
func scene_tree_dump(_args: Dictionary) -> Dictionary:
	if not _editor_plugin:
		return {"ok": false, "error": "Editor plugin not available"}

	var ei = _editor_plugin.get_editor_interface()
	var edited_scene = ei.get_edited_scene_root()

	if not edited_scene:
		return {"ok": true, "tree": "(no scene open)", "message": "No scene is currently open in the editor"}

	var tree_text := _dump_node(edited_scene, 0)

	return {"ok": true, "tree": tree_text, "scene_path": edited_scene.scene_file_path}

func _dump_node(node: Node, depth: int) -> String:
	var indent := "  ".repeat(depth)
	var line := "%s%s (%s)" % [indent, node.name, node.get_class()]

	var script = node.get_script()
	if script:
		line += " [%s]" % script.resource_path.get_file()

	var result := line
	for child in node.get_children():
		result += "\n" + _dump_node(child, depth + 1)
	return result
</file>

<file path="godot-plugin/addons/godot_mcp/tools/scene_tools.gd">
@tool
extends Node
class_name SceneTools
## Scene operation tools for MCP.
## Handles: create_scene, read_scene, add_node, remove_node, modify_node_property,
##          rename_node, move_node, attach_script, detach_script, set_collision_shape,
##          set_sprite_texture

var _editor_plugin: EditorPlugin = null

func set_editor_plugin(plugin: EditorPlugin) -> void:
	_editor_plugin = plugin

# =============================================================================
# Shared helpers
# =============================================================================
func _refresh_and_reload(scene_path: String) -> void:
	_refresh_filesystem()
	_reload_scene_in_editor(scene_path)

func _refresh_filesystem() -> void:
	if _editor_plugin:
		_editor_plugin.get_editor_interface().get_resource_filesystem().scan()

func _reload_scene_in_editor(scene_path: String) -> void:
	if not _editor_plugin:
		return
	var ei = _editor_plugin.get_editor_interface()
	var edited = ei.get_edited_scene_root()
	if edited and edited.scene_file_path == scene_path:
		ei.reload_scene_from_path(scene_path)

func _ensure_res_path(path: String) -> String:
	if not path.begins_with("res://"):
		return "res://" + path
	return path

func _load_scene(scene_path: String) -> Array:
	"""Returns [scene_root, error_dict]. If error_dict is not empty, scene_root is null."""
	if not FileAccess.file_exists(scene_path):
		return [null, {"ok": false, "error": "Scene does not exist: " + scene_path}]

	var packed = load(scene_path) as PackedScene
	if not packed:
		return [null, {"ok": false, "error": "Failed to load scene: " + scene_path}]

	var root = packed.instantiate()
	if not root:
		return [null, {"ok": false, "error": "Failed to instantiate scene"}]

	return [root, {}]

func _save_scene(scene_root: Node, scene_path: String) -> Dictionary:
	"""Pack and save a scene. Returns error dict or empty on success."""
	var packed = PackedScene.new()
	var pack_result = packed.pack(scene_root)
	if pack_result != OK:
		scene_root.queue_free()
		return {"ok": false, "error": "Failed to pack scene: " + str(pack_result)}

	var save_result = ResourceSaver.save(packed, scene_path)
	scene_root.queue_free()

	if save_result != OK:
		return {"ok": false, "error": "Failed to save scene: " + str(save_result)}

	_refresh_and_reload(scene_path)
	return {}

func _find_node(scene_root: Node, node_path: String) -> Node:
	if node_path == "." or node_path.is_empty():
		return scene_root
	return scene_root.get_node_or_null(node_path)

func _parse_value(value):
	"""Convert dictionary-encoded types to Godot types."""
	if typeof(value) == TYPE_DICTIONARY and value.has("type"):
		match value["type"]:
			"Vector2": return Vector2(value.get("x", 0), value.get("y", 0))
			"Vector3": return Vector3(value.get("x", 0), value.get("y", 0), value.get("z", 0))
			"Color": return Color(value.get("r", 1), value.get("g", 1), value.get("b", 1), value.get("a", 1))
			"Vector2i": return Vector2i(value.get("x", 0), value.get("y", 0))
			"Vector3i": return Vector3i(value.get("x", 0), value.get("y", 0), value.get("z", 0))
			"Rect2": return Rect2(value.get("x", 0), value.get("y", 0), value.get("width", 0), value.get("height", 0))
	return value

func _set_node_properties(node: Node, properties: Dictionary) -> void:
	for prop_name in properties:
		var prop_value = _parse_value(properties[prop_name])
		node.set(prop_name, prop_value)

func _serialize_value(value) -> Variant:
	match typeof(value):
		TYPE_VECTOR2: return {"type": "Vector2", "x": value.x, "y": value.y}
		TYPE_VECTOR3: return {"type": "Vector3", "x": value.x, "y": value.y, "z": value.z}
		TYPE_COLOR: return {"type": "Color", "r": value.r, "g": value.g, "b": value.b, "a": value.a}
		TYPE_VECTOR2I: return {"type": "Vector2i", "x": value.x, "y": value.y}
		TYPE_VECTOR3I: return {"type": "Vector3i", "x": value.x, "y": value.y, "z": value.z}
		TYPE_RECT2: return {"type": "Rect2", "x": value.position.x, "y": value.position.y, "width": value.size.x, "height": value.size.y}
		TYPE_OBJECT:
			if value and value is Resource and value.resource_path:
				return {"type": "Resource", "path": value.resource_path}
			return null
		_: return value

# =============================================================================
# create_scene
# =============================================================================
func create_scene(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var root_node_name: String = str(args.get("root_node_name", "Node"))
	var root_node_type: String = str(args.get("root_node_type", ""))
	var nodes: Array = args.get("nodes", [])
	var attach_script_path: String = str(args.get("attach_script", ""))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path' parameter"}
	if root_node_type.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'root_node_type' parameter"}
	if not scene_path.ends_with(".tscn"):
		scene_path += ".tscn"
	if FileAccess.file_exists(scene_path):
		return {"ok": false, "error": "Scene already exists: " + scene_path}
	if not ClassDB.class_exists(root_node_type):
		return {"ok": false, "error": "Invalid root node type: " + root_node_type}

	# Ensure parent directory
	var dir_path := scene_path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		DirAccess.make_dir_recursive_absolute(dir_path)

	var root: Node = ClassDB.instantiate(root_node_type) as Node
	if not root:
		return {"ok": false, "error": "Failed to create root node of type: " + root_node_type}
	root.name = root_node_name

	if not attach_script_path.is_empty():
		var script_res = load(attach_script_path)
		if script_res:
			root.set_script(script_res)

	var node_count := 0
	for node_data in nodes:
		if typeof(node_data) == TYPE_DICTIONARY:
			var created = _create_node_recursive(node_data, root, root)
			if created:
				node_count += _count_nodes(created)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "path": scene_path, "root_type": root_node_type, "child_count": node_count,
		"message": "Scene created at " + scene_path}

func _create_node_recursive(data: Dictionary, parent: Node, owner: Node) -> Node:
	var n_name: String = str(data.get("name", "Node"))
	var n_type: String = str(data.get("type", "Node"))
	var n_script: String = str(data.get("script", ""))
	var props: Dictionary = data.get("properties", {})
	var children: Array = data.get("children", [])

	if not ClassDB.class_exists(n_type):
		return null
	var node: Node = ClassDB.instantiate(n_type) as Node
	if not node:
		return null

	node.name = n_name
	_set_node_properties(node, props)

	if not n_script.is_empty():
		var s = load(n_script)
		if s:
			node.set_script(s)

	parent.add_child(node)
	node.owner = owner

	for child_data in children:
		if typeof(child_data) == TYPE_DICTIONARY:
			_create_node_recursive(child_data, node, owner)
	return node

func _count_nodes(node: Node) -> int:
	var count := 1
	for child in node.get_children():
		count += _count_nodes(child)
	return count

# =============================================================================
# read_scene
# =============================================================================
func read_scene(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var include_properties: bool = args.get("include_properties", false)

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path' parameter"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var structure = _build_node_structure(root, include_properties)
	root.queue_free()

	return {"ok": true, "scene_path": scene_path, "root": structure}

func _build_node_structure(node: Node, include_props: bool, path: String = ".") -> Dictionary:
	var data := {"name": str(node.name), "type": node.get_class(), "path": path, "children": []}
	var script = node.get_script()
	if script:
		data["script"] = script.resource_path

	if include_props:
		var props := {}
		for prop_name in ["position", "rotation", "scale", "size", "offset", "visible",
				"modulate", "z_index", "text", "collision_layer", "collision_mask", "mass"]:
			var val = node.get(prop_name)
			if val != null:
				props[prop_name] = _serialize_value(val)
		if not props.is_empty():
			data["properties"] = props

	for child in node.get_children():
		var child_path = child.name if path == "." else path + "/" + child.name
		data["children"].append(_build_node_structure(child, include_props, child_path))
	return data

# =============================================================================
# add_node
# =============================================================================
func add_node(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_name: String = str(args.get("node_name", ""))
	var node_type: String = str(args.get("node_type", "Node"))
	var parent_path: String = str(args.get("parent_path", "."))
	var properties: Dictionary = args.get("properties", {})

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if node_name.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'node_name'"}
	if not ClassDB.class_exists(node_type):
		return {"ok": false, "error": "Invalid node type: " + node_type}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var parent = _find_node(root, parent_path)
	if not parent:
		root.queue_free()
		return {"ok": false, "error": "Parent node not found: " + parent_path}

	var new_node: Node = ClassDB.instantiate(node_type) as Node
	if not new_node:
		root.queue_free()
		return {"ok": false, "error": "Failed to create node of type: " + node_type}

	new_node.name = node_name
	_set_node_properties(new_node, properties)
	parent.add_child(new_node)
	new_node.owner = root

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "scene_path": scene_path, "node_name": node_name, "node_type": node_type,
		"message": "Added %s (%s) to scene" % [node_name, node_type]}

# =============================================================================
# remove_node
# =============================================================================
func remove_node(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", ""))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if node_path.strip_edges().is_empty() or node_path == ".":
		return {"ok": false, "error": "Cannot remove root node"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = root.get_node_or_null(node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var n_name = target.name
	var n_type = target.get_class()
	target.get_parent().remove_child(target)
	target.queue_free()

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "scene_path": scene_path, "removed_node": node_path,
		"message": "Removed %s (%s)" % [n_name, n_type]}

# =============================================================================
# modify_node_property
# =============================================================================
func modify_node_property(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", "."))
	var property_name: String = str(args.get("property_name", ""))
	var value = args.get("value")

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if property_name.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'property_name'"}
	if value == null:
		return {"ok": false, "error": "Missing 'value'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	# Check property exists
	var prop_exists := false
	for prop in target.get_property_list():
		if prop["name"] == property_name:
			prop_exists = true
			break
	if not prop_exists:
		var node_type = target.get_class()
		root.queue_free()
		return {"ok": false, "error": "Property '%s' not found on %s (%s). Use get_node_properties to discover available properties." % [property_name, node_path, node_type]}

	var parsed = _parse_value(value)
	var old_value = target.get(property_name)

	# Validate resource type compatibility
	if old_value is Resource and not (parsed is Resource):
		root.queue_free()
		return {"ok": false, "error": "Property '%s' expects a Resource. Use specialized tools (set_collision_shape, set_sprite_texture) instead." % property_name}

	target.set(property_name, parsed)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "scene_path": scene_path, "node_path": node_path,
		"property_name": property_name, "old_value": str(old_value), "new_value": str(parsed),
		"message": "Set %s.%s = %s" % [node_path, property_name, str(parsed)]}

# =============================================================================
# rename_node
# =============================================================================
func rename_node(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", ""))
	var new_name: String = str(args.get("new_name", ""))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if node_path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'node_path'"}
	if new_name.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'new_name'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var old_name = target.name
	target.name = new_name

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "old_name": str(old_name), "new_name": new_name,
		"message": "Renamed '%s' to '%s'" % [old_name, new_name]}

# =============================================================================
# move_node
# =============================================================================
func move_node(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", ""))
	var new_parent_path: String = str(args.get("new_parent_path", "."))
	var sibling_index: int = int(args.get("sibling_index", -1))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if node_path.strip_edges().is_empty() or node_path == ".":
		return {"ok": false, "error": "Cannot move root node"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = root.get_node_or_null(node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var new_parent = _find_node(root, new_parent_path)
	if not new_parent:
		root.queue_free()
		return {"ok": false, "error": "New parent not found: " + new_parent_path}

	target.get_parent().remove_child(target)
	new_parent.add_child(target)
	target.owner = root

	if sibling_index >= 0:
		new_parent.move_child(target, mini(sibling_index, new_parent.get_child_count() - 1))

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "message": "Moved '%s' to '%s'" % [node_path, new_parent_path]}

# =============================================================================
# duplicate_node
# =============================================================================
func duplicate_node(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", ""))
	var new_name: String = str(args.get("new_name", ""))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if node_path.strip_edges().is_empty() or node_path == ".":
		return {"ok": false, "error": "Cannot duplicate root node"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = root.get_node_or_null(node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var parent = target.get_parent()
	if not parent:
		root.queue_free()
		return {"ok": false, "error": "Cannot duplicate - no parent"}

	# Duplicate the node
	var duplicate = target.duplicate()
	
	# Generate unique name if not provided
	if new_name.is_empty():
		var base_name = target.name
		var counter = 2
		new_name = base_name + str(counter)
		while parent.has_node(NodePath(new_name)):
			counter += 1
			new_name = base_name + str(counter)
	
	duplicate.name = new_name
	parent.add_child(duplicate)
	
	# Set owner for all duplicated nodes
	_set_owner_recursive(duplicate, root)
	
	# Move duplicate right after original
	var original_index = target.get_index()
	parent.move_child(duplicate, original_index + 1)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "new_name": new_name, 
		"message": "Duplicated '%s' as '%s'" % [node_path, new_name]}


func _set_owner_recursive(node: Node, owner: Node) -> void:
	node.owner = owner
	for child in node.get_children():
		_set_owner_recursive(child, owner)


# =============================================================================
# reorder_node - simpler function just for changing sibling order
# =============================================================================
func reorder_node(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", ""))
	var new_index: int = int(args.get("new_index", -1))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if node_path.strip_edges().is_empty() or node_path == ".":
		return {"ok": false, "error": "Cannot reorder root node"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = root.get_node_or_null(node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var parent = target.get_parent()
	if not parent:
		root.queue_free()
		return {"ok": false, "error": "Cannot reorder - no parent"}

	var old_index = target.get_index()
	var max_index = parent.get_child_count() - 1
	new_index = clampi(new_index, 0, max_index)
	
	if old_index == new_index:
		root.queue_free()
		return {"ok": true, "message": "No change needed"}

	parent.move_child(target, new_index)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "old_index": old_index, "new_index": new_index,
		"message": "Moved '%s' from index %d to %d" % [node_path, old_index, new_index]}


# =============================================================================
# attach_script
# =============================================================================
func attach_script(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", "."))
	var script_path: String = str(args.get("script_path", ""))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if script_path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'script_path'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var script_res = load(script_path)
	if not script_res:
		root.queue_free()
		return {"ok": false, "error": "Failed to load script: " + script_path}

	target.set_script(script_res)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "message": "Attached %s to node '%s'" % [script_path, node_path]}

# =============================================================================
# detach_script
# =============================================================================
func detach_script(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", "."))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	target.set_script(null)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "message": "Detached script from node '%s'" % node_path}

# =============================================================================
# set_collision_shape
# =============================================================================
func set_collision_shape(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", "."))
	var shape_type: String = str(args.get("shape_type", ""))
	var shape_params: Dictionary = args.get("shape_params", {})

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if shape_type.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'shape_type'"}
	if not ClassDB.class_exists(shape_type):
		return {"ok": false, "error": "Invalid shape type: " + shape_type}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	# Create shape resource
	var shape = ClassDB.instantiate(shape_type)
	if not shape:
		root.queue_free()
		return {"ok": false, "error": "Failed to create shape: " + shape_type}

	# Apply shape parameters
	if shape_params.has("radius"):
		shape.set("radius", float(shape_params["radius"]))
	if shape_params.has("height"):
		shape.set("height", float(shape_params["height"]))
	if shape_params.has("size"):
		var size_data = shape_params["size"]
		if typeof(size_data) == TYPE_DICTIONARY:
			if size_data.has("z"):
				shape.set("size", Vector3(size_data.get("x", 1), size_data.get("y", 1), size_data.get("z", 1)))
			else:
				shape.set("size", Vector2(size_data.get("x", 1), size_data.get("y", 1)))

	target.set("shape", shape)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "message": "Set %s on node '%s'" % [shape_type, node_path]}

# =============================================================================
# set_sprite_texture
# =============================================================================
func set_sprite_texture(args: Dictionary) -> Dictionary:
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", "."))
	var texture_type: String = str(args.get("texture_type", ""))
	var texture_params: Dictionary = args.get("texture_params", {})

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if texture_type.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'texture_type'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var texture: Texture2D = null

	match texture_type:
		"ImageTexture":
			var tex_path: String = str(texture_params.get("path", ""))
			if tex_path.is_empty():
				root.queue_free()
				return {"ok": false, "error": "Missing 'path' in texture_params for ImageTexture"}
			texture = load(tex_path)
			if not texture:
				root.queue_free()
				return {"ok": false, "error": "Failed to load texture: " + tex_path}

		"PlaceholderTexture2D":
			texture = PlaceholderTexture2D.new()
			var size_data = texture_params.get("size", {"x": 64, "y": 64})
			if typeof(size_data) == TYPE_DICTIONARY:
				texture.size = Vector2(size_data.get("x", 64), size_data.get("y", 64))

		"GradientTexture2D":
			texture = GradientTexture2D.new()
			texture.width = int(texture_params.get("width", 64))
			texture.height = int(texture_params.get("height", 64))

		"NoiseTexture2D":
			texture = NoiseTexture2D.new()
			texture.width = int(texture_params.get("width", 64))
			texture.height = int(texture_params.get("height", 64))

		_:
			root.queue_free()
			return {"ok": false, "error": "Unknown texture type: " + texture_type}

	target.set("texture", texture)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {"ok": true, "message": "Set %s texture on node '%s'" % [texture_type, node_path]}

# =============================================================================
# get_scene_hierarchy (for visualizer)
# =============================================================================
func get_scene_hierarchy(args: Dictionary) -> Dictionary:
	"""Get the full scene hierarchy with node information for the visualizer."""
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var hierarchy = _build_hierarchy_recursive(root, ".")
	root.queue_free()

	return {"ok": true, "scene_path": scene_path, "hierarchy": hierarchy}

func _build_hierarchy_recursive(node: Node, path: String) -> Dictionary:
	"""Build node hierarchy with all info needed for visualizer."""
	var data := {
		"name": str(node.name),
		"type": node.get_class(),
		"path": path,
		"children": [],
		"child_count": node.get_child_count()
	}

	# Check for attached script
	var script = node.get_script()
	if script:
		data["script"] = script.resource_path

	# Get node index (sibling order)
	var parent = node.get_parent()
	if parent:
		data["index"] = node.get_index()

	# Build children (preserving order for 2D draw order)
	for i in range(node.get_child_count()):
		var child = node.get_child(i)
		var child_path = child.name if path == "." else path + "/" + child.name
		data["children"].append(_build_hierarchy_recursive(child, child_path))

	return data

# =============================================================================
# get_scene_node_properties (dynamic property fetching)
# =============================================================================
func get_scene_node_properties(args: Dictionary) -> Dictionary:
	"""Get all properties of a specific node in a scene with their current values."""
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", "."))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	var node_type = target.get_class()
	var properties: Array = []
	var categories: Dictionary = {}  # category -> [properties]

	# Get property list with full metadata
	for prop in target.get_property_list():
		var prop_name: String = prop["name"]

		# Skip internal/private properties
		if prop_name.begins_with("_"):
			continue
		if prop_name in ["script", "owner", "scene_file_path", "unique_name_in_owner", "editor_description"]:
			continue

		# Only include editor-visible properties
		var usage = prop.get("usage", 0)
		if not (usage & PROPERTY_USAGE_EDITOR):
			continue

		# Get current value
		var current_value = target.get(prop_name)

		var prop_info := {
			"name": prop_name,
			"type": prop["type"],
			"type_name": _type_id_to_name(prop["type"]),
			"hint": prop.get("hint", 0),
			"hint_string": prop.get("hint_string", ""),
			"value": _serialize_value(current_value),
			"usage": usage
		}

		# Determine category from class hierarchy
		var category = _get_property_category(target, prop_name)
		prop_info["category"] = category

		if not categories.has(category):
			categories[category] = []
		categories[category].append(prop_info)
		properties.append(prop_info)

	# Get inheritance chain
	var chain: Array = []
	var cls: String = node_type
	while cls != "":
		chain.append(cls)
		cls = ClassDB.get_parent_class(cls)

	root.queue_free()

	return {
		"ok": true,
		"scene_path": scene_path,
		"node_path": node_path,
		"node_type": node_type,
		"node_name": target.name,
		"inheritance_chain": chain,
		"properties": properties,
		"categories": categories,
		"property_count": properties.size()
	}

func _type_id_to_name(type_id: int) -> String:
	"""Convert Godot type ID to human-readable name."""
	match type_id:
		TYPE_NIL: return "null"
		TYPE_BOOL: return "bool"
		TYPE_INT: return "int"
		TYPE_FLOAT: return "float"
		TYPE_STRING: return "String"
		TYPE_VECTOR2: return "Vector2"
		TYPE_VECTOR2I: return "Vector2i"
		TYPE_RECT2: return "Rect2"
		TYPE_RECT2I: return "Rect2i"
		TYPE_VECTOR3: return "Vector3"
		TYPE_VECTOR3I: return "Vector3i"
		TYPE_TRANSFORM2D: return "Transform2D"
		TYPE_VECTOR4: return "Vector4"
		TYPE_VECTOR4I: return "Vector4i"
		TYPE_PLANE: return "Plane"
		TYPE_QUATERNION: return "Quaternion"
		TYPE_AABB: return "AABB"
		TYPE_BASIS: return "Basis"
		TYPE_TRANSFORM3D: return "Transform3D"
		TYPE_PROJECTION: return "Projection"
		TYPE_COLOR: return "Color"
		TYPE_STRING_NAME: return "StringName"
		TYPE_NODE_PATH: return "NodePath"
		TYPE_RID: return "RID"
		TYPE_OBJECT: return "Object"
		TYPE_CALLABLE: return "Callable"
		TYPE_SIGNAL: return "Signal"
		TYPE_DICTIONARY: return "Dictionary"
		TYPE_ARRAY: return "Array"
		TYPE_PACKED_BYTE_ARRAY: return "PackedByteArray"
		TYPE_PACKED_INT32_ARRAY: return "PackedInt32Array"
		TYPE_PACKED_INT64_ARRAY: return "PackedInt64Array"
		TYPE_PACKED_FLOAT32_ARRAY: return "PackedFloat32Array"
		TYPE_PACKED_FLOAT64_ARRAY: return "PackedFloat64Array"
		TYPE_PACKED_STRING_ARRAY: return "PackedStringArray"
		TYPE_PACKED_VECTOR2_ARRAY: return "PackedVector2Array"
		TYPE_PACKED_VECTOR3_ARRAY: return "PackedVector3Array"
		TYPE_PACKED_COLOR_ARRAY: return "PackedColorArray"
		_: return "Variant"

func _get_property_category(node: Node, prop_name: String) -> String:
	"""Determine which class in the hierarchy defines this property."""
	var cls: String = node.get_class()
	while cls != "":
		# Check if this class defines the property (not inherited)
		var class_props = ClassDB.class_get_property_list(cls, true)  # true = no inheritance
		for prop in class_props:
			if prop["name"] == prop_name:
				return cls
		cls = ClassDB.get_parent_class(cls)
	return node.get_class()

# =============================================================================
# set_scene_node_property (for visualizer inline editing)
# =============================================================================
func set_scene_node_property(args: Dictionary) -> Dictionary:
	"""Set a property on a node in a scene (supports complex types)."""
	var scene_path: String = _ensure_res_path(str(args.get("scene_path", "")))
	var node_path: String = str(args.get("node_path", "."))
	var property_name: String = str(args.get("property_name", ""))
	var value = args.get("value")
	var value_type: int = int(args.get("value_type", -1))

	if scene_path.strip_edges() == "res://":
		return {"ok": false, "error": "Missing 'scene_path'"}
	if property_name.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'property_name'"}

	var result := _load_scene(scene_path)
	if not result[1].is_empty():
		return result[1]

	var root: Node = result[0]
	var target = _find_node(root, node_path)
	if not target:
		root.queue_free()
		return {"ok": false, "error": "Node not found: " + node_path}

	# Parse value based on type
	var parsed_value = _parse_typed_value(value, value_type)
	var old_value = target.get(property_name)

	# Set the property
	target.set(property_name, parsed_value)

	var err := _save_scene(root, scene_path)
	if not err.is_empty():
		return err

	return {
		"ok": true,
		"scene_path": scene_path,
		"node_path": node_path,
		"property_name": property_name,
		"old_value": _serialize_value(old_value),
		"new_value": _serialize_value(parsed_value),
		"message": "Set %s.%s" % [node_path, property_name]
	}

func _parse_typed_value(value, type_hint: int):
	"""Parse a value based on its type hint."""
	# If it's already the right type, return as-is
	if type_hint == -1:
		return _parse_value(value)

	# Handle dictionary-encoded complex types
	if typeof(value) == TYPE_DICTIONARY:
		if value.has("type"):
			return _parse_value(value)

		# Parse based on type_hint
		match type_hint:
			TYPE_VECTOR2:
				return Vector2(value.get("x", 0), value.get("y", 0))
			TYPE_VECTOR2I:
				return Vector2i(value.get("x", 0), value.get("y", 0))
			TYPE_VECTOR3:
				return Vector3(value.get("x", 0), value.get("y", 0), value.get("z", 0))
			TYPE_VECTOR3I:
				return Vector3i(value.get("x", 0), value.get("y", 0), value.get("z", 0))
			TYPE_COLOR:
				return Color(value.get("r", 1), value.get("g", 1), value.get("b", 1), value.get("a", 1))
			TYPE_RECT2:
				return Rect2(value.get("x", 0), value.get("y", 0), value.get("width", 0), value.get("height", 0))

	return value
</file>

<file path="godot-plugin/addons/godot_mcp/tools/script_tools.gd">
@tool
extends Node
class_name ScriptTools
## Script and file management tools for MCP.
## Handles: apply_diff_preview, validate_script, list_scripts,
##          create_folder, delete_file, rename_file

var _editor_plugin: EditorPlugin = null

func set_editor_plugin(plugin: EditorPlugin) -> void:
	_editor_plugin = plugin

func _refresh_filesystem() -> void:
	if _editor_plugin:
		_editor_plugin.get_editor_interface().get_resource_filesystem().scan()

func _ensure_res_path(path: String) -> String:
	if not path.begins_with("res://"):
		return "res://" + path
	return path

# =============================================================================
# apply_diff_preview - Simplified snippet replace without CodeApplier dependency
# =============================================================================
func apply_diff_preview(args: Dictionary) -> Dictionary:
	var edit: Dictionary = args.get("edit", {})
	if edit.is_empty():
		return {"ok": false, "error": "Missing 'edit' payload"}

	var path: String = str(edit.get("file", ""))
	if path.is_empty():
		return {"ok": false, "error": "Missing 'file' in edit"}

	path = _ensure_res_path(path)

	if not FileAccess.file_exists(path):
		return {"ok": false, "error": "File not found: " + path}

	var spec_type: String = str(edit.get("type", "snippet_replace"))
	if spec_type != "snippet_replace":
		return {"ok": false, "error": "Only 'snippet_replace' type is supported"}

	var old_snippet: String = str(edit.get("old_snippet", ""))
	var new_snippet: String = str(edit.get("new_snippet", ""))
	var context_before: String = str(edit.get("context_before", ""))
	var context_after: String = str(edit.get("context_after", ""))

	if old_snippet.is_empty():
		return {"ok": false, "error": "Missing 'old_snippet' in edit"}

	# Read current file content
	var file := FileAccess.open(path, FileAccess.READ)
	if not file:
		return {"ok": false, "error": "Cannot read file: " + path}
	var content := file.get_as_text()
	file.close()

	# Find and replace the snippet
	var search_text := old_snippet
	var pos := content.find(search_text)

	# If not found directly, try with context
	if pos == -1 and not context_before.is_empty():
		var ctx_pos := content.find(context_before)
		if ctx_pos != -1:
			var after_ctx := ctx_pos + context_before.length()
			var remaining := content.substr(after_ctx)
			var snippet_pos := remaining.find(old_snippet)
			if snippet_pos != -1:
				pos = after_ctx + snippet_pos

	if pos == -1:
		return {"ok": false, "error": "Could not find old_snippet in file. Make sure old_snippet matches the file content exactly."}

	# Check for multiple occurrences
	var second_pos := content.find(search_text, pos + 1)
	if second_pos != -1 and context_before.is_empty() and context_after.is_empty():
		return {"ok": false, "error": "old_snippet appears multiple times. Add context_before or context_after for disambiguation."}

	# Apply the replacement
	var original_content := content
	var new_content := content.substr(0, pos) + new_snippet + content.substr(pos + old_snippet.length())

	# Write back
	file = FileAccess.open(path, FileAccess.WRITE)
	if not file:
		return {"ok": false, "error": "Cannot write file: " + path}
	file.store_string(new_content)
	file.close()

	# Count changes
	var old_lines := old_snippet.split("\n")
	var new_lines := new_snippet.split("\n")
	var added := maxi(0, new_lines.size() - old_lines.size())
	var removed := maxi(0, old_lines.size() - new_lines.size())

	_refresh_filesystem()

	return {
		"ok": true,
		"path": path,
		"added": added,
		"removed": removed,
		"auto_applied": true,
		"message": "Applied edit to %s (+%d -%d lines)" % [path, added, removed]
	}

# =============================================================================
# validate_script
# =============================================================================
func validate_script(args: Dictionary) -> Dictionary:
	var path: String = str(args.get("path", ""))
	if path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'path'"}

	path = _ensure_res_path(path)

	if not FileAccess.file_exists(path):
		return {"ok": false, "error": "File not found: " + path}

	# Attempt to load the script - Godot will parse it
	var script: GDScript = load(path)

	if script == null:
		return {
			"ok": true,
			"valid": false,
			"path": path,
			"message": "Script has syntax errors. Check Godot console for details."
		}

	if not script.can_instantiate():
		return {
			"ok": true,
			"valid": false,
			"path": path,
			"message": "Script loaded but cannot be instantiated (may have errors)"
		}

	return {
		"ok": true,
		"valid": true,
		"path": path,
		"message": "No syntax errors found"
	}

# =============================================================================
# list_scripts
# =============================================================================
func list_scripts(args: Dictionary) -> Dictionary:
	var scripts: Array = []
	_collect_scripts("res://", scripts)

	return {
		"ok": true,
		"scripts": scripts,
		"count": scripts.size()
	}

func _collect_scripts(path: String, out: Array) -> void:
	var dir := DirAccess.open(path)
	if dir == null:
		return

	dir.list_dir_begin()
	var name := dir.get_next()
	while name != "":
		if name.begins_with("."):
			name = dir.get_next()
			continue

		var full_path := path.path_join(name)
		if dir.current_is_dir():
			_collect_scripts(full_path, out)
		elif name.ends_with(".gd"):
			out.append(full_path)

		name = dir.get_next()
	dir.list_dir_end()

# =============================================================================
# create_folder
# =============================================================================
func create_folder(args: Dictionary) -> Dictionary:
	var path: String = str(args.get("path", ""))
	if path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'path'"}

	path = _ensure_res_path(path)

	if DirAccess.dir_exists_absolute(path):
		return {"ok": true, "path": path, "message": "Directory already exists"}

	var err := DirAccess.make_dir_recursive_absolute(path)
	if err != OK:
		return {"ok": false, "error": "Failed to create directory: " + str(err)}

	_refresh_filesystem()

	return {"ok": true, "path": path, "message": "Directory created"}

# =============================================================================
# delete_file
# =============================================================================
func delete_file(args: Dictionary) -> Dictionary:
	var path: String = str(args.get("path", ""))
	var confirm: bool = bool(args.get("confirm", false))
	var create_backup: bool = bool(args.get("create_backup", true))

	if path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'path'"}
	if not confirm:
		return {"ok": false, "error": "Must set confirm=true to delete"}

	path = _ensure_res_path(path)

	if not FileAccess.file_exists(path):
		return {"ok": false, "error": "File not found: " + path}

	# Create backup
	if create_backup:
		var backup_path := path + ".bak"
		DirAccess.copy_absolute(path, backup_path)

	var err := DirAccess.remove_absolute(path)
	if err != OK:
		return {"ok": false, "error": "Failed to delete file: " + str(err)}

	_refresh_filesystem()

	return {"ok": true, "path": path, "message": "File deleted" + (" (backup created)" if create_backup else "")}

# =============================================================================
# rename_file
# =============================================================================
func rename_file(args: Dictionary) -> Dictionary:
	var old_path: String = str(args.get("old_path", ""))
	var new_path: String = str(args.get("new_path", ""))

	if old_path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'old_path'"}
	if new_path.strip_edges().is_empty():
		return {"ok": false, "error": "Missing 'new_path'"}

	old_path = _ensure_res_path(old_path)
	new_path = _ensure_res_path(new_path)

	if not FileAccess.file_exists(old_path):
		return {"ok": false, "error": "File not found: " + old_path}
	if FileAccess.file_exists(new_path):
		return {"ok": false, "error": "Target already exists: " + new_path}

	# Ensure target directory exists
	var dir_path := new_path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		DirAccess.make_dir_recursive_absolute(dir_path)

	var err := DirAccess.rename_absolute(old_path, new_path)
	if err != OK:
		return {"ok": false, "error": "Failed to rename: " + str(err)}

	_refresh_filesystem()

	return {"ok": true, "old_path": old_path, "new_path": new_path,
		"message": "Renamed %s to %s" % [old_path, new_path]}
</file>

<file path="godot-plugin/addons/godot_mcp/tools/visualizer_tools.gd">
@tool
extends Node
class_name VisualizerTools
## Crawls a Godot project and parses all GDScript files to build a project map.

var _editor_plugin: EditorPlugin = null
var _scene_tools_ref: Node = null

func set_editor_plugin(plugin: EditorPlugin) -> void:
	_editor_plugin = plugin

func set_scene_tools_ref(scene_tools: Node) -> void:
	_scene_tools_ref = scene_tools

func map_project(args: Dictionary) -> Dictionary:
	"""Crawl the entire project and build a structural map of all scripts."""
	var root_path: String = str(args.get("root", "res://"))
	var include_addons: bool = bool(args.get("include_addons", false))

	if not root_path.begins_with("res://"):
		root_path = "res://" + root_path

	# Collect all .gd files
	var script_paths: Array = []
	_collect_scripts(root_path, script_paths, include_addons)

	if script_paths.is_empty():
		return {"ok": false, "error": "No GDScript files found in " + root_path}

	# Parse each script
	var nodes: Array = []
	var class_map: Dictionary = {}  # class_name -> path

	for path in script_paths:
		var info: Dictionary = _parse_script(path)
		nodes.append(info)
		if info.get("class_name", "") != "":
			class_map[info["class_name"]] = path

	# Build edges
	var edges: Array = []
	for node in nodes:
		var from_path: String = node["path"]

		# extends relationship (resolve class_name to path)
		var extends_class: String = node.get("extends", "")
		if extends_class in class_map:
			edges.append({"from": from_path, "to": class_map[extends_class], "type": "extends"})

		# preload/load references
		for ref in node.get("preloads", []):
			if ref.ends_with(".gd"):
				edges.append({"from": from_path, "to": ref, "type": "preload"})

		# signal connections
		for conn in node.get("connections", []):
			var target: String = conn.get("target", "")
			if target in class_map:
				edges.append({"from": from_path, "to": class_map[target], "type": "signal", "signal_name": conn.get("signal", "")})

	return {
		"ok": true,
		"project_map": {
			"nodes": nodes,
			"edges": edges,
			"total_scripts": nodes.size(),
			"total_connections": edges.size()
		}
	}

func _collect_scripts(path: String, results: Array, include_addons: bool) -> void:
	"""Recursively collect all .gd files."""
	var dir := DirAccess.open(path)
	if dir == null:
		return

	dir.list_dir_begin()
	var name := dir.get_next()
	while name != "":
		if name.begins_with("."):
			name = dir.get_next()
			continue

		var full_path := path.path_join(name)

		if dir.current_is_dir():
			if name == "addons" and not include_addons:
				name = dir.get_next()
				continue
			_collect_scripts(full_path, results, include_addons)
		elif name.ends_with(".gd"):
			results.append(full_path)

		name = dir.get_next()
	dir.list_dir_end()

func _parse_script(path: String) -> Dictionary:
	"""Parse a GDScript file and extract its structure."""
	var file := FileAccess.open(path, FileAccess.READ)
	if file == null:
		return {"path": path, "error": "Cannot open file"}

	var content: String = file.get_as_text()
	file.close()

	var lines: PackedStringArray = content.split("\n")
	var line_count: int = lines.size()

	var description := ""
	var extends_class := ""
	var class_name_str := ""
	var variables: Array = []
	var functions: Array = []
	var signals_list: Array = []
	var preloads: Array = []
	var connections: Array = []

	# Regex patterns
	var re_desc := RegEx.new()
	re_desc.compile("^##\\s*@desc:\\s*(.+)")

	var re_extends := RegEx.new()
	re_extends.compile("^extends\\s+(\\w+)")

	var re_class_name := RegEx.new()
	re_class_name.compile("^class_name\\s+(\\w+)")

	# Match: @export var name: Type = value  OR  var name: Type  OR  var name = value
	# Captures: 1=@export, 2=@onready, 3=name, 4=type, 5=default
	var re_var := RegEx.new()
	re_var.compile("^(@export(?:\\([^)]*\\))?\\s+)?(@onready\\s+)?var\\s+(\\w+)\\s*(?::\\s*(\\w+))?(?:\\s*=\\s*(.+))?")

	# Match: func name(params) -> ReturnType:
	var re_func := RegEx.new()
	re_func.compile("^func\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*(?:->\\s*(\\w+))?")

	# Match: signal name(params)
	var re_signal := RegEx.new()
	re_signal.compile("^signal\\s+(\\w+)(?:\\(([^)]*)\\))?")

	var re_preload := RegEx.new()
	re_preload.compile("(?:preload|load)\\s*\\(\\s*\"(res://[^\"]+)\"\\s*\\)")

	# Match: obj.signal.connect(...) pattern (Godot 4 style)
	var re_connect_obj := RegEx.new()
	re_connect_obj.compile("(\\w+)\\.(\\w+)\\.connect\\s*\\(")
	
	# Match: signal.connect(...) pattern (direct signal)
	var re_connect_direct := RegEx.new()
	re_connect_direct.compile("^\\s*(\\w+)\\.connect\\s*\\(")
	
	# Map of variable names to their types (for resolving signal connections)
	var var_type_map: Dictionary = {}

	# First pass: extract metadata and find function boundaries
	var func_starts: Array = []  # [{line_idx, name}]

	for i in range(line_count):
		var line: String = lines[i]
		var stripped: String = line.strip_edges()

		# Description tag (check first 15 lines)
		if i < 15 and description.is_empty():
			var m := re_desc.search(stripped)
			if m:
				description = m.get_string(1)
				continue

		# extends
		if extends_class.is_empty():
			var m := re_extends.search(stripped)
			if m:
				extends_class = m.get_string(1)
				continue

		# class_name
		if class_name_str.is_empty():
			var m := re_class_name.search(stripped)
			if m:
				class_name_str = m.get_string(1)
				continue

		# Variables - only match top-level (not indented)
		# Skip lines that start with tab or spaces (inside functions)
		if not line.begins_with("\t") and not line.begins_with(" "):
			var m_var := re_var.search(stripped)
			if m_var:
				var exported: bool = m_var.get_string(1).strip_edges() != ""
				var onready: bool = m_var.get_string(2).strip_edges() != ""
				var var_name: String = m_var.get_string(3)
				var var_type: String = m_var.get_string(4).strip_edges()
				var default_val: String = m_var.get_string(5).strip_edges()

				# Try to infer type from default value if no explicit type
				if var_type.is_empty() and not default_val.is_empty():
					var_type = _infer_type(default_val)
				
				# Track variable types for signal connection resolution
				if not var_type.is_empty():
					var_type_map[var_name] = var_type

				variables.append({
					"name": var_name,
					"type": var_type,
					"exported": exported,
					"onready": onready,
					"default": default_val
				})

		# Functions
		var m_func := re_func.search(stripped)
		if m_func:
			var func_name: String = m_func.get_string(1)
			var return_type: String = m_func.get_string(3).strip_edges()
			func_starts.append({"line_idx": i, "name": func_name})
			functions.append({
				"name": func_name,
				"params": m_func.get_string(2).strip_edges(),
				"return_type": return_type,
				"line": i + 1,
				"body": ""  # filled in second pass
			})

		# Signals
		var m_sig := re_signal.search(stripped)
		if m_sig:
			signals_list.append({
				"name": m_sig.get_string(1),
				"params": m_sig.get_string(2).strip_edges() if m_sig.get_string(2) else ""
			})

		# Preload/load references
		var m_preload := re_preload.search(stripped)
		if m_preload:
			preloads.append(m_preload.get_string(1))

		# Signal connections (Godot 4 style)
		# Pattern: obj.signal.connect(...) - e.g. wave_manager.wave_started.connect(...)
		var m_conn_obj := re_connect_obj.search(stripped)
		if m_conn_obj:
			var obj_name: String = m_conn_obj.get_string(1)
			var signal_name: String = m_conn_obj.get_string(2)
			var target_type: String = var_type_map.get(obj_name, "")
			connections.append({
				"object": obj_name,
				"signal": signal_name,
				"target": target_type,
				"line": i + 1
			})
		else:
			# Pattern: signal.connect(...) - e.g. body_entered.connect(...)
			var m_conn_direct := re_connect_direct.search(stripped)
			if m_conn_direct:
				connections.append({
					"signal": m_conn_direct.get_string(1),
					"target": extends_class,  # Direct signal likely from parent class
					"line": i + 1
				})

	# Second pass: extract function bodies
	for fi in range(func_starts.size()):
		var start_idx: int = func_starts[fi]["line_idx"]
		var end_idx: int
		if fi + 1 < func_starts.size():
			end_idx = func_starts[fi + 1]["line_idx"]
		else:
			end_idx = line_count

		# Find actual end: look backwards from next func to skip blank lines
		while end_idx > start_idx + 1 and lines[end_idx - 1].strip_edges().is_empty():
			end_idx -= 1

		# Also check for top-level declarations (var, signal, @export, class_name, etc.)
		# that would end the function body
		for check_idx in range(start_idx + 1, end_idx):
			var check_line: String = lines[check_idx]
			# If line is not indented and not empty and not a comment, it's not part of the function
			if not check_line.is_empty() and not check_line.begins_with("\t") and not check_line.begins_with(" ") and not check_line.begins_with("#"):
				end_idx = check_idx
				break

		var body_lines: PackedStringArray = PackedStringArray()
		for li in range(start_idx, end_idx):
			body_lines.append(lines[li])

		var body: String = "\n".join(body_lines)
		# Cap body size to avoid huge payloads
		if body.length() > 3000:
			body = body.substr(0, 3000) + "\n# ... (truncated)"

		functions[fi]["body"] = body
		functions[fi]["body_lines"] = end_idx - start_idx

	# Determine folder
	var folder: String = path.get_base_dir()
	var filename: String = path.get_file()

	return {
		"path": path,
		"filename": filename,
		"folder": folder,
		"class_name": class_name_str,
		"extends": extends_class,
		"description": description,
		"line_count": line_count,
		"variables": variables,
		"functions": functions,
		"signals": signals_list,
		"preloads": preloads,
		"connections": connections
	}

func _infer_type(default_val: String) -> String:
	"""Try to infer GDScript type from a default value."""
	if default_val == "true" or default_val == "false":
		return "bool"
	if default_val.is_valid_int():
		return "int"
	if default_val.is_valid_float():
		return "float"
	if default_val.begins_with("\"") or default_val.begins_with("'"):
		return "String"
	if default_val.begins_with("Vector2"):
		return "Vector2"
	if default_val.begins_with("Vector3"):
		return "Vector3"
	if default_val.begins_with("Color"):
		return "Color"
	if default_val.begins_with("["):
		return "Array"
	if default_val.begins_with("{"):
		return "Dictionary"
	if default_val == "null":
		return "Variant"
	if default_val.ends_with(".new()"):
		return default_val.replace(".new()", "")
	return ""


func map_scenes(args: Dictionary) -> Dictionary:
	"""Crawl the project and build a map of all scenes."""
	var root_path: String = str(args.get("root", "res://"))
	var include_addons: bool = bool(args.get("include_addons", false))

	if not root_path.begins_with("res://"):
		root_path = "res://" + root_path

	# Collect all .tscn files
	var scene_paths: Array = []
	_collect_scenes(root_path, scene_paths, include_addons)

	if scene_paths.is_empty():
		return {"ok": true, "scene_map": {"scenes": [], "total_scenes": 0}}

	# Parse each scene
	var scenes: Array = []
	for path in scene_paths:
		var info: Dictionary = _parse_scene(path)
		scenes.append(info)

	# Build edges between scenes (instantiation, preloads)
	var edges: Array = []
	for scene in scenes:
		var from_path: String = scene["path"]
		for instance in scene.get("instances", []):
			edges.append({"from": from_path, "to": instance, "type": "instance"})

	return {
		"ok": true,
		"scene_map": {
			"scenes": scenes,
			"edges": edges,
			"total_scenes": scenes.size()
		}
	}


func _collect_scenes(path: String, results: Array, include_addons: bool) -> void:
	"""Recursively collect all .tscn files."""
	var dir := DirAccess.open(path)
	if dir == null:
		return

	dir.list_dir_begin()
	var name := dir.get_next()
	while name != "":
		if name.begins_with("."):
			name = dir.get_next()
			continue

		var full_path := path.path_join(name)

		if dir.current_is_dir():
			if name == "addons" and not include_addons:
				name = dir.get_next()
				continue
			_collect_scenes(full_path, results, include_addons)
		elif name.ends_with(".tscn"):
			results.append(full_path)

		name = dir.get_next()
	dir.list_dir_end()


func _parse_scene(path: String) -> Dictionary:
	"""Parse a scene file and extract its structure."""
	var file := FileAccess.open(path, FileAccess.READ)
	if file == null:
		return {"path": path, "error": "Cannot open file"}

	var content: String = file.get_as_text()
	file.close()

	var scene_name: String = path.get_file().replace(".tscn", "")
	var root_type: String = ""
	var nodes: Array = []
	var instances: Array = []
	var scripts: Array = []

	# Parse .tscn format
	var lines: PackedStringArray = content.split("\n")
	var current_node: Dictionary = {}
	
	var re_ext_resource := RegEx.new()
	re_ext_resource.compile('\\[ext_resource.*path="([^"]+)".*type="([^"]+)"')
	
	var re_node := RegEx.new()
	re_node.compile('\\[node name="([^"]+)".*type="([^"]+)"')
	
	var re_node_instance := RegEx.new()
	re_node_instance.compile('\\[node name="([^"]+)".*instance=ExtResource\\("([^"]+)"\\)')
	
	var re_script := RegEx.new()
	re_script.compile('script = ExtResource\\("([^"]+)"\\)')

	var ext_resources: Dictionary = {}  # id -> {path, type}
	
	for line in lines:
		# External resources
		var m_ext := re_ext_resource.search(line)
		if m_ext:
			var res_path: String = m_ext.get_string(1)
			var res_type: String = m_ext.get_string(2)
			# Extract ID from the line
			var id_match := RegEx.create_from_string('id="([^"]+)"').search(line)
			if id_match:
				ext_resources[id_match.get_string(1)] = {"path": res_path, "type": res_type}
				if res_type == "PackedScene":
					instances.append(res_path)
				elif res_type == "Script":
					scripts.append(res_path)
			continue

		# Regular nodes
		var m_node := re_node.search(line)
		if m_node:
			var node_name: String = m_node.get_string(1)
			var node_type: String = m_node.get_string(2)
			if root_type.is_empty():
				root_type = node_type
			nodes.append({"name": node_name, "type": node_type})
			continue

		# Instance nodes
		var m_inst := re_node_instance.search(line)
		if m_inst:
			var node_name: String = m_inst.get_string(1)
			nodes.append({"name": node_name, "type": "Instance"})

	return {
		"path": path,
		"name": scene_name,
		"root_type": root_type,
		"nodes": nodes,
		"instances": instances,
		"scripts": scripts,
		"node_count": nodes.size()
	}


# ============================================================================
# INTERNAL FILE MODIFICATION FUNCTIONS (not exposed as MCP tools)
# These are called directly by the visualizer for inline editing
# ============================================================================

func _internal_map_scenes(args: Dictionary) -> Dictionary:
	"""Internal wrapper for map_scenes."""
	return map_scenes(args)


func _internal_refresh_map(args: Dictionary) -> Dictionary:
	"""Refresh the project map."""
	return map_project(args)


func _internal_create_script_file(args: Dictionary) -> Dictionary:
	"""Create a new script file."""
	var script_path: String = args.get("path", "")
	var extends_type: String = args.get("extends", "Node")
	var class_name_str: String = args.get("class_name", "")
	
	if script_path.is_empty():
		return {"ok": false, "error": "No path provided"}
	
	if not script_path.begins_with("res://"):
		script_path = "res://" + script_path
	
	if not script_path.ends_with(".gd"):
		script_path += ".gd"
	
	# Check if file already exists
	if FileAccess.file_exists(script_path):
		return {"ok": false, "error": "File already exists: " + script_path}
	
	# Create directory if needed
	var dir_path: String = script_path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		var err := DirAccess.make_dir_recursive_absolute(dir_path)
		if err != OK:
			return {"ok": false, "error": "Failed to create directory"}
	
	# Build script content
	var content := ""
	if not class_name_str.is_empty():
		content += "class_name " + class_name_str + "\n"
	content += "extends " + extends_type + "\n"
	content += "\n\n"
	content += "func _ready() -> void:\n"
	content += "\tpass\n"
	
	# Write file
	var file := FileAccess.open(script_path, FileAccess.WRITE)
	if file == null:
		return {"ok": false, "error": "Cannot create file: " + script_path}
	
	file.store_string(content)
	file.close()
	
	return {"ok": true, "path": script_path}


func _internal_modify_variable(args: Dictionary) -> Dictionary:
	"""Add, update, or delete a variable in a script file."""
	var script_path: String = args.get("path", "")
	var action: String = args.get("action", "")  # "add", "update", "delete"
	var old_name: String = args.get("old_name", "")
	var new_name: String = args.get("name", "")
	var var_type: String = args.get("type", "")
	var default_val: String = args.get("default", "")
	var exported: bool = args.get("exported", false)
	var onready: bool = args.get("onready", false)
	
	if script_path.is_empty():
		return {"ok": false, "error": "No script path provided"}
	
	var file := FileAccess.open(script_path, FileAccess.READ)
	if file == null:
		return {"ok": false, "error": "Cannot open file: " + script_path}
	
	var content: String = file.get_as_text()
	file.close()
	
	var lines: Array = Array(content.split("\n"))
	var modified := false
	
	if action == "delete":
		# Find and remove the variable declaration
		var pattern := RegEx.new()
		pattern.compile("^(@export(?:\\([^)]*\\))?\\s+)?(?:@onready\\s+)?var\\s+" + old_name + "\\s*(?::|=|$)")
		for i in range(lines.size() - 1, -1, -1):
			if pattern.search(lines[i].strip_edges()):
				lines.remove_at(i)
				modified = true
				break
	
	elif action == "update":
		# Find and update the variable declaration
		var pattern := RegEx.new()
		pattern.compile("^(@export(?:\\([^)]*\\))?\\s+)?(@onready\\s+)?var\\s+" + old_name + "\\s*(?::\\s*\\w+)?(?:\\s*=\\s*.+)?$")
		for i in range(lines.size()):
			var m := pattern.search(lines[i].strip_edges())
			if m:
				# Use onready from args, not from matched pattern
				var new_line := _build_var_line(new_name, var_type, default_val, exported, onready)
				lines[i] = new_line
				modified = true
				break
	
	elif action == "add":
		# Find position to insert (after last variable, before first function)
		var insert_pos := _find_var_insert_position(lines, exported)
		var new_line := _build_var_line(new_name, var_type, default_val, exported, false)
		lines.insert(insert_pos, new_line)
		modified = true
	
	if modified:
		var new_content := "\n".join(PackedStringArray(lines))
		var write_file := FileAccess.open(script_path, FileAccess.WRITE)
		if write_file == null:
			return {"ok": false, "error": "Cannot write to file: " + script_path}
		write_file.store_string(new_content)
		write_file.close()
		return {"ok": true, "action": action, "variable": new_name}
	
	return {"ok": false, "error": "Variable not found: " + old_name}


func _internal_modify_signal(args: Dictionary) -> Dictionary:
	"""Add, update, or delete a signal in a script file."""
	var script_path: String = args.get("path", "")
	var action: String = args.get("action", "")
	var old_name: String = args.get("old_name", "")
	var new_name: String = args.get("name", "")
	var params: String = args.get("params", "")
	
	if script_path.is_empty():
		return {"ok": false, "error": "No script path provided"}
	
	var file := FileAccess.open(script_path, FileAccess.READ)
	if file == null:
		return {"ok": false, "error": "Cannot open file: " + script_path}
	
	var content: String = file.get_as_text()
	file.close()
	
	var lines: Array = Array(content.split("\n"))
	var modified := false
	
	if action == "delete":
		var pattern := RegEx.new()
		pattern.compile("^signal\\s+" + old_name + "(?:\\s*\\(|$)")
		for i in range(lines.size() - 1, -1, -1):
			if pattern.search(lines[i].strip_edges()):
				lines.remove_at(i)
				modified = true
				break
	
	elif action == "update":
		var pattern := RegEx.new()
		pattern.compile("^signal\\s+" + old_name + "(?:\\s*\\([^)]*\\))?$")
		for i in range(lines.size()):
			if pattern.search(lines[i].strip_edges()):
				var new_line := "signal " + new_name
				if not params.is_empty():
					new_line += "(" + params + ")"
				lines[i] = new_line
				modified = true
				break
	
	elif action == "add":
		var insert_pos := _find_signal_insert_position(lines)
		var new_line := "signal " + new_name
		if not params.is_empty():
			new_line += "(" + params + ")"
		lines.insert(insert_pos, new_line)
		modified = true
	
	if modified:
		var new_content := "\n".join(PackedStringArray(lines))
		var write_file := FileAccess.open(script_path, FileAccess.WRITE)
		if write_file == null:
			return {"ok": false, "error": "Cannot write to file: " + script_path}
		write_file.store_string(new_content)
		write_file.close()
		return {"ok": true, "action": action, "signal": new_name}
	
	return {"ok": false, "error": "Signal not found: " + old_name}


func _internal_modify_function(args: Dictionary) -> Dictionary:
	"""Update a function's body in a script file."""
	var script_path: String = args.get("path", "")
	var func_name: String = args.get("name", "")
	var new_body: String = args.get("body", "")
	
	if script_path.is_empty() or func_name.is_empty():
		return {"ok": false, "error": "Missing path or function name"}
	
	var file := FileAccess.open(script_path, FileAccess.READ)
	if file == null:
		return {"ok": false, "error": "Cannot open file: " + script_path}
	
	var content: String = file.get_as_text()
	file.close()
	
	var lines: Array = Array(content.split("\n"))
	
	# Find the function
	var re_func := RegEx.new()
	re_func.compile("^func\\s+" + func_name + "\\s*\\(")
	
	var func_start := -1
	var func_end := -1
	
	for i in range(lines.size()):
		if func_start == -1:
			if re_func.search(lines[i].strip_edges()):
				func_start = i
		elif func_start != -1:
			# Find end of function (next top-level declaration or end of file)
			var stripped: String = lines[i].strip_edges()
			if not stripped.is_empty() and not lines[i].begins_with("\t") and not lines[i].begins_with(" ") and not stripped.begins_with("#"):
				func_end = i
				break
	
	if func_start == -1:
		return {"ok": false, "error": "Function not found: " + func_name}
	
	if func_end == -1:
		func_end = lines.size()
	
	# Remove trailing empty lines from function body
	while func_end > func_start + 1 and lines[func_end - 1].strip_edges().is_empty():
		func_end -= 1
	
	# Replace function body
	var new_lines := Array(new_body.split("\n"))
	
	# Remove old function lines
	for i in range(func_end - 1, func_start - 1, -1):
		lines.remove_at(i)
	
	# Insert new function lines
	for i in range(new_lines.size()):
		lines.insert(func_start + i, new_lines[i])
	
	var new_content := "\n".join(PackedStringArray(lines))
	var write_file := FileAccess.open(script_path, FileAccess.WRITE)
	if write_file == null:
		return {"ok": false, "error": "Cannot write to file: " + script_path}
	write_file.store_string(new_content)
	write_file.close()
	
	return {"ok": true, "function": func_name}


func _internal_modify_function_delete(args: Dictionary) -> Dictionary:
	"""Delete a function from a script file."""
	var script_path: String = args.get("path", "")
	var func_name: String = args.get("name", "")
	
	if script_path.is_empty() or func_name.is_empty():
		return {"ok": false, "error": "Missing path or function name"}
	
	var file := FileAccess.open(script_path, FileAccess.READ)
	if file == null:
		return {"ok": false, "error": "Cannot open file: " + script_path}
	
	var content: String = file.get_as_text()
	file.close()
	
	var lines: Array = Array(content.split("\n"))
	
	# Find the function
	var re_func := RegEx.new()
	re_func.compile("^func\\s+" + func_name + "\\s*\\(")
	
	var func_start := -1
	var func_end := -1
	
	for i in range(lines.size()):
		if func_start == -1:
			if re_func.search(lines[i].strip_edges()):
				func_start = i
		elif func_start != -1:
			# Find end of function (next top-level declaration or end of file)
			var stripped: String = lines[i].strip_edges()
			if not stripped.is_empty() and not lines[i].begins_with("\t") and not lines[i].begins_with(" ") and not stripped.begins_with("#"):
				func_end = i
				break
	
	if func_start == -1:
		return {"ok": false, "error": "Function not found: " + func_name}
	
	if func_end == -1:
		func_end = lines.size()
	
	# Remove trailing empty lines before the function
	while func_end > func_start + 1 and lines[func_end - 1].strip_edges().is_empty():
		func_end -= 1
	
	# Remove the function lines
	for i in range(func_end - 1, func_start - 1, -1):
		lines.remove_at(i)
	
	# Remove extra blank lines that might be left
	# (but keep at least one blank line between declarations)
	
	var new_content := "\n".join(PackedStringArray(lines))
	var write_file := FileAccess.open(script_path, FileAccess.WRITE)
	if write_file == null:
		return {"ok": false, "error": "Cannot write to file: " + script_path}
	write_file.store_string(new_content)
	write_file.close()
	
	return {"ok": true, "deleted": func_name}


func _internal_find_usages(args: Dictionary) -> Dictionary:
	"""Find all usages of a variable, signal, or function across all scripts."""
	var name: String = args.get("name", "")
	var item_type: String = args.get("type", "")  # "variable", "signal", "function"
	var root_path: String = args.get("root", "res://")
	
	if name.is_empty():
		return {"ok": false, "error": "No name provided"}
	
	# Collect all scripts
	var script_paths: Array = []
	_collect_scripts(root_path, script_paths, false)
	
	var usages: Array = []
	
	# Build regex pattern based on type
	var pattern := RegEx.new()
	if item_type == "signal":
		# Match: signal_name.emit() or signal_name.connect() or .signal_name.
		pattern.compile("\\b" + name + "\\b")
	else:
		# Match word boundary for variables and functions
		pattern.compile("\\b" + name + "\\b")
	
	for path in script_paths:
		var file := FileAccess.open(path, FileAccess.READ)
		if file == null:
			continue
		
		var content: String = file.get_as_text()
		file.close()
		
		var lines: PackedStringArray = content.split("\n")
		for i in range(lines.size()):
			var line: String = lines[i]
			if pattern.search(line):
				# Skip the declaration line itself
				if item_type == "variable" and RegEx.create_from_string("^\\s*(@export)?\\s*var\\s+" + name + "\\b").search(line):
					continue
				if item_type == "signal" and RegEx.create_from_string("^\\s*signal\\s+" + name + "\\b").search(line):
					continue
				if item_type == "function" and RegEx.create_from_string("^\\s*func\\s+" + name + "\\s*\\(").search(line):
					continue
				
				usages.append({
					"file": path,
					"line": i + 1,
					"code": line.strip_edges()
				})
	
	return {"ok": true, "usages": usages, "count": usages.size()}


# Helper functions for file modification

func _build_var_line(name: String, type: String, default: String, exported: bool, onready: bool) -> String:
	var line := ""
	if exported:
		line += "@export "
	if onready:
		line += "@onready "
	line += "var " + name
	if not type.is_empty():
		line += ": " + type
	if not default.is_empty():
		line += " = " + default
	return line


func _find_var_insert_position(lines: Array, exported: bool) -> int:
	"""Find the best position to insert a new variable."""
	var last_var_line := -1
	var first_func_line := -1
	var after_class_decl := 0
	
	var re_var := RegEx.new()
	re_var.compile("^(@export)?\\s*(@onready)?\\s*var\\s+")
	var re_func := RegEx.new()
	re_func.compile("^func\\s+")
	var re_class := RegEx.new()
	re_class.compile("^(class_name|extends)\\s+")
	
	for i in range(lines.size()):
		var stripped: String = lines[i].strip_edges()
		if re_class.search(stripped):
			after_class_decl = i + 1
		if re_var.search(stripped):
			last_var_line = i
		if re_func.search(stripped) and first_func_line == -1:
			first_func_line = i
			break
	
	# Insert after last variable, or before first function, or after class declarations
	if last_var_line != -1:
		return last_var_line + 1
	if first_func_line != -1:
		return first_func_line
	return max(after_class_decl, 2)  # At least after extends/class_name


func _find_signal_insert_position(lines: Array) -> int:
	"""Find the best position to insert a new signal."""
	var last_signal_line := -1
	var first_var_line := -1
	var after_class_decl := 0
	
	var re_signal := RegEx.new()
	re_signal.compile("^signal\\s+")
	var re_var := RegEx.new()
	re_var.compile("^(@export)?\\s*var\\s+")
	var re_class := RegEx.new()
	re_class.compile("^(class_name|extends)\\s+")
	
	for i in range(lines.size()):
		var stripped: String = lines[i].strip_edges()
		if re_class.search(stripped):
			after_class_decl = i + 1
		if re_signal.search(stripped):
			last_signal_line = i
		if re_var.search(stripped) and first_var_line == -1:
			first_var_line = i
	
	# Insert after last signal, or before first var, or after class declarations
	if last_signal_line != -1:
		return last_signal_line + 1
	if first_var_line != -1:
		return first_var_line
	return max(after_class_decl, 2)


# ============================================================================
# SCENE VISUALIZER INTERNAL FUNCTIONS
# These are called by the visualizer for scene view functionality
# ============================================================================

func _internal_get_scene_hierarchy(args: Dictionary) -> Dictionary:
	"""Get scene hierarchy for visualizer."""
	if _scene_tools_ref and _scene_tools_ref.has_method("get_scene_hierarchy"):
		return _scene_tools_ref.get_scene_hierarchy(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_get_scene_node_properties(args: Dictionary) -> Dictionary:
	"""Get node properties for visualizer panel."""
	if _scene_tools_ref and _scene_tools_ref.has_method("get_scene_node_properties"):
		return _scene_tools_ref.get_scene_node_properties(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_set_scene_node_property(args: Dictionary) -> Dictionary:
	"""Set node property from visualizer panel."""
	if _scene_tools_ref and _scene_tools_ref.has_method("set_scene_node_property"):
		return _scene_tools_ref.set_scene_node_property(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_add_scene_node(args: Dictionary) -> Dictionary:
	"""Add a node to a scene from visualizer."""
	if _scene_tools_ref and _scene_tools_ref.has_method("add_node"):
		return _scene_tools_ref.add_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_remove_scene_node(args: Dictionary) -> Dictionary:
	"""Remove a node from a scene from visualizer."""
	if _scene_tools_ref and _scene_tools_ref.has_method("remove_node"):
		return _scene_tools_ref.remove_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_rename_scene_node(args: Dictionary) -> Dictionary:
	"""Rename a node in a scene from visualizer."""
	if _scene_tools_ref and _scene_tools_ref.has_method("rename_node"):
		return _scene_tools_ref.rename_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_move_scene_node(args: Dictionary) -> Dictionary:
	"""Move/reorder a node in a scene from visualizer."""
	if _scene_tools_ref and _scene_tools_ref.has_method("move_node"):
		return _scene_tools_ref.move_node(args)
	return {"ok": false, "error": "Scene tools not available"}


# Simpler aliases for context menu actions
func _internal_add_node(args: Dictionary) -> Dictionary:
	"""Add a node to a scene."""
	if _scene_tools_ref and _scene_tools_ref.has_method("add_node"):
		return _scene_tools_ref.add_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_remove_node(args: Dictionary) -> Dictionary:
	"""Remove a node from a scene."""
	if _scene_tools_ref and _scene_tools_ref.has_method("remove_node"):
		return _scene_tools_ref.remove_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_rename_node(args: Dictionary) -> Dictionary:
	"""Rename a node in a scene."""
	if _scene_tools_ref and _scene_tools_ref.has_method("rename_node"):
		return _scene_tools_ref.rename_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_move_node(args: Dictionary) -> Dictionary:
	"""Move/reorder a node in a scene."""
	if _scene_tools_ref and _scene_tools_ref.has_method("move_node"):
		return _scene_tools_ref.move_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_duplicate_node(args: Dictionary) -> Dictionary:
	"""Duplicate a node in a scene."""
	if _scene_tools_ref and _scene_tools_ref.has_method("duplicate_node"):
		return _scene_tools_ref.duplicate_node(args)
	return {"ok": false, "error": "Scene tools not available"}


func _internal_reorder_node(args: Dictionary) -> Dictionary:
	"""Reorder a node within its parent (change sibling index)."""
	if _scene_tools_ref and _scene_tools_ref.has_method("reorder_node"):
		return _scene_tools_ref.reorder_node(args)
	return {"ok": false, "error": "Scene tools not available"}
</file>

<file path="godot-plugin/project.godot">
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Godot MCP Test"
config/features=PackedStringArray("4.3", "Forward Plus")

[editor_plugins]

enabled=PackedStringArray("res://addons/godot_mcp/plugin.cfg")
</file>

<file path="godot-plugin/scripts/enemy.gd">
extends CharacterBody2D
## Simple enemy that patrols back and forth

@export var patrol_speed := 100.0
@export var patrol_distance := 200.0

var _start_position: Vector2
var _direction := 1.0

func _ready() -> void:
	_start_position = global_position

func _physics_process(delta: float) -> void:
	# Move in current direction
	velocity.x = patrol_speed * _direction

	# Check if we've gone too far
	var distance_from_start := global_position.x - _start_position.x
	if abs(distance_from_start) > patrol_distance:
		_direction *= -1.0

	move_and_slide()
</file>

<file path="godot-plugin/scripts/player.gd">
extends CharacterBody2D
## Player controller script

const SPEED = 300.0
const JUMP_VELOCITY = -400.0

func _physics_process(delta: float) -> void:
	# Add gravity
	if not is_on_floor():
		velocity += get_gravity() * delta

	# Handle jump
	if Input.is_action_just_pressed("ui_accept") and is_on_floor():
		velocity.y = JUMP_VELOCITY

	# Handle movement
	var direction := Input.get_axis("ui_left", "ui_right")
	if direction:
		velocity.x = direction * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)

	move_and_slide()
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025-2026 Tomer Yud

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="mcp-server/package.json">
{
  "name": "godot-mcp-server",
  "version": "0.1.0",
  "description": "MCP server for Godot game engine integration",
  "type": "module",
  "main": "dist/index.js",
  "bin": {
    "godot-mcp-server": "./dist/index.js"
  },
  "files": [
    "dist",
    "scripts"
  ],
  "scripts": {
    "build": "tsc && node scripts/build-visualizer.js",
    "build:visualizer": "node scripts/build-visualizer.js",
    "prepare": "npm run build",
    "start": "node dist/index.js",
    "dev": "tsc && node scripts/build-visualizer.js && node dist/index.js",
    "watch": "tsc --watch"
  },
  "keywords": [
    "mcp",
    "godot",
    "game-development",
    "ai-assistant"
  ],
  "license": "MIT",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "@types/ws": "^8.5.10",
    "esbuild": "^0.20.0",
    "typescript": "^5.3.0"
  }
}
</file>

<file path="mcp-server/README.md">
# Godot MCP Server

An MCP (Model Context Protocol) server that provides Godot game engine tools to AI assistants like Claude Desktop or RAGy.

## Features

- **File Operations**: List directories, read files, search project, create scripts
- **Scene Operations** (coming soon): Create/edit scenes, add/remove nodes
- **Script Operations** (coming soon): Apply code edits, validate scripts
- **Project Tools** (coming soon): Get project settings, input map, collision layers

## Installation

```bash
cd mcp-server
npm install
npm run build
```

## Usage

### With Claude Desktop

Add to your Claude Desktop config (`~/Library/Application Support/Claude/claude_desktop_config.json`):

```json
{
  "mcpServers": {
    "godot": {
      "command": "node",
      "args": ["/Users/tomeryud/godot-mcp/mcp-server/dist/index.js"]
    }
  }
}
```

Then restart Claude Desktop.

### With RAGy

Add to RAGy's MCP client configuration (see RAGy documentation).

### Standalone Testing

Test with the MCP inspector:

```bash
npx @modelcontextprotocol/inspector node dist/index.js
```

## Development

```bash
# Watch mode (rebuild on changes)
npm run watch

# Build once
npm run build

# Run the server directly
npm start
```

## Architecture

```
mcp-server/
├── src/
│   ├── index.ts          # Main MCP server entry point
│   ├── types.ts          # TypeScript type definitions
│   ├── godot-bridge.ts   # WebSocket connection to Godot (Phase 2)
│   └── tools/
│       ├── index.ts      # Tool registry
│       ├── file-tools.ts # File operation tools
│       └── ...           # More tool categories
└── dist/                 # Compiled JavaScript
```

## Phases

1. **Phase 1 (Current)**: Mock tools - returns fake data for testing
2. **Phase 2**: WebSocket bridge - connects to Godot plugin
3. **Phase 3**: Godot plugin - executes tools in Godot editor
4. **Phase 4+**: Additional tools (scenes, scripts, etc.)

## License

MIT
</file>

<file path="mcp-server/scripts/build-visualizer.js">
#!/usr/bin/env node
/**
 * Build script for the Godot Project Map Visualizer
 * Bundles CSS and JS modules into a single HTML file
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { build } from 'esbuild';

const __dirname = dirname(fileURLToPath(import.meta.url));
const srcDir = join(__dirname, '..', 'src', 'visualizer');
const distDir = join(__dirname, '..', 'dist');

async function buildVisualizer() {
  console.log('Building visualizer...');

  // Ensure dist directory exists
  mkdirSync(distDir, { recursive: true });

  // 1. Read the HTML template
  const template = readFileSync(join(srcDir, 'template.html'), 'utf-8');

  // 2. Read the CSS
  const css = readFileSync(join(srcDir, 'visualizer.css'), 'utf-8');

  // 3. Bundle JavaScript using esbuild
  const jsResult = await build({
    entryPoints: [join(srcDir, 'main.js')],
    bundle: true,
    format: 'iife',
    minify: false, // Keep readable for debugging
    write: false,
    target: ['es2020'],
    sourcemap: false,
  });

  const bundledJs = jsResult.outputFiles[0].text;

  // 4. Combine everything into the final HTML
  let html = template
    .replace('%%CSS%%', css)
    .replace('%%SCRIPT%%', bundledJs);

  // 5. Write the output file
  const outputPath = join(distDir, 'visualizer.html');
  writeFileSync(outputPath, html, 'utf-8');

  console.log(`Visualizer built successfully: ${outputPath}`);

  // Print some stats
  const lines = html.split('\n').length;
  const size = Buffer.byteLength(html, 'utf-8');
  console.log(`  Lines: ${lines}`);
  console.log(`  Size: ${(size / 1024).toFixed(1)} KB`);
}

buildVisualizer().catch(err => {
  console.error('Build failed:', err);
  process.exit(1);
});
</file>

<file path="mcp-server/src/godot-bridge.ts">
/**
 * GodotBridge - WebSocket server for communication with Godot plugin
 *
 * Handles:
 * - WebSocket server on configurable port (default 6505)
 * - Connection management with Godot plugin
 * - Tool invocation requests and response tracking
 * - Timeouts and error handling
 * - Ping/pong keepalive
 */

import { WebSocketServer, WebSocket } from 'ws';
import { randomUUID } from 'crypto';
import type {
  ToolInvokeMessage,
  ToolResultMessage,
  WebSocketMessage
} from './types.js';

// Configuration
const DEFAULT_PORT = 6505;
const DEFAULT_TIMEOUT = 30000; // 30 seconds
const PING_INTERVAL = 10000; // 10 seconds

interface PendingRequest {
  resolve: (result: unknown) => void;
  reject: (error: Error) => void;
  timeout: NodeJS.Timeout;
  toolName: string;
  startTime: number;
}

interface GodotInfo {
  projectPath?: string;
  connectedAt: Date;
}

type ConnectionCallback = (connected: boolean, info?: GodotInfo) => void;

export class GodotBridge {
  private wss: WebSocketServer | null = null;
  private godotConnection: WebSocket | null = null;
  private godotInfo: GodotInfo | null = null;
  private pendingRequests: Map<string, PendingRequest> = new Map();
  private pingInterval: NodeJS.Timeout | null = null;
  private connectionCallbacks: Set<ConnectionCallback> = new Set();

  private port: number;
  private timeout: number;

  constructor(port: number = DEFAULT_PORT, timeout: number = DEFAULT_TIMEOUT) {
    this.port = port;
    this.timeout = timeout;
  }

  /**
   * Start the WebSocket server
   */
  start(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.wss = new WebSocketServer({ port: this.port });

        this.wss.on('connection', (ws, req) => {
          this.handleConnection(ws, req);
        });

        this.wss.on('error', (error) => {
          this.log('error', `WebSocket server error: ${error.message}`);
          reject(error);
        });

        this.wss.on('listening', () => {
          this.log('info', `WebSocket server listening on port ${this.port}`);
          resolve();
        });

      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Stop the WebSocket server
   */
  stop(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }

    // Reject all pending requests
    for (const [id, pending] of this.pendingRequests) {
      clearTimeout(pending.timeout);
      pending.reject(new Error('Server shutting down'));
    }
    this.pendingRequests.clear();

    // Close Godot connection
    if (this.godotConnection) {
      this.godotConnection.close();
      this.godotConnection = null;
    }

    // Close server
    if (this.wss) {
      this.wss.close();
      this.wss = null;
    }

    this.log('info', 'WebSocket server stopped');
  }

  /**
   * Handle new WebSocket connection
   */
  private handleConnection(ws: WebSocket, req: unknown): void {
    // Only allow one Godot connection at a time
    if (this.godotConnection) {
      this.log('warn', 'Rejecting connection - Godot already connected');
      ws.close(4000, 'Another Godot instance is already connected');
      return;
    }

    this.godotConnection = ws;
    this.godotInfo = { connectedAt: new Date() };
    this.log('info', 'Godot plugin connected');

    // Set up ping interval for keepalive
    this.pingInterval = setInterval(() => {
      if (this.godotConnection?.readyState === WebSocket.OPEN) {
        this.sendMessage({ type: 'ping' });
      }
    }, PING_INTERVAL);

    // Handle messages
    ws.on('message', (data) => {
      try {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        this.handleMessage(message);
      } catch (error) {
        this.log('error', `Failed to parse message: ${error}`);
      }
    });

    // Handle close
    ws.on('close', (code, reason) => {
      this.log('info', `Godot disconnected: ${code} - ${reason.toString()}`);
      this.handleDisconnection();
    });

    // Handle errors
    ws.on('error', (error) => {
      this.log('error', `WebSocket error: ${error.message}`);
    });

    // Notify listeners
    this.notifyConnectionChange(true);
  }

  /**
   * Handle Godot disconnection
   */
  private handleDisconnection(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }

    this.godotConnection = null;
    const info = this.godotInfo;
    this.godotInfo = null;

    // Reject all pending requests
    for (const [id, pending] of this.pendingRequests) {
      clearTimeout(pending.timeout);
      pending.reject(new Error('Godot disconnected'));
    }
    this.pendingRequests.clear();

    // Notify listeners
    this.notifyConnectionChange(false, info || undefined);
  }

  /**
   * Handle incoming WebSocket message
   */
  private handleMessage(message: WebSocketMessage): void {
    switch (message.type) {
      case 'tool_result':
        this.handleToolResult(message);
        break;

      case 'pong':
        // Keepalive response - nothing to do
        break;

      case 'godot_ready':
        if (this.godotInfo) {
          this.godotInfo.projectPath = message.project_path;
          this.log('info', `Godot project: ${message.project_path}`);
        }
        break;

      default:
        this.log('warn', `Unknown message type: ${(message as { type: string }).type}`);
    }
  }

  /**
   * Handle tool result from Godot
   */
  private handleToolResult(message: ToolResultMessage): void {
    const pending = this.pendingRequests.get(message.id);

    if (!pending) {
      this.log('warn', `Received result for unknown request: ${message.id}`);
      return;
    }

    clearTimeout(pending.timeout);
    this.pendingRequests.delete(message.id);

    const duration = Date.now() - pending.startTime;
    this.log('debug', `Tool ${pending.toolName} completed in ${duration}ms`);

    if (message.success) {
      pending.resolve(message.result);
    } else {
      pending.reject(new Error(message.error || 'Tool execution failed'));
    }
  }

  /**
   * Invoke a tool on the Godot plugin
   */
  async invokeTool(toolName: string, args: Record<string, unknown>): Promise<unknown> {
    if (!this.isConnected()) {
      throw new Error('Godot is not connected');
    }

    const id = randomUUID();
    const startTime = Date.now();

    return new Promise((resolve, reject) => {
      // Set up timeout
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(id);
        reject(new Error(`Tool ${toolName} timed out after ${this.timeout}ms`));
      }, this.timeout);

      // Store pending request
      this.pendingRequests.set(id, {
        resolve,
        reject,
        timeout,
        toolName,
        startTime
      });

      // Send invocation request
      const message: ToolInvokeMessage = {
        type: 'tool_invoke',
        id,
        tool: toolName,
        args
      };

      this.sendMessage(message);
      this.log('debug', `Invoking tool: ${toolName} (${id})`);
    });
  }

  /**
   * Send a message to Godot
   */
  private sendMessage(message: WebSocketMessage | ToolInvokeMessage): void {
    if (this.godotConnection?.readyState === WebSocket.OPEN) {
      this.godotConnection.send(JSON.stringify(message));
    }
  }

  /**
   * Check if Godot is connected
   */
  isConnected(): boolean {
    return this.godotConnection?.readyState === WebSocket.OPEN;
  }

  /**
   * Get connection status info
   */
  getStatus(): {
    connected: boolean;
    projectPath?: string;
    connectedAt?: Date;
    pendingRequests: number;
    port: number;
  } {
    return {
      connected: this.isConnected(),
      projectPath: this.godotInfo?.projectPath,
      connectedAt: this.godotInfo?.connectedAt,
      pendingRequests: this.pendingRequests.size,
      port: this.port
    };
  }

  /**
   * Register a callback for connection changes
   */
  onConnectionChange(callback: ConnectionCallback): void {
    this.connectionCallbacks.add(callback);
  }

  /**
   * Remove a connection change callback
   */
  offConnectionChange(callback: ConnectionCallback): void {
    this.connectionCallbacks.delete(callback);
  }

  /**
   * Notify all listeners of connection change
   */
  private notifyConnectionChange(connected: boolean, info?: GodotInfo): void {
    for (const callback of this.connectionCallbacks) {
      try {
        callback(connected, info);
      } catch (error) {
        this.log('error', `Connection callback error: ${error}`);
      }
    }
  }

  /**
   * Log a message (to stderr, since stdout is for MCP)
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string): void {
    const timestamp = new Date().toISOString();
    console.error(`[${timestamp}] [GodotBridge] [${level.toUpperCase()}] ${message}`);
  }
}

// Export singleton instance for convenience
let defaultBridge: GodotBridge | null = null;

export function getDefaultBridge(): GodotBridge {
  if (!defaultBridge) {
    defaultBridge = new GodotBridge();
  }
  return defaultBridge;
}

export function createBridge(port?: number, timeout?: number): GodotBridge {
  return new GodotBridge(port, timeout);
}
</file>

<file path="mcp-server/src/index.ts">
#!/usr/bin/env node
/**
 * Godot MCP Server
 *
 * An MCP server that provides Godot game engine tools to AI assistants.
 * Works with Claude Desktop, RAGy, or any MCP-compatible client.
 *
 * Architecture:
 * - MCP protocol via stdio (for AI client communication)
 * - WebSocket server on port 6505 (for Godot plugin communication)
 *
 * Modes:
 * - Mock mode: Returns fake data when Godot is not connected
 * - Live mode: Routes tool calls to Godot plugin via WebSocket
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ErrorCode,
  McpError
} from '@modelcontextprotocol/sdk/types.js';

import { allTools, getMockToolResponse, toolExists } from './tools/index.js';
import { GodotBridge } from './godot-bridge.js';
import { serveVisualization, stopVisualizationServer, setGodotBridge } from './visualizer-server.js';

// Server metadata
const SERVER_NAME = 'godot-mcp-server';
const SERVER_VERSION = '0.2.0';
const WEBSOCKET_PORT = 6505;

// Create MCP server
const server = new Server(
  { name: SERVER_NAME, version: SERVER_VERSION },
  { capabilities: { tools: {} } }
);

// Create Godot bridge (WebSocket server)
const godotBridge = new GodotBridge(WEBSOCKET_PORT);

// Set the bridge reference for the visualizer server
setGodotBridge(godotBridge);

// Log connection changes
godotBridge.onConnectionChange((connected, info) => {
  if (connected) {
    console.error(`[${SERVER_NAME}] Godot connected`);
  } else {
    console.error(`[${SERVER_NAME}] Godot disconnected`);
  }
});

/**
 * Handle ListTools request - returns all available tools
 */
server.setRequestHandler(ListToolsRequestSchema, async () => {
  // Add connection status tool dynamically
  const connectionStatusTool = {
    name: 'get_godot_status',
    description: 'Check if Godot editor is connected to the MCP server. Use this before attempting Godot operations to see if you\'ll get real or mock data.',
    inputSchema: {
      type: 'object' as const,
      properties: {},
      required: []
    }
  };

  return {
    tools: [
      connectionStatusTool,
      ...allTools.map(tool => ({
        name: tool.name,
        description: tool.description,
        inputSchema: tool.inputSchema
      }))
    ]
  };
});

/**
 * Handle CallTool request - executes a tool
 */
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  const toolArgs = (args || {}) as Record<string, unknown>;

  // Handle connection status check
  if (name === 'get_godot_status') {
    const status = godotBridge.getStatus();
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          connected: status.connected,
          server_version: SERVER_VERSION,
          websocket_port: status.port,
          mode: status.connected ? 'live' : 'mock',
          project_path: status.projectPath || null,
          connected_at: status.connectedAt?.toISOString() || null,
          pending_requests: status.pendingRequests,
          message: status.connected
            ? `Godot is connected${status.projectPath ? ` (${status.projectPath})` : ''}. Tools will execute in the Godot editor.`
            : 'Godot is not connected. Tools will return mock data. Open a Godot project with the MCP plugin enabled to connect.'
        }, null, 2)
      }]
    };
  }

  // Validate tool exists
  if (!toolExists(name)) {
    throw new McpError(
      ErrorCode.MethodNotFound,
      `Unknown tool: ${name}. Available tools: ${allTools.map(t => t.name).join(', ')}`
    );
  }

  try {
    let result: unknown;

    if (godotBridge.isConnected()) {
      // Live mode: Route to Godot via WebSocket
      try {
        result = await godotBridge.invokeTool(name, toolArgs);
      } catch (error) {
        // If Godot call fails, return error (don't fall back to mock)
        const errorMessage = error instanceof Error ? error.message : String(error);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify({
              error: errorMessage,
              tool: name,
              args: toolArgs,
              mode: 'live',
              hint: 'The tool call was sent to Godot but failed. Check Godot editor for details.'
            }, null, 2)
          }],
          isError: true
        };
      }
    } else {
      // Mock mode: Return fake data
      result = getMockToolResponse(name, toolArgs);
    }

    // Post-processing for visualization tools
    if (name === 'map_project' && result && typeof result === 'object' && 'project_map' in (result as Record<string, unknown>)) {
      try {
        const projectMap = (result as Record<string, unknown>).project_map;
        const url = await serveVisualization(projectMap);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify({
              ...(result as Record<string, unknown>),
              visualization_url: url,
              message: `Project mapped: ${(projectMap as any).total_scripts} scripts, ${(projectMap as any).total_connections} connections. Interactive visualization opened in browser at ${url}`
            }, null, 2)
          }]
        };
      } catch (vizError) {
        // If visualization fails, still return the data
        console.error(`[${SERVER_NAME}] Visualization failed:`, vizError);
      }
    }

    return {
      content: [{
        type: 'text',
        text: JSON.stringify(result, null, 2)
      }]
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: errorMessage,
          tool: name,
          args: toolArgs
        }, null, 2)
      }],
      isError: true
    };
  }
});

/**
 * Start the MCP server and WebSocket bridge
 */
async function main() {
  // Log to stderr (stdout is reserved for MCP protocol)
  console.error(`[${SERVER_NAME}] Starting MCP server v${SERVER_VERSION}...`);

  // Start WebSocket server for Godot communication
  try {
    await godotBridge.start();
    console.error(`[${SERVER_NAME}] WebSocket server listening on port ${WEBSOCKET_PORT}`);
  } catch (error) {
    console.error(`[${SERVER_NAME}] Failed to start WebSocket server:`, error);
    console.error(`[${SERVER_NAME}] Continuing in mock-only mode`);
  }

  console.error(`[${SERVER_NAME}] Available tools: ${allTools.length + 1}`);
  console.error(`[${SERVER_NAME}] Mode: mock (waiting for Godot connection)`);

  // Start MCP server (stdio transport)
  const transport = new StdioServerTransport();
  await server.connect(transport);

  console.error(`[${SERVER_NAME}] MCP server connected and ready`);
}

// Handle graceful shutdown
function shutdown() {
  console.error(`[${SERVER_NAME}] Shutting down...`);
  stopVisualizationServer();
  godotBridge.stop();
  process.exit(0);
}

process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);

// Run
main().catch((error) => {
  console.error(`[${SERVER_NAME}] Fatal error:`, error);
  process.exit(1);
});
</file>

<file path="mcp-server/src/tools/asset-tools.ts">
/**
 * Asset generation tools for Godot MCP Server
 * Tools for generating 2D assets via SVG and ComfyUI/RunningHub workflows
 */

import type { ToolDefinition } from '../types.js';

export const assetTools: ToolDefinition[] = [
  {
    name: 'generate_2d_asset',
    description: 'Generate a 2D sprite/texture from SVG code and save as PNG. Use for custom visuals (characters, objects, backgrounds, UI). Returns resource_path and dimensions.',
    inputSchema: {
      type: 'object',
      properties: {
        svg_code: {
          type: 'string',
          description: 'Complete SVG code string with <svg> tags including width/height.'
        },
        filename: {
          type: 'string',
          description: 'Filename for the asset (saved as .png). Example: "player_sprite.png"'
        },
        save_path: {
          type: 'string',
          description: 'Godot resource path to save (default: res://assets/generated/)'
        }
      },
      required: ['svg_code', 'filename']
    }
  },
  {
    name: 'search_comfyui_nodes',
    description: 'Search the ComfyUI node library (10,514+ nodes) to discover nodes for building custom workflows.',
    inputSchema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Search keyword - searches node names and descriptions'
        },
        category: {
          type: 'string',
          description: 'Filter by category: loaders, samplers, conditioning, latent, image, output, mask, video, utilities'
        },
        limit: {
          type: 'number',
          description: 'Maximum results to return (default: 20, max: 100)'
        }
      }
    }
  },
  {
    name: 'inspect_runninghub_workflow',
    description: 'Inspect a RunningHub workflow to discover customizable parameters before execution. ALWAYS use before customize_and_run_workflow.',
    inputSchema: {
      type: 'object',
      properties: {
        workflow_id: {
          type: 'string',
          description: 'RunningHub workflow ID from the URL'
        }
      },
      required: ['workflow_id']
    }
  },
  {
    name: 'customize_and_run_workflow',
    description: 'Run a RunningHub workflow to generate assets. Inspect first, then customize node_inputs to control generation.',
    inputSchema: {
      type: 'object',
      properties: {
        workflow_id: {
          type: 'object',
          description: 'String workflow ID or complete custom workflow JSON object'
        },
        node_inputs: {
          type: 'array',
          description: 'Array of customizations: [{nodeId, fieldName, fieldValue}]. MANDATORY - controls what gets generated.'
        },
        save_path: {
          type: 'string',
          description: 'Where to save the generated PNG (default: res://assets/runninghub/)'
        },
        filename: {
          type: 'string',
          description: 'Optional PNG filename'
        }
      },
      required: ['workflow_id', 'node_inputs']
    }
  }
];

export function getMockAssetToolResponse(toolName: string, args: Record<string, unknown>): unknown {
  const mockNote = { _mock: true, _note: 'Connect Godot for real results.' };

  switch (toolName) {
    case 'generate_2d_asset':
      return { ok: true, resource_path: `res://assets/generated/${args.filename}`, dimensions: { width: 64, height: 64 }, ...mockNote };
    case 'search_comfyui_nodes':
      return { ok: true, results: [], count: 0, message: 'Mock: ComfyUI search requires Godot connection', ...mockNote };
    case 'inspect_runninghub_workflow':
      return { ok: true, workflow_id: args.workflow_id, nodes: [], message: 'Mock: Workflow inspection requires Godot connection', ...mockNote };
    case 'customize_and_run_workflow':
      return { ok: true, message: 'Mock: Workflow execution requires Godot connection', ...mockNote };
    default:
      return { error: `Unknown asset tool: ${toolName}`, ...mockNote };
  }
}
</file>

<file path="mcp-server/src/tools/file-tools.ts">
/**
 * File operation tools for Godot MCP Server
 * MVP tools: list_dir, read_file, search_project, create_script
 */

import type { ToolDefinition } from '../types.js';

export const fileTools: ToolDefinition[] = [
  {
    name: 'list_dir',
    description: 'List files and folders under a Godot project path (e.g., res://). Returns arrays of files and folders in the specified directory.',
    inputSchema: {
      type: 'object',
      properties: {
        root: {
          type: 'string',
          description: 'Starting path like res://addons/ai_assistant or res://'
        }
      },
      required: ['root']
    }
  },
  {
    name: 'read_file',
    description: 'Read a text file from the Godot project, optionally a specific line range. Useful for reading GDScript files, scene files, or any text-based content.',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'res:// path to the file (e.g., res://scripts/player.gd)'
        },
        start_line: {
          type: 'number',
          description: '1-based inclusive start line (optional)'
        },
        end_line: {
          type: 'number',
          description: 'Inclusive end line; 0 or missing means to end of file (optional)'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'search_project',
    description: 'Search the Godot project for a substring and return file hits with line numbers. Useful for finding usages of functions, variables, or any text pattern.',
    inputSchema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Case-insensitive substring to find'
        },
        glob: {
          type: 'string',
          description: 'Optional glob filter like **/*.gd to search only GDScript files'
        }
      },
      required: ['query']
    }
  },
  {
    name: 'create_script',
    description: 'Create a NEW GDScript file (.gd) that does not exist yet. Use this for creating new scripts, NOT for editing existing files (use apply_diff_preview for edits).',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Script file path (res://scripts/player.gd) - must not exist yet'
        },
        content: {
          type: 'string',
          description: 'Full GDScript content to write to the file'
        }
      },
      required: ['path', 'content']
    }
  }
];

/**
 * Get mock responses for file tools (Phase 1 - before Godot connection)
 */
export function getMockFileToolResponse(toolName: string, args: Record<string, unknown>): unknown {
  switch (toolName) {
    case 'list_dir':
      return {
        path: args.root || 'res://',
        files: ['project.godot', 'icon.svg', 'default_env.tres'],
        folders: ['scenes', 'scripts', 'assets', 'addons'],
        _mock: true,
        _note: 'This is mock data. Connect Godot for real results.'
      };

    case 'read_file':
      return {
        path: args.path,
        content: `# Mock file content for ${args.path}\n# Connect Godot to read actual file contents\nextends Node\n\nfunc _ready():\n    print("Hello from mock!")`,
        line_count: 5,
        _mock: true
      };

    case 'search_project':
      return {
        query: args.query,
        matches: [
          { file: 'res://scripts/player.gd', line: 10, content: `    # Mock match for "${args.query}"` },
          { file: 'res://scripts/enemy.gd', line: 25, content: `    # Another mock match for "${args.query}"` }
        ],
        total_matches: 2,
        _mock: true
      };

    case 'create_script':
      return {
        success: true,
        path: args.path,
        message: `Mock: Would create script at ${args.path}. Connect Godot to actually create the file.`,
        _mock: true
      };

    default:
      return {
        error: `Unknown file tool: ${toolName}`,
        _mock: true
      };
  }
}
</file>

<file path="mcp-server/src/tools/index.ts">
/**
 * Tool registry - exports all tool definitions and handlers
 */

import { fileTools, getMockFileToolResponse } from './file-tools.js';
import { sceneTools, getMockSceneToolResponse } from './scene-tools.js';
import { scriptTools, getMockScriptToolResponse } from './script-tools.js';
import { projectTools, getMockProjectToolResponse } from './project-tools.js';
import { assetTools, getMockAssetToolResponse } from './asset-tools.js';
import { visualizerTools, getMockVisualizerToolResponse } from './visualizer-tools.js';
import type { ToolDefinition } from '../types.js';

// Export all tool definitions
export const allTools: ToolDefinition[] = [
  ...fileTools,
  ...sceneTools,
  ...scriptTools,
  ...projectTools,
  ...assetTools,
  ...visualizerTools,
];

// Tool name sets for categorization and routing
export const fileToolNames = new Set(fileTools.map(t => t.name));
export const sceneToolNames = new Set(sceneTools.map(t => t.name));
export const scriptToolNames = new Set(scriptTools.map(t => t.name));
export const projectToolNames = new Set(projectTools.map(t => t.name));
export const assetToolNames = new Set(assetTools.map(t => t.name));
export const visualizerToolNames = new Set(visualizerTools.map(t => t.name));

/**
 * Get mock response for any tool (when Godot is not connected)
 */
export function getMockToolResponse(toolName: string, args: Record<string, unknown>): unknown {
  if (fileToolNames.has(toolName)) return getMockFileToolResponse(toolName, args);
  if (sceneToolNames.has(toolName)) return getMockSceneToolResponse(toolName, args);
  if (scriptToolNames.has(toolName)) return getMockScriptToolResponse(toolName, args);
  if (projectToolNames.has(toolName)) return getMockProjectToolResponse(toolName, args);
  if (assetToolNames.has(toolName)) return getMockAssetToolResponse(toolName, args);
  if (visualizerToolNames.has(toolName)) return getMockVisualizerToolResponse(toolName, args);

  return { error: `Unknown tool: ${toolName}`, available_tools: allTools.map(t => t.name) };
}

/**
 * Check if a tool exists
 */
export function toolExists(toolName: string): boolean {
  return allTools.some(t => t.name === toolName);
}
</file>

<file path="mcp-server/src/tools/project-tools.ts">
/**
 * Project configuration and debug tools for Godot MCP Server
 * Tools for inspecting project settings, debugging, and editor interaction
 */

import type { ToolDefinition } from '../types.js';

export const projectTools: ToolDefinition[] = [
  {
    name: 'get_project_settings',
    description: 'Concise project settings summary: main_scene, window size/stretch, physics tick rate, and render basics.',
    inputSchema: {
      type: 'object',
      properties: {
        include_render: {
          type: 'boolean',
          description: 'Include render settings'
        },
        include_physics: {
          type: 'boolean',
          description: 'Include physics settings'
        }
      }
    }
  },
  {
    name: 'get_input_map',
    description: 'Return the InputMap: action names mapped to events (keys, mouse, gamepad).',
    inputSchema: {
      type: 'object',
      properties: {
        include_deadzones: {
          type: 'boolean',
          description: 'Include axis values/deadzones for joypad motion'
        }
      }
    }
  },
  {
    name: 'get_collision_layers',
    description: 'Return named 2D/3D physics collision layers from ProjectSettings.',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  },
  {
    name: 'get_node_properties',
    description: 'Get available properties for a Godot node type. Use this to discover what properties exist on a node type (e.g., anchors_preset for Control, position for Node2D).',
    inputSchema: {
      type: 'object',
      properties: {
        node_type: {
          type: 'string',
          description: 'Node class name (e.g., "Sprite2D", "Control", "Label", "Button")'
        }
      },
      required: ['node_type']
    }
  },
  {
    name: 'get_console_log',
    description: 'Return the latest lines from the Godot editor output log.',
    inputSchema: {
      type: 'object',
      properties: {
        max_lines: {
          type: 'number',
          description: 'Maximum number of lines to include (default: 50)'
        }
      }
    }
  },
  {
    name: 'get_errors',
    description: 'Get ONLY errors from the Godot console with file paths and line numbers. More reliable than get_console_log for finding errors.',
    inputSchema: {
      type: 'object',
      properties: {
        max_errors: {
          type: 'number',
          description: 'Maximum number of errors to return (default: 50)'
        }
      }
    }
  },
  {
    name: 'clear_console_log',
    description: 'Clear the persisted Godot editor output log.',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  },
  {
    name: 'open_in_godot',
    description: 'Open a file in the Godot editor at a specific line (side-effect only).',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'res:// path to open'
        },
        line: {
          type: 'number',
          description: '1-based line number'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'scene_tree_dump',
    description: 'Dump the current running scene tree (names and structure).',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  }
];

export function getMockProjectToolResponse(toolName: string, args: Record<string, unknown>): unknown {
  const mockNote = { _mock: true, _note: 'Connect Godot for real results.' };

  switch (toolName) {
    case 'get_project_settings':
      return { ok: true, settings: { main_scene: 'res://scenes/main.tscn', window: { width: 1152, height: 648 } }, ...mockNote };
    case 'get_input_map':
      return { ok: true, actions: { ui_accept: ['Enter', 'Space'], ui_cancel: ['Escape'], move_left: ['A', 'Left'] }, ...mockNote };
    case 'get_collision_layers':
      return { ok: true, layers_2d: { 1: 'Player', 2: 'Enemies', 3: 'World' }, ...mockNote };
    case 'get_node_properties':
      return { ok: true, node_type: args.node_type, properties: ['position', 'rotation', 'scale', 'visible', 'modulate'], ...mockNote };
    case 'get_console_log':
      return { ok: true, lines: ['[Godot] Project loaded', '[Godot] Scene ready'], ...mockNote };
    case 'get_errors':
      return { ok: true, errors: [], count: 0, ...mockNote };
    case 'clear_console_log':
      return { ok: true, message: 'Mock: Console would be cleared', ...mockNote };
    case 'open_in_godot':
      return { ok: true, message: `Mock: Would open ${args.path} at line ${args.line || 1}`, ...mockNote };
    case 'scene_tree_dump':
      return { ok: true, tree: 'Root (Node2D)\n  Player (CharacterBody2D)\n    Sprite2D\n    CollisionShape2D', ...mockNote };
    default:
      return { error: `Unknown project tool: ${toolName}`, ...mockNote };
  }
}
</file>

<file path="mcp-server/src/tools/scene-tools.ts">
/**
 * Scene operation tools for Godot MCP Server
 * Tools for creating, reading, and modifying Godot scenes (.tscn files)
 */

import type { ToolDefinition } from '../types.js';

export const sceneTools: ToolDefinition[] = [
  {
    name: 'create_scene',
    description: 'Create a new Godot scene (.tscn) file with nodes. Use this to create player scenes, UI screens, game objects, etc.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Scene file path (e.g., res://Scenes/player.tscn)'
        },
        root_node_name: {
          type: 'string',
          description: 'Name of root node (default: derived from filename)'
        },
        root_node_type: {
          type: 'string',
          description: 'Type of root node (e.g., Node2D, CharacterBody2D, Control, Node3D). REQUIRED.'
        },
        nodes: {
          type: 'array',
          description: 'Array of child nodes to add. Each node: {name, type, properties, script, children}.'
        },
        attach_script: {
          type: 'string',
          description: 'Optional script path to attach to root node (res://path/to/script.gd)'
        }
      },
      required: ['scene_path', 'root_node_type']
    }
  },
  {
    name: 'read_scene',
    description: 'Read and parse a scene file to get its full node structure and properties. Use this to understand a scene before editing.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the scene file (res://path/to/scene.tscn)'
        },
        include_properties: {
          type: 'boolean',
          description: 'Include node properties in the output (default: false)'
        }
      },
      required: ['scene_path']
    }
  },
  {
    name: 'add_node',
    description: 'Add a single node to an existing scene file.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the scene file (res://path/to/scene.tscn)'
        },
        node_name: {
          type: 'string',
          description: 'Name for the new node'
        },
        node_type: {
          type: 'string',
          description: 'Type of node (e.g., Sprite2D, Camera2D, RigidBody2D, CollisionShape2D)'
        },
        parent_path: {
          type: 'string',
          description: 'Path to parent node (. for root, or relative path like Sprite2D)'
        },
        properties: {
          type: 'object',
          description: 'Optional dictionary of properties to set on the node'
        }
      },
      required: ['scene_path', 'node_name', 'node_type']
    }
  },
  {
    name: 'remove_node',
    description: 'Remove a node from an existing scene file.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the node to remove (cannot be root, use relative path)'
        }
      },
      required: ['scene_path', 'node_path']
    }
  },
  {
    name: 'modify_node_property',
    description: 'Modify a property on a node in a .tscn scene file. ALWAYS use this tool to modify properties in scene files - NEVER edit .tscn files directly. Use this to change positions, colors, sizes, visibility, etc.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the .tscn scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the node (. for root, or relative path like "Sprite2D")'
        },
        property_name: {
          type: 'string',
          description: 'Name of the property to modify (position, scale, rotation, modulate, visible, etc.)'
        },
        value: {
          type: 'object',
          description: 'New value. For Vector2/Vector3/Color, use {type: "Vector2", x: 100, y: 200}. For primitives, use directly.'
        }
      },
      required: ['scene_path', 'property_name', 'value']
    }
  },
  {
    name: 'rename_node',
    description: 'Rename a node in a scene.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the node to rename'
        },
        new_name: {
          type: 'string',
          description: 'New name for the node'
        }
      },
      required: ['scene_path', 'node_path', 'new_name']
    }
  },
  {
    name: 'move_node',
    description: 'Move a node to a different parent in a scene and optionally control its position among siblings.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the node to move'
        },
        new_parent_path: {
          type: 'string',
          description: 'Path to the new parent node (. for root)'
        },
        sibling_index: {
          type: 'number',
          description: 'Optional position among siblings (0 = first child). Omit or -1 to append.'
        }
      },
      required: ['scene_path', 'node_path', 'new_parent_path']
    }
  },
  {
    name: 'attach_script',
    description: 'Attach or change a script on a node in a scene.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the node (. for root, or relative path)'
        },
        script_path: {
          type: 'string',
          description: 'Path to the script file (res://path/to/script.gd)'
        }
      },
      required: ['scene_path', 'script_path']
    }
  },
  {
    name: 'detach_script',
    description: 'Remove a script from a node in a scene.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the node (. for root)'
        }
      },
      required: ['scene_path', 'node_path']
    }
  },
  {
    name: 'set_collision_shape',
    description: 'Create and assign a collision shape resource to a CollisionShape2D or CollisionShape3D node. Supports: CircleShape2D, RectangleShape2D, CapsuleShape2D, SphereShape3D, BoxShape3D, etc.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the .tscn scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the CollisionShape2D/3D node'
        },
        shape_type: {
          type: 'string',
          description: 'Shape type: CircleShape2D, RectangleShape2D, CapsuleShape2D, SphereShape3D, BoxShape3D, etc.'
        },
        shape_params: {
          type: 'object',
          description: 'Shape parameters: {radius: 32} for circles, {size: {x: 64, y: 64}} for rectangles, etc.'
        }
      },
      required: ['scene_path', 'shape_type']
    }
  },
  {
    name: 'set_sprite_texture',
    description: 'Assign a texture to a Sprite2D/Sprite3D/TextureRect node. Use after generate_2d_asset or to load existing images.',
    inputSchema: {
      type: 'object',
      properties: {
        scene_path: {
          type: 'string',
          description: 'Path to the .tscn scene file'
        },
        node_path: {
          type: 'string',
          description: 'Path to the Sprite2D/Sprite3D/TextureRect node'
        },
        texture_type: {
          type: 'string',
          description: 'Texture type: "ImageTexture", "PlaceholderTexture2D", "GradientTexture2D", "NoiseTexture2D"'
        },
        texture_params: {
          type: 'object',
          description: 'Texture parameters. ImageTexture: {path: "res://assets/sprite.png"}. PlaceholderTexture2D: {size: {x: 64, y: 64}}.'
        }
      },
      required: ['scene_path', 'texture_type']
    }
  }
];

export function getMockSceneToolResponse(toolName: string, args: Record<string, unknown>): unknown {
  const mockNote = { _mock: true, _note: 'Connect Godot for real results.' };

  switch (toolName) {
    case 'create_scene':
      return { ok: true, scene_path: args.scene_path, message: 'Mock: Scene would be created', ...mockNote };
    case 'read_scene':
      return { ok: true, scene_path: args.scene_path, root: { name: 'Root', type: 'Node2D', children: [{ name: 'Sprite2D', type: 'Sprite2D' }] }, ...mockNote };
    case 'add_node':
      return { ok: true, message: `Mock: Would add ${args.node_type} named ${args.node_name}`, ...mockNote };
    case 'remove_node':
      return { ok: true, message: `Mock: Would remove node at ${args.node_path}`, ...mockNote };
    case 'modify_node_property':
      return { ok: true, message: `Mock: Would set ${args.property_name} on ${args.node_path}`, ...mockNote };
    case 'rename_node':
      return { ok: true, message: `Mock: Would rename ${args.node_path} to ${args.new_name}`, ...mockNote };
    case 'move_node':
      return { ok: true, message: `Mock: Would move ${args.node_path} to ${args.new_parent_path}`, ...mockNote };
    case 'attach_script':
      return { ok: true, message: `Mock: Would attach ${args.script_path}`, ...mockNote };
    case 'detach_script':
      return { ok: true, message: `Mock: Would detach script from ${args.node_path}`, ...mockNote };
    case 'set_collision_shape':
      return { ok: true, message: `Mock: Would set ${args.shape_type} shape`, ...mockNote };
    case 'set_sprite_texture':
      return { ok: true, message: `Mock: Would set ${args.texture_type} texture`, ...mockNote };
    default:
      return { error: `Unknown scene tool: ${toolName}`, ...mockNote };
  }
}
</file>

<file path="mcp-server/src/tools/script-tools.ts">
/**
 * Script and file management tools for Godot MCP Server
 * Tools for editing scripts, managing files, and validating code
 */

import type { ToolDefinition } from '../types.js';

export const scriptTools: ToolDefinition[] = [
  {
    name: 'apply_diff_preview',
    description: 'Apply a SMALL, SURGICAL code edit (1-10 lines) to GDScript files. Auto-applies changes. For large changes, call multiple times. ONLY for .gd files - NEVER for .tscn scene files.',
    inputSchema: {
      type: 'object',
      properties: {
        edit: {
          type: 'object',
          description: 'Edit spec: {type: "snippet_replace", file: "res://path.gd", old_snippet: "old code", new_snippet: "new code", context_before: "line above", context_after: "line below"}. Keep old_snippet SMALL (1-10 lines).'
        }
      },
      required: ['edit']
    }
  },
  {
    name: 'validate_script',
    description: 'Validate a GDScript file for syntax errors using Godot\'s built-in parser. Call after creating or modifying scripts to ensure they are error-free.',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the GDScript file to validate (e.g., res://scripts/player.gd)'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'create_folder',
    description: 'Create a directory (with parent directories if needed).',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Directory path (res://path/to/folder)'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'delete_file',
    description: 'Delete a file permanently. ONLY use when explicitly requested. NEVER use to "edit" a file.',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'File to delete'
        },
        confirm: {
          type: 'boolean',
          description: 'Must be true to proceed'
        },
        create_backup: {
          type: 'boolean',
          description: 'Create backup before deleting (default: true)'
        }
      },
      required: ['path', 'confirm']
    }
  },
  {
    name: 'rename_file',
    description: 'Rename or move a file, optionally updating references in other files.',
    inputSchema: {
      type: 'object',
      properties: {
        old_path: {
          type: 'string',
          description: 'Current file path'
        },
        new_path: {
          type: 'string',
          description: 'New file path'
        },
        update_references: {
          type: 'boolean',
          description: 'Update references in other files (default: true)'
        }
      },
      required: ['old_path', 'new_path']
    }
  },
  {
    name: 'list_scripts',
    description: 'List all GDScript files in the project with basic metadata.',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  }
];

export function getMockScriptToolResponse(toolName: string, args: Record<string, unknown>): unknown {
  const mockNote = { _mock: true, _note: 'Connect Godot for real results.' };

  switch (toolName) {
    case 'apply_diff_preview':
      return { ok: true, message: 'Mock: Diff would be applied', ...mockNote };
    case 'validate_script':
      return { ok: true, path: args.path, valid: true, errors: [], ...mockNote };
    case 'create_folder':
      return { ok: true, path: args.path, message: 'Mock: Folder would be created', ...mockNote };
    case 'delete_file':
      return { ok: true, path: args.path, message: 'Mock: File would be deleted', ...mockNote };
    case 'rename_file':
      return { ok: true, old_path: args.old_path, new_path: args.new_path, message: 'Mock: File would be renamed', ...mockNote };
    case 'list_scripts':
      return { ok: true, scripts: ['res://scripts/player.gd', 'res://scripts/enemy.gd'], count: 2, ...mockNote };
    default:
      return { error: `Unknown script tool: ${toolName}`, ...mockNote };
  }
}
</file>

<file path="mcp-server/src/tools/visualizer-tools.ts">
/**
 * Visualizer tools - project mapping and visualization
 */

import type { ToolDefinition } from '../types.js';

export const visualizerTools: ToolDefinition[] = [
  {
    name: 'map_project',
    description: 'Crawl the entire Godot project and build an interactive visual map of all scripts showing their structure (variables, functions, signals), connections (extends, preloads, signal connections), and descriptions. Opens an interactive browser-based visualization.',
    inputSchema: {
      type: 'object',
      properties: {
        root: {
          type: 'string',
          description: 'Root path to start crawling from (default: res://)'
        },
        include_addons: {
          type: 'boolean',
          description: 'Whether to include scripts in the addons/ folder (default: false)'
        }
      },
      required: []
    }
  }
];

export function getMockVisualizerToolResponse(toolName: string, _args: Record<string, unknown>): unknown {
  if (toolName === 'map_project') {
    return {
      project_map: {
        nodes: [
          {
            path: 'res://scripts/player.gd',
            filename: 'player.gd',
            folder: 'res://scripts',
            class_name: 'Player',
            extends: 'CharacterBody2D',
            description: 'Handles player movement and input',
            line_count: 85,
            variables: [
              { name: 'speed', exported: true },
              { name: 'jump_force', exported: true },
              { name: '_velocity', exported: false }
            ],
            functions: [
              { name: '_ready', params: '' },
              { name: '_physics_process', params: 'delta: float' },
              { name: 'take_damage', params: 'amount: float' }
            ],
            signals: ['health_changed', 'died'],
            preloads: ['res://scenes/bullet.tscn'],
            connections: []
          },
          {
            path: 'res://scripts/enemy.gd',
            filename: 'enemy.gd',
            folder: 'res://scripts',
            class_name: 'Enemy',
            extends: 'CharacterBody2D',
            description: 'Base enemy AI with patrol and chase behavior',
            line_count: 120,
            variables: [
              { name: 'patrol_speed', exported: true },
              { name: 'chase_speed', exported: true }
            ],
            functions: [
              { name: '_ready', params: '' },
              { name: '_physics_process', params: 'delta: float' },
              { name: '_on_detection_area_entered', params: 'body: Node2D' }
            ],
            signals: ['enemy_defeated'],
            preloads: [],
            connections: [{ signal: 'body_entered', line: 15 }]
          }
        ],
        edges: [
          { from: 'res://scripts/player.gd', to: 'res://scenes/bullet.tscn', type: 'preload' }
        ],
        total_scripts: 2,
        total_connections: 1
      },
      message: 'Mock project map generated. Connect Godot for real data.'
    };
  }
  return { error: `Unknown visualizer tool: ${toolName}` };
}
</file>

<file path="mcp-server/src/types.ts">
/**
 * Type definitions for the Godot MCP Server
 */

// Tool definition for MCP
export interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, PropertySchema>;
    required?: string[];
  };
}

export interface PropertySchema {
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
  description: string;
  default?: unknown;
  enum?: string[];
  items?: PropertySchema;
}

// WebSocket message types (for Phase 2)
export interface ToolInvokeMessage {
  type: 'tool_invoke';
  id: string;
  tool: string;
  args: Record<string, unknown>;
}

export interface ToolResultMessage {
  type: 'tool_result';
  id: string;
  success: boolean;
  result?: unknown;
  error?: string;
}

export interface PingMessage {
  type: 'ping';
}

export interface PongMessage {
  type: 'pong';
}

export interface GodotReadyMessage {
  type: 'godot_ready';
  project_path: string;
}

export type WebSocketMessage =
  | ToolInvokeMessage
  | ToolResultMessage
  | PingMessage
  | PongMessage
  | GodotReadyMessage;

// Tool result types
export interface ListDirResult {
  files: string[];
  folders: string[];
  path: string;
}

export interface ReadFileResult {
  content: string;
  path: string;
  line_count: number;
}

export interface SearchProjectResult {
  matches: Array<{
    file: string;
    line: number;
    content: string;
  }>;
  query: string;
  total_matches: number;
}

export interface CreateScriptResult {
  success: boolean;
  path: string;
  message: string;
}
</file>

<file path="mcp-server/src/visualizer-server.ts">
/**
 * HTTP + WebSocket server for the project visualization.
 * - Serves HTML template with injected project data
 * - WebSocket for real-time edits (internal, not exposed as MCP tools)
 */

import http from 'node:http';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { exec } from 'node:child_process';
import { WebSocketServer, WebSocket } from 'ws';
import type { GodotBridge } from './godot-bridge.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

let vizServer: http.Server | null = null;
let wss: WebSocketServer | null = null;
let godotBridge: GodotBridge | null = null;
const DEFAULT_PORT = 6510;

/**
 * Set the Godot bridge reference for internal commands.
 */
export function setGodotBridge(bridge: GodotBridge): void {
  godotBridge = bridge;
}

/**
 * Serve the visualization and open the browser.
 * Returns the URL where it's hosted.
 */
export async function serveVisualization(projectData: unknown): Promise<string> {
  // Close previous instance if running
  if (vizServer) {
    if (wss) {
      wss.close();
      wss = null;
    }
    vizServer.close();
    vizServer = null;
  }

  // Read HTML template
  const htmlPath = path.join(__dirname, 'visualizer.html');
  let html: string;
  try {
    html = fs.readFileSync(htmlPath, 'utf-8');
  } catch {
    throw new Error(`Visualizer HTML template not found at ${htmlPath}`);
  }

  // Inject project data
  const dataJson = JSON.stringify(projectData);
  html = html.replace('"%%PROJECT_DATA%%"', dataJson);

  // Find available port
  const port = await findPort(DEFAULT_PORT);

  // Start server
  return new Promise((resolve, reject) => {
    vizServer = http.createServer((_req, res) => {
      res.writeHead(200, {
        'Content-Type': 'text/html; charset=utf-8',
        'Cache-Control': 'no-cache'
      });
      res.end(html);
    });

    // Add WebSocket server for real-time edits
    wss = new WebSocketServer({ server: vizServer });
    wss.on('connection', handleVisualizerConnection);

    vizServer.on('error', (err) => {
      reject(new Error(`Failed to start visualizer server: ${err.message}`));
    });

    vizServer.listen(port, () => {
      const url = `http://localhost:${port}`;
      console.error(`[visualizer] Serving at ${url}`);
      openBrowser(url);
      resolve(url);
    });
  });
}

/**
 * Handle WebSocket connection from the visualizer.
 * Forwards internal commands to Godot.
 */
function handleVisualizerConnection(ws: WebSocket): void {
  console.error('[visualizer] Browser connected via WebSocket');

  ws.on('message', async (data) => {
    try {
      const message = JSON.parse(data.toString());
      const result = await handleInternalCommand(message);
      ws.send(JSON.stringify({ id: message.id, ...result }));
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : 'Unknown error';
      ws.send(JSON.stringify({ error: errMsg }));
    }
  });

  ws.on('close', () => {
    console.error('[visualizer] Browser disconnected');
  });
}

/**
 * Handle internal commands from the visualizer.
 * These are NOT exposed as MCP tools - they're internal only.
 */
async function handleInternalCommand(message: {
  id?: string;
  command: string;
  args: Record<string, unknown>;
}): Promise<{ ok: boolean; error?: string; [key: string]: unknown }> {
  const { command, args } = message;

  if (!godotBridge) {
    return { ok: false, error: 'Bridge not initialized' };
  }

  if (!godotBridge.isConnected()) {
    return { ok: false, error: 'Godot is not connected' };
  }

  console.error(`[visualizer] Internal command: ${command}`);

  try {
    // Forward to Godot's internal functions via tool invocation
    // The tool name prefix "_internal_" ensures these aren't exposed as MCP tools
    const result = await godotBridge.invokeTool(`visualizer._internal_${command}`, args);
    // Add ok: true since the Godot plugin strips it from the response
    return { ok: true, ...(result as Record<string, unknown>) };
  } catch (error) {
    const errMsg = error instanceof Error ? error.message : 'Unknown error';
    return { ok: false, error: errMsg };
  }
}

/**
 * Stop the visualization server if running.
 */
export function stopVisualizationServer(): void {
  if (wss) {
    wss.close();
    wss = null;
  }
  if (vizServer) {
    vizServer.close();
    vizServer = null;
    console.error('[visualizer] Server stopped');
  }
}

function findPort(startPort: number): Promise<number> {
  return new Promise((resolve) => {
    const server = http.createServer();
    server.listen(startPort, () => {
      server.close(() => resolve(startPort));
    });
    server.on('error', () => {
      resolve(findPort(startPort + 1));
    });
  });
}

function openBrowser(url: string): void {
  const cmd = process.platform === 'darwin' ? 'open'
            : process.platform === 'win32' ? 'start'
            : 'xdg-open';
  exec(`${cmd} ${url}`, (err) => {
    if (err) {
      console.error(`[visualizer] Could not open browser: ${err.message}`);
    }
  });
}
</file>

<file path="mcp-server/src/visualizer/canvas.js">
/**
 * Canvas rendering, camera controls, and drawing utilities
 */

import {
  nodes, edges, NODE_W, NODE_H, camera, defaultZoom,
  W, H, setDimensions, searchTerm, hoveredNode, selectedNode,
  currentView, sceneData, expandedScene, expandedSceneHierarchy,
  selectedSceneNode, hoveredSceneNode, scenePositions,
  setExpandedScene, setSelectedSceneNode, setHoveredSceneNode,
  setScenePosition, scriptToScenes
} from './state.js';

let canvas, ctx;
let zoomIndicator, zoomText;
let dpr = 1; // Device pixel ratio

// Storage key for position persistence
const STORAGE_KEY = 'godot-visualizer-positions';

export function initCanvas() {
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');
  zoomIndicator = document.getElementById('zoom-indicator');
  zoomText = document.getElementById('zoom-text');

  // Get device pixel ratio for crisp rendering on high-DPI displays
  dpr = window.devicePixelRatio || 1;

  resize();
  const positionsRestored = loadPositions(); // Restore saved positions
  return { canvas, ctx, positionsRestored };
}

export function getDpr() {
  return dpr;
}

export function getCanvas() {
  return canvas;
}

export function getContext() {
  return ctx;
}

export function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  setDimensions(w, h);

  // Update DPR in case it changed (e.g., moving window between displays)
  dpr = window.devicePixelRatio || 1;

  // Set canvas size accounting for device pixel ratio for crisp rendering
  canvas.width = w * dpr;
  canvas.height = h * dpr;

  // Scale canvas back to CSS size
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';

  // Scale context to account for DPR
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

export function screenToWorld(sx, sy) {
  return {
    x: (sx - W / 2) / camera.zoom + camera.x,
    y: (sy - H / 2) / camera.zoom + camera.y
  };
}

export function updateZoomIndicator() {
  const pct = Math.round(camera.zoom * 100);
  zoomText.value = pct + '%';
  zoomIndicator.classList.toggle('faded', Math.abs(camera.zoom - defaultZoom) < 0.01);
}

export function resetZoom() {
  camera.zoom = defaultZoom;
  updateZoomIndicator();
  draw();
}

export function setCustomZoom(value) {
  // Parse percentage string like "150%" or just "150" or "1.5"
  let parsed = parseFloat(value.replace('%', '').trim());
  if (isNaN(parsed)) return;
  
  // If user entered a small number like 1.5, treat as multiplier
  if (parsed > 0 && parsed < 10) {
    parsed = parsed * 100;
  }
  
  // Clamp to valid range (10% - 500%)
  const newZoom = Math.max(0.1, Math.min(5, parsed / 100));
  camera.zoom = newZoom;
  updateZoomIndicator();
  draw();
}

// Make functions available globally for onclick
window.resetZoom = resetZoom;
window.setCustomZoom = setCustomZoom;

// ---- Position Persistence ----
export function savePositions() {
  try {
    const positions = {};
    nodes.forEach(n => {
      positions[n.path] = { x: n.x, y: n.y };
    });
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      positions,
      camera: { x: camera.x, y: camera.y, zoom: camera.zoom }
    }));
  } catch (e) {
    console.warn('Failed to save positions:', e);
  }
}

export function loadPositions() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) return false;

    const data = JSON.parse(saved);
    let restored = 0;

    if (data.positions) {
      nodes.forEach(n => {
        if (data.positions[n.path]) {
          n.x = data.positions[n.path].x;
          n.y = data.positions[n.path].y;
          restored++;
        }
      });
    }

    if (data.camera && restored > 0) {
      camera.x = data.camera.x;
      camera.y = data.camera.y;
      camera.zoom = data.camera.zoom;
      // Don't change defaultZoom - keep it at 1 (100%) so reset always goes to 100%
    }

    return restored > 0;
  } catch (e) {
    console.warn('Failed to load positions:', e);
    return false;
  }
}

export function clearPositions() {
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch (e) {
    console.warn('Failed to clear positions:', e);
  }
}

// Save positions when node is moved
export function onNodeMoved() {
  savePositions();
}

// ---- Drawing ----
export function draw() {
  if (currentView === 'scenes') {
    drawSceneView();
    return;
  }

  // Ensure DPR transform is set for crisp rendering on high-DPI displays
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  
  // Disable image smoothing for crisper shapes and lines
  ctx.imageSmoothingEnabled = false;
  
  // Use crisp line rendering
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  ctx.translate(Math.round(W / 2), Math.round(H / 2));
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  // Build path index for quick lookup
  const pathIdx = {};
  nodes.forEach((n, i) => pathIdx[n.path] = i);

  // Group edges by node pair, type, and direction for bundled drawing
  const edgeGroups = {};
  for (const e of edges) {
    const si = pathIdx[e.from], ti = pathIdx[e.to];
    if (si === undefined || ti === undefined) continue;

    // Keep direction (A->B is different from B->A)
    const key = `${si}-${ti}-${e.type}`;
    if (!edgeGroups[key]) {
      edgeGroups[key] = { from: e.from, to: e.to, type: e.type, edges: [], si, ti };
    }
    edgeGroups[key].edges.push(e);
  }

  // Draw bundled edges
  for (const key of Object.keys(edgeGroups)) {
    const group = edgeGroups[key];
    const s = nodes[group.si], t = nodes[group.ti];
    const count = group.edges.length;

    // Skip edges where both nodes are hidden during search
    if (searchTerm && s.visible === false && t.visible === false) continue;

    // Dim edges when one node is hidden, or when neither is highlighted
    const bothVisible = s.visible !== false && t.visible !== false;
    ctx.globalAlpha = (!bothVisible || (!s.highlighted && !t.highlighted)) ? 0.08 : 0.5;

    // Calculate perpendicular offset for multiple edge types between same nodes
    const angle = Math.atan2(t.y - s.y, t.x - s.x);
    const perpAngle = angle + Math.PI / 2;

    // Get offset based on edge type (so different types don't overlap)
    const typeOffset = group.type === 'extends' ? 0 : group.type === 'preload' ? 8 : 16;
    const offsetX = Math.cos(perpAngle) * typeOffset;
    const offsetY = Math.sin(perpAngle) * typeOffset;

    ctx.beginPath();
    ctx.moveTo(s.x + offsetX, s.y + offsetY);
    ctx.lineTo(t.x + offsetX, t.y + offsetY);

    // Line widths scale with zoom (fixed world-space size)
    if (group.type === 'extends') {
      ctx.strokeStyle = '#7aa2f7';
      ctx.setLineDash([]);
      ctx.lineWidth = 2;
    } else if (group.type === 'preload') {
      ctx.strokeStyle = '#d4a27f';
      ctx.setLineDash([]);
      ctx.lineWidth = 1.5;
    } else {
      ctx.strokeStyle = '#a6e3a1';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1.5;
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Arrow at midpoint - fixed world-space size
    const al = 10;
    const mx = (s.x + t.x) / 2 + offsetX, my = (s.y + t.y) / 2 + offsetY;
    ctx.beginPath();
    ctx.moveTo(mx + Math.cos(angle) * al, my + Math.sin(angle) * al);
    ctx.lineTo(mx + Math.cos(angle + 2.5) * al * 0.6, my + Math.sin(angle + 2.5) * al * 0.6);
    ctx.lineTo(mx + Math.cos(angle - 2.5) * al * 0.6, my + Math.sin(angle - 2.5) * al * 0.6);
    ctx.closePath();
    ctx.fillStyle = ctx.strokeStyle;
    ctx.fill();

    // Draw count badge if multiple connections of same type
    if (count > 1) {
      const badgeX = mx + Math.cos(perpAngle) * 12;
      const badgeY = my + Math.sin(perpAngle) * 12;
      const badgeSize = 16;

      ctx.globalAlpha = bothVisible ? 0.9 : 0.3;
      ctx.beginPath();
      ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fill();

      // Count text - scales with zoom
      ctx.fillStyle = '#1a1a1e';
      ctx.font = `bold 10px -apple-system, system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(count.toString(), badgeX, badgeY);
    }
  }

  ctx.globalAlpha = 1;

  // Draw nodes
  for (const n of nodes) {
    // Skip hidden nodes during search
    if (searchTerm && n.visible === false) continue;

    // Round coordinates for crisper rendering
    const x = Math.round(n.x - NODE_W / 2);
    const y = Math.round(n.y - NODE_H / 2);
    const isHovered = n === hoveredNode, isSelected = n === selectedNode;

    ctx.globalAlpha = n.highlighted ? 1 : 0.12;

    // Shadow - fixed world-space size
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = isHovered ? 16 : 8;
    ctx.shadowOffsetY = 2;

    // Background
    ctx.beginPath();
    roundRect(ctx, x, y, NODE_W, NODE_H, 10);
    ctx.fillStyle = isSelected ? '#35353b' : isHovered ? '#303036' : '#242428';
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    // Border - fixed world-space width
    ctx.strokeStyle = isSelected ? n.color : isHovered ? n.color : '#3a3a40';
    ctx.lineWidth = isSelected ? 2 : 1;
    ctx.stroke();

    // Left accent bar
    ctx.beginPath();
    ctx.roundRect(x + 4, y + 8, 3, NODE_H - 16, 2);
    ctx.fillStyle = n.color;
    ctx.fill();

    // Title - scales with node (no zoom compensation)
    const titleSize = 14;
    ctx.font = `600 ${titleSize}px -apple-system, system-ui, sans-serif`;
    ctx.fillStyle = '#e8e4df';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';
    const displayName = n.class_name || n.filename.replace('.gd', '');
    ctx.fillText(displayName, x + 16, y + NODE_H / 2 - 6);

    // Subtitle with colored stats - scales with node
    const subSize = 11;
    const varCount = n.variables ? n.variables.length : 0;
    const funcCount = n.functions ? n.functions.length : 0;
    const sigCount = n.signals ? n.signals.length : 0;

    // Draw subtitle parts with colors
    ctx.font = `${subSize}px -apple-system, system-ui, sans-serif`;
    const subY = y + NODE_H / 2 + 9;
    let subX = x + 16;

    // Extends
    ctx.fillStyle = '#706c66';
    const extendsText = (n.extends || 'Node') + ' · ';
    ctx.fillText(extendsText, subX, subY);
    subX += ctx.measureText(extendsText).width;

    // Functions (cyan/teal)
    ctx.fillStyle = '#89dceb';
    ctx.fillText(funcCount + 'f', subX, subY);
    subX += ctx.measureText(funcCount + 'f').width;

    // Space
    ctx.fillStyle = '#706c66';
    ctx.fillText(' ', subX, subY);
    subX += ctx.measureText(' ').width;

    // Variables (purple)
    ctx.fillStyle = '#cba6f7';
    ctx.fillText(varCount + 'v', subX, subY);
    subX += ctx.measureText(varCount + 'v').width;

    // Space
    ctx.fillStyle = '#706c66';
    ctx.fillText(' ', subX, subY);
    subX += ctx.measureText(' ').width;

    // Signals (green)
    ctx.fillStyle = '#a6e3a1';
    ctx.fillText(sigCount + 's', subX, subY);
    subX += ctx.measureText(sigCount + 's').width;

    // Separator
    ctx.fillStyle = '#706c66';
    ctx.fillText(' · ', subX, subY);
    subX += ctx.measureText(' · ').width;

    // Lines (yellow/amber)
    ctx.fillStyle = '#f9e2af';
    ctx.fillText(n.line_count + 'L', subX, subY);
    
    // Scene usage badge (top-right corner)
    const usedInScenes = scriptToScenes[n.path];
    if (usedInScenes && usedInScenes.length > 0) {
      const badgeX = x + NODE_W - 8;
      const badgeY = y + 8;
      
      ctx.fillStyle = 'rgba(166, 227, 161, 0.2)';
      ctx.beginPath();
      ctx.roundRect(badgeX - 20, badgeY - 4, 24, 14, 3);
      ctx.fill();
      
      ctx.fillStyle = '#a6e3a1';
      ctx.font = `600 9px -apple-system, system-ui, sans-serif`;
      ctx.textAlign = 'right';
      ctx.fillText('📦' + usedInScenes.length, badgeX, badgeY + 4);
      ctx.textAlign = 'left';
    }
  }

  ctx.globalAlpha = 1;
  ctx.restore();
}

// Scene view constants
const SCENE_CARD_W = 200;  // Match NODE_W
const SCENE_CARD_H = 54;   // Match NODE_H
const SCENE_NODE_MIN_W = 80;   // Minimum node width
const SCENE_NODE_MAX_W = 200;  // Maximum node width
const SCENE_NODE_H = 36;
const SCENE_NODE_GAP_X = 15;  // Reduced for tighter layout
const SCENE_NODE_GAP_Y = 40;

// Calculate dynamic node width based on name
function calculateNodeWidth(name) {
  // Approximate width: ~7px per character + padding
  const textWidth = (name || 'Node').length * 7;
  const padding = 35; // For script icon and margins
  return Math.min(SCENE_NODE_MAX_W, Math.max(SCENE_NODE_MIN_W, textWidth + padding));
}

function drawSceneView() {
  // Ensure DPR transform is set for crisp rendering on high-DPI displays
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  
  // Disable image smoothing for crisper shapes and lines
  ctx.imageSmoothingEnabled = false;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  ctx.translate(Math.round(W / 2), Math.round(H / 2));
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  if (!sceneData || !sceneData.scenes || sceneData.scenes.length === 0) {
    drawSceneViewPlaceholder();
    ctx.restore();
    return;
  }

  // Check if we're in expanded mode
  if (expandedScene && expandedSceneHierarchy) {
    drawExpandedSceneView();
  } else {
    drawSceneOverview();
  }

  ctx.restore();
}

function drawSceneOverview() {
  const scenes = sceneData.scenes;
  
  // Calculate positions if not set
  scenes.forEach((scene, i) => {
    if (!scenePositions[scene.path]) {
      const cols = Math.max(1, Math.floor(Math.sqrt(scenes.length * 1.5)));
      setScenePosition(
        scene.path,
        (i % cols) * (SCENE_CARD_W + 40) - ((cols - 1) * (SCENE_CARD_W + 40)) / 2,
        Math.floor(i / cols) * (SCENE_CARD_H + 30) - 100
      );
    }
  });

  // Draw edges between scenes (instance relationships)
  if (sceneData.edges) {
    ctx.globalAlpha = 0.4;
    for (const edge of sceneData.edges) {
      const fromScene = scenes.find(s => s.path === edge.from);
      const toScene = scenes.find(s => s.path === edge.to);
      if (!fromScene || !toScene) continue;

      const fromPos = scenePositions[edge.from];
      const toPos = scenePositions[edge.to];
      if (!fromPos || !toPos) continue;

      const fromX = fromPos.x + SCENE_CARD_W / 2;
      const fromY = fromPos.y + SCENE_CARD_H;
      const toX = toPos.x + SCENE_CARD_W / 2;
      const toY = toPos.y;

      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.strokeStyle = '#89dceb';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    ctx.globalAlpha = 1;
  }

  // Draw scene cards
  scenes.forEach((scene, i) => {
    const pos = scenePositions[scene.path];
    const x = pos.x;
    const y = pos.y;
    
    const isHovered = hoveredSceneNode && hoveredSceneNode.scenePath === scene.path && !hoveredSceneNode.nodePath;
    const isExpanded = expandedScene === scene.path;
    const sceneColor = getSceneColor(scene.path);

    // Shadow - match script node styling
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = isHovered ? 16 : 8;
    ctx.shadowOffsetY = 2;

    // Scene card background - match script node colors
    ctx.beginPath();
    roundRect(ctx, x, y, SCENE_CARD_W, SCENE_CARD_H, 10);
    ctx.fillStyle = isExpanded ? '#35353b' : isHovered ? '#303036' : '#242428';
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    // Border - match script node styling
    ctx.strokeStyle = isExpanded ? sceneColor : isHovered ? sceneColor : '#3a3a40';
    ctx.lineWidth = isExpanded ? 2 : 1;
    ctx.stroke();

    // Left accent bar (scene color)
    ctx.beginPath();
    ctx.roundRect(x + 4, y + 8, 3, SCENE_CARD_H - 16, 2);
    ctx.fillStyle = sceneColor;
    ctx.fill();

    // Scene name (main label)
    ctx.fillStyle = '#e8e4df';
    ctx.font = `600 13px -apple-system, system-ui, sans-serif`;
    ctx.textAlign = 'left';
    const sceneName = scene.name || scene.path.split('/').pop().replace('.tscn', '');
    ctx.fillText(sceneName, x + 14, y + 22);

    // Root type and stats on second line
    const nodeCount = scene.node_count || (scene.nodes ? scene.nodes.length : 0);
    ctx.fillStyle = '#706c66';
    ctx.font = `11px -apple-system, system-ui, sans-serif`;
    ctx.fillText(`${scene.root_type || 'Node'} · ${nodeCount} nodes`, x + 14, y + 40);
  });
}

function drawExpandedSceneView() {
  const hierarchy = expandedSceneHierarchy;
  if (!hierarchy) return;

  // Draw back button area (handled by HTML overlay)
  
  // Draw the node tree
  const treeLayout = calculateTreeLayout(hierarchy);
  
  // Draw connection lines first
  drawTreeConnections(treeLayout.nodes);
  
  // Draw nodes
  for (const node of treeLayout.nodes) {
    drawSceneNode(node);
  }
}

function calculateTreeLayout(hierarchy) {
  const nodes = [];
  const LEVEL_HEIGHT = SCENE_NODE_H + SCENE_NODE_GAP_Y;
  
  // Simple layout: each node positions its children directly below,
  // centered on itself, without considering grandchildren widths
  function processNode(node, depth, centerX) {
    const nodeWidth = calculateNodeWidth(node.name);
    const x = centerX - nodeWidth / 2;
    const y = depth * LEVEL_HEIGHT;
    
    const nodeLayout = {
      ...node,
      x,
      y,
      width: nodeWidth,
      height: SCENE_NODE_H,
      childPositions: []
    };
    nodes.push(nodeLayout);

    // Layout children centered under this node
    if (node.children && node.children.length > 0) {
      // Calculate total width of direct children only
      let totalChildrenWidth = 0;
      for (const child of node.children) {
        totalChildrenWidth += calculateNodeWidth(child.name) + SCENE_NODE_GAP_X;
      }
      totalChildrenWidth -= SCENE_NODE_GAP_X; // Remove last gap
      
      // Start children centered under parent
      let childX = centerX - totalChildrenWidth / 2;
      
      for (const child of node.children) {
        const childWidth = calculateNodeWidth(child.name);
        const childCenterX = childX + childWidth / 2;
        
        nodeLayout.childPositions.push({
          x: childCenterX,
          y: (depth + 1) * LEVEL_HEIGHT
        });
        
        processNode(child, depth + 1, childCenterX);
        childX += childWidth + SCENE_NODE_GAP_X;
      }
    }

    return nodeLayout;
  }

  processNode(hierarchy, 0, 0);

  return { nodes };
}

function drawTreeConnections(nodes) {
  ctx.strokeStyle = '#4a5568';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([]);

  for (const node of nodes) {
    if (node.childPositions && node.childPositions.length > 0) {
      const parentX = node.x + node.width / 2;
      const parentY = node.y + SCENE_NODE_H;

      for (const childPos of node.childPositions) {
        ctx.beginPath();
        ctx.moveTo(parentX, parentY);
        
        // Draw an elbow connector
        const midY = parentY + (childPos.y - parentY) / 2;
        ctx.lineTo(parentX, midY);
        ctx.lineTo(childPos.x, midY);
        ctx.lineTo(childPos.x, childPos.y);
        
        ctx.stroke();
      }
    }
  }
}

function drawSceneNode(node) {
  const x = node.x;
  const y = node.y;
  const w = node.width;
  const isSelected = selectedSceneNode && selectedSceneNode.path === node.path;
  const isHovered = hoveredSceneNode && hoveredSceneNode.nodePath === node.path;
  const isHighlighted = node.highlighted !== false; // Default to true if not set

  // Node type color
  const nodeColor = getNodeTypeColor(node.type);
  
  // Dim non-highlighted nodes when searching
  ctx.globalAlpha = isHighlighted ? 1 : 0.25;

  // Shadow
  ctx.shadowColor = 'rgba(0,0,0,0.25)';
  ctx.shadowBlur = isHovered ? 12 : 6;
  ctx.shadowOffsetY = 2;

  // Background - highlight matching nodes with a glow
  ctx.beginPath();
  roundRect(ctx, x, y, w, SCENE_NODE_H, 6);
  ctx.fillStyle = isSelected ? '#35353b' : isHovered ? '#303036' : '#242428';
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;

  // Border - use accent color for highlighted search results
  const borderColor = isSelected ? nodeColor : isHovered ? nodeColor : 
                      (isHighlighted && searchTerm ? '#f9e2af' : '#3a3a40');
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = (isSelected || (isHighlighted && searchTerm)) ? 2 : 1;
  ctx.stroke();

  // Left accent
  ctx.beginPath();
  ctx.roundRect(x + 3, y + 6, 2, SCENE_NODE_H - 12, 1);
  ctx.fillStyle = nodeColor;
  ctx.fill();

  // Node name
  ctx.fillStyle = '#e8e4df';
  ctx.font = `600 11px -apple-system, system-ui, sans-serif`;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  
  const displayName = node.name || 'Node';
  ctx.fillText(displayName, x + 10, y + SCENE_NODE_H / 2 - 4);

  // Node type (smaller, below name)
  ctx.fillStyle = '#706c66';
  ctx.font = `9px -apple-system, system-ui, sans-serif`;
  ctx.fillText(node.type, x + 10, y + SCENE_NODE_H / 2 + 7);

  // Script indicator
  if (node.script) {
    ctx.fillStyle = '#a6e3a1';
    ctx.font = `10px -apple-system, system-ui, sans-serif`;
    ctx.textAlign = 'right';
    ctx.fillText('📜', x + w - 6, y + SCENE_NODE_H / 2);
    ctx.textAlign = 'left';
  }

  // Sibling index indicator (for node order)
  if (node.index !== undefined && node.index > 0) {
    ctx.fillStyle = '#4a5568';
    ctx.font = `9px -apple-system, system-ui, sans-serif`;
    ctx.textAlign = 'right';
    ctx.fillText(`#${node.index}`, x + w - 6, y + 10);
    ctx.textAlign = 'left';
  }
  
  // Reset alpha
  ctx.globalAlpha = 1;
}

function getSceneColor(scenePath) {
  // Generate consistent color based on path
  const colors = ['#89dceb', '#a6e3a1', '#f9e2af', '#cba6f7', '#f38ba8', '#fab387'];
  let hash = 0;
  for (let i = 0; i < scenePath.length; i++) {
    hash = scenePath.charCodeAt(i) + ((hash << 5) - hash);
  }
  return colors[Math.abs(hash) % colors.length];
}

function getNodeTypeColor(nodeType) {
  // Godot's actual node type colors
  const GODOT_GREEN = '#8eef97';   // Control/UI nodes
  const GODOT_BLUE = '#8da5f3';    // Node2D nodes
  const GODOT_RED = '#fc7f7f';     // Node3D nodes
  const GODOT_GRAY = '#b2b2b2';    // Base Node
  
  // Control/UI nodes (green)
  const controlTypes = [
    'Control', 'Label', 'Button', 'LineEdit', 'TextEdit', 'RichTextLabel',
    'Panel', 'PanelContainer', 'Container', 'BoxContainer', 'VBoxContainer', 
    'HBoxContainer', 'GridContainer', 'MarginContainer', 'ScrollContainer',
    'TabContainer', 'ProgressBar', 'TextureRect', 'ColorRect', 'NinePatchRect',
    'CheckBox', 'CheckButton', 'OptionButton', 'SpinBox', 'Slider', 'HSlider',
    'VSlider', 'Tree', 'ItemList', 'MenuButton', 'LinkButton', 'CanvasLayer'
  ];
  
  // Node2D nodes (blue)
  const node2DTypes = [
    'Node2D', 'Sprite2D', 'AnimatedSprite2D', 'CharacterBody2D', 'RigidBody2D',
    'StaticBody2D', 'Area2D', 'CollisionShape2D', 'CollisionPolygon2D',
    'Camera2D', 'Path2D', 'PathFollow2D', 'Line2D', 'Polygon2D', 'TileMap',
    'TileMapLayer', 'Marker2D', 'RemoteTransform2D', 'VisibleOnScreenNotifier2D',
    'GPUParticles2D', 'CPUParticles2D', 'LightOccluder2D', 'PointLight2D',
    'DirectionalLight2D', 'AudioStreamPlayer2D', 'NavigationRegion2D'
  ];
  
  // Node3D nodes (red)
  const node3DTypes = [
    'Node3D', 'Sprite3D', 'AnimatedSprite3D', 'CharacterBody3D', 'RigidBody3D',
    'StaticBody3D', 'Area3D', 'CollisionShape3D', 'CollisionPolygon3D',
    'Camera3D', 'MeshInstance3D', 'MultiMeshInstance3D', 'CSGBox3D',
    'CSGCylinder3D', 'CSGSphere3D', 'CSGMesh3D', 'Path3D', 'PathFollow3D',
    'GPUParticles3D', 'CPUParticles3D', 'OmniLight3D', 'SpotLight3D',
    'DirectionalLight3D', 'AudioStreamPlayer3D', 'NavigationRegion3D'
  ];
  
  // Check exact matches first, then partial
  for (const type of controlTypes) {
    if (nodeType === type || nodeType.includes(type)) return GODOT_GREEN;
  }
  for (const type of node2DTypes) {
    if (nodeType === type || nodeType.includes(type)) return GODOT_BLUE;
  }
  for (const type of node3DTypes) {
    if (nodeType === type || nodeType.includes(type)) return GODOT_RED;
  }
  
  // Fallback: check for 2D/3D suffix
  if (nodeType.endsWith('2D')) return GODOT_BLUE;
  if (nodeType.endsWith('3D')) return GODOT_RED;
  
  return GODOT_GRAY; // Default gray for base Node
}

function drawSceneViewPlaceholder() {
  ctx.fillStyle = '#706c66';
  ctx.font = `16px -apple-system, system-ui, sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('No scenes found', 0, 0);
  ctx.fillText('Create a .tscn file in your project', 0, 24);
  ctx.textAlign = 'left';
}

// Export scene hit testing
export function sceneHitTest(wx, wy) {
  if (!sceneData || !sceneData.scenes) return null;

  if (expandedScene && expandedSceneHierarchy) {
    // Hit test expanded scene nodes
    const treeLayout = calculateTreeLayout(expandedSceneHierarchy);
    for (let i = treeLayout.nodes.length - 1; i >= 0; i--) {
      const node = treeLayout.nodes[i];
      if (wx >= node.x && wx <= node.x + node.width &&
          wy >= node.y && wy <= node.y + SCENE_NODE_H) {
        return { type: 'sceneNode', node, scenePath: expandedScene };
      }
    }
    return null;
  } else {
    // Hit test scene cards
    for (const scene of sceneData.scenes) {
      const pos = scenePositions[scene.path];
      if (!pos) continue;
      
      if (wx >= pos.x && wx <= pos.x + SCENE_CARD_W &&
          wy >= pos.y && wy <= pos.y + SCENE_CARD_H) {
        return { type: 'sceneCard', scene, scenePath: scene.path };
      }
    }
    return null;
  }
}

export { SCENE_CARD_W, SCENE_CARD_H, SCENE_NODE_H };

export function roundRect(ctx, x, y, w, h, r) {
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
}

export function hitTest(wx, wy) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    // Skip hidden nodes during search
    if (searchTerm && n.visible === false) continue;
    if (wx >= n.x - NODE_W / 2 && wx <= n.x + NODE_W / 2 &&
        wy >= n.y - NODE_H / 2 && wy <= n.y + NODE_H / 2) return n;
  }
  return null;
}

export function centerOnNodes(nodeList) {
  if (!nodeList || nodeList.length === 0) return;

  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodeList.forEach(n => {
    minX = Math.min(minX, n.x);
    maxX = Math.max(maxX, n.x);
    minY = Math.min(minY, n.y);
    maxY = Math.max(maxY, n.y);
  });

  camera.x = (minX + maxX) / 2;
  camera.y = (minY + maxY) / 2;
  updateZoomIndicator();
}

export function fitToView(nodeList) {
  if (!nodeList || nodeList.length === 0) return;

  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodeList.forEach(n => {
    minX = Math.min(minX, n.x);
    maxX = Math.max(maxX, n.x);
    minY = Math.min(minY, n.y);
    maxY = Math.max(maxY, n.y);
  });

  camera.x = (minX + maxX) / 2;
  camera.y = (minY + maxY) / 2;

  const spanX = (maxX - minX) + NODE_W * 2;
  const spanY = (maxY - minY) + NODE_H * 2;
  // Calculate zoom to fit all nodes, but cap at 100% (1.0) to avoid zooming in too much
  camera.zoom = Math.min(1.0, W / spanX, H / spanY) * 0.9;
  // Don't change defaultZoom - keep it at 1 (100%) so reset always goes to 100%
  updateZoomIndicator();
}
</file>

<file path="mcp-server/src/visualizer/events.js">
/**
 * Event handlers for mouse, keyboard, and search
 */

import {
  nodes, edges, camera, W, H, defaultZoom,
  dragging, setDragging,
  hoveredNode, setHoveredNode,
  searchTerm, setSearchTerm,
  currentView, expandedScene, expandedSceneHierarchy, sceneData,
  setExpandedScene, setExpandedSceneHierarchy,
  setSelectedSceneNode, setHoveredSceneNode,
  selectedSceneNode, scenePositions, setScenePosition
} from './state.js';
import {
  getCanvas, screenToWorld, hitTest, draw, resize,
  updateZoomIndicator, centerOnNodes, savePositions,
  sceneHitTest, SCENE_CARD_W, SCENE_CARD_H
} from './canvas.js';
import { openPanel, closePanel, openSceneNodePanel, closeSceneNodePanel } from './panel.js';
import { sendCommand } from './websocket.js';

const DRAG_THRESHOLD = 5; // pixels - minimum movement to count as drag

export function initEvents() {
  const canvas = getCanvas();
  const searchInput = document.getElementById('search');
  const statsEl = document.getElementById('stats');

  // Mouse events
  canvas.addEventListener('mousedown', (e) => {
    const w = screenToWorld(e.clientX, e.clientY);
    
    if (currentView === 'scenes') {
      handleSceneMouseDown(e, w);
    } else {
      handleScriptsMouseDown(e, w);
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (currentView === 'scenes') {
      handleSceneMouseMove(e);
    } else {
      handleScriptsMouseMove(e);
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (currentView === 'scenes') {
      handleSceneMouseUp(e);
    } else {
      handleScriptsMouseUp(e);
    }
  });

  // Prevent click from also opening panel (mouseup already handles it)
  canvas.addEventListener('click', (e) => {
    // Only handle clicks on empty space (not nodes) - nodes are handled by mouseup
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    // Smaller zoom increments for finer control
    const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
    const newZoom = Math.max(0.1, Math.min(5, camera.zoom * zoomFactor));
    const wx = (e.clientX - W / 2) / camera.zoom + camera.x;
    const wy = (e.clientY - H / 2) / camera.zoom + camera.y;
    camera.zoom = newZoom;
    camera.x = wx - (e.clientX - W / 2) / camera.zoom;
    camera.y = wy - (e.clientY - H / 2) / camera.zoom;
    updateZoomIndicator();
    draw();
  }, { passive: false });

  // Double-click to rename
  canvas.addEventListener('dblclick', (e) => {
    if (currentView === 'scenes' && expandedScene) {
      const w = screenToWorld(e.clientX, e.clientY);
      const hit = sceneHitTest(w.x, w.y);
      
      if (hit && hit.type === 'sceneNode') {
        e.preventDefault();
        startInlineRename(e.clientX, e.clientY, hit.node, hit.scenePath);
      }
    }
  });

  // Right-click context menu
  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    
    if (currentView === 'scenes' && expandedScene) {
      const w = screenToWorld(e.clientX, e.clientY);
      const hit = sceneHitTest(w.x, w.y);
      
      if (hit && hit.type === 'sceneNode') {
        showSceneContextMenu(e.clientX, e.clientY, hit.node, hit.scenePath);
        return;
      }
    }
    
    // Hide scene context menu if clicking elsewhere
    hideSceneContextMenu();
  });

  // Close context menus when clicking elsewhere
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#scene-context-menu')) {
      hideSceneContextMenu();
    }
  });

  // Search
  searchInput.addEventListener('input', () => {
    const term = searchInput.value.toLowerCase().trim();
    setSearchTerm(term);

    if (currentView === 'scripts') {
      nodes.forEach(n => {
        if (!term) {
          n.highlighted = true;
          n.visible = true;
          return;
        }
        const matches = n.filename.toLowerCase().includes(term) ||
          (n.class_name && n.class_name.toLowerCase().includes(term)) ||
          (n.description && n.description.toLowerCase().includes(term)) ||
          (n.path && n.path.toLowerCase().includes(term));
        n.highlighted = matches;
        n.visible = matches;
      });

      const matchingNodes = nodes.filter(n => n.highlighted);
      const count = matchingNodes.length;
      statsEl.textContent = term
        ? `${count}/${nodes.length}`
        : `${nodes.length} scripts · ${edges.length} connections`;

      // If there are matching results, center the view on them
      if (term && matchingNodes.length > 0) {
        centerOnNodes(matchingNodes);

        // Adjust zoom if needed to fit all matching nodes
        if (matchingNodes.length === 1) {
          camera.zoom = Math.max(defaultZoom, 1);
        }
        updateZoomIndicator();
      }
    }
    // Scene search
    if (currentView === 'scenes') {
      if (expandedScene && expandedSceneHierarchy) {
        // Search within expanded scene - highlight matching nodes
        const matchingPaths = [];
        
        function searchNode(node) {
          const matches = !term || 
            node.name.toLowerCase().includes(term) ||
            (node.type && node.type.toLowerCase().includes(term));
          
          node.highlighted = matches;
          if (matches && term) matchingPaths.push(node.path);
          
          if (node.children) {
            for (const child of node.children) {
              searchNode(child);
            }
          }
        }
        
        searchNode(expandedSceneHierarchy);
        
        const totalNodes = countNodes(expandedSceneHierarchy);
        statsEl.textContent = term
          ? `${matchingPaths.length}/${totalNodes} nodes`
          : `${totalNodes} nodes`;
      } else if (sceneData && sceneData.scenes) {
        // Search in scene overview
        let matchCount = 0;
        for (const scene of sceneData.scenes) {
          const sceneName = scene.name || scene.path.split('/').pop().replace('.tscn', '');
          scene.highlighted = !term || 
            sceneName.toLowerCase().includes(term) ||
            (scene.root_type && scene.root_type.toLowerCase().includes(term));
          if (scene.highlighted) matchCount++;
        }
        
        statsEl.textContent = term
          ? `${matchCount}/${sceneData.scenes.length} scenes`
          : `${sceneData.scenes.length} scenes`;
      }
    }

    draw();
  });
  
  function countNodes(node) {
    let count = 1;
    if (node.children) {
      for (const child of node.children) {
        count += countNodes(child);
      }
    }
    return count;
  }

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      // Also close context menus
      hideSceneContextMenu();
      
      if (currentView === 'scenes') {
        if (selectedSceneNode) {
          setSelectedSceneNode(null);
          closeSceneNodePanel();
          draw();
        } else if (expandedScene) {
          goBackToSceneOverview();
        }
      } else {
        closePanel();
      }
    }
    
    // Focus search with /
    if (e.key === '/' && document.activeElement !== searchInput) {
      e.preventDefault();
      searchInput.focus();
    }
    
    // Delete key to delete selected scene node
    if ((e.key === 'Delete' || e.key === 'Backspace') && currentView === 'scenes' && selectedSceneNode && !e.target.matches('input, textarea')) {
      e.preventDefault();
      sceneNodeAction('delete');
    }
    
    // Enter to open properties panel for selected node
    if (e.key === 'Enter' && currentView === 'scenes' && expandedScene && !e.target.matches('input, textarea')) {
      // If no node selected, select root
      // If node selected, this could toggle the panel (already handled by re-click)
    }
  });

  // Window resize
  window.addEventListener('resize', () => {
    resize();
    draw();
  });
}

// ---- Scripts view event handlers ----
function handleScriptsMouseDown(e, w) {
  const canvas = getCanvas();
  const hit = hitTest(w.x, w.y);

  if (hit && e.button === 0) {
    setDragging({
      type: 'node',
      node: hit,
      offX: hit.x - w.x,
      offY: hit.y - w.y,
      startScreenX: e.clientX,
      startScreenY: e.clientY,
      moved: false
    });
    canvas.classList.add('dragging');
  } else {
    setDragging({ type: 'pan', startX: e.clientX, startY: e.clientY, camX: camera.x, camY: camera.y });
    canvas.classList.add('dragging');
  }
}

function handleScriptsMouseMove(e) {
  const canvas = getCanvas();
  if (dragging) {
    if (dragging.type === 'node') {
      const w = screenToWorld(e.clientX, e.clientY);
      dragging.node.x = w.x + dragging.offX;
      dragging.node.y = w.y + dragging.offY;

      // Check if moved past threshold
      const dx = Math.abs(e.clientX - dragging.startScreenX);
      const dy = Math.abs(e.clientY - dragging.startScreenY);
      if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
        dragging.moved = true;
      }
    } else {
      const dx = (e.clientX - dragging.startX) / camera.zoom;
      const dy = (e.clientY - dragging.startY) / camera.zoom;
      camera.x = dragging.camX - dx;
      camera.y = dragging.camY - dy;
    }
    draw();
  } else {
    const w = screenToWorld(e.clientX, e.clientY);
    const prev = hoveredNode;
    setHoveredNode(hitTest(w.x, w.y));
    if (hoveredNode !== prev) {
      canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
      draw();
    }
  }
}

function handleScriptsMouseUp(e) {
  const canvas = getCanvas();
  if (dragging && dragging.type === 'node') {
    if (dragging.moved) {
      // Node was moved - save positions
      savePositions();
    } else {
      // Node was clicked - open panel
      openPanel(dragging.node);
    }
  }
  canvas.classList.remove('dragging');
  setDragging(null);
}

// ---- Scene view event handlers ----
function handleSceneMouseDown(e, w) {
  const canvas = getCanvas();
  const hit = sceneHitTest(w.x, w.y);

  if (hit && e.button === 0) {
    if (hit.type === 'sceneCard') {
      // Scene card - prepare for possible drag or click
      const pos = scenePositions[hit.scenePath];
      setDragging({
        type: 'sceneCard',
        scene: hit.scene,
        scenePath: hit.scenePath,
        offX: pos.x - w.x,
        offY: pos.y - w.y,
        startScreenX: e.clientX,
        startScreenY: e.clientY,
        moved: false
      });
      canvas.classList.add('dragging');
    } else if (hit.type === 'sceneNode') {
      // Scene node in expanded view - click to select
      setDragging({
        type: 'sceneNode',
        node: hit.node,
        scenePath: hit.scenePath,
        startScreenX: e.clientX,
        startScreenY: e.clientY,
        moved: false
      });
    }
  } else {
    setDragging({ type: 'pan', startX: e.clientX, startY: e.clientY, camX: camera.x, camY: camera.y });
    canvas.classList.add('dragging');
  }
}

function handleSceneMouseMove(e) {
  const canvas = getCanvas();
  if (dragging) {
    if (dragging.type === 'sceneCard') {
      const w = screenToWorld(e.clientX, e.clientY);
      const newX = w.x + dragging.offX;
      const newY = w.y + dragging.offY;
      setScenePosition(dragging.scenePath, newX, newY);

      // Check if moved past threshold
      const dx = Math.abs(e.clientX - dragging.startScreenX);
      const dy = Math.abs(e.clientY - dragging.startScreenY);
      if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
        dragging.moved = true;
      }
      draw();
    } else if (dragging.type === 'pan') {
      const dx = (e.clientX - dragging.startX) / camera.zoom;
      const dy = (e.clientY - dragging.startY) / camera.zoom;
      camera.x = dragging.camX - dx;
      camera.y = dragging.camY - dy;
      draw();
    }
  } else {
    const w = screenToWorld(e.clientX, e.clientY);
    const hit = sceneHitTest(w.x, w.y);
    
    if (hit) {
      if (hit.type === 'sceneCard') {
        setHoveredSceneNode({ scenePath: hit.scenePath, nodePath: null });
      } else if (hit.type === 'sceneNode') {
        setHoveredSceneNode({ scenePath: hit.scenePath, nodePath: hit.node.path });
      }
      canvas.style.cursor = 'pointer';
    } else {
      setHoveredSceneNode(null);
      canvas.style.cursor = 'grab';
    }
    draw();
  }
}

function handleSceneMouseUp(e) {
  const canvas = getCanvas();
  
  if (dragging) {
    if (dragging.type === 'sceneCard' && !dragging.moved) {
      // Scene card was clicked - expand the scene
      expandScene(dragging.scenePath);
    } else if (dragging.type === 'sceneNode' && !dragging.moved) {
      // Scene node was clicked - select it and open properties panel
      selectSceneNode(dragging.node, dragging.scenePath);
    }
  }
  
  canvas.classList.remove('dragging');
  setDragging(null);
}

// ---- Scene expansion and navigation ----
async function expandScene(scenePath) {
  console.log('Expanding scene:', scenePath);
  
  try {
    // Fetch the scene hierarchy
    const result = await sendCommand('get_scene_hierarchy', { scene_path: scenePath });
    
    if (result.ok) {
      setExpandedScene(scenePath);
      setExpandedSceneHierarchy(result.hierarchy);
      
      // Reset camera position but keep user's zoom level
      camera.x = 0;
      camera.y = 100;
      // Don't change zoom - keep user's preference
      
      // Update UI
      updateSceneBackButton(true, scenePath);
      draw();
    } else {
      console.error('Failed to get scene hierarchy:', result.error);
      alert('Failed to load scene: ' + (result.error || 'Unknown error'));
    }
  } catch (err) {
    console.error('Failed to expand scene:', err);
    alert('Failed to load scene: ' + err.message);
  }
}

async function selectSceneNode(node, scenePath) {
  console.log('Selected scene node:', node.name, 'in', scenePath);
  
  // If clicking the same node that's already selected, close the panel
  if (selectedSceneNode && selectedSceneNode.path === node.path) {
    setSelectedSceneNode(null);
    closeSceneNodePanel();
    draw();
    return;
  }
  
  setSelectedSceneNode(node);
  
  // Open the properties panel for this node
  await openSceneNodePanel(scenePath, node);
  draw();
}

export function goBackToSceneOverview() {
  setExpandedScene(null);
  setExpandedSceneHierarchy(null);
  setSelectedSceneNode(null);
  setHoveredSceneNode(null);
  closeSceneNodePanel();
  updateSceneBackButton(false);
  draw();
}

function updateSceneBackButton(show, scenePath = '') {
  const backBtn = document.getElementById('scene-back-btn');
  const legend = document.getElementById('legend');
  
  if (backBtn) {
    backBtn.style.display = show ? 'flex' : 'none';
    if (show) {
      const sceneName = scenePath.split('/').pop().replace('.tscn', '');
      backBtn.querySelector('.scene-name').textContent = sceneName;
    }
  }
  
  // Hide legend when in expanded scene view (it's not relevant there)
  if (legend) {
    legend.classList.toggle('hidden', show);
  }
}

// Expose for global access
window.goBackToSceneOverview = goBackToSceneOverview;
window.expandSceneFromPanel = expandScene;

export function updateStats() {
  const statsEl = document.getElementById('stats');
  if (currentView === 'scripts') {
    statsEl.textContent = `${nodes.length} scripts · ${edges.length} connections`;
  } else if (sceneData && sceneData.scenes) {
    statsEl.textContent = `${sceneData.scenes.length} scenes`;
  }
}

// ---- Scene Node Context Menu ----
let contextMenuNode = null;
let contextMenuScenePath = null;

function showSceneContextMenu(x, y, node, scenePath) {
  const menu = document.getElementById('scene-context-menu');
  contextMenuNode = node;
  contextMenuScenePath = scenePath;
  
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.classList.add('visible');
}

function hideSceneContextMenu() {
  const menu = document.getElementById('scene-context-menu');
  menu.classList.remove('visible');
  contextMenuNode = null;
  contextMenuScenePath = null;
}

async function sceneNodeAction(action) {
  // Save node info BEFORE hiding menu (which clears these variables)
  const node = contextMenuNode;
  const scenePath = contextMenuScenePath;
  
  hideSceneContextMenu();
  
  if (!node || !scenePath) return;
  
  try {
    switch (action) {
      case 'add_child': {
        const nodeType = prompt('Enter node type (e.g., Node2D, Sprite2D, Label):', 'Node2D');
        if (!nodeType) return;
        const nodeName = prompt('Enter node name:', 'NewNode');
        if (!nodeName) return;
        
        const result = await sendCommand('add_node', {
          scene_path: scenePath,
          parent_path: node.path,
          node_type: nodeType,
          node_name: nodeName
        });
        
        if (result.ok) {
          await refreshExpandedScene(scenePath);
        } else {
          alert('Failed to add node: ' + (result.error || 'Unknown error'));
        }
        break;
      }
      
      case 'rename': {
        const newName = prompt('Enter new name:', node.name);
        if (!newName || newName === node.name) return;
        
        const result = await sendCommand('rename_node', {
          scene_path: scenePath,
          node_path: node.path,
          new_name: newName
        });
        
        if (result.ok) {
          await refreshExpandedScene(scenePath);
        } else {
          alert('Failed to rename: ' + (result.error || 'Unknown error'));
        }
        break;
      }
      
      case 'duplicate': {
        const result = await sendCommand('duplicate_node', {
          scene_path: scenePath,
          node_path: node.path
        });
        
        if (result.ok) {
          await refreshExpandedScene(scenePath);
        } else {
          alert('Failed to duplicate: ' + (result.error || 'Unknown error'));
        }
        break;
      }
      
      case 'move_up': {
        if (node.index === undefined || node.index <= 0) {
          alert('Cannot move node up - already at top');
          return;
        }
        const result = await sendCommand('reorder_node', {
          scene_path: scenePath,
          node_path: node.path,
          new_index: node.index - 1
        });
        
        if (result.ok) {
          await refreshExpandedScene(scenePath);
        } else {
          alert('Failed to move: ' + (result.error || 'Unknown error'));
        }
        break;
      }
      
      case 'move_down': {
        const result = await sendCommand('reorder_node', {
          scene_path: scenePath,
          node_path: node.path,
          new_index: (node.index || 0) + 1
        });
        
        if (result.ok) {
          await refreshExpandedScene(scenePath);
        } else {
          alert('Failed to move: ' + (result.error || 'Unknown error'));
        }
        break;
      }
      
      case 'delete': {
        if (node.path === '.') {
          alert('Cannot delete root node');
          return;
        }
        if (!confirm(`Delete node "${node.name}" and all its children?`)) return;
        
        const result = await sendCommand('remove_node', {
          scene_path: scenePath,
          node_path: node.path
        });
        
        if (result.ok) {
          closeSceneNodePanel();
          setSelectedSceneNode(null);
          await refreshExpandedScene(scenePath);
        } else {
          alert('Failed to delete: ' + (result.error || 'Unknown error'));
        }
        break;
      }
    }
  } catch (err) {
    console.error('Scene action failed:', err);
    alert('Action failed: ' + err.message);
  }
}

async function refreshExpandedScene(scenePath) {
  // Re-fetch the scene hierarchy
  const result = await sendCommand('get_scene_hierarchy', { scene_path: scenePath });
  if (result.ok) {
    setExpandedSceneHierarchy(result.hierarchy);
    draw();
  }
}

// ---- Inline Rename ----
function startInlineRename(screenX, screenY, node, scenePath) {
  // Create an input overlay at the node position
  const existingInput = document.getElementById('inline-rename-input');
  if (existingInput) existingInput.remove();
  
  const input = document.createElement('input');
  input.id = 'inline-rename-input';
  input.type = 'text';
  input.value = node.name;
  input.style.cssText = `
    position: fixed;
    left: ${screenX - 50}px;
    top: ${screenY - 12}px;
    width: 120px;
    padding: 4px 8px;
    font-size: 12px;
    font-family: -apple-system, system-ui, sans-serif;
    font-weight: 600;
    background: #242428;
    border: 2px solid #7aa2f7;
    border-radius: 4px;
    color: #e8e4df;
    z-index: 1000;
    outline: none;
  `;
  
  document.body.appendChild(input);
  input.focus();
  input.select();
  
  async function finishRename() {
    const newName = input.value.trim();
    input.remove();
    
    if (newName && newName !== node.name) {
      try {
        const result = await sendCommand('rename_node', {
          scene_path: scenePath,
          node_path: node.path,
          new_name: newName
        });
        
        if (result.ok) {
          await refreshExpandedScene(scenePath);
        } else {
          alert('Failed to rename: ' + (result.error || 'Unknown error'));
        }
      } catch (err) {
        alert('Failed to rename: ' + err.message);
      }
    }
  }
  
  input.addEventListener('blur', finishRename);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      input.blur();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      input.value = node.name; // Reset to original
      input.blur();
    }
  });
}

// Expose for global access
window.sceneNodeAction = sceneNodeAction;
</file>

<file path="mcp-server/src/visualizer/layout.js">
/**
 * Force-directed layout algorithm for node positioning
 */

import { nodes, edges, NODE_W, NODE_H } from './state.js';

// Minimum spacing between nodes
const MIN_SPACING_X = NODE_W + 40;
const MIN_SPACING_Y = NODE_H + 30;

export function initLayout() {
  if (nodes.length === 0) return;

  // Build adjacency map for connected nodes
  const adjacency = new Map();
  nodes.forEach(n => adjacency.set(n.path, []));

  edges.forEach(e => {
    if (adjacency.has(e.from) && adjacency.has(e.to)) {
      adjacency.get(e.from).push(e.to);
      adjacency.get(e.to).push(e.from);
    }
  });

  // Find root nodes (most connections or extends nothing)
  const connectionCount = new Map();
  nodes.forEach(n => {
    const count = (adjacency.get(n.path) || []).length;
    connectionCount.set(n.path, count);
  });

  // Sort nodes by connection count (most connected first)
  const sortedNodes = [...nodes].sort((a, b) =>
    connectionCount.get(b.path) - connectionCount.get(a.path)
  );

  // Initial placement: spread nodes in a grid with good spacing
  const cols = Math.ceil(Math.sqrt(nodes.length));
  const startX = -(cols * MIN_SPACING_X) / 2;
  const startY = -(Math.ceil(nodes.length / cols) * MIN_SPACING_Y) / 2;

  sortedNodes.forEach((n, i) => {
    const col = i % cols;
    const row = Math.floor(i / cols);
    n.x = startX + col * MIN_SPACING_X;
    n.y = startY + row * MIN_SPACING_Y;
  });

  // Run force-directed simulation with collision detection
  const iterations = 150;
  for (let iter = 0; iter < iterations; iter++) {
    const alpha = Math.pow(1 - iter / iterations, 2); // Quadratic cooling
    applyForces(alpha, adjacency);
    resolveCollisions();
  }

  // Final collision resolution pass
  for (let i = 0; i < 10; i++) {
    resolveCollisions();
  }

  // Center the layout
  centerLayout();
}

function applyForces(alpha, adjacency) {
  const repulsion = 50000;  // Strong repulsion
  const attraction = 0.08;  // Moderate attraction
  const idealEdgeLength = MIN_SPACING_X * 1.2;

  // Repulsion between all nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const a = nodes[i];
      const b = nodes[j];
      let dx = b.x - a.x;
      let dy = b.y - a.y;

      // Add small random offset if nodes are at same position
      if (dx === 0 && dy === 0) {
        dx = (Math.random() - 0.5) * 10;
        dy = (Math.random() - 0.5) * 10;
      }

      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const minDist = MIN_SPACING_X; // Minimum desired distance

      // Stronger repulsion when nodes are close
      let force = repulsion / (dist * dist);
      if (dist < minDist) {
        force *= 3; // Extra push when too close
      }

      const fx = (dx / dist) * force * alpha;
      const fy = (dy / dist) * force * alpha;
      a.x -= fx;
      a.y -= fy;
      b.x += fx;
      b.y += fy;
    }
  }

  // Attraction along edges - pull connected nodes together
  edges.forEach(e => {
    const from = nodes.find(n => n.path === e.from);
    const to = nodes.find(n => n.path === e.to);
    if (!from || !to) return;

    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;

    // Only attract if nodes are far apart
    if (dist > idealEdgeLength) {
      const force = (dist - idealEdgeLength) * attraction * alpha;
      const fx = (dx / dist) * force;
      const fy = (dy / dist) * force;
      from.x += fx;
      from.y += fy;
      to.x -= fx;
      to.y -= fy;
    }
  });
}

function resolveCollisions() {
  // Separate overlapping nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const a = nodes[i];
      const b = nodes[j];

      // Check for overlap using bounding boxes
      const overlapX = MIN_SPACING_X - Math.abs(b.x - a.x);
      const overlapY = MIN_SPACING_Y - Math.abs(b.y - a.y);

      if (overlapX > 0 && overlapY > 0) {
        // Nodes are overlapping - push them apart
        let dx = b.x - a.x;
        let dy = b.y - a.y;

        // Add random offset if exactly overlapping
        if (dx === 0) dx = (Math.random() - 0.5) * 2;
        if (dy === 0) dy = (Math.random() - 0.5) * 2;

        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

        // Push apart in the direction of least overlap
        if (overlapX < overlapY) {
          // Push horizontally
          const push = (overlapX / 2 + 5) * Math.sign(dx);
          a.x -= push;
          b.x += push;
        } else {
          // Push vertically
          const push = (overlapY / 2 + 5) * Math.sign(dy);
          a.y -= push;
          b.y += push;
        }
      }
    }
  }
}

function centerLayout() {
  if (nodes.length === 0) return;

  // Find bounding box
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  nodes.forEach(n => {
    minX = Math.min(minX, n.x);
    maxX = Math.max(maxX, n.x);
    minY = Math.min(minY, n.y);
    maxY = Math.max(maxY, n.y);
  });

  // Center around origin
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  nodes.forEach(n => {
    n.x -= centerX;
    n.y -= centerY;
  });
}
</file>

<file path="mcp-server/src/visualizer/main.js">
/**
 * Main entry point for the Godot Project Map Visualizer
 */

import {
  nodes, edges, camera, NODE_W, NODE_H
} from './state.js';
import { connectWebSocket } from './websocket.js';
import { initLayout } from './layout.js';
import { initCanvas, resize, draw, updateZoomIndicator, fitToView } from './canvas.js';
import { initPanel } from './panel.js';
import { initModals } from './modals.js';
import { initEvents, updateStats } from './events.js';
import './usages.js'; // Load usages module for side effects (global functions)

// Initialize everything when DOM is ready
function init() {
  // Connect WebSocket for real-time communication
  connectWebSocket();

  // Initialize canvas and rendering (also restores saved positions)
  const { positionsRestored } = initCanvas();

  // Initialize panel and modals
  initPanel();
  initModals();

  // Initialize event handlers
  initEvents();

  // Update stats
  updateStats();

  // Get zoom indicator element
  const zoomIndicator = document.getElementById('zoom-indicator');

  if (nodes.length === 0) {
    // No scripts found - show placeholder
    const ctx = document.getElementById('canvas').getContext('2d');
    const W = window.innerWidth;
    const H = window.innerHeight;

    ctx.font = '18px -apple-system, system-ui, sans-serif';
    ctx.fillStyle = '#706c66';
    ctx.textAlign = 'center';
    ctx.fillText('No scripts found in project', W / 2, H / 2);
    zoomIndicator.style.display = 'none';
  } else {
    if (positionsRestored) {
      // Positions were restored from localStorage - just update zoom indicator
      updateZoomIndicator();
    } else {
      // No saved positions - run force-directed layout
      initLayout();
      // Fit view to show all nodes
      fitToView(nodes);
    }

    // Initial draw
    draw();
  }
}

// Start when DOM is loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
</file>

<file path="mcp-server/src/visualizer/modals.js">
/**
 * Context menu, new script modal, and view switching
 */

import {
  nodes, edges, setCurrentView, setSceneData, getFolderColor,
  setExpandedScene, setExpandedSceneHierarchy, setSelectedSceneNode,
  setHoveredSceneNode, expandedScene
} from './state.js';
import { sendCommand } from './websocket.js';
import { draw, getCanvas, roundRect, getContext, clearPositions, fitToView } from './canvas.js';
import { initLayout } from './layout.js';
import { closePanel, closeSceneNodePanel } from './panel.js';
import { updateStats } from './events.js';

let contextMenu;

export function initModals() {
  contextMenu = document.getElementById('context-menu');
  initContextMenu();
}

// ---- Context Menu ----
function initContextMenu() {
  const canvas = getCanvas();

  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();

    // Position menu at mouse
    contextMenu.style.left = e.clientX + 'px';
    contextMenu.style.top = e.clientY + 'px';
    contextMenu.classList.add('visible');
  });

  // Hide context menu on click elsewhere
  document.addEventListener('click', (e) => {
    if (!contextMenu.contains(e.target)) {
      contextMenu.classList.remove('visible');
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      contextMenu.classList.remove('visible');
      closeNewScriptModal();
    }
  });
}

// ---- New Script Creation ----
window.createNewScript = function () {
  contextMenu.classList.remove('visible');
  document.getElementById('new-script-modal').style.display = 'flex';
  document.getElementById('new-script-path').focus();
};

window.closeNewScriptModal = function () {
  document.getElementById('new-script-modal').style.display = 'none';
};

function closeNewScriptModal() {
  document.getElementById('new-script-modal').style.display = 'none';
}

window.submitNewScript = async function () {
  const path = document.getElementById('new-script-path').value.trim();
  const extendsType = document.getElementById('new-script-extends').value;
  const className = document.getElementById('new-script-classname').value.trim();

  if (!path) {
    alert('Please enter a script path');
    return;
  }

  if (!path.startsWith('res://') || !path.endsWith('.gd')) {
    alert('Path must start with res:// and end with .gd');
    return;
  }

  try {
    // Use existing create_script tool via invokeTool (not internal)
    const result = await sendCommand('create_script_file', {
      path: path,
      extends: extendsType,
      class_name: className || ''
    });

    if (result.ok) {
      closeNewScriptModal();
      // Refresh the project map
      refreshProject();
    } else {
      alert('Failed to create script: ' + (result.error || 'Unknown error'));
    }
  } catch (err) {
    alert('Failed to create script: ' + err.message);
  }
};

window.refreshProject = async function () {
  contextMenu.classList.remove('visible');
  try {
    const result = await sendCommand('refresh_map', {});
    if (result.ok && result.project_map) {
      // Update nodes and edges
      const newNodes = result.project_map.nodes.map((n, i) => ({
        ...n,
        x: nodes[i]?.x || 0,
        y: nodes[i]?.y || 0,
        color: getFolderColor(n.folder),
        highlighted: true,
        visible: true
      }));
      nodes.length = 0;
      nodes.push(...newNodes);
      edges.length = 0;
      edges.push(...result.project_map.edges);
      initLayout();
      draw();
    }
  } catch (err) {
    console.error('Failed to refresh:', err);
  }
};

function refreshProject() {
  window.refreshProject();
}

// ---- Reset Layout ----
window.resetLayout = function () {
  contextMenu.classList.remove('visible');
  // Clear saved positions
  clearPositions();
  // Re-run force-directed layout
  initLayout();
  // Fit view to show all nodes
  fitToView(nodes);
  // Redraw
  draw();
};

// ---- View Switching (Scripts/Scenes) ----
window.switchView = function (view) {
  const currentViewTab = document.querySelector('#view-tabs button.active')?.textContent.toLowerCase();
  if (view === currentViewTab) return;

  // Close any open panels
  if (view === 'scripts') {
    closeSceneNodePanel();
    // Clear scene state
    setExpandedScene(null);
    setExpandedSceneHierarchy(null);
    setSelectedSceneNode(null);
    setHoveredSceneNode(null);
    // Hide scene back button
    const backBtn = document.getElementById('scene-back-btn');
    if (backBtn) backBtn.style.display = 'none';
    // Show legend for scripts view
    const legend = document.getElementById('legend');
    if (legend) legend.classList.remove('hidden');
  } else {
    closePanel();
  }

  setCurrentView(view);

  // Update tab buttons
  document.querySelectorAll('#view-tabs button').forEach(btn => {
    btn.classList.toggle('active', btn.textContent.toLowerCase() === view);
  });

  // Update search placeholder
  const searchInput = document.getElementById('search');
  if (searchInput) {
    searchInput.placeholder = view === 'scripts' ? 'Search scripts...' : 'Search scenes...';
  }

  if (view === 'scenes') {
    loadSceneView();
  } else {
    updateStats();
    draw();
  }
};

async function loadSceneView() {
  // Request scene data from Godot
  try {
    const result = await sendCommand('map_scenes', { root: 'res://' });
    if (result.ok) {
      setSceneData(result.scene_map);
      updateStats();
      draw();
    } else {
      console.error('Failed to load scenes:', result.error);
      alert('Failed to load scenes: ' + (result.error || 'Unknown error'));
    }
  } catch (err) {
    console.error('Failed to load scenes:', err);
    // Show placeholder for now
    draw();
  }
}
</file>

<file path="mcp-server/src/visualizer/panel.js">
/**
 * Detail panel, inline editing, function viewer, and section management
 */

import {
  nodes, edges, selectedNode, setSelectedNode, esc,
  selectedSceneNode, setSelectedSceneNode,
  sceneNodeProperties, setSceneNodeProperties,
  expandedScene, scriptToScenes
} from './state.js';
import { sendCommand } from './websocket.js';
import { highlightGDScript } from './syntax.js';
import { draw } from './canvas.js';

let detailPanel;
let currentPanelMode = 'script'; // 'script' or 'sceneNode'

export function initPanel() {
  detailPanel = document.getElementById('detail-panel');
  initPanelResizing();
}

export function openPanel(node) {
  setSelectedNode(node);

  document.getElementById('panel-title').textContent = node.class_name || node.filename.replace('.gd', '');
  document.getElementById('panel-path').textContent = node.path;

  let html = '';

  // Description
  if (node.description) {
    html += `<div class="desc-block">${esc(node.description)}</div>`;
  }

  // Meta badges
  html += `<div class="meta-row">`;
  html += `<div class="meta-badge"><span>${node.line_count}</span> lines</div>`;
  html += `<div class="meta-badge">extends <span>${node.extends || 'Node'}</span></div>`;
  if (node.class_name) html += `<div class="meta-badge">class <span>${esc(node.class_name)}</span></div>`;
  html += `</div>`;
  
  // Scene usage (if this script is used in scenes)
  const usedInScenes = scriptToScenes[node.path];
  if (usedInScenes && usedInScenes.length > 0) {
    html += `<div class="section scene-usage-section">`;
    html += `<div class="section-header">Used in Scenes <span class="section-count">${usedInScenes.length}</span></div>`;
    html += `<ul class="item-list scene-list">`;
    for (const scene of usedInScenes) {
      html += `<li class="scene-link" onclick="jumpToScene('${esc(scene.path)}')">`;
      html += `<span class="scene-icon">📦</span>`;
      html += `<span class="scene-name">${esc(scene.name)}</span>`;
      html += `</li>`;
    }
    html += `</ul>`;
    html += `</div>`;
  }

  // Variables - split into @export and regular
  const exportVars = (node.variables || []).filter(v => v.exported);
  const regularVars = (node.variables || []).filter(v => !v.exported);

  // Exports section (always show for adding)
  html += `<div class="section">`;
  html += `<div class="section-header">Exports <span class="section-count">${exportVars.length}</span></div>`;
  html += `<ul class="item-list" id="exports-list">`;
  for (let vi = 0; vi < exportVars.length; vi++) {
    const v = exportVars[vi];
    html += `<li data-var-index="${vi}" data-exported="true">`;
    html += `<span class="exp">@export</span> `;
    html += `<span class="kw">var</span> `;
    html += `<span class="editable var-name" contenteditable="true" data-field="name" data-original="${esc(v.name)}">${esc(v.name)}</span>`;
    html += `<span class="ret">:</span> `;
    html += `<span class="tp editable var-type" contenteditable="true" data-field="type" data-placeholder="Type" data-original="${esc(v.type || '')}">${esc(v.type || '')}</span>`;
    html += ` <span class="ret">=</span> `;
    html += `<span class="num editable var-default" contenteditable="true" data-field="default" data-placeholder="value" data-original="${esc(v.default || '')}">${esc(v.default || '')}</span>`;
    html += `<span class="item-actions">`;
    html += `<button class="delete" onclick="showDeleteUsages(${vi}, true, 'variable')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewVariable(true)">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add export</div>`;
  html += `</div>`;

  // Variables section (always show for adding)
  html += `<div class="section">`;
  html += `<div class="section-header">Variables <span class="section-count">${regularVars.length}</span></div>`;
  html += `<ul class="item-list" id="vars-list">`;
  for (let vi = 0; vi < regularVars.length; vi++) {
    const v = regularVars[vi];
    html += `<li data-var-index="${vi}" data-exported="false" data-onready="${v.onready || false}">`;
    if (v.onready) {
      html += `<span class="onready-badge" onclick="toggleOnready(${vi}, false)" title="Click to toggle @onready">@onready</span>`;
    }
    html += `<span class="kw">var</span> `;
    html += `<span class="editable var-name" contenteditable="true" data-field="name" data-original="${esc(v.name)}">${esc(v.name)}</span>`;
    html += `<span class="ret">:</span> `;
    html += `<span class="tp editable var-type" contenteditable="true" data-field="type" data-placeholder="Type" data-original="${esc(v.type || '')}">${esc(v.type || '')}</span>`;
    html += ` <span class="ret">=</span> `;
    html += `<span class="num editable var-default" contenteditable="true" data-field="default" data-placeholder="value" data-original="${esc(v.default || '')}">${esc(v.default || '')}</span>`;
    html += `<span class="item-actions">`;
    if (!v.onready) {
      html += `<button onclick="toggleOnready(${vi}, false)" title="Add @onready" style="font-size:9px;width:auto;padding:0 4px;">⏱</button>`;
    }
    html += `<button class="delete" onclick="showDeleteUsages(${vi}, false, 'variable')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewVariable(false)">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add variable</div>`;
  html += `</div>`;

  // Functions
  if ((node.functions || []).length > 0) {
    html += `<div class="section">`;
    html += `<div class="section-header">Functions <span class="section-count">${node.functions.length}</span></div>`;
    html += `<ul class="item-list">`;
    for (let fi = 0; fi < node.functions.length; fi++) {
      const f = node.functions[fi];
      html += `<li class="clickable" onclick="toggleFunc(${fi})">`;
      html += `<span class="kw">func</span> <span class="fn">${esc(f.name)}</span>`;
      html += `<span class="param">(${esc(f.params)})</span>`;
      if (f.return_type) html += ` <span class="ret">&rarr;</span> <span class="tp">${esc(f.return_type)}</span>`;
      html += `<span style="margin-left:auto;display:flex;gap:4px;align-items:center">`;
      if (f.body_lines) html += `<span class="tag tag-lines">${f.body_lines}L</span>`;
      html += `<button class="delete" onclick="event.stopPropagation();showDeleteUsages(${fi}, false, 'function')" title="Delete function" style="opacity:0">×</button>`;
      html += `</span>`;
      html += `</li>`;
      html += `<div id="func-viewer-${fi}" class="func-viewer" style="display:none"></div>`;
    }
    html += `</ul></div>`;
  }

  // Signals section (always show for adding)
  const signalsList = node.signals || [];
  html += `<div class="section">`;
  html += `<div class="section-header">Signals <span class="section-count">${signalsList.length}</span></div>`;
  html += `<ul class="item-list" id="signals-list">`;
  for (let si = 0; si < signalsList.length; si++) {
    const s = signalsList[si];
    const sigName = typeof s === 'string' ? s : s.name;
    const sigParams = typeof s === 'object' ? s.params : '';
    html += `<li data-signal-index="${si}">`;
    html += `<span class="kw">signal</span> `;
    html += `<span class="sig editable signal-name" contenteditable="true" data-field="name" data-original="${esc(sigName)}">${esc(sigName)}</span>`;
    html += `<span class="param">(</span>`;
    html += `<span class="editable signal-params" contenteditable="true" data-field="params" data-placeholder="params" data-original="${esc(sigParams)}">${esc(sigParams)}</span>`;
    html += `<span class="param">)</span>`;
    html += `<span class="item-actions">`;
    html += `<button class="delete" onclick="showDeleteUsages(${si}, false, 'signal')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewSignal()">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add signal</div>`;
  html += `</div>`;

  // Connections - group by target and show signal names
  const related = edges.filter(e => e.from === node.path || e.to === node.path);
  if (related.length > 0) {
    // Group connections by target and type
    const connGroups = {};
    for (const e of related) {
      const other = e.from === node.path ? e.to : e.from;
      const dir = e.from === node.path ? 'out' : 'in';
      const key = `${other}-${e.type}-${dir}`;
      if (!connGroups[key]) {
        connGroups[key] = { other, type: e.type, dir, signals: [] };
      }
      if (e.signal_name) connGroups[key].signals.push(e.signal_name);
    }

    html += `<div class="section">`;
    html += `<div class="section-header">Connections <span class="section-count">${related.length}</span></div>`;
    html += `<ul class="item-list">`;

    for (const key of Object.keys(connGroups)) {
      const g = connGroups[key];
      const dirIcon = g.dir === 'out' ? '→' : '←';
      const color = g.type === 'extends' ? 'var(--edge-extends)' : g.type === 'preload' ? 'var(--edge-preload)' : 'var(--edge-signal)';
      const filename = g.other.split('/').pop();

      html += `<li style="flex-wrap:wrap">`;
      html += `${dirIcon} <span style="color:${color}">${esc(filename)}</span> <span class="ret">(${g.type})</span>`;

      // Show signal names if this is a signal connection
      if (g.type === 'signal' && g.signals.length > 0) {
        const uniqueSignals = [...new Set(g.signals)];
        html += `<div style="width:100%;margin-top:4px;padding-left:20px;font-size:11px;color:var(--text-muted)">`;
        html += uniqueSignals.map(s => `<span class="sig">${esc(s)}</span>`).join(', ');
        html += `</div>`;
      }
      html += `</li>`;
    }
    html += `</ul></div>`;
  }

  // Preloads
  if ((node.preloads || []).length > 0) {
    html += `<div class="section">`;
    html += `<div class="section-header">Preloads <span class="section-count">${node.preloads.length}</span></div>`;
    html += `<ul class="item-list">`;
    for (const p of node.preloads) {
      html += `<li><span class="str">"${esc(p)}"</span></li>`;
    }
    html += `</ul></div>`;
  }

  document.getElementById('panel-body').innerHTML = html;
  detailPanel.classList.add('open');
  initSectionResizing();
  initInlineEditing();
  draw();
}

export function closePanel() {
  setSelectedNode(null);
  detailPanel.classList.remove('open');
  draw();
}

// Make closePanel available globally for onclick
window.closePanel = closePanel;

// Toggle function body viewer with inline editing
window.toggleFunc = function (fi) {
  const viewer = document.getElementById(`func-viewer-${fi}`);
  if (!viewer) return;

  if (viewer.style.display !== 'none') {
    viewer.style.display = 'none';
    viewer.innerHTML = '';
    return;
  }

  const f = selectedNode.functions[fi];
  if (!f.body) return;

  const editorId = `code-editor-${fi}`;

  viewer.innerHTML = `
    <div class="func-viewer-header">
      <span><span class="func-title">${esc(f.name)}</span> · <span id="line-count-${fi}">${f.body.split('\n').length}</span> lines</span>
      <button class="func-viewer-close" onclick="toggleFunc(${fi})">&times;</button>
    </div>
    <div class="func-viewer-code">
      <div class="code-editor-container" id="${editorId}">
        <div class="code-editor-highlight" id="highlight-${fi}"></div>
        <textarea class="code-editor-textarea" id="textarea-${fi}" spellcheck="false"></textarea>
      </div>
    </div>
    <div class="func-viewer-footer">
      <span class="status" id="status-${fi}">Modified</span>
      <span style="display:flex;gap:8px;align-items:center">
        <span style="opacity:0.6">Ctrl+S to save</span>
        <button class="save-btn" id="save-btn-${fi}" onclick="saveFunction(${fi})">Save</button>
      </span>
    </div>
  `;

  const textarea = document.getElementById(`textarea-${fi}`);
  const highlight = document.getElementById(`highlight-${fi}`);
  const statusEl = document.getElementById(`status-${fi}`);
  const saveBtn = document.getElementById(`save-btn-${fi}`);
  const lineCountEl = document.getElementById(`line-count-${fi}`);

  // Store original code for comparison
  textarea.dataset.original = f.body;
  textarea.dataset.funcIndex = fi;
  textarea.dataset.scriptPath = selectedNode.path;
  textarea.dataset.funcName = f.name;
  textarea.value = f.body;

  // Initial highlight
  updateHighlight(fi);

  // Sync highlight on input
  textarea.addEventListener('input', () => {
    updateHighlight(fi);
    const modified = textarea.value !== textarea.dataset.original;
    statusEl.classList.toggle('visible', modified);
    saveBtn.classList.toggle('active', modified);
    lineCountEl.textContent = textarea.value.split('\n').length;
  });

  // Sync scroll
  textarea.addEventListener('scroll', () => {
    highlight.style.transform = `translate(-${textarea.scrollLeft}px, -${textarea.scrollTop}px)`;
  });

  // Handle tab key
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      textarea.value = textarea.value.substring(0, start) + '\t' + textarea.value.substring(end);
      textarea.selectionStart = textarea.selectionEnd = start + 1;
      textarea.dispatchEvent(new Event('input'));
    }
    // Ctrl+S to save
    if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      saveFunction(fi);
    }
  });

  // Auto-resize textarea height
  function autoResize() {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
    highlight.style.height = textarea.scrollHeight + 'px';
  }
  textarea.addEventListener('input', autoResize);
  setTimeout(autoResize, 0);

  viewer.style.display = 'block';
};

// Update syntax highlighting
function updateHighlight(fi) {
  const textarea = document.getElementById(`textarea-${fi}`);
  const highlight = document.getElementById(`highlight-${fi}`);
  if (!textarea || !highlight) return;

  // Highlight each line, wrap in spans for line-level highlighting
  const lines = textarea.value.split('\n');
  highlight.innerHTML = lines.map((line, i) =>
    `<div class="code-line" data-line="${i}">${highlightGDScript(line) || ' '}</div>`
  ).join('');
}

// Save function changes back to Godot
window.saveFunction = async function (fi) {
  const textarea = document.getElementById(`textarea-${fi}`);
  const statusEl = document.getElementById(`status-${fi}`);
  const saveBtn = document.getElementById(`save-btn-${fi}`);

  if (!textarea || textarea.value === textarea.dataset.original) return;

  const scriptPath = textarea.dataset.scriptPath;
  const funcName = textarea.dataset.funcName;
  const newCode = textarea.value;

  statusEl.textContent = 'Saving...';
  statusEl.classList.add('visible');

  try {
    // Send to Godot
    await sendCommand('modify_function', {
      path: scriptPath,
      name: funcName,
      body: newCode
    });

    // Update local state
    const funcIndex = parseInt(textarea.dataset.funcIndex);
    selectedNode.functions[funcIndex].body = newCode;
    selectedNode.functions[funcIndex].body_lines = newCode.split('\n').length;

    textarea.dataset.original = newCode;
    statusEl.textContent = 'Saved!';
    saveBtn.classList.remove('active');

    setTimeout(() => {
      statusEl.classList.remove('visible');
    }, 2000);

    console.log(`Saved function "${funcName}" in ${scriptPath}`);
  } catch (err) {
    statusEl.textContent = 'Error: ' + err.message;
    console.error('Failed to save:', err);
  }
};

// ---- Inline Editing for Variables/Signals ----
function initInlineEditing() {
  // Handle blur on editable fields - save changes
  document.querySelectorAll('.editable').forEach(el => {
    el.addEventListener('blur', handleInlineEdit);
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        el.blur();
      }
      if (e.key === 'Escape') {
        el.textContent = el.dataset.original || '';
        el.blur();
      }
    });
  });
}

async function handleInlineEdit(e) {
  const el = e.target;
  const li = el.closest('li');
  if (!li) return;

  const newValue = el.textContent.trim();
  const original = el.dataset.original || '';
  const field = el.dataset.field;

  if (newValue === original) return; // No change

  // Determine what type of item this is
  const isSignal = li.dataset.signalIndex !== undefined;
  const isExport = li.dataset.exported === 'true';
  const index = parseInt(isSignal ? li.dataset.signalIndex : li.dataset.varIndex);

  try {
    if (isSignal) {
      // Update signal
      const sig = selectedNode.signals[index];
      const oldName = typeof sig === 'string' ? sig : sig.name;
      const oldParams = typeof sig === 'object' ? sig.params : '';

      const newSig = {
        name: field === 'name' ? newValue : oldName,
        params: field === 'params' ? newValue : oldParams
      };

      // Send to Godot
      await sendCommand('modify_signal', {
        path: selectedNode.path,
        action: 'update',
        old_name: oldName,
        name: newSig.name,
        params: newSig.params
      });

      // Update local state
      selectedNode.signals[index] = newSig;
      console.log(`Updated signal in ${selectedNode.path}:`, newSig);
    } else {
      // Update variable
      const vars = selectedNode.variables.filter(v => v.exported === isExport);
      const v = vars[index];
      const actualIndex = selectedNode.variables.findIndex(vr => vr.name === v.name);

      if (actualIndex !== -1) {
        const newVar = { ...selectedNode.variables[actualIndex] };
        if (field === 'name') newVar.name = newValue;
        if (field === 'type') newVar.type = newValue;
        if (field === 'default') newVar.default = newValue;

        // Send to Godot
        await sendCommand('modify_variable', {
          path: selectedNode.path,
          action: 'update',
          old_name: v.name,
          name: newVar.name,
          type: newVar.type,
          default: newVar.default,
          exported: isExport
        });

        // Update local state
        selectedNode.variables[actualIndex] = newVar;
        console.log(`Updated variable in ${selectedNode.path}:`, newVar);
      }
    }

    // Update the original value
    el.dataset.original = newValue;
  } catch (err) {
    console.error('Failed to update:', err);
    // Revert on error
    el.textContent = original;
    alert('Failed to save: ' + err.message);
  }
}

// ---- Toggle @onready ----
window.toggleOnready = async function (index, isExport) {
  const vars = selectedNode.variables.filter(v => v.exported === isExport);
  const v = vars[index];
  const actualIndex = selectedNode.variables.findIndex(vr => vr.name === v.name);

  if (actualIndex === -1) return;

  const newOnready = !v.onready;

  try {
    await sendCommand('modify_variable', {
      path: selectedNode.path,
      action: 'update',
      old_name: v.name,
      name: v.name,
      type: v.type || '',
      default: v.default || '',
      exported: isExport,
      onready: newOnready
    });

    selectedNode.variables[actualIndex].onready = newOnready;
    openPanel(selectedNode);
  } catch (err) {
    console.error('Failed to toggle @onready:', err);
    alert('Failed to update: ' + err.message);
  }
};

// ---- Add New Items ----
window.addNewVariable = async function (isExport) {
  const newVar = { name: 'new_var', type: '', default: '', exported: isExport };

  try {
    // Send to Godot first
    await sendCommand('modify_variable', {
      path: selectedNode.path,
      action: 'add',
      name: newVar.name,
      type: newVar.type,
      default: newVar.default,
      exported: isExport
    });

    // Update local state
    selectedNode.variables.push(newVar);
    openPanel(selectedNode);

    // Focus the new variable name after panel refresh
    setTimeout(() => {
      const list = document.getElementById(isExport ? 'exports-list' : 'vars-list');
      const lastItem = list?.querySelector('li:last-of-type .var-name');
      if (lastItem) {
        lastItem.focus();
        const range = document.createRange();
        range.selectNodeContents(lastItem);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }, 50);
  } catch (err) {
    console.error('Failed to add variable:', err);
    alert('Failed to add variable: ' + err.message);
  }
};

window.addNewSignal = async function () {
  const newSig = { name: 'new_signal', params: '' };

  try {
    // Send to Godot first
    await sendCommand('modify_signal', {
      path: selectedNode.path,
      action: 'add',
      name: newSig.name,
      params: newSig.params
    });

    // Update local state
    if (!selectedNode.signals) selectedNode.signals = [];
    selectedNode.signals.push(newSig);
    openPanel(selectedNode);

    setTimeout(() => {
      const list = document.getElementById('signals-list');
      const lastItem = list?.querySelector('li:last-of-type .signal-name');
      if (lastItem) {
        lastItem.focus();
        const range = document.createRange();
        range.selectNodeContents(lastItem);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }, 50);
  } catch (err) {
    console.error('Failed to add signal:', err);
    alert('Failed to add signal: ' + err.message);
  }
};

// Section resizing
let resizingList = null;
let resizeStartY = 0;
let resizeStartHeight = 0;

function initSectionResizing() {
  document.querySelectorAll('.section-resize-handle').forEach(handle => {
    // Remove old listeners
    handle.replaceWith(handle.cloneNode(true));
  });

  document.querySelectorAll('.section-resize-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();

      // Find the item-list in this section
      const section = handle.closest('.section');
      resizingList = section?.querySelector('.item-list');
      if (!resizingList) return;

      section.classList.add('resizing');
      resizeStartY = e.clientY;
      resizeStartHeight = resizingList.offsetHeight;

      document.addEventListener('mousemove', onSectionResize);
      document.addEventListener('mouseup', onSectionResizeEnd);
    });
  });
}

function onSectionResize(e) {
  if (!resizingList) return;
  const dy = e.clientY - resizeStartY;
  const newHeight = Math.max(50, Math.min(500, resizeStartHeight + dy));
  resizingList.style.maxHeight = newHeight + 'px';
}

function onSectionResizeEnd() {
  if (resizingList) {
    const section = resizingList.closest('.section');
    section?.classList.remove('resizing');
    resizingList = null;
  }
  document.removeEventListener('mousemove', onSectionResize);
  document.removeEventListener('mouseup', onSectionResizeEnd);
}

// Panel horizontal resizing
let panelResizing = false;
let panelResizeStartX = 0;
let panelStartWidth = 460;

function initPanelResizing() {
  const handle = document.getElementById('panel-resize-handle');
  const panel = document.getElementById('detail-panel');

  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    panelResizing = true;
    panel.classList.add('resizing');
    panelResizeStartX = e.clientX;
    panelStartWidth = panel.offsetWidth;

    document.addEventListener('mousemove', onPanelResize);
    document.addEventListener('mouseup', onPanelResizeEnd);
  });
}

function onPanelResize(e) {
  if (!panelResizing) return;
  const panel = document.getElementById('detail-panel');
  const dx = panelResizeStartX - e.clientX; // Dragging left = wider
  const newWidth = Math.max(300, Math.min(window.innerWidth * 0.8, panelStartWidth + dx));
  panel.style.width = newWidth + 'px';
  panel.style.right = '0';
}

function onPanelResizeEnd() {
  panelResizing = false;
  const panel = document.getElementById('detail-panel');
  panel.classList.remove('resizing');
  document.removeEventListener('mousemove', onPanelResize);
  document.removeEventListener('mouseup', onPanelResizeEnd);
}

// Function to expand and highlight a specific line in a function viewer
export function expandAndHighlightFunction(funcName, targetLine, nodeData) {
  const node = nodeData || selectedNode;

  // Find the function index
  const funcIndex = node.functions.findIndex(f => f.name === funcName);
  if (funcIndex === -1) {
    console.log('Function not found:', funcName);
    return;
  }

  console.log(`Expanding function ${funcName} (index ${funcIndex}) to line ${targetLine}`);

  // Get the function viewer element
  const viewer = document.getElementById(`func-viewer-${funcIndex}`);
  if (!viewer) {
    console.log('Viewer element not found for index:', funcIndex);
    return;
  }

  // Check if already expanded
  const isExpanded = viewer.style.display !== 'none';

  if (!isExpanded) {
    // Need to expand - call toggleFunc
    window.toggleFunc(funcIndex);
  }

  // Wait for expansion, then highlight
  setTimeout(() => {
    highlightLineInViewer(viewer, funcName, targetLine, node);
    // Scroll the viewer into view
    viewer.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }, isExpanded ? 100 : 300);
}

function highlightLineInViewer(viewer, funcName, targetLine, nodeData) {
  // Find the function to get its start line
  const node = nodeData || selectedNode;
  const func = node.functions.find(f => f.name === funcName);
  if (!func) {
    console.log('Function not found for highlighting:', funcName);
    return;
  }

  const funcStartLine = func.line || 1;
  const relativeLineIndex = targetLine - funcStartLine;

  console.log(`Highlighting line ${targetLine} in ${funcName} (start: ${funcStartLine}, relative: ${relativeLineIndex})`);

  // Find the highlight overlay within the viewer
  const highlightDiv = viewer.querySelector('.code-editor-highlight');
  if (!highlightDiv) {
    console.log('Highlight div not found in viewer');
    return;
  }

  // Clear all previous highlights
  document.querySelectorAll('.code-line-highlight').forEach(el => {
    el.classList.remove('code-line-highlight');
  });

  // Get all lines and highlight the target
  const lines = highlightDiv.querySelectorAll('.code-line');
  console.log(`Found ${lines.length} lines in viewer`);

  if (relativeLineIndex >= 0 && relativeLineIndex < lines.length) {
    const targetLineEl = lines[relativeLineIndex];
    targetLineEl.classList.add('code-line-highlight');

    // Scroll the line into view within the code editor
    setTimeout(() => {
      targetLineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 50);
  } else {
    console.log(`Line index ${relativeLineIndex} out of range (0-${lines.length - 1})`);
  }
}

// ============================================================================
// SCENE NODE PROPERTIES PANEL
// ============================================================================

export async function openSceneNodePanel(scenePath, node) {
  currentPanelMode = 'sceneNode';
  setSelectedSceneNode(node);

  // Show loading state
  document.getElementById('panel-title').textContent = node.name;
  document.getElementById('panel-path').textContent = `${node.type} • ${node.path}`;
  document.getElementById('panel-body').innerHTML = '<div class="loading-state">Loading properties...</div>';
  detailPanel.classList.add('open');

  try {
    // Fetch properties from Godot
    const result = await sendCommand('get_scene_node_properties', {
      scene_path: scenePath,
      node_path: node.path
    });

    if (result.ok) {
      setSceneNodeProperties(result);
      renderSceneNodePanel(result, scenePath, node);
    } else {
      document.getElementById('panel-body').innerHTML = `<div class="error-state">Failed to load properties: ${result.error}</div>`;
    }
  } catch (err) {
    console.error('Failed to fetch node properties:', err);
    document.getElementById('panel-body').innerHTML = `<div class="error-state">Error: ${err.message}</div>`;
  }
}

export function closeSceneNodePanel() {
  if (currentPanelMode === 'sceneNode') {
    setSelectedSceneNode(null);
    setSceneNodeProperties(null);
    detailPanel.classList.remove('open');
    draw();
  }
}

function renderSceneNodePanel(data, scenePath, node) {
  document.getElementById('panel-title').textContent = data.node_name;
  document.getElementById('panel-path').textContent = `${data.node_type} • ${data.node_path}`;

  let html = '';

  // Meta badges
  html += `<div class="meta-row">`;
  html += `<div class="meta-badge"><span>${data.node_type}</span></div>`;
  html += `<div class="meta-badge">${data.property_count} <span>properties</span></div>`;
  if (node.script) {
    html += `<div class="meta-badge script-badge" onclick="jumpToScript('${esc(node.script)}')">📜 <span>${node.script.split('/').pop()}</span></div>`;
  }
  html += `</div>`;

  // Render categories
  const categories = data.categories || {};
  const categoryOrder = data.inheritance_chain || Object.keys(categories);

  for (const category of categoryOrder) {
    const props = categories[category];
    if (!props || props.length === 0) continue;

    html += `<div class="section property-section" data-category="${esc(category)}">`;
    html += `<div class="section-header clickable" onclick="togglePropertySection(this)">`;
    html += `<span>${category}</span>`;
    html += `<span class="section-count">${props.length}</span>`;
    html += `</div>`;
    html += `<div class="property-list">`;

    for (const prop of props) {
      html += renderPropertyRow(prop, scenePath, data.node_path);
    }

    html += `</div></div>`;
  }

  document.getElementById('panel-body').innerHTML = html;
  initPropertyEditing(scenePath, data.node_path);
}

// Convert snake_case to Title Case for display
function formatPropertyName(name) {
  return name
    .replace(/_/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}

function renderPropertyRow(prop, scenePath, nodePath) {
  const { name, type, type_name, value, hint, hint_string } = prop;
  const displayName = formatPropertyName(name);

  let html = `<div class="property-row" data-prop="${esc(name)}" data-type="${type}">`;
  html += `<label class="property-name" title="${esc(name)}">${esc(displayName)}</label>`;
  html += `<div class="property-value">`;

  // Render appropriate control based on type
  switch (type) {
    case 1: // TYPE_BOOL
      const boolChecked = value === true ? 'checked' : '';
      html += `<label class="toggle-switch">
        <input type="checkbox" ${boolChecked} data-prop="${esc(name)}" data-type="${type}">
        <span class="toggle-slider"></span>
      </label>`;
      break;

    case 2: // TYPE_INT
      if (hint === 2 && hint_string) { // PROPERTY_HINT_ENUM
        html += renderEnumSelect(name, type, value, hint_string);
      } else if (hint === 1 && hint_string) { // PROPERTY_HINT_RANGE
        html += renderRangeSlider(name, type, value, hint_string, true);
      } else {
        html += `<input type="number" class="property-input" value="${value ?? 0}" step="1" data-prop="${esc(name)}" data-type="${type}">`;
      }
      break;

    case 3: // TYPE_FLOAT
      if (hint === 1 && hint_string) { // PROPERTY_HINT_RANGE
        html += renderRangeSlider(name, type, value, hint_string, false);
      } else {
        html += `<input type="number" class="property-input" value="${value ?? 0}" step="0.01" data-prop="${esc(name)}" data-type="${type}">`;
      }
      break;

    case 4: // TYPE_STRING
      html += `<input type="text" class="property-input" value="${esc(value || '')}" data-prop="${esc(name)}" data-type="${type}">`;
      break;

    case 5: // TYPE_VECTOR2
      html += renderVector2Input(name, type, value);
      break;

    case 6: // TYPE_VECTOR2I
      html += renderVector2Input(name, type, value, true);
      break;

    case 9: // TYPE_VECTOR3
      html += renderVector3Input(name, type, value);
      break;

    case 10: // TYPE_VECTOR3I
      html += renderVector3Input(name, type, value, true);
      break;

    case 20: // TYPE_COLOR
      html += renderColorInput(name, type, value);
      break;

    case 24: // TYPE_OBJECT (Resource)
      if (value && value.type === 'Resource') {
        html += `<span class="resource-path">${esc(value.path || 'null')}</span>`;
      } else {
        html += `<span class="resource-path">null</span>`;
      }
      break;

    default:
      // Display value as text for unsupported types
      const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value ?? 'null');
      html += `<span class="property-readonly">${esc(displayValue.substring(0, 50))}${displayValue.length > 50 ? '...' : ''}</span>`;
  }

  html += `</div></div>`;
  return html;
}

function renderEnumSelect(name, type, value, hintString) {
  const options = hintString.split(',').map(opt => {
    const parts = opt.split(':');
    return { value: parts.length > 1 ? parseInt(parts[0]) : opt.trim(), label: parts.length > 1 ? parts[1].trim() : opt.trim() };
  });

  let html = `<select class="property-select" data-prop="${esc(name)}" data-type="${type}">`;
  for (const opt of options) {
    const selected = opt.value === value ? 'selected' : '';
    html += `<option value="${opt.value}" ${selected}>${esc(opt.label)}</option>`;
  }
  html += `</select>`;
  return html;
}

function renderRangeSlider(name, type, value, hintString, isInt) {
  const parts = hintString.split(',');
  const min = parseFloat(parts[0]) || 0;
  const max = parseFloat(parts[1]) || 100;
  const step = parts[2] ? parseFloat(parts[2]) : (isInt ? 1 : 0.01);

  return `<div class="range-input-group">
    <input type="range" class="property-range" value="${value ?? min}" min="${min}" max="${max}" step="${step}" data-prop="${esc(name)}" data-type="${type}">
    <input type="number" class="property-input range-number" value="${value ?? min}" min="${min}" max="${max}" step="${step}" data-prop="${esc(name)}" data-type="${type}">
  </div>`;
}

function renderVector2Input(name, type, value, isInt = false) {
  const x = value?.x ?? 0;
  const y = value?.y ?? 0;
  const step = isInt ? '1' : '0.01';

  return `<div class="vector-input-group" data-prop="${esc(name)}" data-type="${type}">
    <label>x</label><input type="number" class="property-input vec-x" value="${x}" step="${step}" data-component="x">
    <label>y</label><input type="number" class="property-input vec-y" value="${y}" step="${step}" data-component="y">
  </div>`;
}

function renderVector3Input(name, type, value, isInt = false) {
  const x = value?.x ?? 0;
  const y = value?.y ?? 0;
  const z = value?.z ?? 0;
  const step = isInt ? '1' : '0.01';

  return `<div class="vector-input-group vec3" data-prop="${esc(name)}" data-type="${type}">
    <label>x</label><input type="number" class="property-input vec-x" value="${x}" step="${step}" data-component="x">
    <label>y</label><input type="number" class="property-input vec-y" value="${y}" step="${step}" data-component="y">
    <label>z</label><input type="number" class="property-input vec-z" value="${z}" step="${step}" data-component="z">
  </div>`;
}

function renderColorInput(name, type, value) {
  const r = Math.round((value?.r ?? 1) * 255);
  const g = Math.round((value?.g ?? 1) * 255);
  const b = Math.round((value?.b ?? 1) * 255);
  const a = value?.a ?? 1;
  const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;

  return `<div class="color-input-group" data-prop="${esc(name)}" data-type="${type}">
    <input type="color" class="property-color" value="${hex}" data-prop="${esc(name)}">
    <input type="number" class="property-input color-alpha" value="${a}" min="0" max="1" step="0.01" placeholder="α" data-component="a">
  </div>`;
}

function initPropertyEditing(scenePath, nodePath) {
  // Boolean toggles
  document.querySelectorAll('.property-row input[type="checkbox"]').forEach(el => {
    el.addEventListener('change', () => {
      const propName = el.dataset.prop;
      const value = el.checked;
      saveSceneNodeProperty(scenePath, nodePath, propName, value, parseInt(el.dataset.type));
    });
  });

  // Number and text inputs
  document.querySelectorAll('.property-row input.property-input:not(.vec-x):not(.vec-y):not(.vec-z):not(.color-alpha):not(.range-number)').forEach(el => {
    el.addEventListener('change', () => {
      const propName = el.dataset.prop;
      const type = parseInt(el.dataset.type);
      let value = el.value;
      if (type === 2 || type === 3) value = parseFloat(value);
      saveSceneNodeProperty(scenePath, nodePath, propName, value, type);
    });
  });

  // Select dropdowns
  document.querySelectorAll('.property-row select.property-select').forEach(el => {
    el.addEventListener('change', () => {
      const propName = el.dataset.prop;
      const type = parseInt(el.dataset.type);
      saveSceneNodeProperty(scenePath, nodePath, propName, parseInt(el.value), type);
    });
  });

  // Range sliders (sync with number input)
  document.querySelectorAll('.range-input-group').forEach(group => {
    const range = group.querySelector('input[type="range"]');
    const number = group.querySelector('input[type="number"]');

    range.addEventListener('input', () => {
      number.value = range.value;
    });
    range.addEventListener('change', () => {
      const propName = range.dataset.prop;
      const type = parseInt(range.dataset.type);
      saveSceneNodeProperty(scenePath, nodePath, propName, parseFloat(range.value), type);
    });
    number.addEventListener('change', () => {
      range.value = number.value;
      const propName = number.dataset.prop;
      const type = parseInt(number.dataset.type);
      saveSceneNodeProperty(scenePath, nodePath, propName, parseFloat(number.value), type);
    });
  });

  // Vector inputs
  document.querySelectorAll('.vector-input-group').forEach(group => {
    const propName = group.dataset.prop;
    const type = parseInt(group.dataset.type);
    const inputs = group.querySelectorAll('input');

    inputs.forEach(input => {
      input.addEventListener('change', () => {
        const x = parseFloat(group.querySelector('.vec-x').value);
        const y = parseFloat(group.querySelector('.vec-y').value);
        const zInput = group.querySelector('.vec-z');
        const value = zInput ? { x, y, z: parseFloat(zInput.value) } : { x, y };
        saveSceneNodeProperty(scenePath, nodePath, propName, value, type);
      });
    });
  });

  // Color inputs
  document.querySelectorAll('.color-input-group').forEach(group => {
    const propName = group.dataset.prop;
    const type = parseInt(group.dataset.type);
    const colorInput = group.querySelector('input[type="color"]');
    const alphaInput = group.querySelector('.color-alpha');

    const saveColor = () => {
      const hex = colorInput.value;
      const r = parseInt(hex.substr(1, 2), 16) / 255;
      const g = parseInt(hex.substr(3, 2), 16) / 255;
      const b = parseInt(hex.substr(5, 2), 16) / 255;
      const a = parseFloat(alphaInput.value);
      saveSceneNodeProperty(scenePath, nodePath, propName, { r, g, b, a }, type);
    };

    colorInput.addEventListener('change', saveColor);
    alphaInput.addEventListener('change', saveColor);
  });
}

async function saveSceneNodeProperty(scenePath, nodePath, propName, value, valueType) {
  console.log(`Saving property: ${propName} =`, value);

  try {
    const result = await sendCommand('set_scene_node_property', {
      scene_path: scenePath,
      node_path: nodePath,
      property_name: propName,
      value: value,
      value_type: valueType
    });

    if (result.ok) {
      console.log(`Property ${propName} saved successfully`);
    } else {
      console.error('Failed to save property:', result.error);
      alert('Failed to save: ' + (result.error || 'Unknown error'));
    }
  } catch (err) {
    console.error('Failed to save property:', err);
    alert('Failed to save: ' + err.message);
  }
}

// Toggle property section visibility
window.togglePropertySection = function(header) {
  const section = header.closest('.property-section');
  section.classList.toggle('collapsed');
};

// Jump to script in scripts view
window.jumpToScript = function(scriptPath) {
  // Switch to scripts view and select the script
  window.switchView('scripts');
  // Find and select the node
  const scriptNode = nodes.find(n => n.path === scriptPath);
  if (scriptNode) {
    setTimeout(() => openPanel(scriptNode), 100);
  }
};

// Jump to scene in scenes view
window.jumpToScene = function(scenePath) {
  // Switch to scenes view and expand the scene
  closePanel();
  window.switchView('scenes');
  // Trigger scene expansion after view switch
  setTimeout(() => {
    window.expandSceneFromPanel && window.expandSceneFromPanel(scenePath);
  }, 100);
};
</file>

<file path="mcp-server/src/visualizer/state.js">
/**
 * Shared state and constants for the visualizer
 */

// Project data injected at build time
export const PROJECT_DATA = "%%PROJECT_DATA%%";

// Node dimensions
export const NODE_W = 200;
export const NODE_H = 54;

// Camera state
export const camera = { x: 0, y: 0, zoom: 1 };
export let defaultZoom = 1;

export function setDefaultZoom(value) {
  defaultZoom = value;
}

// Viewport dimensions
export let W = 0;
export let H = 0;

export function setDimensions(width, height) {
  W = width;
  H = height;
}

// Interaction state
export let dragging = null;
export let hoveredNode = null;
export let selectedNode = null;
export let searchTerm = '';

export function setDragging(value) {
  dragging = value;
}

export function setHoveredNode(value) {
  hoveredNode = value;
}

export function setSelectedNode(value) {
  selectedNode = value;
}

export function setSearchTerm(value) {
  searchTerm = value;
}

// Folder color mapping
const FOLDER_COLORS = [
  '#d4a27f', '#7aa2f7', '#a6e3a1', '#f38ba8', '#89dceb',
  '#fab387', '#cba6f7', '#f9e2af', '#94e2d5', '#eba0ac'
];

const folderColorMap = {};
let folderColorIdx = 0;

export function getFolderColor(folder) {
  if (!folder) return FOLDER_COLORS[0];
  if (!folderColorMap[folder]) {
    folderColorMap[folder] = FOLDER_COLORS[folderColorIdx % FOLDER_COLORS.length];
    folderColorIdx++;
  }
  return folderColorMap[folder];
}

// Initialize nodes from project data
export const nodes = PROJECT_DATA.nodes.map((n, i) => ({
  ...n,
  x: 0,
  y: 0,
  color: getFolderColor(n.folder),
  highlighted: true,
  visible: true
}));

export const edges = PROJECT_DATA.edges;

// View state
export let currentView = 'scripts';
export let sceneData = null;

// Scene view state
export let expandedScene = null;        // The scene currently expanded (path)
export let expandedSceneHierarchy = null; // Full hierarchy of expanded scene
export let selectedSceneNode = null;    // Currently selected node in scene tree
export let hoveredSceneNode = null;     // Node being hovered over
export let sceneNodeProperties = null;  // Properties of selected scene node

// Scene positions (for scene cards in overview)
export const scenePositions = {};

export function setCurrentView(view) {
  currentView = view;
  // Clear scene-specific state when switching views
  if (view === 'scripts') {
    expandedScene = null;
    expandedSceneHierarchy = null;
    selectedSceneNode = null;
    hoveredSceneNode = null;
    sceneNodeProperties = null;
  }
}

// Script to scenes mapping (which scripts are used in which scenes)
export const scriptToScenes = {};

export function setSceneData(data) {
  sceneData = data;
  
  // Build script-to-scenes mapping
  for (const key in scriptToScenes) {
    delete scriptToScenes[key];
  }
  
  if (data && data.scenes) {
    for (const scene of data.scenes) {
      const sceneName = scene.name || scene.path.split('/').pop().replace('.tscn', '');
      if (scene.scripts) {
        for (const scriptPath of scene.scripts) {
          if (!scriptToScenes[scriptPath]) {
            scriptToScenes[scriptPath] = [];
          }
          scriptToScenes[scriptPath].push({
            path: scene.path,
            name: sceneName
          });
        }
      }
    }
  }
}

export function setExpandedScene(scenePath) {
  expandedScene = scenePath;
  if (!scenePath) {
    expandedSceneHierarchy = null;
    selectedSceneNode = null;
    hoveredSceneNode = null;
    sceneNodeProperties = null;
  }
}

export function setExpandedSceneHierarchy(hierarchy) {
  expandedSceneHierarchy = hierarchy;
}

export function setSelectedSceneNode(node) {
  selectedSceneNode = node;
  sceneNodeProperties = null; // Clear until loaded
}

export function setHoveredSceneNode(node) {
  hoveredSceneNode = node;
}

export function setSceneNodeProperties(props) {
  sceneNodeProperties = props;
}

export function setScenePosition(scenePath, x, y) {
  scenePositions[scenePath] = { x, y };
}

// Delete operation state
export let pendingDelete = null;
export let currentUsages = [];

export function setPendingDelete(value) {
  pendingDelete = value;
}

export function setCurrentUsages(value) {
  currentUsages = value;
}

// Utility function
export function esc(s) {
  return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
</file>

<file path="mcp-server/src/visualizer/syntax.js">
/**
 * GDScript syntax highlighting (Godot 4 colors)
 * Uses a tokenizer approach to avoid regex conflicts
 */

const GD_KEYWORDS = new Set([
  'var', 'func', 'signal', 'class_name', 'extends', 'class', 'enum', 'const',
  'if', 'elif', 'else', 'for', 'while', 'match', 'break', 'continue', 'pass', 'return',
  'and', 'or', 'not', 'in', 'is', 'as', 'self', 'super', 'true', 'false', 'null',
  'void', 'await', 'yield', 'static', 'preload', 'load'
]);

const GD_TYPES = new Set([
  'int', 'float', 'bool', 'String', 'Vector2', 'Vector3', 'Vector4',
  'Color', 'Array', 'Dictionary', 'Object', 'Node', 'Node2D', 'Node3D',
  'Control', 'Resource', 'Variant', 'void'
]);

export function highlightGDScript(code) {
  const tokens = [];
  let i = 0;

  while (i < code.length) {
    const ch = code[i];
    const rest = code.slice(i);

    // Comments
    if (ch === '#') {
      const end = code.indexOf('\n', i);
      const comment = end === -1 ? code.slice(i) : code.slice(i, end);
      tokens.push({ type: 'comment', text: comment });
      i += comment.length;
      continue;
    }

    // Strings
    if (ch === '"' || ch === "'") {
      let j = i + 1;
      while (j < code.length && code[j] !== ch) {
        if (code[j] === '\\') j++; // skip escaped char
        j++;
      }
      const str = code.slice(i, j + 1);
      tokens.push({ type: 'string', text: str });
      i = j + 1;
      continue;
    }

    // Annotations (@export, @onready, etc.)
    if (ch === '@') {
      const match = rest.match(/^@\w+/);
      if (match) {
        tokens.push({ type: 'annotation', text: match[0] });
        i += match[0].length;
        continue;
      }
    }

    // Arrow ->
    if (rest.startsWith('->')) {
      tokens.push({ type: 'arrow', text: '->' });
      i += 2;
      continue;
    }

    // Numbers
    if (/\d/.test(ch)) {
      const match = rest.match(/^\d+\.?\d*/);
      if (match) {
        tokens.push({ type: 'number', text: match[0] });
        i += match[0].length;
        continue;
      }
    }

    // Words (identifiers, keywords, types, function calls)
    if (/[a-zA-Z_]/.test(ch)) {
      const match = rest.match(/^[a-zA-Z_]\w*/);
      if (match) {
        const word = match[0];
        const afterWord = code.slice(i + word.length);
        const isCallable = /^\s*\(/.test(afterWord); // followed by (

        let type = 'identifier'; // default: white for variables
        if (GD_KEYWORDS.has(word)) type = 'keyword';
        else if (GD_TYPES.has(word) || /^[A-Z]/.test(word)) type = 'type';
        else if (isCallable) type = 'function'; // function/method calls

        tokens.push({ type, text: word });
        i += word.length;
        continue;
      }
    }

    // Everything else (operators, punctuation, whitespace)
    tokens.push({ type: 'plain', text: ch });
    i++;
  }

  // Convert tokens to HTML with Godot-like colors
  return tokens.map(t => {
    const escaped = t.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    switch (t.type) {
      case 'keyword': return `<span style="color:#FF7085">${escaped}</span>`; // Pink/red
      case 'type': return `<span style="color:#8EFFDA">${escaped}</span>`; // Teal/mint
      case 'function': return `<span style="color:#66E6FF">${escaped}</span>`; // Cyan (function calls)
      case 'string': return `<span style="color:#FFE566">${escaped}</span>`; // Yellow
      case 'number': return `<span style="color:#A3FFB4">${escaped}</span>`; // Green
      case 'comment': return `<span style="color:#9A9EA6">${escaped}</span>`; // Gray
      case 'annotation': return `<span style="color:#FFB373">${escaped}</span>`; // Orange
      case 'arrow': return `<span style="color:#ABC8FF">${escaped}</span>`; // Light blue
      case 'identifier': return `<span style="color:#CDCFD2">${escaped}</span>`; // White/light gray (variables)
      default: return escaped;
    }
  }).join('');
}
</file>

<file path="mcp-server/src/visualizer/template.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Godot Project Map</title>
<style>
%%CSS%%
</style>
</head>
<body>
<div id="search-bar">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
  <input type="text" id="search" placeholder="Search scripts..." />
  <span class="stats" id="stats"></span>
</div>

<div id="legend">
  <div class="item"><div class="line" style="background:var(--edge-extends)"></div> extends</div>
  <div class="item"><div class="line" style="background:var(--edge-preload)"></div> preload</div>
  <div class="item"><div class="line" style="background:var(--edge-signal);height:0;border-top:2px dotted var(--edge-signal)"></div> signal</div>
</div>

<div id="zoom-indicator" title="Click to reset, or type custom zoom">
  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="2" onclick="resetZoom()" style="cursor:pointer"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/><path d="M8 11h6"/><path d="M11 8v6"/></svg>
  <input type="text" class="zoom-input" id="zoom-text" value="100%" onchange="setCustomZoom(this.value)" onkeydown="if(event.key==='Enter'){this.blur()}" onclick="this.select()">
</div>

<div id="detail-panel">
  <div id="panel-resize-handle"></div>
  <div class="panel-header">
    <button class="close-btn" onclick="closePanel()">&times;</button>
    <h2 id="panel-title"></h2>
    <div class="path" id="panel-path"></div>
  </div>
  <div class="panel-body" id="panel-body"></div>
</div>

<!-- View Tabs -->
<div id="view-tabs">
  <button class="active" onclick="switchView('scripts')">Scripts</button>
  <button onclick="switchView('scenes')">Scenes</button>
</div>

<!-- Scene Back Button (shown when scene is expanded) -->
<div id="scene-back-btn" style="display:none" onclick="goBackToSceneOverview()">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M19 12H5M12 19l-7-7 7-7"/>
  </svg>
  <span>← Back to Scenes</span>
  <span class="scene-name"></span>
</div>

<!-- Context Menu (Scripts) -->
<div id="context-menu">
  <div class="menu-item" onclick="createNewScript()">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
      <polyline points="14,2 14,8 20,8"/>
      <line x1="12" y1="18" x2="12" y2="12"/>
      <line x1="9" y1="15" x2="15" y2="15"/>
    </svg>
    New Script
  </div>
  <div class="menu-divider"></div>
  <div class="menu-item" onclick="refreshProject()">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M23 4v6h-6M1 20v-6h6"/>
      <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
    </svg>
    Refresh
  </div>
  <div class="menu-item" onclick="resetLayout()">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="3" y="3" width="7" height="7"/>
      <rect x="14" y="3" width="7" height="7"/>
      <rect x="14" y="14" width="7" height="7"/>
      <rect x="3" y="14" width="7" height="7"/>
    </svg>
    Reset Layout
  </div>
</div>

<!-- Context Menu (Scene Nodes) -->
<div id="scene-context-menu">
  <div class="menu-item" onclick="sceneNodeAction('add_child')">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="10"/>
      <line x1="12" y1="8" x2="12" y2="16"/>
      <line x1="8" y1="12" x2="16" y2="12"/>
    </svg>
    Add Child Node
  </div>
  <div class="menu-item" onclick="sceneNodeAction('rename')">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
    </svg>
    Rename
  </div>
  <div class="menu-item" onclick="sceneNodeAction('duplicate')">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
    </svg>
    Duplicate
  </div>
  <div class="menu-divider"></div>
  <div class="menu-item" onclick="sceneNodeAction('move_up')">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="18 15 12 9 6 15"/>
    </svg>
    Move Up
  </div>
  <div class="menu-item" onclick="sceneNodeAction('move_down')">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="6 9 12 15 18 9"/>
    </svg>
    Move Down
  </div>
  <div class="menu-divider"></div>
  <div class="menu-item danger" onclick="sceneNodeAction('delete')">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="3 6 5 6 21 6"/>
      <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
    </svg>
    Delete
  </div>
</div>

<!-- Floating Usage Panel -->
<div id="usage-float-panel">
  <div class="ufp-header" id="ufp-header">
    <div class="ufp-info">
      <div class="ufp-title" id="ufp-title">⚠ Delete Variable</div>
      <div class="ufp-count" id="ufp-count"></div>
    </div>
    <div class="ufp-buttons">
      <button class="refresh-btn" onclick="refreshUsages()" title="Re-scan for usages">↻</button>
      <button class="close-btn" onclick="closeUsagePanel()" title="Cancel">×</button>
    </div>
  </div>
  <div class="ufp-list" id="ufp-list"></div>
  <div class="ufp-actions">
    <button class="cancel" onclick="closeUsagePanel()">Cancel</button>
    <button class="delete" id="ufp-delete-btn">Delete Anyway</button>
  </div>
  <div class="ufp-resize" id="ufp-resize"></div>
</div>

<!-- New Script Modal -->
<div id="new-script-modal" class="modal" style="display:none">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Create New Script</h3>
      <button class="close-btn" onclick="closeNewScriptModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Script Path</label>
        <input type="text" id="new-script-path" placeholder="res://scripts/my_script.gd">
      </div>
      <div class="form-group">
        <label>Extends</label>
        <select id="new-script-extends">
          <option value="Node">Node</option>
          <option value="Node2D">Node2D</option>
          <option value="Node3D">Node3D</option>
          <option value="CharacterBody2D">CharacterBody2D</option>
          <option value="CharacterBody3D">CharacterBody3D</option>
          <option value="RigidBody2D">RigidBody2D</option>
          <option value="Area2D">Area2D</option>
          <option value="Control">Control</option>
          <option value="Resource">Resource</option>
          <option value="RefCounted">RefCounted</option>
        </select>
      </div>
      <div class="form-group">
        <label>Class Name (optional)</label>
        <input type="text" id="new-script-classname" placeholder="MyClass">
      </div>
    </div>
    <div class="modal-footer">
      <button class="cancel" onclick="closeNewScriptModal()">Cancel</button>
      <button class="confirm" onclick="submitNewScript()">Create</button>
    </div>
  </div>
</div>

<canvas id="canvas"></canvas>

<script>
%%SCRIPT%%
</script>
</body>
</html>
</file>

<file path="mcp-server/src/visualizer/usages.js">
/**
 * Usage detection, delete operations, and floating usage panel
 */

import {
  nodes, selectedNode, pendingDelete, setPendingDelete,
  currentUsages, setCurrentUsages, esc
} from './state.js';
import { sendCommand } from './websocket.js';
import { highlightGDScript } from './syntax.js';
import { openPanel, expandAndHighlightFunction } from './panel.js';

// ---- Delete with Floating Usage Panel ----
window.showDeleteUsages = async function (index, isExport, type) {
  // Get the item name
  let itemName = '';
  if (type === 'signal') {
    const sig = selectedNode.signals[index];
    itemName = typeof sig === 'string' ? sig : sig.name;
  } else if (type === 'function') {
    const func = selectedNode.functions[index];
    itemName = func?.name || '';
  } else {
    const vars = selectedNode.variables.filter(v => v.exported === isExport);
    itemName = vars[index]?.name || '';
  }

  // Store pending delete info and the declaring node
  setPendingDelete({ index, isExport, type, itemName, declaringNode: selectedNode });

  // Find usages with smart detection
  const usages = findUsagesSmart(itemName, type);
  setCurrentUsages(usages);

  if (usages.length === 0) {
    // No usages, delete directly
    await performDelete(index, isExport, type, itemName);
    return;
  }

  renderUsagePanel();
};

function renderUsagePanel() {
  if (!pendingDelete) return;
  const { itemName, type } = pendingDelete;

  const panel = document.getElementById('usage-float-panel');
  const titleEl = document.getElementById('ufp-title');
  const countEl = document.getElementById('ufp-count');
  const listEl = document.getElementById('ufp-list');
  const deleteBtn = document.getElementById('ufp-delete-btn');

  // Set title based on type
  const typeLabel = type === 'signal' ? 'Signal' : type === 'function' ? 'Function' : 'Variable';
  titleEl.innerHTML = `⚠ Delete ${typeLabel}: <span style="color:#f38ba8;font-weight:600">${itemName}</span>`;

  if (currentUsages.length === 0) {
    // All usages fixed! Can delete now
    countEl.innerHTML = `<span style="color:#a6e3a1">✓ All usages fixed! Safe to delete.</span>`;
    listEl.innerHTML = '<div style="padding: 30px; text-align: center; color: var(--text-muted);">No more usages found</div>';
    deleteBtn.textContent = 'Delete Now';
    deleteBtn.style.background = 'rgba(166, 227, 161, 0.2)';
    deleteBtn.style.color = '#a6e3a1';
    deleteBtn.style.borderColor = 'rgba(166, 227, 161, 0.4)';
  } else {
    countEl.innerHTML = `Found <span class="count-num">${currentUsages.length}</span> usage${currentUsages.length > 1 ? 's' : ''} — click to navigate`;

    listEl.innerHTML = currentUsages.map((u, i) => {
      const highlightedCode = highlightUsageInCode(u.code, itemName);
      const fileName = u.file.split('/').pop().replace('.gd', '');
      return `
        <div class="ufp-item"
             data-usage-index="${i}"
             data-file="${u.file}"
             data-line="${u.line}"
             data-func="${u.funcName || ''}"
             onclick="navigateToUsage(this)">
          <div class="ufp-loc">
            <span class="ufp-func">${u.funcName || 'unknown'}</span>
            <span class="ufp-line">line ${u.line}</span>
          </div>
          <div class="ufp-code">${highlightedCode}</div>
          <div class="ufp-file">${fileName}.gd</div>
        </div>
      `;
    }).join('');
    deleteBtn.textContent = 'Delete Anyway';
    deleteBtn.style.background = '';
    deleteBtn.style.color = '';
    deleteBtn.style.borderColor = '';
  }

  deleteBtn.onclick = () => forceDeleteFromPanel();

  // Position panel if not already positioned by drag
  if (!panel.dataset.positioned) {
    const detailPanel = document.getElementById('detail-panel');
    const detailWidth = detailPanel.offsetWidth;
    panel.style.right = (detailWidth + 20) + 'px';
    panel.style.top = '80px';
    panel.style.left = 'auto';
  }

  panel.classList.add('visible');
  initUsagePanelDrag();
  initUsagePanelResize();
}

window.refreshUsages = function () {
  if (!pendingDelete) return;
  const { itemName, type } = pendingDelete;

  // Re-scan for usages
  const usages = findUsagesSmart(itemName, type);
  setCurrentUsages(usages);
  renderUsagePanel();
};

// ---- Draggable Usage Panel ----
let ufpDragging = false;
let ufpDragStart = { x: 0, y: 0 };
let ufpPanelStart = { x: 0, y: 0 };

function initUsagePanelDrag() {
  const header = document.getElementById('ufp-header');
  const panel = document.getElementById('usage-float-panel');

  // Remove existing listeners
  header.onmousedown = (e) => {
    if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons

    ufpDragging = true;
    panel.classList.add('dragging');
    ufpDragStart = { x: e.clientX, y: e.clientY };

    const rect = panel.getBoundingClientRect();
    ufpPanelStart = { x: rect.left, y: rect.top };

    document.addEventListener('mousemove', onUfpDrag);
    document.addEventListener('mouseup', onUfpDragEnd);
  };
}

function onUfpDrag(e) {
  if (!ufpDragging) return;

  const panel = document.getElementById('usage-float-panel');
  const dx = e.clientX - ufpDragStart.x;
  const dy = e.clientY - ufpDragStart.y;

  const newX = ufpPanelStart.x + dx;
  const newY = ufpPanelStart.y + dy;

  // Switch to left/top positioning for dragging
  panel.style.left = Math.max(0, newX) + 'px';
  panel.style.top = Math.max(0, newY) + 'px';
  panel.style.right = 'auto';
  panel.dataset.positioned = 'true';
}

function onUfpDragEnd() {
  ufpDragging = false;
  document.getElementById('usage-float-panel')?.classList.remove('dragging');
  document.removeEventListener('mousemove', onUfpDrag);
  document.removeEventListener('mouseup', onUfpDragEnd);
}

// ---- Resizable Usage Panel ----
let ufpResizing = false;
let ufpResizeStart = { x: 0, y: 0, w: 0, h: 0 };

function initUsagePanelResize() {
  const resizeHandle = document.getElementById('ufp-resize');
  const panel = document.getElementById('usage-float-panel');

  resizeHandle.onmousedown = (e) => {
    e.preventDefault();
    e.stopPropagation();
    ufpResizing = true;
    ufpResizeStart = {
      x: e.clientX,
      y: e.clientY,
      w: panel.offsetWidth,
      h: panel.offsetHeight
    };
    document.addEventListener('mousemove', onUfpResize);
    document.addEventListener('mouseup', onUfpResizeEnd);
  };
}

function onUfpResize(e) {
  if (!ufpResizing) return;
  const panel = document.getElementById('usage-float-panel');

  const dw = e.clientX - ufpResizeStart.x;
  const dh = e.clientY - ufpResizeStart.y;

  const newW = Math.max(300, ufpResizeStart.w + dw);
  const newH = Math.max(200, ufpResizeStart.h + dh);

  panel.style.width = newW + 'px';
  panel.style.height = newH + 'px';
}

function onUfpResizeEnd() {
  ufpResizing = false;
  document.removeEventListener('mousemove', onUfpResize);
  document.removeEventListener('mouseup', onUfpResizeEnd);
}

function highlightUsageInCode(code, name) {
  const escaped = esc(code);
  // Highlight the variable/signal/function name
  const regex = new RegExp(`\\b(${name})\\b`, 'g');
  return escaped.replace(regex, '<span class="highlight">$1</span>');
}

window.closeUsagePanel = function () {
  const panel = document.getElementById('usage-float-panel');
  panel.classList.remove('visible');
  panel.dataset.positioned = '';
  panel.style.left = '';
  panel.style.right = '';
  panel.style.top = '';
  setPendingDelete(null);
  setCurrentUsages([]);
};

window.navigateToUsage = function (el) {
  // Mark this item as active
  document.querySelectorAll('#ufp-list .ufp-item').forEach(item => {
    item.classList.remove('active');
  });
  el.classList.add('active');

  const file = el.dataset.file;
  const line = parseInt(el.dataset.line);
  const funcName = el.dataset.func;

  // Find the node for this file
  const targetNode = nodes.find(n => n.path === file);
  if (!targetNode) {
    console.log('Node not found for file:', file);
    return;
  }

  // If it's a different node, switch to it
  if (selectedNode?.path !== targetNode.path) {
    openPanel(targetNode);
    // Wait for panel to render
    setTimeout(() => {
      if (funcName) {
        expandAndHighlightFunction(funcName, line, targetNode);
      }
    }, 150);
  } else {
    // Same node, just expand/highlight
    if (funcName) {
      expandAndHighlightFunction(funcName, line, targetNode);
    }
  }
};

async function performDelete(index, isExport, type, itemName) {
  try {
    if (type === 'signal') {
      await sendCommand('modify_signal', {
        path: selectedNode.path,
        action: 'delete',
        old_name: itemName
      });
      selectedNode.signals.splice(index, 1);
    } else if (type === 'function') {
      await sendCommand('modify_function_delete', {
        path: selectedNode.path,
        name: itemName
      });
      selectedNode.functions.splice(index, 1);
    } else {
      await sendCommand('modify_variable', {
        path: selectedNode.path,
        action: 'delete',
        old_name: itemName
      });
      const vars = selectedNode.variables.filter(v => v.exported === isExport);
      const actualIndex = selectedNode.variables.findIndex(v => v.name === vars[index].name);
      if (actualIndex !== -1) selectedNode.variables.splice(actualIndex, 1);
    }
    console.log(`Deleted ${type} "${itemName}" from ${selectedNode.path}`);
    window.closeUsagePanel();
    openPanel(selectedNode);
  } catch (err) {
    console.error('Failed to delete:', err);
    alert('Failed to delete: ' + err.message);
  }
}

async function forceDeleteFromPanel() {
  if (!pendingDelete) return;
  const { index, isExport, type, itemName } = pendingDelete;
  await performDelete(index, isExport, type, itemName);
}

// ---- Smart Usage Detection ----
// Avoids false positives like matching "new" in "SomeClass.new()"
function findUsagesSmart(name, type) {
  const usages = [];

  // GDScript built-in methods/keywords to avoid false positives
  const builtinMethods = ['new', 'free', 'queue_free', 'get', 'set', 'call', 'emit', 'connect', 'disconnect'];
  const isBuiltinMethod = builtinMethods.includes(name);

  for (const node of nodes) {
    // Check if this is the node where the item is declared
    const isDeclaringNode = node.path === selectedNode?.path;

    for (const func of (node.functions || [])) {
      if (!func.body) continue;

      const lines = func.body.split('\n');
      lines.forEach((line, i) => {
        const lineNum = (func.line || 1) + i;

        // Skip the declaration line itself
        if (isDeclaringNode && isDeclarationLine(line, name, type)) {
          return;
        }

        // Check if this line actually uses the variable/signal/function
        if (isActualUsage(line, name, type, isBuiltinMethod)) {
          usages.push({
            file: node.path,
            line: lineNum,
            code: line.trim(),
            funcName: func.name
          });
        }
      });
    }
  }

  return usages;
}

function isDeclarationLine(line, name, type) {
  const trimmed = line.trim();
  if (type === 'variable') {
    // var name, @export var name, @onready var name
    return new RegExp(`^(@export\\s+)?(@onready\\s+)?var\\s+${name}\\b`).test(trimmed);
  }
  if (type === 'signal') {
    return new RegExp(`^signal\\s+${name}\\b`).test(trimmed);
  }
  if (type === 'function') {
    return new RegExp(`^func\\s+${name}\\s*\\(`).test(trimmed);
  }
  return false;
}

function isActualUsage(line, name, type, isBuiltinMethod) {
  // Build a regex that matches the name as a word boundary
  const namePattern = `\\b${name}\\b`;

  if (!new RegExp(namePattern).test(line)) {
    return false; // Name not in line at all
  }

  // For variables named like builtins (e.g., "new"), do extra checks
  if (isBuiltinMethod) {
    // Exclude patterns like "ClassName.new()" or ".new()"
    // These are constructor calls, not variable usages
    const constructorPattern = new RegExp(`\\.${name}\\s*\\(`);
    if (constructorPattern.test(line)) {
      // Check if the name appears OUTSIDE of a constructor pattern too
      const withoutConstructors = line.replace(new RegExp(`\\w+\\.${name}\\s*\\([^)]*\\)`, 'g'), '');
      if (!new RegExp(namePattern).test(withoutConstructors)) {
        return false; // Only appears in constructor calls
      }
    }
  }

  // For signals, check for signal-specific patterns
  if (type === 'signal') {
    // Match: signal_name.emit(), signal_name.connect(), etc.
    return new RegExp(`\\b${name}\\s*\\.\\s*(emit|connect|disconnect)\\b`).test(line) ||
      new RegExp(`\\.${name}\\s*\\.\\s*(connect|emit)`).test(line);
  }

  // For functions, match function calls
  if (type === 'function') {
    return new RegExp(`\\b${name}\\s*\\(`).test(line);
  }

  // For variables, the name should appear as a standalone identifier
  // Not as part of another word and not only in a method call position
  return true;
}
</file>

<file path="mcp-server/src/visualizer/visualizer.css">
/* Godot Project Map Visualizer Styles */

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  /* Claude-inspired palette */
  --bg-primary: #1a1a1e;
  --bg-secondary: #242428;
  --bg-tertiary: #2e2e33;
  --bg-hover: #35353b;
  --bg-surface: #28282d;
  --border: #3a3a40;
  --border-light: #4a4a52;
  --text-primary: #e8e4df;
  --text-secondary: #a8a49e;
  --text-muted: #706c66;
  --accent: #d4a27f;
  --accent-light: #e4b896;
  --accent-dim: #8b6f55;

  /* GDScript syntax colors */
  --gd-keyword: #cc7832;
  --gd-func-name: #ffc66d;
  --gd-type: #6897bb;
  --gd-string: #6a8759;
  --gd-number: #6897bb;
  --gd-comment: #808080;
  --gd-var: #cc7832;
  --gd-signal: #a6e3a1;
  --gd-export: #bbb529;
  --gd-builtin: #8888c6;

  /* Edge colors */
  --edge-extends: #7aa2f7;
  --edge-preload: #d4a27f;
  --edge-signal: #a6e3a1;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  overflow: hidden;
  height: 100vh;
}

canvas { display: block; cursor: grab; }
canvas.dragging { cursor: grabbing; }

/* Search bar */
#search-bar {
  position: fixed;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 10px 18px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#search-bar input {
  background: transparent;
  border: none;
  outline: none;
  color: var(--text-primary);
  font-size: 14px;
  width: 260px;
  font-family: inherit;
}

#search-bar input::placeholder { color: var(--text-muted); }
#search-bar .stats { color: var(--text-muted); font-size: 12px; white-space: nowrap; }
#search-bar svg { flex-shrink: 0; }

/* View tabs */
#view-tabs {
  position: fixed;
  top: 16px;
  left: 16px;
  z-index: 100;
  display: flex;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 4px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#view-tabs button {
  background: transparent;
  border: none;
  color: var(--text-muted);
  font-size: 13px;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
}

#view-tabs button:hover { color: var(--text-secondary); background: var(--bg-hover); }
#view-tabs button.active { color: var(--text-primary); background: var(--bg-tertiary); }

/* Context menu */
#context-menu {
  position: fixed;
  z-index: 500;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 6px 0;
  min-width: 180px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  display: none;
}

#context-menu.visible { display: block; }

#context-menu .menu-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 14px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: background 0.1s;
}

#context-menu .menu-item:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

#context-menu .menu-item svg { flex-shrink: 0; opacity: 0.7; }

#context-menu .menu-divider {
  height: 1px;
  background: var(--border);
  margin: 6px 0;
}

/* Scene Context Menu - reuse context menu styles */
#scene-context-menu {
  position: fixed;
  z-index: 500;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 6px 0;
  min-width: 180px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  display: none;
}

#scene-context-menu.visible { display: block; }

#scene-context-menu .menu-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 14px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: background 0.1s;
}

#scene-context-menu .menu-item:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

#scene-context-menu .menu-item.danger { color: #f38ba8; }
#scene-context-menu .menu-item.danger:hover { background: rgba(243, 139, 168, 0.1); }

#scene-context-menu .menu-item svg { flex-shrink: 0; opacity: 0.7; }

#scene-context-menu .menu-divider {
  height: 1px;
  background: var(--border);
  margin: 6px 0;
}

/* Modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.6);
  z-index: 600;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  width: 400px;
  box-shadow: 0 16px 64px rgba(0,0,0,0.5);
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid var(--border);
}

.modal-header h3 {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
}

.modal-body {
  padding: 20px;
}

.modal-body .form-group {
  margin-bottom: 16px;
}

.modal-body .form-group:last-child { margin-bottom: 0; }

.modal-body label {
  display: block;
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 6px;
}

.modal-body input, .modal-body select {
  width: 100%;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 12px;
  font-size: 14px;
  color: var(--text-primary);
  font-family: 'SF Mono', Monaco, monospace;
}

.modal-body input:focus, .modal-body select:focus {
  outline: none;
  border-color: var(--accent);
}

.modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  padding: 16px 20px;
  border-top: 1px solid var(--border);
}

.modal-footer button {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
  border: 1px solid var(--border);
}

.modal-footer .cancel {
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}

.modal-footer .confirm {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
}

.modal-footer .confirm:hover { background: var(--accent-light); }

/* Legend */
#legend {
  position: fixed;
  bottom: 16px;
  left: 16px;
  z-index: 100;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px 18px;
  font-size: 12px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

/* Zoom indicator - positioned bottom-left, offset from legend */
#zoom-indicator {
  position: fixed;
  bottom: 16px;
  left: 150px;
  z-index: 100;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#zoom-indicator:hover { background: var(--bg-hover); border-color: var(--border-light); }
#zoom-indicator.faded { opacity: 0.4; }
#zoom-indicator.faded:hover { opacity: 1; }
#zoom-indicator svg { flex-shrink: 0; cursor: pointer; }
#zoom-indicator svg:hover { stroke: var(--text-primary); }
#zoom-indicator .zoom-input {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  font-weight: 500;
  font-size: 12px;
  width: 42px;
  text-align: center;
  padding: 2px 0;
  cursor: text;
}
#zoom-indicator .zoom-input:focus {
  outline: none;
  background: var(--bg-tertiary);
  border-radius: 3px;
  color: var(--text-primary);
}

#legend .item { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; color: var(--text-secondary); }
#legend .item:last-child { margin-bottom: 0; }
#legend .line { width: 28px; height: 2px; border-radius: 1px; }

/* Detail panel */
#detail-panel {
  position: fixed;
  top: 0;
  right: -480px;
  width: 460px;
  min-width: 300px;
  max-width: 80vw;
  height: 100vh;
  background: var(--bg-primary);
  border-left: 1px solid var(--border);
  z-index: 200;
  overflow-y: auto;
  transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: -8px 0 32px rgba(0,0,0,0.4);
}

#detail-panel.open { right: 0; }
#detail-panel.resizing { transition: none; }

/* Horizontal resize handle for panel */
#panel-resize-handle {
  position: absolute;
  left: -4px;
  top: 0;
  width: 8px;
  height: 100%;
  cursor: col-resize;
  z-index: 201;
}
#panel-resize-handle::after {
  content: '';
  position: absolute;
  left: 3px;
  top: 50%;
  transform: translateY(-50%);
  width: 3px;
  height: 50px;
  background: var(--border);
  border-radius: 2px;
  opacity: 0;
  transition: opacity 0.2s;
}
#panel-resize-handle:hover::after,
#detail-panel.resizing #panel-resize-handle::after {
  opacity: 1;
  background: var(--accent);
}

#detail-panel::-webkit-scrollbar { width: 6px; }
#detail-panel::-webkit-scrollbar-track { background: transparent; }
#detail-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.panel-header {
  position: sticky;
  top: 0;
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
  padding: 20px 24px;
  z-index: 10;
}

.panel-header h2 {
  font-size: 20px;
  font-weight: 600;
  color: var(--accent-light);
  margin-bottom: 4px;
  padding-right: 40px;
}

.panel-header .path {
  font-size: 12px;
  color: var(--text-muted);
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  word-break: break-all;
}

.close-btn {
  position: absolute;
  top: 16px;
  right: 16px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  width: 30px;
  height: 30px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.close-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

.panel-body { padding: 16px 24px 32px; }

.desc-block {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  padding: 10px 14px;
  background: var(--bg-secondary);
  border-radius: 8px;
  border-left: 3px solid var(--accent);
  line-height: 1.5;
}

.meta-row {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.meta-badge {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  color: var(--text-secondary);
}

.meta-badge span { color: var(--accent-light); font-weight: 600; }

/* Sections */
.section {
  margin-bottom: 16px;
}

.section .item-list {
  /* No max-height - show all items */
}

.section-resize-handle {
  position: relative;
  height: 12px;
  cursor: row-resize;
  z-index: 5;
  margin: 4px 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.section-resize-handle::after {
  content: '';
  width: 40px;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  opacity: 0.3;
  transition: opacity 0.2s;
}

.section-resize-handle:hover::after,
.section.resizing .section-resize-handle::after {
  opacity: 1;
  background: var(--accent);
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 6px;
}

.section-count {
  background: var(--bg-tertiary);
  color: var(--text-muted);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
}

.item-list { list-style: none; }

.item-list li {
  padding: 6px 10px;
  border-radius: 6px;
  margin-bottom: 1px;
  font-size: 13px;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 6px;
  line-height: 1.4;
}

.item-list li:hover { background: var(--bg-secondary); }
.item-list li.clickable { cursor: pointer; }
.item-list li.clickable:hover { background: var(--bg-tertiary); }

/* Scene usage list */
.scene-usage-section { margin-bottom: 16px; }
.scene-list li.scene-link {
  cursor: pointer;
  font-family: -apple-system, system-ui, sans-serif;
}
.scene-list li.scene-link:hover {
  background: rgba(166, 227, 161, 0.1);
}
.scene-list .scene-icon {
  font-size: 14px;
}
.scene-list .scene-name {
  color: #a6e3a1;
  font-weight: 500;
}

/* Inline editable items */
.item-list li .item-actions {
  margin-left: auto;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  flex-shrink: 0;
}
.item-list li:hover .item-actions { opacity: 1; }
.item-list li:hover .delete { opacity: 1 !important; }
.item-actions button {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  width: 22px;
  height: 22px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.item-actions button:hover { background: var(--bg-hover); color: var(--text-primary); }
.item-actions button.delete:hover { background: #3d2020; color: #f38ba8; }

/* Inline editable spans */
.editable {
  cursor: text;
  padding: 1px 4px;
  margin: -1px -4px;
  border-radius: 3px;
  transition: background 0.15s;
  min-width: 20px;
  display: inline-block;
}
.editable:hover { background: rgba(255,255,255,0.08); }
.editable:focus {
  outline: none;
  background: rgba(255,255,255,0.12);
  box-shadow: 0 0 0 1px var(--accent);
}
.editable[data-placeholder]:empty::before {
  content: attr(data-placeholder);
  color: var(--text-muted);
  opacity: 0.5;
}

/* @onready badge */
.onready-badge {
  display: inline-block;
  font-size: 9px;
  padding: 2px 5px;
  background: rgba(137, 180, 250, 0.2);
  color: #89b4fa;
  border-radius: 3px;
  margin-right: 6px;
  font-weight: 500;
  cursor: pointer;
  user-select: none;
}
.onready-badge:hover { background: rgba(137, 180, 250, 0.3); }
.onready-badge.inactive {
  background: rgba(255,255,255,0.05);
  color: var(--text-muted);
  opacity: 0.5;
}

/* Floating usage panel (to the left of detail panel) */
#usage-float-panel {
  position: fixed;
  top: 80px;
  right: 480px;
  width: 380px;
  min-width: 300px;
  min-height: 250px;
  max-height: calc(100vh - 100px);
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  z-index: 150;
  display: none;
  flex-direction: column;
  overflow: hidden;
}

#usage-float-panel.visible { display: flex; }
#usage-float-panel.dragging { user-select: none; }

/* Resize handle */
#usage-float-panel .ufp-resize {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 16px;
  height: 16px;
  cursor: nwse-resize;
  z-index: 10;
}
#usage-float-panel .ufp-resize::after {
  content: '';
  position: absolute;
  right: 4px;
  bottom: 4px;
  width: 8px;
  height: 8px;
  border-right: 2px solid var(--border);
  border-bottom: 2px solid var(--border);
  opacity: 0.5;
}
#usage-float-panel .ufp-resize:hover::after { opacity: 1; }

#usage-float-panel .ufp-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 16px;
  background: rgba(243, 139, 168, 0.12);
  border-bottom: 1px solid var(--border);
  cursor: grab;
}

#usage-float-panel .ufp-header:active { cursor: grabbing; }

#usage-float-panel .ufp-header .ufp-info {
  flex: 1;
  min-width: 0;
}

#usage-float-panel .ufp-header .ufp-title {
  font-size: 14px;
  font-weight: 600;
  color: #f38ba8;
  line-height: 1.3;
}

#usage-float-panel .ufp-header .ufp-count {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
  line-height: 1.3;
}

#usage-float-panel .ufp-header .ufp-count .count-num {
  font-weight: 700;
  font-size: 14px;
  color: #fab387;
}

#usage-float-panel .ufp-header .ufp-buttons {
  display: flex;
  gap: 4px;
  align-items: center;
  flex-shrink: 0;
}

#usage-float-panel .ufp-header .refresh-btn,
#usage-float-panel .ufp-header .close-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  width: 28px;
  height: 28px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

#usage-float-panel .ufp-header .close-btn {
  font-size: 18px;
}

#usage-float-panel .ufp-header .refresh-btn:hover,
#usage-float-panel .ufp-header .close-btn:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

#usage-float-panel .ufp-list {
  flex: 1;
  overflow-y: auto;
  max-height: 300px;
}

#usage-float-panel .ufp-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 10px 16px;
  font-size: 12px;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
  transition: background 0.1s;
}

#usage-float-panel .ufp-item:last-child { border-bottom: none; }
#usage-float-panel .ufp-item:hover { background: var(--bg-hover); }
#usage-float-panel .ufp-item.active { background: rgba(212, 162, 127, 0.2); border-left: 3px solid var(--accent); margin-left: -3px; padding-left: 19px; }

#usage-float-panel .ufp-item .ufp-loc {
  display: flex;
  align-items: center;
  gap: 8px;
}

#usage-float-panel .ufp-item .ufp-file {
  color: var(--text-muted);
  font-size: 11px;
}

#usage-float-panel .ufp-item .ufp-func {
  color: #89dceb;
  font-weight: 600;
  font-size: 12px;
}

#usage-float-panel .ufp-item .ufp-func::before {
  content: 'func ';
  color: var(--gd-keyword);
  font-weight: normal;
}

#usage-float-panel .ufp-item .ufp-line {
  color: var(--text-muted);
  font-size: 10px;
  margin-left: auto;
}

#usage-float-panel .ufp-item .ufp-code {
  color: var(--text-secondary);
  font-family: 'SF Mono', Monaco, monospace;
  font-size: 11px;
  background: var(--bg-tertiary);
  padding: 6px 10px;
  border-radius: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#usage-float-panel .ufp-item .ufp-code .highlight {
  color: #f38ba8;
  font-weight: 600;
  background: rgba(243, 139, 168, 0.15);
  padding: 1px 3px;
  border-radius: 2px;
}

#usage-float-panel .ufp-item .ufp-file {
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 2px;
}

#usage-float-panel .ufp-actions {
  display: flex;
  gap: 10px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  background: var(--bg-tertiary);
}

#usage-float-panel .ufp-actions button {
  flex: 1;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  border: 1px solid var(--border);
  font-weight: 500;
}

#usage-float-panel .ufp-actions .cancel {
  background: var(--bg-secondary);
  color: var(--text-secondary);
}

#usage-float-panel .ufp-actions .delete {
  background: rgba(243, 139, 168, 0.2);
  color: #f38ba8;
  border-color: rgba(243, 139, 168, 0.4);
}

#usage-float-panel .ufp-actions .delete:hover {
  background: rgba(243, 139, 168, 0.3);
}

/* Highlight line in function viewer */
.code-line-highlight {
  background: rgba(243, 139, 168, 0.25) !important;
  border-left: 3px solid #f38ba8 !important;
  margin-left: -14px !important;
  padding-left: 11px !important;
}

/* Add item form */
.add-item-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 10px;
  color: var(--text-muted);
  font-size: 12px;
  cursor: pointer;
  border-radius: 6px;
  margin-top: 4px;
}
.add-item-btn:hover { background: var(--bg-secondary); color: var(--text-secondary); }
.add-item-btn svg { opacity: 0.6; }

.add-item-form {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  margin-top: 8px;
}
.add-item-form .form-row {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}
.add-item-form .form-row:last-child { margin-bottom: 0; }
.add-item-form input, .add-item-form select {
  flex: 1;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  font-family: inherit;
}
.add-item-form input:focus, .add-item-form select:focus {
  outline: none;
  border-color: var(--accent);
}
.add-item-form .form-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
.add-item-form button {
  padding: 6px 14px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  border: 1px solid var(--border);
}
.add-item-form button.cancel {
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}
.add-item-form button.confirm {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
  font-weight: 600;
}

/* Syntax tokens */
.kw { color: var(--gd-keyword); font-weight: 600; }
.fn { color: var(--gd-func-name); }
.tp { color: var(--gd-type); }
.str { color: var(--gd-string); }
.num { color: var(--gd-number); }
.cmt { color: var(--gd-comment); font-style: italic; }
.sig { color: var(--gd-signal); }
.exp { color: var(--gd-export); }
.param { color: var(--text-secondary); }
.ret { color: var(--text-muted); }

/* Tags */
.tag {
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: -apple-system, system-ui, sans-serif;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.tag-export { background: #3d3520; color: var(--gd-export); }
.tag-signal { background: #1e3326; color: var(--gd-signal); }
.tag-lines { background: var(--bg-tertiary); color: var(--text-muted); font-weight: normal; }
.tag-return { background: #1e2a3a; color: var(--gd-type); }

/* Function viewer */
.func-viewer {
  margin-top: 16px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  overflow: hidden;
}

.func-viewer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  color: var(--text-secondary);
}

.func-viewer-header .func-title { color: var(--gd-func-name); font-weight: 600; }

.func-viewer-close {
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 14px;
  padding: 2px 6px;
  border-radius: 4px;
}

.func-viewer-close:hover { color: var(--text-primary); background: var(--bg-hover); }

.func-viewer-code {
  position: relative;
  padding: 12px 0;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  font-size: 12px;
  line-height: 1.6;
  overflow: auto;
  tab-size: 4;
}

/* Editable code area */
.code-editor-container {
  position: relative;
  margin: 0 14px;
}

.code-editor-textarea {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  tab-size: inherit;
  padding: 0;
  margin: 0;
  border: none;
  background: transparent;
  color: transparent;
  caret-color: var(--text-primary);
  resize: none;
  outline: none;
  overflow: hidden;
  white-space: pre;
}

.code-editor-textarea::selection {
  background: rgba(255, 255, 255, 0.2);
}

.code-editor-highlight {
  white-space: pre;
  pointer-events: none;
}

.code-editor-container:focus-within {
  outline: 1px solid var(--accent);
  outline-offset: 4px;
  border-radius: 4px;
}

.func-viewer-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 14px;
  background: var(--bg-tertiary);
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--text-muted);
}

.func-viewer-footer .status { opacity: 0; transition: opacity 0.2s; }
.func-viewer-footer .status.visible { opacity: 1; }
.func-viewer-footer .save-btn {
  background: var(--accent);
  color: var(--bg-primary);
  border: none;
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.2s;
}
.func-viewer-footer .save-btn.active { opacity: 1; }
.func-viewer-footer .save-btn.active:hover { background: var(--accent-light); }

.code-line {
  display: block;
  padding: 0 14px;
  min-height: 1.4em;
  white-space: pre;
}

.code-line:hover { background: rgba(255,255,255,0.03); }

.line-num {
  color: var(--text-muted);
  min-width: 36px;
  text-align: right;
  padding-right: 16px;
  user-select: none;
  flex-shrink: 0;
  font-size: 11px;
}

.line-content {
  white-space: pre;
  flex: 1;
}

/* ============================================================================
   SCENE VIEW STYLES
   ============================================================================ */

/* Scene Back Button - positioned well after the view toggle */
#scene-back-btn {
  position: fixed;
  top: 20px;
  left: 180px;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 4px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 10px;
  font-size: 11px;
  color: var(--text-secondary);
  cursor: pointer;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
  transition: all 0.15s;
}

#scene-back-btn:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
  border-color: var(--border-light);
}

#scene-back-btn svg { flex-shrink: 0; opacity: 0.7; width: 12px; height: 12px; }
#scene-back-btn .scene-name {
  color: var(--accent);
  font-weight: 600;
  max-width: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Hide legend in expanded scene view */
#legend.hidden { display: none; }

/* ============================================================================
   SCENE NODE PROPERTIES PANEL STYLES
   ============================================================================ */

/* Loading and error states */
.loading-state, .error-state {
  padding: 40px 20px;
  text-align: center;
  color: var(--text-muted);
  font-size: 14px;
}

.error-state {
  color: #f38ba8;
}

/* Property sections - styled like Godot inspector */
.property-section {
  margin-bottom: 4px;
  border-radius: 6px;
  overflow: hidden;
}

.property-section .section-header {
  cursor: pointer;
  user-select: none;
  background: var(--bg-secondary);
  padding: 10px 14px;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.property-section .section-header:hover {
  background: var(--bg-hover);
}

.property-section .section-count {
  background: var(--bg-tertiary);
  color: var(--text-muted);
  font-size: 11px;
  padding: 3px 8px;
  border-radius: 10px;
  font-weight: 500;
}

.property-section.collapsed .property-list {
  display: none;
}

.property-section.collapsed .section-header span:first-child::before {
  content: '▶ ';
}

.property-section:not(.collapsed) .section-header span:first-child::before {
  content: '▼ ';
}

.property-section .section-header span:first-child {
  display: flex;
  align-items: center;
}

.property-section .section-header span:first-child::before {
  margin-right: 4px;
  font-size: 10px;
  opacity: 0.6;
}

.property-list {
  padding: 4px 0;
  background: var(--bg-primary);
}

/* Property rows - cleaner layout */
.property-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  margin-bottom: 1px;
  transition: background 0.1s;
}

.property-row:hover {
  background: rgba(255, 255, 255, 0.03);
}

.property-name {
  flex: 0 0 40%;
  font-size: 13px;
  color: var(--text-secondary);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
  padding-right: 8px;
}

.property-value {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 4px;
  min-width: 0;
}

/* Property inputs */
.property-input {
  width: 100%;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 10px;
  font-size: 13px;
  color: var(--text-primary);
  font-family: 'SF Mono', Monaco, monospace;
}

.property-input:focus {
  outline: none;
  border-color: var(--accent);
}

.property-input::-webkit-inner-spin-button,
.property-input::-webkit-outer-spin-button {
  opacity: 1;
}

/* Property select */
.property-select {
  width: 100%;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 10px;
  font-size: 13px;
  color: var(--text-primary);
  cursor: pointer;
}

.property-select:focus {
  outline: none;
  border-color: var(--accent);
}

/* Toggle switch */
.toggle-switch {
  position: relative;
  display: inline-block;
  width: 36px;
  height: 20px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 20px;
  transition: 0.15s;
}

.toggle-slider::before {
  position: absolute;
  content: "";
  height: 14px;
  width: 14px;
  left: 2px;
  bottom: 2px;
  background-color: var(--text-muted);
  border-radius: 50%;
  transition: 0.15s;
}

.toggle-switch input:checked + .toggle-slider {
  background-color: rgba(166, 227, 161, 0.3);
  border-color: var(--gd-signal);
}

.toggle-switch input:checked + .toggle-slider::before {
  background-color: var(--gd-signal);
  transform: translateX(16px);
}

/* Range input group */
.range-input-group {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.property-range {
  flex: 1;
  height: 4px;
  -webkit-appearance: none;
  background: var(--bg-tertiary);
  border-radius: 2px;
  outline: none;
}

.property-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
}

.property-range::-webkit-slider-thumb:hover {
  background: var(--accent-light);
}

.range-number {
  width: 60px !important;
  flex: 0 0 auto;
}

/* Vector input group */
.vector-input-group {
  display: flex;
  align-items: center;
  gap: 4px;
  width: 100%;
}

.vector-input-group label {
  font-size: 10px;
  color: var(--text-muted);
  font-weight: 600;
}

.vector-input-group .property-input {
  width: auto;
  flex: 1;
  min-width: 50px;
}

.vector-input-group.vec3 .property-input {
  min-width: 40px;
}

/* Color input group */
.color-input-group {
  display: flex;
  align-items: center;
  gap: 6px;
  width: 100%;
}

.property-color {
  width: 40px;
  height: 26px;
  padding: 0;
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
}

.property-color::-webkit-color-swatch-wrapper {
  padding: 2px;
}

.property-color::-webkit-color-swatch {
  border-radius: 2px;
  border: none;
}

.color-alpha {
  width: 50px !important;
  flex: 0 0 auto;
}

/* Readonly property */
.property-readonly {
  font-size: 11px;
  color: var(--text-muted);
  font-family: 'SF Mono', Monaco, monospace;
  background: var(--bg-tertiary);
  padding: 4px 8px;
  border-radius: 4px;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Resource path */
.resource-path {
  font-size: 11px;
  color: var(--gd-string);
  font-family: 'SF Mono', Monaco, monospace;
  background: var(--bg-tertiary);
  padding: 4px 8px;
  border-radius: 4px;
}

/* Script badge in meta row */
.meta-badge.script-badge {
  cursor: pointer;
  transition: background 0.1s;
}

.meta-badge.script-badge:hover {
  background: var(--bg-tertiary);
}
</file>

<file path="mcp-server/src/visualizer/websocket.js">
/**
 * WebSocket connection for real-time communication with Godot
 */

let ws = null;
let wsConnected = false;
const pendingRequests = new Map();
let requestId = 0;

export function connectWebSocket() {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${protocol}//${window.location.host}`);

  ws.onopen = () => {
    wsConnected = true;
    console.log('[visualizer] WebSocket connected');
  };

  ws.onclose = () => {
    wsConnected = false;
    console.log('[visualizer] WebSocket disconnected, reconnecting...');
    setTimeout(connectWebSocket, 2000);
  };

  ws.onerror = (err) => {
    console.error('[visualizer] WebSocket error:', err);
  };

  ws.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      if (msg.id && pendingRequests.has(msg.id)) {
        const { resolve, reject } = pendingRequests.get(msg.id);
        pendingRequests.delete(msg.id);
        if (msg.error) {
          reject(new Error(msg.error));
        } else {
          resolve(msg.result || msg);
        }
      }
    } catch (err) {
      console.error('[visualizer] Failed to parse message:', err);
    }
  };
}

export function sendCommand(command, args) {
  return new Promise((resolve, reject) => {
    if (!wsConnected || !ws) {
      reject(new Error('WebSocket not connected'));
      return;
    }

    const id = ++requestId;
    pendingRequests.set(id, { resolve, reject });

    ws.send(JSON.stringify({
      type: 'visualizer_command',
      id,
      command,
      args
    }));

    // Timeout after 30 seconds
    setTimeout(() => {
      if (pendingRequests.has(id)) {
        pendingRequests.delete(id);
        reject(new Error('Request timeout'));
      }
    }, 30000);
  });
}

export function isConnected() {
  return wsConnected;
}
</file>

<file path="mcp-server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="PROJECT_PLAN.md">
# Godot MCP Server - Complete Project Plan

## Overview

This document contains everything needed to build a **Godot MCP Server** that integrates Godot game engine tools with the RAGy application via the Model Context Protocol (MCP).

**Goal:** Create a clean, modular MCP server that exposes Godot editor functionality (scene manipulation, script editing, file operations) to any MCP-compatible AI client, with RAGy as the primary client.

---

## Project Paths

```
/Users/tomeryud/
├── projects/RAGy/                    # RAGy app (MCP client) - REFERENCE
├── godot-ai-assistant/               # Old Godot app - REFERENCE (do not modify)
└── godot-mcp/                        # NEW PROJECT (build here)
    ├── mcp-server/                   # Node.js MCP server
    └── godot-plugin/                 # Minimal GDScript plugin
```

---

## Part 1: Understanding RAGy (The MCP Client)

### What is RAGy?

RAGy is an Electron desktop app for building RAG (Retrieval-Augmented Generation) systems. It allows users to:
- Upload documents and chunk them
- Generate embeddings and build vector databases
- Chat with AI using RAG context
- Use MCP tools for extended functionality

### RAGy's MCP Architecture

RAGy already has MCP infrastructure. Key files to study:

#### MCP Client Manager
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`

This manages connections to MCP servers. Key code pattern:

```javascript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

class MCPClientManager {
  constructor() {
    this.clients = new Map(); // serverName -> { client, transport }
    this.initialized = false;
  }

  async initialize() {
    // Connect to each MCP server as a child process
    await this.connectToServer('memory', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/memory-server.js')],
    });

    await this.connectToServer('rag', {
      command: 'node',
      args: [path.join(__dirname, '../mcp-servers/rag-server.js')],
    });

    // TODO: Add godot server here
    // await this.connectToServer('godot', {
    //   command: 'node',
    //   args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
    // });
  }

  async connectToServer(serverName, config) {
    const client = new Client({ name: 'ragy-chat-client', version: '1.0.0' }, { capabilities: {} });
    const transport = new StdioClientTransport({ command: config.command, args: config.args });
    await client.connect(transport);
    this.clients.set(serverName, { client, transport, config });
  }

  async getAllTools() {
    // Collects tools from all connected servers
    const allTools = [];
    for (const [serverName, { client }] of this.clients) {
      const response = await client.listTools();
      const toolsWithServer = response.tools.map(tool => ({ ...tool, _mcpServer: serverName }));
      allTools.push(...toolsWithServer);
    }
    return allTools;
  }

  async callTool(toolName, args, serverName) {
    const serverInfo = this.clients.get(serverName);
    return await serverInfo.client.callTool({ name: toolName, arguments: args });
  }
}
```

#### Example MCP Server (RAG Server)
**Path:** `/Users/tomeryud/projects/RAGy/server/mcp-servers/rag-server.js`

This shows the pattern for building MCP servers:

```javascript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';

const server = new Server(
  { name: 'ragy-rag-server', version: '1.0.0' },
  { capabilities: { tools: {} } }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'search_documents',
        description: 'Semantic search across the knowledge base',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: 'Search query' },
            top_k: { type: 'number', description: 'Number of results' }
          },
          required: ['query']
        }
      }
    ]
  };
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === 'search_documents') {
    // Execute the tool and return result
    const results = await doSearch(args.query, args.top_k);
    return {
      content: [{ type: 'text', text: JSON.stringify(results) }]
    };
  }
});

// Start server
const transport = new StdioServerTransport();
await server.connect(transport);
```

#### AI Service with Tools
**Path:** `/Users/tomeryud/projects/RAGy/server/services/ai-with-tools.service.js`

This shows how RAGy uses MCP tools with AI providers. Key points:
- Gets tools via `mcpClientManager.getToolsForOpenAI()` or `getToolsForAnthropic()`
- Sends tools to AI provider
- When AI returns tool_call, executes via `mcpClientManager.callTool()`
- Returns result to AI for final response

### RAGy Tech Stack
- **Frontend:** React 18 + Vite
- **Backend:** Express.js (port 3001)
- **Desktop:** Electron
- **MCP SDK:** `@modelcontextprotocol/sdk`

---

## Part 2: Understanding the Old Godot AI Assistant (Reference)

### What is it?

The old Godot AI Assistant is a standalone app with:
- Express.js server with AI integration (multiple providers)
- React frontend for chat UI
- Godot plugin that polls server for tool invocations
- 33 tools for Godot manipulation

**Important:** Do NOT modify this project. Use it only as reference for tool implementations.

### Key Files to Reference

#### Tool Schemas (Copy tool definitions from here)
**Path:** `/Users/tomeryud/godot-ai-assistant/tool_schemas/`

Files:
- `openaiTools.js` - Tool definitions in OpenAI format
- `geminiTools.js` - Tool definitions in Gemini format
- `anthropicTools.js` - Tool definitions in Anthropic format

These contain the 33+ tool definitions with names, descriptions, and parameter schemas. Convert these to MCP format.

#### Tool Implementations in Godot Plugin
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/`

This contains GDScript implementations for each tool:
- `file_operations/` - read_file, list_dir, search_project
- `scene_operations/` - read_scene, create_scene, add_node, modify_node
- `script_operations/` - create_script, apply_diff_preview

Study these to understand what each tool does and how to implement in the new plugin.

#### Tool Registry (Tool routing logic)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/tool_registry.gd`

Shows how tools are registered and routed to handlers.

#### External App Communicator (HTTP polling - replace with WebSocket)
**Path:** `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/Core/external_app_communicator.gd`

This uses HTTP polling (bad). Replace with WebSocket in new implementation.

### Complete Tool List (33 Tools)

**File System (6 tools):**
1. `list_dir` - List files/folders in a directory
2. `read_file` - Read text file contents
3. `search_project` - Regex/substring search across project
4. `list_scripts` - List all GDScript files
5. `create_script` - Create new GDScript file
6. `open_in_godot` - Open file at specific line in editor

**Scene Operations (10 tools):**
7. `scene_tree_dump` - Get current scene tree structure
8. `read_scene` - Parse .tscn file to get node structure
9. `create_scene` - Create new .tscn file with nodes
10. `add_node` - Add node to existing scene
11. `remove_node` - Remove node from scene
12. `rename_node` - Rename a node
13. `move_node` - Reorder node in hierarchy
14. `modify_node_property` - Change node properties
15. `get_node_properties` - Discover properties for node type
16. `set_collision_shape` - Configure collision shape

**Script Operations (4 tools):**
17. `apply_diff_preview` - Apply surgical code edits (1-10 lines)
18. `validate_script` - Check script syntax
19. `attach_script` - Attach script to node
20. `detach_script` - Remove script from node

**Project Configuration (4 tools):**
21. `get_project_settings` - Access window size, physics settings
22. `get_input_map` - Query input actions and bindings
23. `get_collision_layers` - Access collision layer names
24. `get_render_settings` - Graphics/render configuration

**Debugging (3 tools):**
25. `get_console_log` - Access Godot editor output
26. `get_errors` - Get structured error data
27. `clear_console_log` - Clear console

**Asset Operations (3 tools):**
28. `set_sprite_texture` - Set texture on Sprite2D
29. `generate_2d_asset` - Generate 2D graphics
30. `customize_and_run_workflow` - Run asset workflows

**Workflow (3 tools):**
31. `inspect_runninghub_workflow` - Inspect workflows
32. `search_comfyui_nodes` - Search node library
33. `manage_task_list` - Task management

---

## Part 3: New Architecture

### High-Level Design

```
┌─────────────────────────────────────────────────────────────┐
│  RAGy (or any MCP client)                                   │
│      │                                                      │
│      │ stdio (MCP protocol)                                 │
│      ▼                                                      │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  godot-mcp-server (Node.js)                         │    │
│  │  - Speaks MCP via stdio                             │    │
│  │  - Speaks WebSocket to Godot plugin                 │    │
│  │  - Defines all Godot tools                          │    │
│  │  - Routes tool calls to Godot                       │    │
│  └──────────────────────┬──────────────────────────────┘    │
│                         │                                   │
│                         │ WebSocket (port 6505)             │
│                         │ (bidirectional, real-time)        │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  Godot Plugin (minimal)                             │    │
│  │  - Connects via WebSocket                           │    │
│  │  - Receives tool invocation requests                │    │
│  │  - Executes tools in Godot context                  │    │
│  │  - Returns results immediately                      │    │
│  │  - Shows connection status (minimal UI)             │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### WebSocket Protocol

Messages between MCP server and Godot plugin:

**Tool Invocation (Server → Godot):**
```json
{
  "type": "tool_invoke",
  "id": "unique-request-id",
  "tool": "read_scene",
  "args": {
    "scene_path": "res://scenes/player.tscn"
  }
}
```

**Tool Result (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": true,
  "result": { "nodes": [...] }
}
```

**Error (Godot → Server):**
```json
{
  "type": "tool_result",
  "id": "unique-request-id",
  "success": false,
  "error": "Scene file not found"
}
```

**Connection Status:**
```json
{ "type": "ping" }
{ "type": "pong" }
{ "type": "godot_ready", "project_path": "/path/to/project" }
```

---

## Part 4: Directory Structure

```
/Users/tomeryud/godot-mcp/
├── PROJECT_PLAN.md                   # This file
│
├── mcp-server/                       # Node.js MCP server
│   ├── package.json
│   ├── src/
│   │   ├── index.js                  # Main entry point
│   │   ├── godot-bridge.js           # WebSocket connection to Godot
│   │   ├── tools/
│   │   │   ├── index.js              # Exports all tools
│   │   │   ├── file-tools.js         # list_dir, read_file, etc.
│   │   │   ├── scene-tools.js        # read_scene, create_scene, etc.
│   │   │   ├── script-tools.js       # apply_diff, validate_script, etc.
│   │   │   ├── project-tools.js      # get_project_settings, etc.
│   │   │   └── debug-tools.js        # get_console_log, get_errors, etc.
│   │   └── utils/
│   │       └── logger.js             # Logging utility
│   └── README.md
│
└── godot-plugin/                     # Godot 4.x plugin
    ├── addons/
    │   └── godot_mcp/
    │       ├── plugin.cfg            # Plugin configuration
    │       ├── plugin.gd             # Main plugin script
    │       ├── mcp_client.gd         # WebSocket client
    │       ├── tool_executor.gd      # Routes and executes tools
    │       ├── tools/
    │       │   ├── file_tools.gd
    │       │   ├── scene_tools.gd
    │       │   ├── script_tools.gd
    │       │   └── project_tools.gd
    │       └── ui/
    │           └── status_indicator.gd  # Minimal connection status
    └── project.godot                 # Test project for development
```

---

## Part 5: Implementation Phases

### Phase 1: Skeleton MCP Server

**Goal:** Working MCP server that RAGy can connect to, with mock tools.

**Files to create:**

1. `mcp-server/package.json`:
```json
{
  "name": "godot-mcp-server",
  "version": "0.1.0",
  "type": "module",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "ws": "^8.18.0"
  }
}
```

2. `mcp-server/src/index.js`:
- Create MCP server using `@modelcontextprotocol/sdk`
- Register 3 mock tools: `list_dir`, `read_file`, `read_scene`
- Return fake data for testing
- NO WebSocket yet (Phase 2)

**Test:**
1. Add to RAGy's mcp-client.js
2. Start RAGy
3. Ask AI: "List the files in my Godot project"
4. Verify mock response received

---

### Phase 2: WebSocket Bridge

**Goal:** MCP server can communicate with Godot via WebSocket.

**Files to create/modify:**

1. `mcp-server/src/godot-bridge.js`:
```javascript
import { WebSocketServer } from 'ws';

class GodotBridge {
  constructor(port = 6505) {
    this.port = port;
    this.godotConnection = null;
    this.pendingRequests = new Map(); // id -> { resolve, reject, timeout }
  }

  start() {
    this.wss = new WebSocketServer({ port: this.port });
    this.wss.on('connection', (ws) => this.handleConnection(ws));
  }

  handleConnection(ws) {
    this.godotConnection = ws;
    ws.on('message', (data) => this.handleMessage(JSON.parse(data)));
    ws.on('close', () => { this.godotConnection = null; });
  }

  async invokeTool(toolName, args) {
    if (!this.godotConnection) {
      throw new Error('Godot not connected');
    }

    const id = crypto.randomUUID();

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(id);
        reject(new Error('Tool execution timeout'));
      }, 30000);

      this.pendingRequests.set(id, { resolve, reject, timeout });

      this.godotConnection.send(JSON.stringify({
        type: 'tool_invoke',
        id,
        tool: toolName,
        args
      }));
    });
  }

  handleMessage(message) {
    if (message.type === 'tool_result') {
      const pending = this.pendingRequests.get(message.id);
      if (pending) {
        clearTimeout(pending.timeout);
        this.pendingRequests.delete(message.id);
        if (message.success) {
          pending.resolve(message.result);
        } else {
          pending.reject(new Error(message.error));
        }
      }
    }
  }

  isConnected() {
    return this.godotConnection !== null;
  }
}
```

2. Update `mcp-server/src/index.js`:
- Import GodotBridge
- Start WebSocket server on startup
- Route tool calls through bridge (if connected) or return "not connected" error

**Test:**
1. Start MCP server
2. Connect with `wscat -c ws://localhost:6505`
3. Verify connection established
4. Send fake tool_result, verify handling

---

### Phase 3: Minimal Godot Plugin

**Goal:** Godot plugin connects to MCP server via WebSocket.

**Files to create:**

1. `godot-plugin/addons/godot_mcp/plugin.cfg`:
```ini
[plugin]
name="Godot MCP"
description="MCP server integration for AI assistants"
author="Your Name"
version="0.1.0"
script="plugin.gd"
```

2. `godot-plugin/addons/godot_mcp/plugin.gd`:
```gdscript
@tool
extends EditorPlugin

var mcp_client: MCPClient

func _enter_tree():
    mcp_client = MCPClient.new()
    add_child(mcp_client)
    mcp_client.connect_to_server()

func _exit_tree():
    if mcp_client:
        mcp_client.disconnect_from_server()
        mcp_client.queue_free()
```

3. `godot-plugin/addons/godot_mcp/mcp_client.gd`:
```gdscript
extends Node
class_name MCPClient

signal connected
signal disconnected
signal tool_invoked(id: String, tool_name: String, args: Dictionary)

var socket: WebSocketPeer
var server_url := "ws://localhost:6505"
var is_connected := false

func _ready():
    socket = WebSocketPeer.new()

func _process(_delta):
    if socket.get_ready_state() == WebSocketPeer.STATE_OPEN:
        socket.poll()
        while socket.get_available_packet_count() > 0:
            var packet = socket.get_packet()
            _handle_message(packet.get_string_from_utf8())

func connect_to_server():
    var err = socket.connect_to_url(server_url)
    if err != OK:
        push_error("Failed to connect to MCP server")

func _handle_message(json_string: String):
    var message = JSON.parse_string(json_string)
    if message.type == "tool_invoke":
        tool_invoked.emit(message.id, message.tool, message.args)

func send_result(id: String, success: bool, result = null, error: String = ""):
    var response = {
        "type": "tool_result",
        "id": id,
        "success": success
    }
    if success:
        response["result"] = result
    else:
        response["error"] = error
    socket.send_text(JSON.stringify(response))
```

**Test:**
1. Start MCP server
2. Open Godot project with plugin enabled
3. Verify "Connected" in Godot output
4. Verify MCP server logs connection

---

### Phase 4: First Real Tools (File Operations)

**Goal:** Implement file tools end-to-end.

**Tools to implement:**
- `list_dir` - List directory contents
- `read_file` - Read file contents

**MCP Server side (`mcp-server/src/tools/file-tools.js`):**
```javascript
export const fileTools = [
  {
    name: 'list_dir',
    description: 'List files and folders in a Godot project directory',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Directory path (e.g., "res://", "res://scenes/")'
        }
      },
      required: ['path']
    }
  },
  {
    name: 'read_file',
    description: 'Read contents of a file in the Godot project',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'File path (e.g., "res://scripts/player.gd")'
        },
        start_line: {
          type: 'number',
          description: 'Optional start line (1-indexed)'
        },
        end_line: {
          type: 'number',
          description: 'Optional end line (1-indexed)'
        }
      },
      required: ['path']
    }
  }
];
```

**Godot side (`godot-plugin/addons/godot_mcp/tools/file_tools.gd`):**
```gdscript
extends Node
class_name FileTools

func list_dir(args: Dictionary) -> Dictionary:
    var path = args.get("path", "res://")
    var dir = DirAccess.open(path)
    if dir == null:
        return {"error": "Cannot open directory: " + path}

    var files = []
    var folders = []

    dir.list_dir_begin()
    var file_name = dir.get_next()
    while file_name != "":
        if dir.current_is_dir():
            folders.append(file_name)
        else:
            files.append(file_name)
        file_name = dir.get_next()
    dir.list_dir_end()

    return {"files": files, "folders": folders}

func read_file(args: Dictionary) -> Dictionary:
    var path = args.get("path", "")
    if not FileAccess.file_exists(path):
        return {"error": "File not found: " + path}

    var file = FileAccess.open(path, FileAccess.READ)
    var content = file.get_as_text()
    file.close()

    return {"content": content, "path": path}
```

**Test:**
1. Start MCP server
2. Open Godot with plugin
3. In RAGy, ask: "List the files in my Godot project's root directory"
4. Verify real file listing returned

---

### Phase 5: Scene Tools

**Tools to implement:**
- `read_scene` - Parse .tscn file structure
- `create_scene` - Create new scene
- `add_node` - Add node to scene
- `modify_node_property` - Change node property

Reference the old implementations:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/scene_operations/`

---

### Phase 6: Script Tools

**Tools to implement:**
- `create_script` - Create new GDScript
- `apply_diff_preview` - Apply code edits
- `validate_script` - Check syntax

Reference:
- `/Users/tomeryud/godot-ai-assistant/addons/ai_assistant/tools/script_operations/`

---

### Phase 7: All Remaining Tools

Port remaining tools from old project:
- Project settings tools
- Debug tools
- Asset tools

---

### Phase 8: RAGy Integration

**Goal:** Add Godot MCP server to RAGy with settings UI.

**Files to modify in RAGy:**

1. `/Users/tomeryud/projects/RAGy/server/mcp/mcp-client.js`:
```javascript
// Add in initialize():
if (settings.godotEnabled) {
  await this.connectToServer('godot', {
    command: 'node',
    args: ['/Users/tomeryud/godot-mcp/mcp-server/src/index.js'],
  });
}
```

2. Add settings for enabling/disabling Godot tools
3. Add UI indicator for Godot connection status

---

## Part 6: Testing Checklist

### Phase 1 Tests
- [ ] MCP server starts without errors
- [ ] RAGy connects to MCP server
- [ ] Mock tools appear in AI tool list
- [ ] AI can call mock tools and get responses

### Phase 2 Tests
- [ ] WebSocket server starts on port 6505
- [ ] External WebSocket client can connect
- [ ] Messages sent/received correctly
- [ ] Timeout handling works

### Phase 3 Tests
- [ ] Plugin loads in Godot without errors
- [ ] Plugin connects to MCP server
- [ ] Connection status updates correctly
- [ ] Reconnection works after disconnect

### Phase 4 Tests
- [ ] `list_dir` returns real directory contents
- [ ] `read_file` returns real file contents
- [ ] Errors handled gracefully
- [ ] Full flow works: RAGy → AI → MCP → Godot → result

### Phase 5-7 Tests
- [ ] Each tool works individually
- [ ] Complex workflows work (create scene, add nodes, add script)
- [ ] Error handling for all edge cases

### Phase 8 Tests
- [ ] Godot tools can be enabled/disabled in RAGy
- [ ] Connection status shows in RAGy UI
- [ ] Graceful handling when Godot not connected

---

## Part 7: Key Technical Details

### MCP Protocol Basics

MCP uses JSON-RPC over stdio (stdin/stdout). The SDK handles this.

**Tool definition format:**
```javascript
{
  name: 'tool_name',
  description: 'What the tool does',
  inputSchema: {
    type: 'object',
    properties: {
      param1: { type: 'string', description: '...' },
      param2: { type: 'number', description: '...' }
    },
    required: ['param1']
  }
}
```

**Tool result format:**
```javascript
{
  content: [
    { type: 'text', text: 'Result as string or JSON' }
  ]
}
```

### Godot 4.x WebSocket API

```gdscript
var socket = WebSocketPeer.new()
socket.connect_to_url("ws://localhost:6505")

# In _process:
socket.poll()
while socket.get_available_packet_count() > 0:
    var data = socket.get_packet().get_string_from_utf8()
    # Handle data

# Send:
socket.send_text(JSON.stringify(message))
```

### Error Handling Strategy

1. **MCP Server errors:** Return error in content with `isError: true`
2. **Godot not connected:** Return clear error message
3. **Tool execution timeout:** 30 second timeout with clear error
4. **Invalid arguments:** Validate and return specific error

---

## Part 8: Commands Reference

### Development Commands

```bash
# Navigate to project
cd /Users/tomeryud/godot-mcp

# Install MCP server dependencies
cd mcp-server && npm install

# Start MCP server standalone (for testing)
cd mcp-server && npm start

# Test WebSocket connection
npx wscat -c ws://localhost:6505
```

### RAGy Commands

```bash
# Navigate to RAGy
cd /Users/tomeryud/projects/RAGy

# Start RAGy (includes MCP servers)
npm run dev
```

---

## Summary

This project creates a clean, modular bridge between Godot and RAGy:

1. **MCP Server (Node.js):** Speaks MCP to RAGy, WebSocket to Godot
2. **Godot Plugin (GDScript):** Minimal, focused on tool execution
3. **Architecture:** Clean separation, reusable, testable

Follow the phases in order, testing each before moving to the next. Use the old godot-ai-assistant as reference for tool implementations but don't modify it.

Start with Phase 1: Create the skeleton MCP server with mock tools.
</file>

<file path="README.md">
# Godot MCP

**Give your AI assistant full access to the Godot editor.**

Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching. AI reads, writes, and manipulates your scenes, scripts, nodes, and project settings directly.

> Godot 4.x · 32 tools · Interactive project visualizer · MIT license

---

## Quick Start

### 1. Add the MCP server to your AI client

The server is hosted on npm — no cloning or building required.

**Claude Desktop** — edit `~/Library/Application Support/Claude/claude_desktop_config.json`:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**Cursor** — add to MCP settings (Settings → MCP → Add Server):
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

Works with any MCP-compatible client.

### 2. Install the Godot plugin

Copy the `godot-plugin/addons/godot_mcp/` folder into your Godot project's `addons/` directory. Then enable it: Project → Project Settings → Plugins → **Godot MCP** → Enable.

### 3. Restart Godot

Check the **top-right corner** of the editor. You should see **MCP Connected** in green. You're ready to go — start talking to your AI about your game.

---

## What Can It Do?

### 32 Tools Across 6 Categories

| Category | Tools | Examples |
|----------|-------|---------|
| **File Operations** | 4 | Browse directories, read files, search project, create scripts |
| **Scene Operations** | 11 | Create scenes, add/remove/move nodes, set properties, attach scripts, assign collision shapes and textures |
| **Script Operations** | 6 | Apply code edits, validate syntax, rename/move files with reference updates |
| **Project Tools** | 9 | Read project settings, input map, collision layers, console errors, scene tree dumps |
| **Asset Generation** | 4 | Generate 2D sprites from SVG, ComfyUI node search, RunningHub workflow execution |
| **Visualization** | 1 | Interactive browser-based project map |

### Interactive Visualizer

Run `map_project` and get a browser-based explorer at `localhost:6510`:
- Force-directed graph of all scripts and their relationships
- Click any script to see variables, functions, signals, and connections
- Edit code directly in the visualizer — changes sync to Godot in real time
- Scene view with node property editing
- Find usages before refactoring

### What Developers Are Saying AI + Godot Is Missing

| Problem | Godot MCP |
|---------|-----------|
| AI can't see my project — constant copy-pasting | **Solved** — AI reads/writes directly |
| `.tscn` files are unreadable to AI | **Solved** — structured scene tools |
| "What properties does this node have?" | **Solved** — full property discovery |
| Debugging is slow — digging through console | **Solved** — AI reads errors and dumps scene tree |
| Can't see the big picture of my project | **Solved** — interactive visualizer |
| Need placeholder art to prototype | **Solved** — SVG generation + AI art pipelines |
| Refactoring breaks things | **Partially solved** — rename with references + find usages |
| AI hallucinates wrong Godot APIs | **Partially solved** — AI sees your actual project context |

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — runs on localhost, no remote connections
- **Single connection** — one Godot instance at a time
- **Editor only** — works in the editor, not in exported games
- **No undo** — changes save directly (use version control)
- **No runtime control** — can't press play or simulate input
- **AI is still limited in Godot knowledge** — it can't create 100% of the game alone, but it can help debug, write scripts, and tag along for the journey

---

## Full Documentation

See [SUMMARY.md](SUMMARY.md) for the complete tool reference, feature list, and detailed pain point analysis.

---

## Development

To build from source instead of using npm:

```bash
cd mcp-server
npm install
npm run build
```

Then point your AI client at `mcp-server/dist/index.js` instead of using `npx`.

---

## License

MIT

---

**[npm package](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="scenes/BitKnob.gd">
extends Control

signal value_changed(new_value: int)

@export var min_value: int = 1
@export var max_value: int = 12
@export var value: int = 1:
	set(v):
		value = clampi(v, min_value, max_value)
		queue_redraw()
@export var min_angle_deg: float = -135.0
@export var max_angle_deg: float = 135.0

var is_dragging: bool = false

func _ready():
	custom_minimum_size = Vector2(220, 220)
	mouse_filter = MOUSE_FILTER_STOP

func _gui_input(event):
	var is_active = false

	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.pressed:
				is_dragging = true
				is_active = true
			else:
				is_dragging = false

	elif event is InputEventScreenTouch:
		if event.pressed:
			is_dragging = true
			is_active = true
		else:
			is_dragging = false

	elif (event is InputEventMouseMotion or event is InputEventScreenDrag) and is_dragging:
		is_active = true

	if is_active:
		_process_input_pos(get_local_mouse_position())

func _process_input_pos(local_pos: Vector2):
	var center = size / 2.0
	var angle = (local_pos - center).angle() # Radians -PI to PI
	var deg = rad_to_deg(angle)

	# Rotate so -90 (up) is 0 for easier calc if needed,
	# but simple clamping to min/max angle range works better standardly.
	# Godot 0 is Right (3 o'clock). -90 is Up. 90 is Down.
	# Our range is typically -135 (South-West) to +135 (South-East) going clockwise via Top.
	# This crosses the -180/180 discontinuity if we go via bottom, but via top (-135 to -180... wait)
	# Let's map typical knob:
	# Min (-135 deg) -> 7-8 o'clock
	# Max (135 deg) -> 4-5 o'clock
	# 0 deg -> 3 o'clock. -90 -> 12 o'clock.
	# The range -135 to +135 is continuous if we treat it as -135...0...+135.
	# But input `angle` returns -180..180.
	# If input is 170 (bottom left), it's outside our range > 135.
	# If input is -170 (bottom left), it's < -135.
	# So simple clamp works for the top hemisphere.

	# Actually, usually knobs have 0 at -90 (Up) or -135 (Start).
	# Let's shift so MinAngle is 0.0 internal progress.

	# Let's just project to closest point in range.
	# Check if angle is in the "dead zone" at the bottom.
	# Dead zone is roughly 135 to 180 and -180 to -135.
	if deg > max_angle_deg and deg < 180:
		deg = max_angle_deg
	elif deg < min_angle_deg and deg > -180:
		deg = min_angle_deg
	elif deg >= 180 or deg <= -180:
		# Bottom center, snap to closest boundary
		if abs(deg - max_angle_deg) < abs(deg - min_angle_deg):
			deg = max_angle_deg
		else:
			deg = min_angle_deg

	# Map deg to value
	var t = (deg - min_angle_deg) / (max_angle_deg - min_angle_deg)
	t = clampf(t, 0.0, 1.0)

	var new_val = roundi(lerp(float(min_value), float(max_value), t))

	if new_val != value:
		value = new_val
		value_changed.emit(value)
		queue_redraw()

func _draw():
	var center = size / 2.0
	var radius = min(size.x, size.y) / 2.0 - 10.0

	# 1. Base/Glow
	draw_circle(center, radius, Color(0.1, 0.1, 0.1, 1.0))
	draw_circle(center, radius * 0.95, Color(0.2, 0.2, 0.2, 1.0))

	# Glow effect (faint rings)
	draw_arc(center, radius * 0.8, 0, TAU, 32, Color(0.2, 1.0, 0.2, 0.05), 4.0)
	draw_arc(center, radius * 0.6, 0, TAU, 32, Color(0.2, 1.0, 0.2, 0.05), 4.0)

	# 2. Ticks
	var total_steps = max_value - min_value
	for i in range(total_steps + 1):
		var t = float(i) / total_steps
		var angle_rad = deg_to_rad(lerp(min_angle_deg, max_angle_deg, t))
		var dir = Vector2.from_angle(angle_rad)
		var p1 = center + dir * (radius - 15)
		var p2 = center + dir * (radius - 5)

		# Highlight active tick
		var val_i = min_value + i
		var color = Color(0.4, 0.4, 0.4)
		var width = 2.0

		if val_i <= value:
			color = Color(0.2, 1.0, 0.2) # Active range
		if val_i == value:
			color = Color(1.0, 1.0, 1.0) # Current value tick
			width = 3.0

		draw_line(p1, p2, color, width, true)

	# 3. Indicator (Needle)
	var t_curr = float(value - min_value) / total_steps
	var angle_curr = deg_to_rad(lerp(min_angle_deg, max_angle_deg, t_curr))
	var dir_curr = Vector2.from_angle(angle_curr)

	draw_line(center, center + dir_curr * (radius - 20), Color(1, 1, 1), 4.0, true)
	draw_circle(center, 8.0, Color(0.8, 0.8, 0.8)) # Pivot cap
</file>

<file path="scenes/TimeKnob.gd">
extends Control

signal value_changed(value: float, delta: float)

@export var min_value: float = 0.0
@export var max_value: float = 30.0
@export var step: float = 0.1
@export var start_angle_deg: float = -225.0
@export var end_angle_deg: float = 45.0
@export var value: float = 0.0

var _dragging: bool = false

func _ready() -> void:
	mouse_filter = Control.MOUSE_FILTER_STOP
	value = _quantize(clampf(value, min_value, max_value))
	queue_redraw()

func _gui_input(event: InputEvent) -> void:
	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			_dragging = true
			_set_value_from_pos(touch_event.position)
		else:
			_dragging = false
	elif event is InputEventScreenDrag:
		if _dragging:
			var drag_event: InputEventScreenDrag = event
			_set_value_from_pos(drag_event.position)
	elif event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT:
			_dragging = mouse_event.pressed
			if mouse_event.pressed:
				_set_value_from_pos(mouse_event.position)
	elif event is InputEventMouseMotion and _dragging:
		var motion_event: InputEventMouseMotion = event
		_set_value_from_pos(motion_event.position)

func _draw() -> void:
	var center: Vector2 = size * 0.5
	var radius: float = minf(size.x, size.y) * 0.42
	if radius <= 2.0:
		return

	var base_color: Color = Color(0.15, 0.15, 0.15, 1.0)
	var active_color: Color = Color(0.2, 0.9, 0.4, 1.0)
	var pointer_color: Color = Color(0.95, 0.95, 0.95, 1.0)

	draw_circle(center, radius, base_color)
	draw_circle(center, radius * 0.82, Color(0.06, 0.06, 0.06, 1.0))

	var start_rad: float = deg_to_rad(start_angle_deg)
	var sweep_rad: float = _get_sweep_rad()
	var current_t: float = _value_to_t(value)

	draw_arc(center, radius * 0.95, start_rad, start_rad + sweep_rad, 64, Color(0.25, 0.25, 0.25, 1.0), 5.0, true)
	draw_arc(center, radius * 0.95, start_rad, start_rad + sweep_rad * current_t, 64, active_color, 6.0, true)

	var marker_angle: float = start_rad + sweep_rad * current_t
	var marker_dir: Vector2 = Vector2(cos(marker_angle), sin(marker_angle))
	var marker_pos: Vector2 = center + marker_dir * radius * 0.70
	draw_circle(marker_pos, radius * 0.10, pointer_color)

func set_knob_value(new_value: float, emit_change: bool = false) -> void:
	var normalized: float = _quantize(clampf(new_value, min_value, max_value))
	if is_equal_approx(normalized, value):
		return

	var delta: float = normalized - value
	value = normalized
	queue_redraw()
	if emit_change:
		value_changed.emit(value, delta)

func _set_value_from_pos(pos: Vector2) -> void:
	var center: Vector2 = size * 0.5
	var local: Vector2 = pos - center
	if local.length() < 4.0:
		return

	var angle: float = atan2(local.y, local.x)
	var t: float = _angle_to_t(angle)
	var new_value: float = min_value + (max_value - min_value) * t
	set_knob_value(new_value, true)

func _get_sweep_rad() -> float:
	var start_rad: float = deg_to_rad(start_angle_deg)
	var end_rad: float = deg_to_rad(end_angle_deg)
	var sweep: float = wrapf(end_rad - start_rad, 0.0, TAU)
	if sweep <= 0.0:
		sweep += TAU
	return sweep

func _angle_to_t(angle: float) -> float:
	var start_rad: float = deg_to_rad(start_angle_deg)
	var sweep: float = _get_sweep_rad()
	var rel: float = wrapf(angle - start_rad, 0.0, TAU)
	var t: float = rel / sweep
	return clampf(t, 0.0, 1.0)

func _value_to_t(current_value: float) -> float:
	if max_value <= min_value:
		return 0.0
	return clampf((current_value - min_value) / (max_value - min_value), 0.0, 1.0)

func _quantize(input_value: float) -> float:
	if step <= 0.0:
		return input_value
	var steps: float = round((input_value - min_value) / step)
	return min_value + steps * step
</file>

<file path="scenes/ui/subnet/BitCell.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/BitCell.gd" id="1_script"]

[node name="BitCell" type="PanelContainer"]
custom_minimum_size = Vector2(50, 50)
mouse_filter = 2
script = ExtResource("1_script")

[node name="LabelValue" type="Label" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
horizontal_alignment = 1
vertical_alignment = 1
text = "-"
</file>

<file path="scenes/ui/subnet/SubnetRuler.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/SubnetRuler.gd" id="1_script"]

[node name="SubnetRuler" type="Control"]
custom_minimum_size = Vector2(0, 132)
size_flags_horizontal = 3
script = ExtResource("1_script")
</file>

<file path="scenes/ui/TagPileZone.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TagPileZone.gd" id="1_script"]

[node name="TagPileZone" type="PanelContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1_script")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="PileTitle" type="Label" parent="VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СКЛАД"

[node name="Scroll" type="ScrollContainer" parent="VBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ItemsGrid" type="GridContainer" parent="VBox/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2
</file>

<file path="scripts/AudioManager.gd">
extends Node

var sounds = {
	"click": load("res://audio/click.wav"),
	"relay": load("res://audio/relay.wav"),
	"error": load("res://audio/error.wav")
}

func play(sound_name: String):
	if sounds.has(sound_name):
		var player = AudioStreamPlayer.new()
		add_child(player)
		player.stream = sounds[sound_name]
		player.play()
		player.finished.connect(player.queue_free)
</file>

<file path="scripts/case_08/fr8_data.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = [
	"id",
	"briefing",
	"format",
	"validator_profile",
	"allowed_containers",
	"slots",
	"fragments",
	"expected_sequence",
	"scoring_model",
	"feedback_rules"
]

const REQUIRED_FRAGMENT_KEYS: Array[String] = ["fragment_id", "label", "kind", "token"]
const REQUIRED_RULE_KEYS: Array[String] = ["code", "min_state", "points", "stability_delta", "verdict_code"]
const REQUIRED_DEFAULT_RULE_KEYS: Array[String] = ["code", "points", "stability_delta", "verdict_code"]
const REQUIRED_FEEDBACK_KEYS: Array[String] = ["UNBALANCED_TAG", "HIERARCHY_VIOLATION", "ORDER_MISMATCH", "OK"]
const SUPPORTED_PROFILES: Array[String] = ["LIST_BASIC", "NAV_MENU", "TABLE_LOG", "FORM_SIMPLE", "ARTICLE_NOTE", "FIGURE_MEDIA"]

static func load_levels(path: String) -> Array:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("FR8Data: failed to open %s" % path)
		return []

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("FR8Data: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return []

	if typeof(json.data) != TYPE_ARRAY:
		push_error("FR8Data: root in %s must be an array" % path)
		return []

	var levels: Array = []
	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_data: Dictionary = level_var as Dictionary
		if validate_level(level_data):
			levels.append(level_data)
		else:
			push_error("FR8Data: invalid level contract: %s" % str(level_data.get("id", "UNKNOWN")))

	return levels

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("FR8Data: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "TAG_ORDERING":
		push_error("FR8Data: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var profile: String = str(level.get("validator_profile", "")).strip_edges().to_upper()
	if not (profile in SUPPORTED_PROFILES):
		push_error("FR8Data: unsupported validator_profile '%s' in level %s" % [profile, str(level.get("id", "UNKNOWN"))])
		return false

	var slots: Array = level.get("slots", []) as Array
	if slots.size() < 5 or slots.size() > 7:
		push_error("FR8Data: level %s must have 5-7 slots" % str(level.get("id", "UNKNOWN")))
		return false

	var slot_ids: Dictionary = {}
	for slot_var in slots:
		var slot_id: String = str(slot_var).strip_edges()
		if slot_id.is_empty() or slot_ids.has(slot_id):
			push_error("FR8Data: duplicate/empty slot id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		slot_ids[slot_id] = true

	var allowed_containers: Array = level.get("allowed_containers", []) as Array
	if allowed_containers.is_empty():
		push_error("FR8Data: level %s has no allowed_containers" % str(level.get("id", "UNKNOWN")))
		return false

	var allowed_map: Dictionary = {}
	for container_var in allowed_containers:
		var container_name: String = str(container_var).strip_edges().to_lower()
		if container_name.is_empty():
			continue
		allowed_map[container_name] = true
	if allowed_map.is_empty():
		push_error("FR8Data: level %s allowed_containers are invalid" % str(level.get("id", "UNKNOWN")))
		return false

	if level.has("allowed_inner_kinds") and typeof(level.get("allowed_inner_kinds")) != TYPE_ARRAY:
		push_error("FR8Data: allowed_inner_kinds must be array in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for req_key in ["required_tags_all", "required_tags_any", "required_kinds_all", "required_kinds_any"]:
		if level.has(req_key) and typeof(level.get(req_key)) != TYPE_ARRAY:
			push_error("FR8Data: %s must be array in level %s" % [req_key, str(level.get("id", "UNKNOWN"))])
			return false

	var fragments: Array = level.get("fragments", []) as Array
	if fragments.is_empty():
		push_error("FR8Data: level %s has empty fragments list" % str(level.get("id", "UNKNOWN")))
		return false

	var fragment_ids: Dictionary = {}
	for fragment_var in fragments:
		if typeof(fragment_var) != TYPE_DICTIONARY:
			push_error("FR8Data: fragment entry must be a dictionary")
			return false
		var fragment: Dictionary = fragment_var as Dictionary
		for key in REQUIRED_FRAGMENT_KEYS:
			if not fragment.has(key):
				push_error("FR8Data: fragment is missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
				return false
		var fragment_id: String = str(fragment.get("fragment_id", "")).strip_edges()
		if fragment_id.is_empty() or fragment_ids.has(fragment_id):
			push_error("FR8Data: duplicate/empty fragment_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		fragment_ids[fragment_id] = true

	var expected_sequence: Array = level.get("expected_sequence", []) as Array
	if expected_sequence.size() != slots.size():
		push_error("FR8Data: expected_sequence length mismatch in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for expected_var in expected_sequence:
		var expected_id: String = str(expected_var).strip_edges()
		if expected_id == "(EMPTY)":
			continue
		if expected_id.is_empty():
			push_error("FR8Data: expected_sequence cannot contain empty ids (use '(EMPTY)') in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not fragment_ids.has(expected_id):
			push_error("FR8Data: expected fragment '%s' missing in level %s" % [expected_id, str(level.get("id", "UNKNOWN"))])
			return false

	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = scoring_model.get("rules", []) as Array
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	if rules.is_empty() or default_rule.is_empty():
		push_error("FR8Data: scoring_model is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for rule_var in rules:
		if typeof(rule_var) != TYPE_DICTIONARY:
			push_error("FR8Data: scoring rule must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var rule: Dictionary = rule_var as Dictionary
		for rule_key in REQUIRED_RULE_KEYS:
			if not rule.has(rule_key):
				push_error("FR8Data: scoring rule key '%s' is missing in level %s" % [rule_key, str(level.get("id", "UNKNOWN"))])
				return false
		var min_state: String = str(rule.get("min_state", "")).to_upper()
		if not (min_state in ["ORDER_OK", "SYNTAX_OK", "FAIL", "ANY"]):
			push_error("FR8Data: unsupported min_state '%s' in level %s" % [min_state, str(level.get("id", "UNKNOWN"))])
			return false

	for default_key in REQUIRED_DEFAULT_RULE_KEYS:
		if not default_rule.has(default_key):
			push_error("FR8Data: default_rule key '%s' is missing in level %s" % [default_key, str(level.get("id", "UNKNOWN"))])
			return false

	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	for feedback_key in REQUIRED_FEEDBACK_KEYS:
		if not feedback_rules.has(feedback_key):
			push_error("FR8Data: feedback rule '%s' missing in level %s" % [feedback_key, str(level.get("id", "UNKNOWN"))])
			return false

	return true
</file>

<file path="scripts/case_08/fr8_scoring.gd">
extends RefCounted

const PROFILE_LIST_BASIC := "LIST_BASIC"
const PROFILE_NAV_MENU := "NAV_MENU"
const PROFILE_TABLE_LOG := "TABLE_LOG"
const PROFILE_FORM_SIMPLE := "FORM_SIMPLE"
const PROFILE_ARTICLE_NOTE := "ARTICLE_NOTE"
const PROFILE_FIGURE_MEDIA := "FIGURE_MEDIA"

const STATE_INCOMPLETE := "INCOMPLETE"
const STATE_ORDER_OK := "ORDER_OK"
const STATE_SYNTAX_OK := "SYNTAX_OK"
const STATE_FAIL := "FAIL"

const ERROR_INCOMPLETE := "INCOMPLETE"
const ERROR_UNBALANCED := "UNBALANCED_TAG"
const ERROR_HIERARCHY := "HIERARCHY_VIOLATION"
const ERROR_REQUIRED := "REQUIRED_TAG_MISSING"
const ERROR_ORDER := "ORDER_MISMATCH"
const ERROR_OK := "OK"

static func normalize_expected_sequence(level: Dictionary) -> Array[String]:
	var raw_expected: Array = level.get("expected_sequence", []) as Array
	var normalized: Array[String] = []
	for expected_var in raw_expected:
		var expected_id: String = str(expected_var).strip_edges()
		normalized.append("" if expected_id == "(EMPTY)" else expected_id)
	return normalized

static func evaluate(level: Dictionary, sequence: Array, fragment_by_id: Dictionary) -> Dictionary:
	var expected_sequence: Array[String] = normalize_expected_sequence(level)
	var checks: Dictionary = {
		"container_ok": false,
		"hierarchy_ok": false,
		"required_ok": false,
		"order_ok": false
	}

	if _is_incomplete(sequence, expected_sequence):
		return {
			"state": STATE_INCOMPLETE,
			"error_code": ERROR_INCOMPLETE,
			"incomplete": true,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}

	var first_index: int = -1
	var last_index: int = -1
	for i in range(sequence.size()):
		var fragment_id: String = str(sequence[i]).strip_edges()
		if fragment_id.is_empty():
			continue
		if first_index < 0:
			first_index = i
		last_index = i

	if first_index < 0 or last_index <= first_index:
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_UNBALANCED,
			"incomplete": false,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}

	var profile: String = str(level.get("validator_profile", PROFILE_LIST_BASIC)).to_upper()

	var open_id: String = str(sequence[first_index]).strip_edges()
	var close_id: String = str(sequence[last_index]).strip_edges()
	var open_kind: String = _fragment_kind(fragment_by_id, open_id)
	var close_kind: String = _fragment_kind(fragment_by_id, close_id)
	if open_kind != "CONTAINER_OPEN" or close_kind != "CONTAINER_CLOSE":
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_UNBALANCED,
			"incomplete": false,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}

	var allowed_containers: Dictionary = {}
	for container_var in level.get("allowed_containers", []) as Array:
		allowed_containers[str(container_var).strip_edges().to_lower()] = true

	var open_tag: String = _container_tag(fragment_by_id, open_id)
	var close_tag: String = _container_tag(fragment_by_id, close_id)
	if open_tag.is_empty() or close_tag.is_empty() or open_tag != close_tag or not allowed_containers.has(open_tag):
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_UNBALANCED,
			"incomplete": false,
			"checks": checks,
			"container_ok": false,
			"hierarchy_ok": false,
			"order_ok": false
		}
	checks["container_ok"] = true

	var allowed_inner_kinds: Dictionary = _allowed_inner_kind_map(level, profile)
	var inner_fragment_ids: Array[String] = []
	for i in range(first_index + 1, last_index):
		var inner_id: String = str(sequence[i]).strip_edges()
		if inner_id.is_empty():
			return {
				"state": STATE_FAIL,
				"error_code": ERROR_HIERARCHY,
				"incomplete": false,
				"checks": checks,
				"container_ok": true,
				"hierarchy_ok": false,
				"order_ok": false
			}
		inner_fragment_ids.append(inner_id)
		var inner_kind: String = _fragment_kind(fragment_by_id, inner_id)
		if not allowed_inner_kinds.has(inner_kind):
			return {
				"state": STATE_FAIL,
				"error_code": ERROR_HIERARCHY,
				"incomplete": false,
				"checks": checks,
				"container_ok": true,
				"hierarchy_ok": false,
				"order_ok": false
			}
	checks["hierarchy_ok"] = true

	var required_result: Dictionary = _check_required(level, profile, inner_fragment_ids, fragment_by_id)
	if not bool(required_result.get("ok", false)):
		return {
			"state": STATE_FAIL,
			"error_code": ERROR_REQUIRED,
			"incomplete": false,
			"checks": checks,
			"container_ok": true,
			"hierarchy_ok": true,
			"order_ok": false
		}
	checks["required_ok"] = true

	var order_ok: bool = _sequence_equals_expected(sequence, expected_sequence)
	checks["order_ok"] = order_ok

	if order_ok:
		return {
			"state": STATE_ORDER_OK,
			"error_code": ERROR_OK,
			"incomplete": false,
			"checks": checks,
			"container_ok": true,
			"hierarchy_ok": true,
			"order_ok": true
		}

	return {
		"state": STATE_SYNTAX_OK,
		"error_code": ERROR_ORDER,
		"incomplete": false,
		"checks": checks,
		"container_ok": true,
		"hierarchy_ok": true,
		"order_ok": false
	}

static func resolve_score(level: Dictionary, evaluation: Dictionary) -> Dictionary:
	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = scoring_model.get("rules", []) as Array
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	var state: String = str(evaluation.get("state", STATE_FAIL))
	var incomplete: bool = bool(evaluation.get("incomplete", false))

	var max_points: int = 0
	for rule_var in rules:
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule_data: Dictionary = rule_var as Dictionary
		max_points = max(max_points, int(rule_data.get("points", 0)))

	var selected_rule: Dictionary = {}
	if incomplete:
		selected_rule = default_rule
	else:
		for rule_var in rules:
			if typeof(rule_var) != TYPE_DICTIONARY:
				continue
			var rule: Dictionary = rule_var as Dictionary
			var min_state: String = str(rule.get("min_state", "ANY")).to_upper()
			if _state_matches(state, min_state):
				selected_rule = rule
				break

	if selected_rule.is_empty():
		selected_rule = {
			"code": "FALLBACK",
			"points": 0,
			"stability_delta": -30,
			"verdict_code": "FAIL"
		}

	var is_fit: bool = false
	var is_correct: bool = false
	if not incomplete:
		if state == STATE_ORDER_OK:
			is_fit = true
			is_correct = true
		elif state == STATE_SYNTAX_OK:
			is_fit = true

	return {
		"rule_code": str(selected_rule.get("code", "SCORING_RULE")),
		"points": int(selected_rule.get("points", 0)),
		"max_points": max_points,
		"stability_delta": int(selected_rule.get("stability_delta", -30)),
		"verdict_code": str(selected_rule.get("verdict_code", "FAIL")),
		"is_fit": is_fit,
		"is_correct": is_correct
	}

static func feedback_text(level: Dictionary, evaluation: Dictionary) -> String:
	if bool(evaluation.get("incomplete", false)):
		return "Не все фрагменты вставлены"

	var error_code: String = str(evaluation.get("error_code", ERROR_ORDER))
	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	if feedback_rules.has(error_code):
		return str(feedback_rules.get(error_code, ""))
	if feedback_rules.has("OK"):
		return str(feedback_rules.get("OK", ""))
	return "Проверка завершена."

static func _is_incomplete(sequence: Array, expected_sequence: Array[String]) -> bool:
	if sequence.size() != expected_sequence.size():
		return true
	for i in range(sequence.size()):
		var actual_id: String = str(sequence[i]).strip_edges()
		var expected_id: String = expected_sequence[i]
		if actual_id.is_empty() and not expected_id.is_empty():
			return true
	return false

static func _allowed_inner_kind_map(level: Dictionary, profile: String) -> Dictionary:
	var base_kinds: Array[String] = []
	match profile:
		PROFILE_LIST_BASIC:
			base_kinds = ["LI_ITEM"]
		PROFILE_NAV_MENU:
			base_kinds = ["LINK", "LI_ITEM", "TEXT_BLOCK", "NAV_LIST_OPEN", "NAV_LIST_CLOSE"]
		PROFILE_TABLE_LOG:
			base_kinds = ["TR_ROW"]
		PROFILE_FORM_SIMPLE:
			base_kinds = ["FORM_FIELD", "BUTTON", "TEXT_BLOCK"]
		PROFILE_ARTICLE_NOTE:
			base_kinds = ["TEXT_BLOCK"]
		PROFILE_FIGURE_MEDIA:
			base_kinds = ["MEDIA", "TEXT_BLOCK"]
		_:
			base_kinds = ["LI_ITEM"]

	for kind_var in level.get("allowed_inner_kinds", []) as Array:
		var kind_name: String = str(kind_var).strip_edges().to_upper()
		if kind_name.is_empty():
			continue
		if not (kind_name in base_kinds):
			base_kinds.append(kind_name)

	var out: Dictionary = {}
	for kind_name in base_kinds:
		out[kind_name] = true
	return out

static func _check_required(level: Dictionary, profile: String, inner_fragment_ids: Array[String], fragment_by_id: Dictionary) -> Dictionary:
	var required_tags_all: Array[String] = _to_lower_str_array(level.get("required_tags_all", []))
	var required_tags_any: Array[String] = _to_lower_str_array(level.get("required_tags_any", []))
	var required_kinds_all: Array[String] = _to_upper_str_array(level.get("required_kinds_all", []))
	var required_kinds_any: Array[String] = _to_upper_str_array(level.get("required_kinds_any", []))

	if profile == PROFILE_NAV_MENU and required_tags_any.is_empty():
		required_tags_any.append("a")
	if profile == PROFILE_FORM_SIMPLE and required_tags_all.is_empty():
		required_tags_all.append_array(["input", "button"])
	if profile == PROFILE_FIGURE_MEDIA and required_tags_all.is_empty():
		required_tags_all.append_array(["img", "figcaption"])

	var inner_kind_map: Dictionary = {}
	var inner_tag_map: Dictionary = {}
	for fragment_id in inner_fragment_ids:
		var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
		var kind_name: String = str(fragment_data.get("kind", "")).to_upper()
		if not kind_name.is_empty():
			inner_kind_map[kind_name] = true

		var token: String = str(fragment_data.get("token", ""))
		for tag_name in _extract_tag_names(token):
			inner_tag_map[tag_name] = true

	for tag_name in required_tags_all:
		if not inner_tag_map.has(tag_name):
			return {"ok": false}
	if not required_tags_any.is_empty():
		var any_tag_found: bool = false
		for tag_name in required_tags_any:
			if inner_tag_map.has(tag_name):
				any_tag_found = true
				break
		if not any_tag_found:
			return {"ok": false}

	for kind_name in required_kinds_all:
		if not inner_kind_map.has(kind_name):
			return {"ok": false}
	if not required_kinds_any.is_empty():
		var any_kind_found: bool = false
		for kind_name in required_kinds_any:
			if inner_kind_map.has(kind_name):
				any_kind_found = true
				break
		if not any_kind_found:
			return {"ok": false}

	return {"ok": true}

static func _to_lower_str_array(raw: Variant) -> Array[String]:
	var out: Array[String] = []
	if typeof(raw) != TYPE_ARRAY:
		return out
	var raw_array: Array = raw as Array
	for item in raw_array:
		var value: String = str(item).strip_edges().to_lower()
		if value.is_empty():
			continue
		if not (value in out):
			out.append(value)
	return out

static func _to_upper_str_array(raw: Variant) -> Array[String]:
	var out: Array[String] = []
	if typeof(raw) != TYPE_ARRAY:
		return out
	var raw_array: Array = raw as Array
	for item in raw_array:
		var value: String = str(item).strip_edges().to_upper()
		if value.is_empty():
			continue
		if not (value in out):
			out.append(value)
	return out

static func _extract_tag_names(token: String) -> Array[String]:
	var out: Array[String] = []
	var lower_token: String = token.to_lower()
	var cursor: int = 0
	while true:
		var start_idx: int = lower_token.find("<", cursor)
		if start_idx < 0:
			break
		var end_idx: int = lower_token.find(">", start_idx + 1)
		if end_idx < 0:
			break

		var segment: String = lower_token.substr(start_idx + 1, end_idx - start_idx - 1).strip_edges()
		if segment.begins_with("/"):
			segment = segment.substr(1).strip_edges()
		if segment.begins_with("!"):
			cursor = end_idx + 1
			continue

		var space_idx: int = segment.find(" ")
		var slash_idx: int = segment.find("/")
		var cut_idx: int = segment.length()
		if space_idx >= 0:
			cut_idx = min(cut_idx, space_idx)
		if slash_idx >= 0:
			cut_idx = min(cut_idx, slash_idx)
		var tag_name: String = segment.substr(0, cut_idx).strip_edges()
		if not tag_name.is_empty() and not (tag_name in out):
			out.append(tag_name)

		cursor = end_idx + 1
	return out

static func _fragment_kind(fragment_by_id: Dictionary, fragment_id: String) -> String:
	if not fragment_by_id.has(fragment_id):
		return ""
	var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
	return str(fragment_data.get("kind", "")).to_upper()

static func _container_tag(fragment_by_id: Dictionary, fragment_id: String) -> String:
	if not fragment_by_id.has(fragment_id):
		return ""
	var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
	var token: String = str(fragment_data.get("token", "")).strip_edges().to_lower()
	var tags: Array[String] = _extract_tag_names(token)
	if tags.is_empty():
		return ""
	return tags[0]

static func _sequence_equals_expected(sequence: Array, expected_sequence: Array[String]) -> bool:
	if sequence.size() != expected_sequence.size():
		return false
	for i in range(sequence.size()):
		if str(sequence[i]).strip_edges() != expected_sequence[i]:
			return false
	return true

static func _state_matches(state: String, min_state: String) -> bool:
	match min_state:
		"ORDER_OK":
			return state == STATE_ORDER_OK
		"SYNTAX_OK":
			return state == STATE_SYNTAX_OK or state == STATE_ORDER_OK
		"FAIL":
			return state == STATE_FAIL
		"ANY":
			return true
		_:
			return false
</file>

<file path="scripts/case_08/fr8b_data.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = [
	"id",
	"briefing",
	"format",
	"cards",
	"dependencies",
	"expected_order",
	"feedback_rules",
	"scoring_model",
	"anti_cheat"
]

const REQUIRED_CARD_KEYS: Array[String] = ["stage_id", "title", "hint"]
const REQUIRED_DEP_KEYS: Array[String] = ["a", "b", "code"]
const REQUIRED_FEEDBACK_KEYS: Array[String] = ["LOGIC_GAP", "CAUSALITY_LOOP", "ORDER_MISMATCH", "OK"]
const REQUIRED_SCORE_KEYS: Array[String] = ["points", "stability_delta", "verdict_code"]
const ALLOWED_DEP_CODES: Array[String] = ["LOGIC_GAP", "CAUSALITY_LOOP"]

static func load_levels(path: String) -> Array:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("FR8BData: failed to open %s" % path)
		return []

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("FR8BData: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return []

	if typeof(json.data) != TYPE_ARRAY:
		push_error("FR8BData: root in %s must be an array" % path)
		return []

	var levels: Array = []
	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_data: Dictionary = level_var as Dictionary
		if validate_level(level_data):
			levels.append(level_data)
		else:
			push_error("FR8BData: invalid level contract: %s" % str(level_data.get("id", "UNKNOWN")))

	return levels

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("FR8BData: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "TIMELINE_SORT":
		push_error("FR8BData: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var cards_var: Variant = level.get("cards", [])
	if typeof(cards_var) != TYPE_ARRAY:
		push_error("FR8BData: cards must be an array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var cards: Array = cards_var as Array
	if cards.size() < 4 or cards.size() > 7:
		push_error("FR8BData: level %s must have 4-7 cards" % str(level.get("id", "UNKNOWN")))
		return false

	var stage_ids: Dictionary = {}
	for card_var in cards:
		if typeof(card_var) != TYPE_DICTIONARY:
			push_error("FR8BData: card entry must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var card: Dictionary = card_var as Dictionary
		for card_key in REQUIRED_CARD_KEYS:
			if not card.has(card_key):
				push_error("FR8BData: card missing key '%s' in level %s" % [card_key, str(level.get("id", "UNKNOWN"))])
				return false
		var stage_id: String = str(card.get("stage_id", "")).strip_edges()
		if stage_id.is_empty() or stage_ids.has(stage_id):
			push_error("FR8BData: duplicate/empty stage_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		stage_ids[stage_id] = true

	var expected_var: Variant = level.get("expected_order", [])
	if typeof(expected_var) != TYPE_ARRAY:
		push_error("FR8BData: expected_order must be an array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var expected_order: Array = expected_var as Array
	if expected_order.size() != cards.size():
		push_error("FR8BData: expected_order length mismatch in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var expected_seen: Dictionary = {}
	for stage_var in expected_order:
		var stage_id: String = str(stage_var).strip_edges()
		if stage_id.is_empty() or expected_seen.has(stage_id):
			push_error("FR8BData: duplicate/empty expected_order value in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not stage_ids.has(stage_id):
			push_error("FR8BData: unknown stage_id '%s' in expected_order (%s)" % [stage_id, str(level.get("id", "UNKNOWN"))])
			return false
		expected_seen[stage_id] = true

	var deps_var: Variant = level.get("dependencies", [])
	if typeof(deps_var) != TYPE_ARRAY:
		push_error("FR8BData: dependencies must be an array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var deps: Array = deps_var as Array
	if deps.is_empty():
		push_error("FR8BData: dependencies cannot be empty in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for dep_var in deps:
		if typeof(dep_var) != TYPE_DICTIONARY:
			push_error("FR8BData: dependency must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var dep: Dictionary = dep_var as Dictionary
		for dep_key in REQUIRED_DEP_KEYS:
			if not dep.has(dep_key):
				push_error("FR8BData: dependency missing key '%s' in level %s" % [dep_key, str(level.get("id", "UNKNOWN"))])
				return false
		var a: String = str(dep.get("a", "")).strip_edges()
		var b: String = str(dep.get("b", "")).strip_edges()
		if a.is_empty() or b.is_empty() or a == b:
			push_error("FR8BData: invalid dependency endpoints in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not stage_ids.has(a) or not stage_ids.has(b):
			push_error("FR8BData: dependency uses unknown stage_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var dep_code: String = str(dep.get("code", "")).to_upper()
		if not (dep_code in ALLOWED_DEP_CODES):
			push_error("FR8BData: unsupported dependency code '%s' in level %s" % [dep_code, str(level.get("id", "UNKNOWN"))])
			return false

	var feedback_var: Variant = level.get("feedback_rules", {})
	if typeof(feedback_var) != TYPE_DICTIONARY:
		push_error("FR8BData: feedback_rules must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var feedback_rules: Dictionary = feedback_var as Dictionary
	for feedback_key in REQUIRED_FEEDBACK_KEYS:
		if not feedback_rules.has(feedback_key):
			push_error("FR8BData: feedback rule '%s' missing in level %s" % [feedback_key, str(level.get("id", "UNKNOWN"))])
			return false

	var scoring_var: Variant = level.get("scoring_model", {})
	if typeof(scoring_var) != TYPE_DICTIONARY:
		push_error("FR8BData: scoring_model must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var scoring_model: Dictionary = scoring_var as Dictionary
	if not scoring_model.has("perfect") or not scoring_model.has("fail"):
		push_error("FR8BData: scoring_model must contain perfect/fail in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for score_key in ["perfect", "fail"]:
		var score_rule_var: Variant = scoring_model.get(score_key, {})
		if typeof(score_rule_var) != TYPE_DICTIONARY:
			push_error("FR8BData: scoring_model.%s must be dictionary in level %s" % [score_key, str(level.get("id", "UNKNOWN"))])
			return false
		var score_rule: Dictionary = score_rule_var as Dictionary
		for rule_key in REQUIRED_SCORE_KEYS:
			if not score_rule.has(rule_key):
				push_error("FR8BData: scoring_model.%s missing key '%s' in level %s" % [score_key, rule_key, str(level.get("id", "UNKNOWN"))])
				return false

	var anti_cheat_var: Variant = level.get("anti_cheat", {})
	if typeof(anti_cheat_var) != TYPE_DICTIONARY:
		push_error("FR8BData: anti_cheat must be a dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var anti_cheat: Dictionary = anti_cheat_var as Dictionary
	if anti_cheat.has("shuffle_cards") and typeof(anti_cheat.get("shuffle_cards", false)) != TYPE_BOOL:
		push_error("FR8BData: anti_cheat.shuffle_cards must be bool in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	return true
</file>

<file path="scripts/case_08/fr8b_scoring.gd">
extends RefCounted

const STATE_ORDER_OK := "ORDER_OK"
const STATE_FAIL := "FAIL"

const ERROR_LOGIC_GAP := "LOGIC_GAP"
const ERROR_CAUSALITY_LOOP := "CAUSALITY_LOOP"
const ERROR_ORDER_MISMATCH := "ORDER_MISMATCH"
const ERROR_OK := "OK"

static func evaluate(level: Dictionary, current_order: Array[String]) -> Dictionary:
	var normalized_order: Array[String] = []
	for stage_id in current_order:
		normalized_order.append(str(stage_id).strip_edges())

	var expected_order: Array[String] = _normalized_array(level.get("expected_order", []))
	var positions: Dictionary = {}
	for i in range(normalized_order.size()):
		var stage_id: String = normalized_order[i]
		if stage_id.is_empty():
			continue
		positions[stage_id] = i

	var violations: Array = []
	for dep_var in level.get("dependencies", []) as Array:
		if typeof(dep_var) != TYPE_DICTIONARY:
			continue
		var dep: Dictionary = dep_var as Dictionary
		var a: String = str(dep.get("a", "")).strip_edges()
		var b: String = str(dep.get("b", "")).strip_edges()
		if a.is_empty() or b.is_empty():
			continue

		var broken: bool = false
		if not positions.has(a) or not positions.has(b):
			broken = true
		elif int(positions[a]) >= int(positions[b]):
			broken = true

		if broken:
			violations.append({
				"a": a,
				"b": b,
				"code": str(dep.get("code", ERROR_LOGIC_GAP)).to_upper(),
				"message": str(dep.get("message", ""))
			})

	if not violations.is_empty():
		var top_error: String = _pick_top_error(violations)
		var top_violation: Dictionary = _pick_top_violation(violations, top_error)
		return {
			"state": STATE_FAIL,
			"error_code": top_error,
			"violations": violations,
			"top_violation": top_violation,
			"order_ok": false
		}

	var order_ok: bool = _arrays_equal(normalized_order, expected_order)
	if order_ok:
		return {
			"state": STATE_ORDER_OK,
			"error_code": ERROR_OK,
			"violations": [],
			"top_violation": {},
			"order_ok": true
		}

	return {
		"state": STATE_FAIL,
		"error_code": ERROR_ORDER_MISMATCH,
		"violations": [],
		"top_violation": {},
		"order_ok": false
	}

static func resolve_score(level: Dictionary, evaluation: Dictionary) -> Dictionary:
	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var perfect_rule: Dictionary = scoring_model.get("perfect", {
		"points": 2,
		"stability_delta": 0,
		"verdict_code": "PERFECT"
	}) as Dictionary
	var fail_rule: Dictionary = scoring_model.get("fail", {
		"points": 0,
		"stability_delta": -25,
		"verdict_code": "FAIL"
	}) as Dictionary

	var is_order_ok: bool = str(evaluation.get("state", STATE_FAIL)) == STATE_ORDER_OK
	var selected: Dictionary = perfect_rule if is_order_ok else fail_rule
	var max_points: int = max(int(perfect_rule.get("points", 2)), int(fail_rule.get("points", 0)))

	return {
		"points": int(selected.get("points", 0)),
		"max_points": max_points,
		"stability_delta": int(selected.get("stability_delta", -25)),
		"verdict_code": str(selected.get("verdict_code", "FAIL")),
		"is_fit": is_order_ok,
		"is_correct": is_order_ok
	}

static func feedback_text(level: Dictionary, evaluation: Dictionary) -> String:
	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	var error_code: String = str(evaluation.get("error_code", ERROR_ORDER_MISMATCH))
	var top_violation: Dictionary = evaluation.get("top_violation", {}) as Dictionary

	if not top_violation.is_empty() and (error_code == ERROR_CAUSALITY_LOOP or error_code == ERROR_LOGIC_GAP):
		var msg: String = str(top_violation.get("message", "")).strip_edges()
		if not msg.is_empty():
			return msg

	if feedback_rules.has(error_code):
		return str(feedback_rules.get(error_code, ""))
	if feedback_rules.has(ERROR_OK):
		return str(feedback_rules.get(ERROR_OK, ""))
	return "Проверка завершена."

static func _pick_top_error(violations: Array) -> String:
	for violation_var in violations:
		if typeof(violation_var) != TYPE_DICTIONARY:
			continue
		var violation: Dictionary = violation_var as Dictionary
		if str(violation.get("code", "")).to_upper() == ERROR_CAUSALITY_LOOP:
			return ERROR_CAUSALITY_LOOP

	for violation_var in violations:
		if typeof(violation_var) != TYPE_DICTIONARY:
			continue
		var violation: Dictionary = violation_var as Dictionary
		if str(violation.get("code", "")).to_upper() == ERROR_LOGIC_GAP:
			return ERROR_LOGIC_GAP

	return ERROR_ORDER_MISMATCH

static func _pick_top_violation(violations: Array, error_code: String) -> Dictionary:
	for violation_var in violations:
		if typeof(violation_var) != TYPE_DICTIONARY:
			continue
		var violation: Dictionary = violation_var as Dictionary
		if str(violation.get("code", "")).to_upper() == error_code:
			return violation
	if violations.is_empty():
		return {}
	if typeof(violations[0]) != TYPE_DICTIONARY:
		return {}
	return violations[0] as Dictionary

static func _normalized_array(raw: Variant) -> Array[String]:
	var out: Array[String] = []
	if typeof(raw) != TYPE_ARRAY:
		return out
	for item in raw as Array:
		out.append(str(item).strip_edges())
	return out

static func _arrays_equal(a: Array[String], b: Array[String]) -> bool:
	if a.size() != b.size():
		return false
	for i in range(a.size()):
		if a[i] != b[i]:
			return false
	return true
</file>

<file path="scripts/case_08/fr8c_data.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = [
	"id",
	"briefing",
	"format",
	"target_text",
	"html",
	"rules",
	"options",
	"correct_option_id",
	"feedback_rules"
]

const REQUIRED_RULE_KEYS: Array[String] = ["source_id", "kind", "weight", "important", "decl"]
const REQUIRED_DECL_KEYS: Array[String] = ["prop", "value"]
const REQUIRED_OPTION_KEYS: Array[String] = ["id", "label", "value"]

static func load_levels(path: String) -> Array:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("FR8CData: failed to open %s" % path)
		return []

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("FR8CData: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return []

	if typeof(json.data) != TYPE_ARRAY:
		push_error("FR8CData: root in %s must be an array" % path)
		return []

	var levels: Array = []
	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level_data: Dictionary = level_var as Dictionary
		if validate_level(level_data):
			levels.append(level_data)
		else:
			push_error("FR8CData: invalid level contract: %s" % str(level_data.get("id", "UNKNOWN")))
	return levels

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("FR8CData: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "CSS_CASCADE":
		push_error("FR8CData: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var html_var: Variant = level.get("html", [])
	if typeof(html_var) != TYPE_ARRAY or (html_var as Array).is_empty():
		push_error("FR8CData: html must be non-empty array in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var rules_var: Variant = level.get("rules", [])
	if typeof(rules_var) != TYPE_ARRAY or (rules_var as Array).is_empty():
		push_error("FR8CData: rules must be non-empty array in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var source_ids: Dictionary = {}
	for i in range((rules_var as Array).size()):
		var rule_var: Variant = (rules_var as Array)[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			push_error("FR8CData: rule entry must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var rule: Dictionary = rule_var as Dictionary
		for rule_key in REQUIRED_RULE_KEYS:
			if not rule.has(rule_key):
				push_error("FR8CData: rule missing key '%s' in level %s" % [rule_key, str(level.get("id", "UNKNOWN"))])
				return false
		if _selector_of(rule).is_empty():
			push_error("FR8CData: rule selector missing in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var source_id: String = str(rule.get("source_id", "")).strip_edges()
		if source_id.is_empty() or source_ids.has(source_id):
			push_error("FR8CData: duplicate/empty source_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		source_ids[source_id] = true
		if not _is_number(rule.get("weight", 0)):
			push_error("FR8CData: rule weight must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if typeof(rule.get("important", false)) != TYPE_BOOL:
			push_error("FR8CData: rule important must be bool in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if rule.has("order") and not _is_number(rule.get("order", 0)):
			push_error("FR8CData: rule order must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var decl_var: Variant = rule.get("decl", {})
		if typeof(decl_var) != TYPE_DICTIONARY:
			push_error("FR8CData: rule decl must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var decl: Dictionary = decl_var as Dictionary
		for decl_key in REQUIRED_DECL_KEYS:
			if not decl.has(decl_key):
				push_error("FR8CData: rule decl missing '%s' in level %s" % [decl_key, str(level.get("id", "UNKNOWN"))])
				return false

	if level.has("inline_decl") and level.get("inline_decl") != null:
		var inline_var: Variant = level.get("inline_decl")
		if typeof(inline_var) != TYPE_DICTIONARY:
			push_error("FR8CData: inline_decl must be dictionary/null in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var inline_decl: Dictionary = inline_var as Dictionary
		for inline_key in ["source_id", "kind", "weight", "important", "decl"]:
			if not inline_decl.has(inline_key):
				push_error("FR8CData: inline_decl missing '%s' in level %s" % [inline_key, str(level.get("id", "UNKNOWN"))])
				return false
		if inline_decl.has("order") and not _is_number(inline_decl.get("order", 0)):
			push_error("FR8CData: inline_decl order must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if not _is_number(inline_decl.get("weight", 0)):
			push_error("FR8CData: inline_decl weight must be int in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if typeof(inline_decl.get("decl", {})) != TYPE_DICTIONARY:
			push_error("FR8CData: inline_decl decl must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false

	var options_var: Variant = level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY or (options_var as Array).size() < 2:
		push_error("FR8CData: options must be array(>=2) in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var option_ids: Dictionary = {}
	for option_var in options_var as Array:
		if typeof(option_var) != TYPE_DICTIONARY:
			push_error("FR8CData: option entry must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		var option: Dictionary = option_var as Dictionary
		for option_key in REQUIRED_OPTION_KEYS:
			if not option.has(option_key):
				push_error("FR8CData: option missing key '%s' in level %s" % [option_key, str(level.get("id", "UNKNOWN"))])
				return false
		var option_id: String = str(option.get("id", "")).strip_edges()
		if option_id.is_empty() or option_ids.has(option_id):
			push_error("FR8CData: duplicate/empty option id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		option_ids[option_id] = true

	var correct_option_id: String = str(level.get("correct_option_id", "")).strip_edges()
	if correct_option_id.is_empty() or not option_ids.has(correct_option_id):
		push_error("FR8CData: correct_option_id invalid in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var feedback_var: Variant = level.get("feedback_rules", {})
	if typeof(feedback_var) != TYPE_DICTIONARY:
		push_error("FR8CData: feedback_rules must be dictionary in level %s" % str(level.get("id", "UNKNOWN")))
		return false
	var feedback_rules: Dictionary = feedback_var as Dictionary
	if not feedback_rules.has("OK"):
		push_error("FR8CData: feedback_rules missing 'OK' in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	return true

static func _selector_of(rule: Dictionary) -> String:
	var selector: String = str(rule.get("selector", "")).strip_edges()
	if not selector.is_empty():
		return selector
	selector = str(rule.get(".selector", "")).strip_edges()
	return selector

static func _is_number(value: Variant) -> bool:
	var value_type: int = typeof(value)
	return value_type == TYPE_INT or value_type == TYPE_FLOAT
</file>

<file path="scripts/TrialV2.gd">
extends RefCounted
class_name TrialV2

static func build(quest_id: String, stage_id: String, task_id: String, interaction_type: String, variant_hash: String = "") -> Dictionary:
	var normalized_task_id := task_id if task_id != "" else "unknown_task"
	var normalized_variant_hash := variant_hash
	if normalized_variant_hash == "":
		normalized_variant_hash = str(hash("%s|%s|%s|%s" % [quest_id, stage_id, normalized_task_id, interaction_type]))

	return {
		"schema_version": "trial.v2",
		"quest_id": quest_id,
		"stage": stage_id,
		"task_id": normalized_task_id,
		"interaction_type": interaction_type,
		"variant_hash": normalized_variant_hash,
		"match_key": "%s|%s|%s|v%s" % [quest_id, stage_id, normalized_task_id, normalized_variant_hash]
	}
</file>

<file path="scripts/ui/ClueBucketZone.gd">
extends PanelContainer

var bucket_id: String = ""
@onready var items_flow = $VBox/ItemsFlow

func _ready():
	mouse_exited.connect(func(): modulate = Color(1,1,1))

func setup(p_bucket_id: String, p_label_text: String):
	bucket_id = p_bucket_id
	var title_lbl = $VBox/BucketTitle
	if title_lbl:
		title_lbl.text = p_label_text

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) == TYPE_DICTIONARY and data.get("kind") == "CLUE_ITEM":
		modulate = Color(1.2, 1.2, 1.2) # Highlight
		return true
	return false

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	modulate = Color(1.0, 1.0, 1.0) # Remove highlight

	var source_path = data.get("source_path")
	var source_node = get_node_or_null(source_path)

	if source_node and items_flow:
		source_node.reparent(items_flow)
		AudioManager.play("click")

		# Snap effect
		var tw = create_tween()
		source_node.scale = Vector2(1.05, 1.05)
		tw.tween_property(source_node, "scale", Vector2.ONE, 0.1)

func _notification(what):
	if what == NOTIFICATION_DRAG_END:
		if not is_drag_successful():
			modulate = Color(1.0, 1.0, 1.0)
</file>

<file path="scripts/ui/ClueItem.gd">
extends Button

var item_id: String = ""
var label: String = ""
var correct_bucket_id: String = ""

func setup(item_data: Dictionary):
	item_id = item_data.get("item_id", "")
	label = item_data.get("label", "")
	correct_bucket_id = item_data.get("correct_bucket_id", "")

	text = label
	custom_minimum_size = Vector2(0, 80)

func _get_drag_data(_at_position: Vector2):
	var data = {
		"kind": "CLUE_ITEM",
		"item_id": item_id,
		"label": label,
		"source_path": get_path()
	}

	var preview = self.duplicate()
	preview.modulate.a = 0.8
	# Wrap in control to center
	var c = Control.new()
	c.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(c)

	return data
</file>

<file path="scripts/ui/CodeBlock.gd">
extends Button

var data: Dictionary = {}

func setup(block_data: Dictionary):
	data = block_data
	text = str(data.get("label", "???"))
	custom_minimum_size = Vector2(80, 64) # Ensure touch friendly

	# Optional: Differentiate types visually
	if data.get("slot_type") == "OP":
		modulate = Color(0.88, 0.88, 0.86)
	else:
		modulate = Color(1.0, 1.0, 1.0)

func _get_drag_data(at_position: Vector2):
	# Create a visual preview
	var preview = Button.new()
	preview.text = text
	preview.custom_minimum_size = size
	preview.modulate = Color(1, 1, 1, 0.8)
	# Remove stylebox if needed or just let it use default theme

	# Center the preview
	var ctrl = Control.new()
	ctrl.add_child(preview)
	preview.position = -size / 2
	set_drag_preview(ctrl)

	# Return data strictly as per spec
	return {
		"kind": "CODE_BLOCK",
		"block_id": data.get("block_id"),
		"slot_type": data.get("slot_type"),
		"label": data.get("label"),
		"insert": data.get("insert"),
		"source_path": get_path()
	}
</file>

<file path="scripts/ui/network_trace/network_trace_device_card.gd">
extends Button
class_name NetworkTraceDeviceCard

var device_id: String = ""
var device_label: String = ""
var error_code: String = ""

func setup(option_id: String, label_text: String, option_error_code: String) -> void:
	device_id = option_id
	device_label = label_text
	error_code = option_error_code
	text = label_text
	tooltip_text = label_text
	disabled = false

func clear_state() -> void:
	device_id = ""
	device_label = ""
	error_code = ""
	text = ""
	disabled = true

func _get_drag_data(_at_position: Vector2) -> Variant:
	if disabled:
		return null
	if device_id.is_empty():
		return null

	var preview: Label = Label.new()
	preview.text = device_label
	preview.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	preview.add_theme_font_size_override("font_size", 18)
	set_drag_preview(preview)

	return {
		"type": "network_trace_device",
		"device_id": device_id,
		"label": device_label,
		"error_code": error_code
	}
</file>

<file path="scripts/ui/pipeline/ModuleCard.gd">
extends PanelContainer
class_name PipelineModuleCard

signal module_selected(module_data: Dictionary, sender: Node)
signal module_drag_started(module_data: Dictionary)

var label_text: Label = null

var module_data: Dictionary = {}

func _ready() -> void:
	if label_text == null:
		label_text = get_node_or_null("Margin/Label") as Label
	if label_text != null and not module_data.is_empty():
		label_text.text = str(module_data.get("display", "?"))

func setup(data: Dictionary) -> void:
	module_data = data.duplicate(true)
	if label_text == null:
		label_text = get_node_or_null("Margin/Label") as Label
	if label_text != null:
		label_text.text = str(module_data.get("display", "?"))
	tooltip_text = "%s [%s]" % [
		str(module_data.get("module_id", "unknown")),
		str(module_data.get("slot_type", ""))
	]
	set_selected(false)

func get_module_data() -> Dictionary:
	return module_data.duplicate(true)

func set_selected(selected: bool) -> void:
	if selected:
		modulate = Color(1.0, 1.0, 0.82, 1.0)
	else:
		modulate = Color(1.0, 1.0, 1.0, 1.0)

func _get_drag_data(_at_position: Vector2) -> Variant:
	if module_data.is_empty():
		return null

	emit_signal("module_drag_started", module_data.duplicate(true))

	var preview_panel: PanelContainer = PanelContainer.new()
	preview_panel.custom_minimum_size = Vector2(120.0, 48.0)
	var preview_margin: MarginContainer = MarginContainer.new()
	preview_margin.add_theme_constant_override("margin_left", 8)
	preview_margin.add_theme_constant_override("margin_top", 6)
	preview_margin.add_theme_constant_override("margin_right", 8)
	preview_margin.add_theme_constant_override("margin_bottom", 6)
	var preview_label: Label = Label.new()
	preview_label.text = str(module_data.get("display", "?"))
	preview_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	preview_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	preview_margin.add_child(preview_label)
	preview_panel.add_child(preview_margin)
	set_drag_preview(preview_panel)

	return {
		"kind": "pipeline_module",
		"module": module_data.duplicate(true)
	}

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("module_selected", module_data.duplicate(true), self)
			accept_event()
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("module_selected", module_data.duplicate(true), self)
			accept_event()
</file>

<file path="scripts/ui/ResusPartItem.gd">
extends Button

signal drag_started(item_id: String, from_zone: String)

var item_id: String = ""
var item_label: String = ""
var correct_bucket_id: String = ""

func setup(item_data: Dictionary) -> void:
	item_id = str(item_data.get("item_id", ""))
	item_label = str(item_data.get("label", ""))
	correct_bucket_id = str(item_data.get("correct_bucket_id", "")).to_upper()
	text = item_label
	custom_minimum_size = Vector2(0, 76)
	set_meta("zone_id", "PILE")

func set_zone_id(zone_id: String) -> void:
	set_meta("zone_id", zone_id)

func get_zone_id() -> String:
	return str(get_meta("zone_id", "PILE"))

func _get_drag_data(_at_position: Vector2) -> Variant:
	var from_zone: String = get_zone_id()
	drag_started.emit(item_id, from_zone)

	var data: Dictionary = {
		"kind": "RESUS_ITEM",
		"item_id": item_id,
		"label": item_label,
		"source_path": get_path(),
		"from_zone": from_zone
	}

	var preview: Button = duplicate() as Button
	preview.modulate.a = 0.9
	var holder: Control = Control.new()
	holder.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(holder)

	return data
</file>

<file path="scripts/ui/ResusPileZone.gd">
extends PanelContainer

signal item_placed(item_id: String, to_bucket: String, from_bucket: String)

@export var title_path: NodePath = NodePath("VBox/BucketTitle")
@export var items_container_path: NodePath = NodePath("VBox/Scroll/PartsGrid")

var bucket_id: String = "PILE"

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		modulate = Color(1, 1, 1, 1)
	)

func setup(p_bucket_id: String, p_label_text: String) -> void:
	bucket_id = p_bucket_id.to_upper()
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func get_items_container() -> Control:
	return _items_container

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		_items_container.remove_child(child)
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	var current_parent: Node = item_control.get_parent()
	if current_parent == null:
		_items_container.add_child(item_control)
	elif current_parent != _items_container:
		item_control.reparent(_items_container)

	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", bucket_id)
	else:
		item_control.set_meta("zone_id", bucket_id)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "RESUS_ITEM":
		return false
	modulate = Color(1.08, 1.03, 1.03, 1.0)
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	modulate = Color(1, 1, 1, 1)
	if typeof(data) != TYPE_DICTIONARY:
		return
	var payload: Dictionary = data as Dictionary
	var source_path: String = str(payload.get("source_path", ""))
	if source_path == "":
		return
	var source_node: Node = get_node_or_null(source_path)
	if source_node == null or not is_instance_valid(_items_container):
		return

	var from_bucket: String = str(payload.get("from_zone", source_node.get_meta("zone_id", "PILE")))
	source_node.reparent(_items_container)
	if source_node.has_method("set_zone_id"):
		source_node.call("set_zone_id", bucket_id)
	else:
		source_node.set_meta("zone_id", bucket_id)

	if source_node is Control:
		var control_node: Control = source_node as Control
		var tween: Tween = create_tween()
		control_node.scale = Vector2(1.05, 1.05)
		tween.tween_property(control_node, "scale", Vector2.ONE, 0.1)

	item_placed.emit(str(payload.get("item_id", "")), bucket_id, from_bucket)
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		modulate = Color(1, 1, 1, 1)
</file>

<file path="scripts/ui/subnet/BitCell.gd">
extends PanelContainer
class_name SubnetBitCell

var label_value: Label = null
var bit_value: int = -1
var highlighted: bool = false

func _ready() -> void:
	_ensure_label()
	_refresh()

func set_bit(value: int) -> void:
	bit_value = clampi(value, 0, 1)
	_refresh()

func set_empty() -> void:
	bit_value = -1
	_refresh()

func set_highlight(active: bool) -> void:
	highlighted = active
	_refresh()

func pulse(color: Color, duration_sec: float = 0.12) -> void:
	modulate = color
	var tween: Tween = create_tween()
	tween.tween_property(self, "modulate", Color(1.0, 1.0, 1.0, 1.0), duration_sec)

func _ensure_label() -> void:
	if label_value == null:
		label_value = get_node_or_null("LabelValue") as Label

func _refresh() -> void:
	_ensure_label()
	if label_value == null:
		return

	if bit_value < 0:
		label_value.text = "-"
		label_value.modulate = Color(0.62, 0.64, 0.62, 1.0)
	elif bit_value == 0:
		label_value.text = "0"
		label_value.modulate = Color(0.78, 0.84, 0.8, 1.0)
	else:
		label_value.text = "1"
		label_value.modulate = Color(0.4, 1.0, 0.62, 1.0)

	if highlighted:
		self_modulate = Color(1.0, 1.0, 0.82, 1.0)
	else:
		self_modulate = Color(1.0, 1.0, 1.0, 1.0)
</file>

<file path="scripts/ui/subnet/MaskDropTarget.gd">
extends PanelContainer
class_name SubnetMaskDropTarget

signal mask_dropped(mask_data: Dictionary)
signal bad_drop(data: Dictionary)
signal target_tapped

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	var mask_data: Dictionary = _extract_mask_data(data)
	return not mask_data.is_empty()

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	var mask_data: Dictionary = _extract_mask_data(data)
	if mask_data.is_empty():
		emit_signal("bad_drop", {})
		return
	emit_signal("mask_dropped", mask_data)

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("target_tapped")
			accept_event()
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("target_tapped")
			accept_event()

func flash_bad_drop() -> void:
	modulate = Color(1.0, 0.55, 0.55, 1.0)
	var tween: Tween = create_tween()
	tween.tween_property(self, "modulate", Color(1.0, 1.0, 1.0, 1.0), 0.2)

func _extract_mask_data(data: Variant) -> Dictionary:
	if typeof(data) != TYPE_DICTIONARY:
		return {}
	var drop_data: Dictionary = data
	if str(drop_data.get("kind", "")) != "subnet_mask_overlay":
		return {}
	var mask_variant: Variant = drop_data.get("mask", {})
	if typeof(mask_variant) != TYPE_DICTIONARY:
		return {}
	var mask_dict: Dictionary = mask_variant
	return mask_dict.duplicate(true)
</file>

<file path="scripts/ui/TagFragmentItem.gd">
extends Button

signal drag_started(fragment_id: String, from_zone: String)

var fragment_id: String = ""
var fragment_label: String = ""
var fragment_kind: String = ""
var fragment_token: String = ""

func setup(fragment_data: Dictionary) -> void:
	fragment_id = str(fragment_data.get("fragment_id", ""))
	fragment_label = str(fragment_data.get("label", ""))
	fragment_kind = str(fragment_data.get("kind", ""))
	fragment_token = str(fragment_data.get("token", fragment_label))

	text = fragment_label
	custom_minimum_size = Vector2(0, 72)
	theme_type_variation = &"FlatButton"
	set_zone_id("PILE")

func set_zone_id(zone_id: String) -> void:
	set_meta("zone_id", zone_id)

func get_zone_id() -> String:
	return str(get_meta("zone_id", "PILE"))

func get_fragment_id() -> String:
	return fragment_id

func _get_drag_data(_at_position: Vector2) -> Variant:
	var from_zone: String = get_zone_id()
	drag_started.emit(fragment_id, from_zone)

	var data: Dictionary = {
		"kind": "TAG_FRAGMENT",
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"source_path": get_path()
	}

	var preview: Button = duplicate() as Button
	preview.modulate.a = 0.9
	var holder: Control = Control.new()
	holder.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(holder)

	return data
</file>

<file path="scripts/ui/TagPileZone.gd">
extends PanelContainer

signal item_placed(fragment_id: String, to_zone: String, from_zone: String)

@export var title_path: NodePath = NodePath("VBox/PileTitle")
@export var items_container_path: NodePath = NodePath("VBox/Scroll/ItemsGrid")

var zone_id: String = "PILE"
var _drag_hovered: bool = false

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		_drag_hovered = false
		_apply_visual_state()
	)
	_apply_visual_state()

func setup(p_zone_id: String, p_label_text: String) -> void:
	zone_id = p_zone_id
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		_items_container.remove_child(child)
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	var current_parent: Node = item_control.get_parent()
	if current_parent == null:
		_items_container.add_child(item_control)
	elif current_parent != _items_container:
		item_control.reparent(_items_container)
	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", zone_id)
	else:
		item_control.set_meta("zone_id", zone_id)

	var tween: Tween = create_tween()
	item_control.scale = Vector2(1.05, 1.05)
	tween.tween_property(item_control, "scale", Vector2.ONE, 0.1)

func set_grid_columns(columns: int) -> void:
	if not (_items_container is GridContainer):
		return
	(_items_container as GridContainer).columns = max(1, columns)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "TAG_FRAGMENT":
		return false
	_drag_hovered = true
	_apply_visual_state()
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	_drag_hovered = false
	_apply_visual_state()
	if typeof(data) != TYPE_DICTIONARY:
		return

	var payload: Dictionary = data as Dictionary
	var controller: Node = _get_drop_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_drop_to_pile", payload)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		return

	_pulse()
	item_placed.emit(str(result.get("fragment_id", "")), zone_id, str(result.get("from_zone", "PILE")))
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		_drag_hovered = false
		_apply_visual_state()

func _get_drop_controller() -> Node:
	return get_tree().get_first_node_in_group("fr8_drop_controller")

func _apply_visual_state() -> void:
	self_modulate = Color(1.06, 1.06, 1.06, 1.0) if _drag_hovered else Color(1.0, 1.0, 1.0, 1.0)

func _pulse() -> void:
	var tween: Tween = create_tween()
	scale = Vector2(1.01, 1.01)
	tween.tween_property(self, "scale", Vector2.ONE, 0.08)
</file>

<file path="scripts/ui/TagSlotZone.gd">
extends PanelContainer

signal item_placed(fragment_id: String, to_zone: String, from_zone: String)

@export var title_path: NodePath = NodePath("VBox/SlotTitle")
@export var items_container_path: NodePath = NodePath("VBox/Center/Items")

var zone_id: String = ""
var _feedback_state: String = "neutral"
var _drag_hovered: bool = false

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		_drag_hovered = false
		_apply_visual_state()
	)
	_apply_visual_state()

func setup(p_zone_id: String, p_label_text: String) -> void:
	zone_id = p_zone_id
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func get_zone_id() -> String:
	return zone_id

func get_items_container() -> Control:
	return _items_container

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		_items_container.remove_child(child)
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	var current_parent: Node = item_control.get_parent()
	if current_parent == null:
		_items_container.add_child(item_control)
	elif current_parent != _items_container:
		item_control.reparent(_items_container)
	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", zone_id)
	else:
		item_control.set_meta("zone_id", zone_id)

	var tween: Tween = create_tween()
	item_control.scale = Vector2(1.05, 1.05)
	tween.tween_property(item_control, "scale", Vector2.ONE, 0.1)

func get_current_fragment_id() -> String:
	if not is_instance_valid(_items_container):
		return ""
	if _items_container.get_child_count() <= 0:
		return ""
	var item_node: Node = _items_container.get_child(0)
	if item_node.has_method("get_fragment_id"):
		return str(item_node.call("get_fragment_id"))
	return str(item_node.get_meta("fragment_id", ""))

func set_feedback_state(state: String) -> void:
	_feedback_state = state
	_apply_visual_state()

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "TAG_FRAGMENT":
		return false
	_drag_hovered = true
	_apply_visual_state()
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	_drag_hovered = false
	_apply_visual_state()
	if typeof(data) != TYPE_DICTIONARY:
		return

	var payload: Dictionary = data as Dictionary
	var controller: Node = _get_drop_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_drop_to_slot", zone_id, payload)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		return

	_pulse()
	item_placed.emit(str(result.get("fragment_id", "")), zone_id, str(result.get("from_zone", "PILE")))
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		_drag_hovered = false
		_apply_visual_state()

func _get_drop_controller() -> Node:
	return get_tree().get_first_node_in_group("fr8_drop_controller")

func _apply_visual_state() -> void:
	var tone: Color = Color(1.0, 1.0, 1.0, 1.0)
	match _feedback_state:
		"ok":
			tone = Color(0.78, 1.05, 0.82, 1.0)
		"bad":
			tone = Color(1.08, 0.78, 0.78, 1.0)
		_:
			tone = Color(1.0, 1.0, 1.0, 1.0)

	if _drag_hovered:
		tone = Color(tone.r * 1.08, tone.g * 1.08, tone.b * 1.08, tone.a)

	self_modulate = tone

func _pulse() -> void:
	var tween: Tween = create_tween()
	scale = Vector2(1.02, 1.02)
	tween.tween_property(self, "scale", Vector2.ONE, 0.1)
</file>

<file path="scripts/ui/TimelineCard.gd">
extends PanelContainer

signal move_requested(stage_id: String, dir: int)
signal hint_requested(stage_id: String)

@onready var stage_title: Label = $Margin/VBox/Header/StageTitle
@onready var stage_hint_btn: Button = $Margin/VBox/Header/StageHintBtn
@onready var btn_left: Button = $Margin/VBox/Controls/BtnLeft
@onready var btn_right: Button = $Margin/VBox/Controls/BtnRight

var stage_id: String = ""
var hint_text: String = ""

func _ready() -> void:
	btn_left.pressed.connect(_on_left_pressed)
	btn_right.pressed.connect(_on_right_pressed)
	stage_hint_btn.pressed.connect(_on_hint_pressed)

func setup(card_data: Dictionary) -> void:
	stage_id = str(card_data.get("stage_id", "")).strip_edges()
	hint_text = str(card_data.get("hint", "")).strip_edges()
	stage_title.text = str(card_data.get("title", stage_id))
	stage_hint_btn.disabled = hint_text.is_empty()

func set_move_enabled(can_left: bool, can_right: bool) -> void:
	btn_left.disabled = not can_left
	btn_right.disabled = not can_right

func _on_left_pressed() -> void:
	move_requested.emit(stage_id, -1)

func _on_right_pressed() -> void:
	move_requested.emit(stage_id, 1)

func _on_hint_pressed() -> void:
	hint_requested.emit(stage_id)
</file>

<file path="shaders/blur.gdshader">
shader_type canvas_item;
render_mode unshaded;

uniform float blur_size = 3.0;

void fragment() {
	vec2 uv = SCREEN_UV;
	vec2 off = SCREEN_PIXEL_SIZE * blur_size;

	vec4 sum = vec4(0.0);
	sum += texture(SCREEN_TEXTURE, uv);
	sum += texture(SCREEN_TEXTURE, uv + vec2(off.x, 0.0));
	sum += texture(SCREEN_TEXTURE, uv - vec2(off.x, 0.0));
	sum += texture(SCREEN_TEXTURE, uv + vec2(0.0, off.y));
	sum += texture(SCREEN_TEXTURE, uv - vec2(0.0, off.y));
	sum += texture(SCREEN_TEXTURE, uv + off);
	sum += texture(SCREEN_TEXTURE, uv - off);
	sum += texture(SCREEN_TEXTURE, uv + vec2(off.x, -off.y));
	sum += texture(SCREEN_TEXTURE, uv + vec2(-off.x, off.y));

	COLOR = sum / 9.0;
}
</file>

<file path="SUMMARY.md">
# Godot MCP — AI-Powered Godot Development

**Give your AI assistant full access to the Godot editor.** Build games faster with Claude, Cursor, or any MCP-compatible AI — no copy-pasting, no context switching, no friction.

> Works with Godot 4.x · Open source (MIT) · 32 tools · Visual project explorer included

---

## What Is This?

Godot MCP is a bridge between AI assistants and the Godot editor. It lets AI read, write, and manipulate your project directly — scenes, scripts, nodes, assets, settings — all through natural conversation.

```
You ↔ AI Assistant ↔ MCP Server ↔ Godot Editor
         (Claude, Cursor, etc.)    (WebSocket)     (Plugin)
```

Install the Godot plugin, point your AI client at the MCP server, and start building.

---

## Tools (32)

### File Operations (4 tools)
| Tool | What it does |
|------|-------------|
| `list_dir` | Browse project directories (`res://` paths) |
| `read_file` | Read any text file with optional line ranges |
| `search_project` | Full-text search across the project with glob filtering |
| `create_script` | Scaffold new GDScript files |

### Scene Operations (11 tools)
| Tool | What it does |
|------|-------------|
| `create_scene` | Create `.tscn` files with a node hierarchy |
| `read_scene` | Parse and inspect scene structure |
| `add_node` | Add nodes to existing scenes |
| `remove_node` | Remove nodes from scenes |
| `modify_node_property` | Set any node property (transforms, colors, physics, etc.) |
| `rename_node` | Rename nodes |
| `move_node` | Reparent nodes in the scene tree |
| `attach_script` | Attach a GDScript to a node |
| `detach_script` | Remove a script from a node |
| `set_collision_shape` | Assign collision shapes (Circle, Rectangle, Capsule, etc.) |
| `set_sprite_texture` | Assign textures to sprites (image, placeholder, gradient, noise) |

### Script Operations (6 tools)
| Tool | What it does |
|------|-------------|
| `apply_diff_preview` | Apply targeted code edits to GDScript files |
| `validate_script` | Check GDScript syntax without running |
| `list_scripts` | List all `.gd` files in the project |
| `create_folder` | Create directories |
| `delete_file` | Delete files (with safety checks) |
| `rename_file` | Rename/move files with optional reference updates |

### Project Tools (9 tools)
| Tool | What it does |
|------|-------------|
| `get_project_settings` | Read project configuration (window size, renderer, physics) |
| `get_input_map` | Inspect all input actions and their bindings |
| `get_collision_layers` | Read physics collision layer names |
| `get_node_properties` | Discover every property a node type supports |
| `get_console_log` | Read the editor output log |
| `get_errors` | Extract only errors from the console |
| `clear_console_log` | Clear the console |
| `open_in_godot` | Open a file in the editor (jumps to line for scripts) |
| `scene_tree_dump` | Dump the running scene tree for debugging |

### Asset Generation (4 tools)
| Tool | What it does |
|------|-------------|
| `generate_2d_asset` | Generate 2D sprites from SVG code |
| `search_comfyui_nodes` | Search 10,500+ ComfyUI nodes for AI art pipelines |
| `inspect_runninghub_workflow` | Inspect RunningHub workflow parameters |
| `customize_and_run_workflow` | Execute RunningHub workflows for asset generation |

### Visualization (1 tool)
| Tool | What it does |
|------|-------------|
| `map_project` | Build an interactive visual map of your entire project |

---

## Features

### Core
- **Live editor connection** — WebSocket bridge between MCP server and Godot editor. Changes happen in real time.
- **Works with any MCP client** — Claude Desktop, Cursor, RAGy, or anything that speaks MCP.
- **Mock mode** — Test and develop without Godot running.
- **Auto-reconnect** — Plugin reconnects automatically if the connection drops.

### Scene Manipulation
- Create scenes from scratch with full node hierarchies
- Add, remove, rename, move, and reparent nodes
- Set any node property with automatic type parsing (Vector2, Color, etc.)
- Attach/detach scripts, assign collision shapes and textures
- Read and inspect existing scene structures

### Script Intelligence
- Apply surgical code edits with snippet matching
- Validate GDScript syntax before saving
- Full project-wide text search
- Scaffold new scripts from templates
- Rename/move files with reference tracking

### Project Awareness
- AI can read your project settings, input map, and collision layers
- Console log and error access for debugging
- Scene tree dumps of the running game
- Property discovery — AI can look up what properties any node type supports

### Asset Pipeline
- Generate 2D placeholder sprites from SVG descriptions
- ComfyUI node search for AI art workflow building
- RunningHub integration for automated asset generation

### Interactive Visualizer
- **Browser-based project explorer** served at `localhost:6510`
- Force-directed graph of all scripts and their relationships
- Color-coded by folder, searchable, zoomable
- Click any script to inspect variables, functions, signals, and connections
- **Inline editing** — edit variables, function bodies, and signals directly in the visualizer
- **Scene view** — browse scene hierarchies and edit node properties
- **Find usages** — check where a function or variable is used before changing it
- Changes sync back to Godot in real time

---

## Godot Developer Pain Points

| Pain Point | Status | How |
|-----------|--------|-----|
| **"AI can't see my project"** — context switching between AI chat and editor | **Solved** | AI reads/writes your project directly through 32 tools |
| **"Scene files are unreadable"** — `.tscn` is a custom text format AI struggles with | **Solved** | Structured scene tools abstract away the format |
| **"I have to copy-paste code back and forth"** — manual AI workflow | **Solved** | AI edits scripts in-place, validates syntax, and opens files in editor |
| **"I don't know what properties a node has"** — memorizing the API | **Solved** | `get_node_properties` lets AI discover any node's full property list |
| **"Debugging is slow"** — checking console, finding errors | **Solved** | AI reads console logs, extracts errors, dumps the scene tree |
| **"I can't visualize my project structure"** — hard to see the big picture | **Solved** | Interactive visualizer maps scripts, scenes, and their connections |
| **"Setting up input maps / collision layers is tedious"** | **Solved** | AI reads and understands your input map and collision layers |
| **"I need placeholder art to prototype"** | **Solved** | SVG-based 2D asset generation, ComfyUI/RunningHub integration |
| **"Refactoring is scary"** — renaming breaks things | **Partially solved** | File rename with reference updates + find usages in visualizer |
| **"GDScript has no LSP-quality AI support"** | **Partially solved** | Syntax validation + property discovery, but no autocomplete or go-to-definition |
| **"AI generates code for the wrong Godot version"** | **Partially solved** | AI sees your actual project settings and node types, reducing hallucination |
| **"I need AI to playtest / run my game"** | **Not yet** | Scene tree dump works, but no automated play/test/input simulation |
| **"Shader editing is painful"** | **Not yet** | No shader-specific tools (files can be read/written as text) |
| **"Managing exports and builds"** | **Not yet** | No export/build pipeline tools |
| **"Tilemap and level design"** | **Not yet** | No tilemap-specific tools |
| **"Animation editing"** | **Not yet** | No AnimationPlayer/AnimationTree tools |
| **"Version control integration"** | **Not yet** | No built-in git tools (use your AI client's native git support) |
| **"Multi-file refactoring"** | **Not yet** | Single-file edits only; no cross-file rename symbol |

---

## Quick Start

**1. Add the MCP server to your AI client**

No installation needed — the server is on npm. Add to your AI client config:
```json
{
  "mcpServers": {
    "godot": {
      "command": "npx",
      "args": ["-y", "godot-mcp-server"]
    }
  }
}
```

**2. Install the Godot plugin**
Copy `godot-plugin/addons/godot_mcp/` into your project's `addons/` folder. Enable it in Project → Project Settings → Plugins.

**3. Restart Godot.** Check the top-right corner of the editor — you should see **MCP Connected** in green. You're ready to go.

---

## Architecture

```
┌─────────────┐    MCP (stdio)    ┌─────────────┐   WebSocket    ┌──────────────┐
│  AI Client   │◄────────────────►│  MCP Server  │◄─────────────►│ Godot Editor │
│  (Claude,    │                  │  (Node.js)   │   port 6505   │  (Plugin)    │
│   Cursor)    │                  │              │               │              │
└─────────────┘                  │  Visualizer  │               │  32 tool     │
                                 │  HTTP :6510  │               │  handlers    │
                                 └──────┬───────┘               └──────────────┘
                                        │
                                 ┌──────▼───────┐
                                 │   Browser     │
                                 │  Visualizer   │
                                 └──────────────┘
```

---

## Current Limitations

- **Local only** — WebSocket runs on localhost, no remote connections or auth
- **Single connection** — One Godot instance at a time
- **Editor only** — Plugin runs in `@tool` mode, not in exported games
- **No undo** — Changes are saved directly (use version control)
- **Regex-based parsing** — Script analysis may miss edge cases in complex GDScript
- **No runtime control** — Can't press play, simulate input, or automate testing
- **All AI is limited in Godot knowledge** - scene editing, GDScript, editing node properties, building and placing UI elements. It cant create 100% of the game alone but it can help debug, write scripts, and tag along for the journey :)
---

## What's Next (maybe)

- Animation tools (AnimationPlayer, tweens)
- Tilemap and level design tools  
- Shader editing support
- Automated playtesting and input simulation
- Multi-file refactoring
- Plugin marketplace / asset library integration
- improvements to current tools

---

## License

MIT — use it however you want.

**[GitHub](https://github.com/tomyud1/godot-mcp)** · **[npm](https://www.npmjs.com/package/godot-mcp-server)** · **[Report Issues](https://github.com/tomyud1/godot-mcp/issues)**
</file>

<file path="ui/theme_noir_detective.tres">
[gd_resource type="Theme" load_steps=9 format=3 uid="uid://ckh2j4fimo232"]

[ext_resource type="FontFile" uid="uid://b6l43b80tas2q" path="res://fonts/IBMPlexMono-Medium.ttf" id="1_font"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.09, 0.09, 0.09, 0.92)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.33, 0.33, 0.33, 0.7)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.16, 0.16, 0.16, 0.98)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.86, 0.2, 0.24, 1)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.11, 0.11, 0.11, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.85, 0.85, 0.85, 0.9)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 14.0
content_margin_top = 10.0
content_margin_right = 14.0
content_margin_bottom = 10.0
bg_color = Color(0.2, 0.2, 0.2, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.98, 0.28, 0.33, 1)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 14.0
content_margin_top = 12.0
content_margin_right = 14.0
content_margin_bottom = 12.0
bg_color = Color(0.07, 0.07, 0.07, 0.94)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.72, 0.72, 0.72, 0.75)
corner_radius_top_left = 12
corner_radius_top_right = 12
corner_radius_bottom_right = 12
corner_radius_bottom_left = 12
shadow_color = Color(0, 0, 0, 0.45)
shadow_size = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.12, 0.12, 0.12, 1)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0.9, 0.22, 0.26, 0.95)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6

[resource]
default_font = ExtResource("1_font")
default_font_size = 19
Button/colors/font_color = Color(0.93, 0.93, 0.93, 1)
Button/colors/font_disabled_color = Color(0.55, 0.55, 0.55, 1)
Button/colors/font_hover_color = Color(1, 0.93, 0.94, 1)
Button/colors/font_pressed_color = Color(1, 1, 1, 1)
Button/constants/h_separation = 8
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(0.9, 0.9, 0.9, 1)
LineEdit/colors/font_color = Color(0.9, 0.9, 0.9, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0.9, 0.9, 0.9, 1)
</file>

<file path="VISUAL_TREE_ROADMAP.md">
# Visual Tree Roadmap

## Completed
- [x] Inline variable/signal editing
- [x] @onready toggle
- [x] Function code editing with syntax highlighting
- [x] Usage detection before delete
- [x] Floating usage panel with navigation
- [x] Right-click context menu
- [x] New script creation
- [x] Draggable/resizable panels
- [x] Scene View tab (Phase 4 - Core)
  - Scene overview with cards showing scene info
  - Click scene → expand to full node hierarchy tree
  - Visual node tree with parent-child connections
  - Sibling order indicators (for 2D draw order)
  - Click node → dynamic properties panel
  - Inline editing of all node properties
  - Property controls: toggles, sliders, vectors, colors, enums
  - Back navigation to scene overview

## In Progress
- [ ] Function deletion with usage check

## Planned

### Phase 2: Visual Connections
- Drag from signal → function to create `.connect()` code
- Visual ports on node edges when hovering

### Phase 3: Script Management
- Right click to add a new node (script)
- Script templates (Node2D, State Machine, Singleton, etc.)
- Delete/rename scripts

### Phase 4: Scene View (Enhancements)
- Drag to reorder siblings (change draw order)
- Right-click context menu on scene nodes (add child, delete, rename)
- Drag scripts onto scene nodes to attach
- Cross-scene signal visualization

### Phase 5: Advanced
- Minimap
- Node grouping
- Full-text search in function bodies
- Refactoring (rename across files)
- Undo/redo
- Git integration (modified files indicator)

### Phase 6: Polish
- Documentation generation
- Dependency analysis (circular deps, unused scripts)
- Code snippets library
</file>

<file path="data/final_report_b_levels.json">
[
  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-01",
    "briefing": "Инвесторы ждут план. Расставьте этапы разработки по времени.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"IDEA","title":"Идея","hint":"Формулировка проблемы и решения."},
      {"stage_id":"MVP","title":"MVP","hint":"Минимально рабочая версия продукта."},
      {"stage_id":"ALPHA","title":"Альфа","hint":"Внутреннее тестирование."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичное тестирование."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз для всех."}
    ],
    "dependencies": [
      {"a":"IDEA","b":"MVP","code":"LOGIC_GAP","message":"Нельзя делать MVP раньше идеи."},
      {"a":"MVP","b":"ALPHA","code":"LOGIC_GAP","message":"Нельзя тестировать Альфу раньше MVP."},
      {"a":"ALPHA","b":"BETA","code":"CAUSALITY_LOOP","message":"Нельзя показывать Бету до Альфы."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Нельзя выпускать релиз до Беты."}
    ],
    "expected_order": ["IDEA","MVP","ALPHA","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Вы пытаетесь утвердить этап, который не подготовлен.",
      "CAUSALITY_LOOP": "Нельзя отдавать людям сырой продукт до внутренней проверки.",
      "ORDER_MISMATCH": "Почти. Проверьте хронологию.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-02",
    "briefing": "Команда хочет быстрее «выйти в люди». Убедитесь, что порядок логичен.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"PROBLEM","title":"Проблема","hint":"Сначала понять, что решаем."},
      {"stage_id":"PROTOTYPE","title":"Прототип","hint":"Быстрая проверка идеи."},
      {"stage_id":"MVP","title":"MVP","hint":"Минимальная рабочая версия."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"PROBLEM","b":"PROTOTYPE","code":"LOGIC_GAP","message":"Нельзя строить прототип без проблемы."},
      {"a":"PROTOTYPE","b":"MVP","code":"LOGIC_GAP","message":"MVP не рождается из воздуха."},
      {"a":"MVP","b":"BETA","code":"CAUSALITY_LOOP","message":"Бета только после MVP."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["PROBLEM","PROTOTYPE","MVP","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Сломана причинность этапов.",
      "CAUSALITY_LOOP": "Публичность раньше внутренней готовности.",
      "ORDER_MISMATCH": "Есть несостыковка порядка.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-03",
    "briefing": "Система безопасности. Расставьте этапы подготовки к релизу.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"THREAT","title":"Модель угроз","hint":"Определить, от чего защищаемся."},
      {"stage_id":"LOGGING","title":"Логирование","hint":"Сначала фиксируем события."},
      {"stage_id":"PENTEST","title":"Пентест","hint":"Проверка уязвимостей."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"THREAT","b":"LOGGING","code":"LOGIC_GAP","message":"Логи без понимания угроз бесполезны."},
      {"a":"LOGGING","b":"PENTEST","code":"LOGIC_GAP","message":"Пентест без логов хуже диагностики."},
      {"a":"PENTEST","b":"BETA","code":"CAUSALITY_LOOP","message":"Нельзя выпускать Бету до проверки безопасности."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["THREAT","LOGGING","PENTEST","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Этап пропущен или стоит не на месте.",
      "CAUSALITY_LOOP": "Публичный этап раньше проверки.",
      "ORDER_MISMATCH": "Проверьте порядок.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-04",
    "briefing": "Инвесторский цикл. Упорядочьте этапы так, чтобы это не выглядело как сказка.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"PITCH","title":"Питч","hint":"Презентация идеи."},
      {"stage_id":"MEETING","title":"Встреча","hint":"Обсуждение деталей."},
      {"stage_id":"FUNDING","title":"Финансирование","hint":"Деньги пришли."},
      {"stage_id":"HIRE","title":"Найм","hint":"Собрать команду."},
      {"stage_id":"MVP","title":"MVP","hint":"Сделать продукт."}
    ],
    "dependencies": [
      {"a":"PITCH","b":"MEETING","code":"LOGIC_GAP","message":"Сначала питч, потом встреча."},
      {"a":"MEETING","b":"FUNDING","code":"LOGIC_GAP","message":"Финансирование после обсуждения."},
      {"a":"FUNDING","b":"HIRE","code":"LOGIC_GAP","message":"Найм обычно после денег."},
      {"a":"HIRE","b":"MVP","code":"LOGIC_GAP","message":"MVP делают люди, а не воздух."}
    ],
    "expected_order": ["PITCH","MEETING","FUNDING","HIRE","MVP"],
    "feedback_rules": {
      "LOGIC_GAP": "Порядок не выглядит реалистично.",
      "CAUSALITY_LOOP": "Сломана причинность.",
      "ORDER_MISMATCH": "Почти.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-05",
    "briefing": "Юр.чистота перед публичным запуском. Расставьте этапы.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"MVP","title":"MVP","hint":"Есть продукт."},
      {"stage_id":"PRIVACY","title":"Конфиденциальность","hint":"Политика конфиденциальности."},
      {"stage_id":"TERMS","title":"Условия","hint":"Пользовательское соглашение."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"MVP","b":"PRIVACY","code":"LOGIC_GAP","message":"Сначала продукт, потом документы."},
      {"a":"PRIVACY","b":"TERMS","code":"LOGIC_GAP","message":"Документы должны быть согласованы."},
      {"a":"TERMS","b":"BETA","code":"CAUSALITY_LOOP","message":"Публичность после документов."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["MVP","PRIVACY","TERMS","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Порядок документов нарушен.",
      "CAUSALITY_LOOP": "Нельзя выпускать на публику без базовой юридической базы.",
      "ORDER_MISMATCH": "Проверьте порядок.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  },

  {
    "quest_id": "CASE_08_FINAL_REPORT",
    "schema_version": "1.0.0",
    "id": "FR8-B-06",
    "briefing": "Контроль качества. Правильный порядок спасает от позора.",
    "format": "TIMELINE_SORT",
    "cards": [
      {"stage_id":"MVP","title":"MVP","hint":"Рабочая основа."},
      {"stage_id":"ALPHA","title":"Альфа","hint":"Внутренний тест."},
      {"stage_id":"QA","title":"QA","hint":"Проверка качества."},
      {"stage_id":"BETA","title":"Бета","hint":"Публичный тест."},
      {"stage_id":"RELEASE","title":"Релиз","hint":"Релиз."}
    ],
    "dependencies": [
      {"a":"MVP","b":"ALPHA","code":"LOGIC_GAP","message":"Альфа после MVP."},
      {"a":"ALPHA","b":"QA","code":"LOGIC_GAP","message":"QA после внутреннего теста."},
      {"a":"QA","b":"BETA","code":"CAUSALITY_LOOP","message":"Бета после QA."},
      {"a":"BETA","b":"RELEASE","code":"LOGIC_GAP","message":"Релиз после Беты."}
    ],
    "expected_order": ["MVP","ALPHA","QA","BETA","RELEASE"],
    "feedback_rules": {
      "LOGIC_GAP": "Этапы качества стоят странно.",
      "CAUSALITY_LOOP": "Публичный этап раньше контроля качества.",
      "ORDER_MISMATCH": "Почти.",
      "OK": "План утверждён."
    },
    "scoring_model": {
      "perfect": {"points":2,"stability_delta":0,"verdict_code":"PERFECT"},
      "fail": {"points":0,"stability_delta":-25,"verdict_code":"FAIL"}
    },
    "anti_cheat": {"shuffle_cards": true}
  }
]
</file>

<file path="data/final_report_c_levels.json">
[
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-01",
    "briefing": "Текст скрыт конфликтом стилей. Определите итоговый цвет.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      }
    ],
    "options": [
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"}
    ],
    "correct_option_id": "GREEN",
    "feedback_rules": {
      "SPECIFICITY_ERROR": "ID-защита сильнее класса: #x (100) > .alert (10).",
      "OK": "Взлом успешен: победил #x."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-02",
    "briefing": "Два класса спорят. Кто сильнее решает порядок.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p class=\"alert stealth\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": ".stealth",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#0000ff"}
      }
    ],
    "options": [
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"}
    ],
    "correct_option_id": "BLUE",
    "feedback_rules": {
      "ORDER_TIE": "Вес равный (10 и 10), побеждает правило ниже по файлу (order=2).",
      "OK": "Верно: одинаковый вес решает порядок."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-03",
    "briefing": "Есть !important. Не притворяйтесь, что его нет.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      },
      {
        "source_id": "R2",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": true,
        "order": 3,
        "decl": {"prop": "color", "value": "#ff0000"}
      }
    ],
    "options": [
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"}
    ],
    "correct_option_id": "RED",
    "feedback_rules": {
      "IMPORTANT_MISSED": "!important перебивает обычное правило, даже если селектор слабее.",
      "OK": "Верно: важность сильнее веса."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-04",
    "briefing": "Встроенный стиль на элементе. Он не для красоты.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\" style=\"color:#0000ff;\">Секретный код</p>"
    ],
    "inline_decl": {
      "source_id": "INLINE",
      "kind": "inline",
      "weight": 1000,
      "important": false,
      "decl": {"prop": "color", "value": "#0000ff"}
    },
    "rules": [
      {
        "source_id": "R1",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      },
      {
        "source_id": "R2",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 3,
        "decl": {"prop": "color", "value": "#ff0000"}
      }
    ],
    "options": [
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "RED", "label": "Красный", "value": "#ff0000"}
    ],
    "correct_option_id": "BLUE",
    "feedback_rules": {
      "INLINE_OVERRIDE": "Встроенный стиль (1000) перекрывает #id (100) и .class (10).",
      "OK": "Верно: встроенный стиль сильнее."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-05",
    "briefing": "Комбинированный селектор сильнее одиночного класса.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\" class=\"alert\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": ".alert",
        "kind": "class",
        "weight": 10,
        "important": false,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": "p#x",
        "kind": "mixed",
        "weight": 101,
        "important": false,
        "order": 2,
        "decl": {"prop": "color", "value": "#0000ff"}
      }
    ],
    "options": [
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"},
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"}
    ],
    "correct_option_id": "BLUE",
    "feedback_rules": {
      "SPECIFICITY_ERROR": "p#x (101) сильнее .alert (10).",
      "OK": "Верно: суммарный вес решает."
    }
  },
  {
    "schema_version": "1.0.0",
    "quest_id": "CASE_08_FINAL_REPORT",
    "id": "FR8-C-06",
    "briefing": "Два ID-правила с !important. Побеждает более позднее.",
    "format": "CSS_CASCADE",
    "target_text": "Секретный код",
    "html": [
      "<p id=\"x\">Секретный код</p>"
    ],
    "inline_decl": null,
    "rules": [
      {
        "source_id": "R1",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": true,
        "order": 1,
        "decl": {"prop": "color", "value": "#ff0000"}
      },
      {
        "source_id": "R2",
        "selector": "#x",
        "kind": "id",
        "weight": 100,
        "important": true,
        "order": 2,
        "decl": {"prop": "color", "value": "#00ff00"}
      }
    ],
    "options": [
      {"id": "GREEN", "label": "Зелёный", "value": "#00ff00"},
      {"id": "RED", "label": "Красный", "value": "#ff0000"},
      {"id": "BLUE", "label": "Синий", "value": "#0000ff"}
    ],
    "correct_option_id": "GREEN",
    "feedback_rules": {
      "ORDER_TIE": "Важность и вес равны, решает порядок (позже = сильнее).",
      "OK": "Верно: последняя директива выигрывает."
    }
  }
]
</file>

<file path="data/network_trace_a_levels.json">
[
  {
    "id": "NT_A_01",
    "incident_id": "INC_01",
    "briefing": "Трафик между офисом и серверной зоной остановился после обновления сегментации.",
    "prompt": "Какое устройство нужно для передачи трафика между разными подсетями?",
    "required_evidence": 2,
    "logs": [
      "SRC 192.168.1.10 -> DST 10.0.0.5 : NO ROUTE",
      "ARP работает внутри 192.168.1.0/24",
      "Таблица шлюза на хосте пуста"
    ],
    "topology": {
      "nodes": [
        "OfficeLAN",
        "SwitchA",
        "?",
        "SwitchB",
        "ServerLAN"
      ],
      "edges": [
        [
          "OfficeLAN",
          "SwitchA"
        ],
        [
          "SwitchA",
          "?"
        ],
        [
          "?",
          "SwitchB"
        ],
        [
          "SwitchB",
          "ServerLAN"
        ]
      ],
      "labels": {
        "OfficeLAN": "192.168.1.0/24",
        "ServerLAN": "10.0.0.0/24"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Маршрутизатор выполняет L3-маршрутизацию между подсетями.",
    "explain_full": "Разные сети требуют маршрутизации по IP-префиксу. Коммутатор пересылает кадры только внутри широковещательного домена. Хаб и повторитель — компоненты физического уровня.",
    "tags": [
      "routing",
      "subnet",
      "l3"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_02",
    "incident_id": "INC_01",
    "briefing": "Два VLAN пингуются внутри себя, но не между собой.",
    "prompt": "Выберите устройство, которое восстановит меж-VLAN связь.",
    "required_evidence": 2,
    "logs": [
      "Таймаут ping между VLAN 10 и VLAN 20",
      "MAC-таблицы на коммутаторах доступа в норме",
      "Нет ответа шлюза по умолчанию от интерфейсов VLAN"
    ],
    "topology": {
      "nodes": [
        "VLAN10",
        "AccessSW",
        "?",
        "CoreSW",
        "VLAN20"
      ],
      "edges": [
        [
          "VLAN10",
          "AccessSW"
        ],
        [
          "AccessSW",
          "?"
        ],
        [
          "?",
          "CoreSW"
        ],
        [
          "CoreSW",
          "VLAN20"
        ]
      ],
      "labels": {
        "VLAN10": "172.16.10.0/24",
        "VLAN20": "172.16.20.0/24"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "ap",
        "label": "Точка доступа",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Меж-VLAN трафику нужна L3-маршрутизация.",
    "explain_full": "Хостам в разных VLAN-подсетях нужен маршрутизирующий переход. Одной L2-пересылки недостаточно для внешних сетей.",
    "tags": [
      "vlan",
      "routing",
      "gateway"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_03",
    "incident_id": "INC_02",
    "briefing": "Широковещательный трафик резко вырос после замены пограничного оборудования.",
    "prompt": "Какое устройство нужно установить для изоляции доменов коллизий?",
    "required_evidence": 2,
    "logs": [
      "Счётчик коллизий растёт каждую секунду",
      "Кадры зеркалируются на все порты",
      "Только одна подсеть, маршрутизация не требуется"
    ],
    "topology": {
      "nodes": [
        "Clients",
        "?",
        "Printer",
        "NAS"
      ],
      "edges": [
        [
          "Clients",
          "?"
        ],
        [
          "?",
          "Printer"
        ],
        [
          "?",
          "NAS"
        ]
      ],
      "labels": {
        "Clients": "192.168.50.0/24"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор пересылает по MAC и сегментирует коллизии по портам.",
    "explain_full": "Симптом — локальное L2-заливание, а не маршрутизация подсетей. Коммутатор решает это пересылкой только на порт MAC-назначения.",
    "tags": [
      "switching",
      "collision",
      "lan"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_04",
    "incident_id": "INC_02",
    "briefing": "SOC сообщает, что каждый хост может прослушивать чужой офисный трафик.",
    "prompt": "Выберите замену, которая ограничивает широкую видимость кадров.",
    "required_evidence": 2,
    "logs": [
      "Промискуитетный захват видит все кадры рабочих станций",
      "В этом случае нет перехода между подсетями",
      "У текущего устройства нет MAC-таблицы"
    ],
    "topology": {
      "nodes": [
        "DeskA",
        "DeskB",
        "?",
        "DeskC",
        "DeskD"
      ],
      "edges": [
        [
          "DeskA",
          "?"
        ],
        [
          "DeskB",
          "?"
        ],
        [
          "DeskC",
          "?"
        ],
        [
          "DeskD",
          "?"
        ]
      ],
      "labels": {
        "DeskA": "Сегмент одной подсети"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "bridge",
        "label": "Мост",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор подавляет лишнюю заливку после изучения MAC.",
    "explain_full": "Поведение как у хаба раскрывает весь трафик. Коммутатор изучает MAC-адреса и перестаёт слать каждый кадр всем узлам.",
    "tags": [
      "security",
      "sniffing",
      "switch"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_05",
    "incident_id": "INC_03",
    "briefing": "Сигнал падает на длинном медном сегменте коридора.",
    "prompt": "Выберите компонент, который восстанавливает только физический сигнал.",
    "required_evidence": 2,
    "logs": [
      "Всплески CRC-ошибок после 92 м медного участка",
      "Ошибки адресации или политик не обнаружены",
      "Проблема возникает до разбора заголовков пакетов"
    ],
    "topology": {
      "nodes": [
        "Камера",
        "CableSpan",
        "?",
        "Коммутатор"
      ],
      "edges": [
        [
          "Камера",
          "CableSpan"
        ],
        [
          "CableSpan",
          "?"
        ],
        [
          "?",
          "Коммутатор"
        ]
      ],
      "labels": {
        "CableSpan": "Длинная медная линия"
      }
    },
    "options": [
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "repeater",
    "explain_short": "Повторитель регенерирует физический сигнал на длинных линиях.",
    "explain_full": "Этот инцидент — физическое затухание, а не адресация. Повторитель продлевает целостность сигнала, но не маршрутизирует и не фильтрует трафик.",
    "tags": [
      "physical",
      "crc",
      "repeater"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_06",
    "incident_id": "INC_03",
    "briefing": "Пограничная ветка не может достичь подсети HQ после миграции.",
    "prompt": "Какое устройство должно связать IP-сети филиала и HQ?",
    "required_evidence": 2,
    "logs": [
      "Сеть филиала 192.168.30.0/24 не может достичь 172.20.0.0/16",
      "Локальный ARP резолвится только внутри филиала",
      "Нет маршрутных записей для назначения штаб-квартиры"
    ],
    "topology": {
      "nodes": [
        "BranchLAN",
        "Коммутатор",
        "?",
        "WAN",
        "HQLAN"
      ],
      "edges": [
        [
          "BranchLAN",
          "Коммутатор"
        ],
        [
          "Коммутатор",
          "?"
        ],
        [
          "?",
          "WAN"
        ],
        [
          "WAN",
          "HQLAN"
        ]
      ],
      "labels": {
        "BranchLAN": "192.168.30.0/24",
        "HQLAN": "172.20.0.0/16"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "firewall",
        "label": "Межсетевой экран",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Для межсетевой пересылки требуется маршрутизатор.",
    "explain_full": "Разные префиксы требуют таблиц маршрутизации шлюза. L2-оборудование и пассивное железо не пересылают через маршрутизируемые границы.",
    "tags": [
      "wan",
      "routing",
      "gateway"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_07",
    "incident_id": "INC_04",
    "briefing": "Сеть складского этажа стала нестабильной после установки старого запасного устройства.",
    "prompt": "Какой выбор устройства предотвращает всплески коллизий в одной подсети?",
    "required_evidence": 2,
    "logs": [
      "Счётчики коллизий и поздних коллизий растут",
      "MAC назначения определяется, но кадры всё равно фладятся",
      "Все хосты остаются в одной подсети 10.10.40.0/24"
    ],
    "topology": {
      "nodes": [
        "ScannerA",
        "ScannerB",
        "?",
        "Controller"
      ],
      "edges": [
        [
          "ScannerA",
          "?"
        ],
        [
          "ScannerB",
          "?"
        ],
        [
          "Controller",
          "?"
        ]
      ],
      "labels": {
        "Controller": "Один L2-домен"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "bridge",
        "label": "Мост",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор изолирует трафик по портам и подавляет коллизии.",
    "explain_full": "В сценарии коллизий в одной подсети коммутатор — правильная точка L2-контроля. Маршрутизатор не решает локальные коллизии.",
    "tags": [
      "collision",
      "operations",
      "switch"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_08",
    "incident_id": "INC_04",
    "briefing": "Техник утверждает, что патч-панель может фильтровать доступ.",
    "prompt": "Выберите корректную техническую оценку.",
    "required_evidence": 2,
    "logs": [
      "Стойка содержит только пассивное патч-поле",
      "Процессор плоскости управления или таблица пересылки не обнаружены",
      "Перемаркировка панели не влияет на пакеты"
    ],
    "topology": {
      "nodes": [
        "UserLAN",
        "PatchRack",
        "?",
        "Core"
      ],
      "edges": [
        [
          "UserLAN",
          "PatchRack"
        ],
        [
          "PatchRack",
          "?"
        ],
        [
          "?",
          "Core"
        ]
      ],
      "labels": {
        "PatchRack": "Пассивная панель"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": ""
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      }
    ],
    "correct_id": "patch",
    "explain_short": "Патч-панель — пассивное кабельное оборудование.",
    "explain_full": "Патч-панель завершает и организует линии. Она не умеет маршрутизировать, коммутировать или фильтровать трафик, потому что не имеет логики пересылки.",
    "tags": [
      "passive",
      "rack",
      "hardware"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_09",
    "incident_id": "INC_05",
    "briefing": "После добавления гостевой подсети офисные хосты потеряли доступ к зоне ERP.",
    "prompt": "Какое устройство восстанавливает связь между офисом и подсетью ERP?",
    "required_evidence": 2,
    "logs": [
      "Office: 192.168.80.0/24, ERP: 192.168.120.0/24",
      "Хосты могут пинговать только локальный шлюз",
      "Логи коммутатора не содержат записей маршрутизации"
    ],
    "topology": {
      "nodes": [
        "Office",
        "AccessSW",
        "?",
        "DistSW",
        "ERP"
      ],
      "edges": [
        [
          "Office",
          "AccessSW"
        ],
        [
          "AccessSW",
          "?"
        ],
        [
          "?",
          "DistSW"
        ],
        [
          "DistSW",
          "ERP"
        ]
      ],
      "labels": {
        "Office": "192.168.80.0/24",
        "ERP": "192.168.120.0/24"
      }
    },
    "options": [
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "firewall",
        "label": "Межсетевой экран",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "router",
    "explain_short": "Разным подсетям нужен путь L3-маршрутизации.",
    "explain_full": "Даже при исправных коммутаторах пакеты не проходят между префиксами подсетей без маршрутизации.",
    "tags": [
      "subnet",
      "erp",
      "router"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_10",
    "incident_id": "INC_05",
    "briefing": "Мониторинг показывает, что пакеты копируются на все порты сегмента этажа.",
    "prompt": "Выберите устройство-замену для выборочной пересылки кадров.",
    "required_evidence": 2,
    "logs": [
      "SPAN фиксирует одинаковые копии кадров на каждом порту",
      "Нет задачи соединять разные IP-сети",
      "Флад неизвестного unicast сохраняется на старом оборудовании"
    ],
    "topology": {
      "nodes": [
        "Desk1",
        "Desk2",
        "?",
        "Desk3",
        "Desk4"
      ],
      "edges": [
        [
          "Desk1",
          "?"
        ],
        [
          "Desk2",
          "?"
        ],
        [
          "Desk3",
          "?"
        ],
        [
          "Desk4",
          "?"
        ]
      ],
      "labels": {
        "Desk1": "Один офисный сегмент"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": "A_L1_PHYSICAL"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор изучает назначения и пересылает выборочно.",
    "explain_full": "Заливка как у хаба указывает на отсутствие MAC-пересылки. Коммутатор пересылает по портам и снижает раскрытие трафика.",
    "tags": [
      "mac",
      "forwarding",
      "switch"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_11",
    "incident_id": "INC_06",
    "briefing": "Связь с удалённым датчиком срывается на длинной кабельной линии в цехе.",
    "prompt": "Какой компонент напрямую решает проблему физического затухания?",
    "required_evidence": 2,
    "logs": [
      "Уровень сигнала ухудшается после длинного медного участка",
      "Заголовки пакетов содержат корректные адреса до сброса",
      "Проблема повторяется независимо от конфигурации подсети"
    ],
    "topology": {
      "nodes": [
        "Sensor",
        "LongRun",
        "?",
        "EdgeSwitch"
      ],
      "edges": [
        [
          "Sensor",
          "LongRun"
        ],
        [
          "LongRun",
          "?"
        ],
        [
          "?",
          "EdgeSwitch"
        ]
      ],
      "labels": {
        "LongRun": "Промышленная кабельная линия"
      }
    },
    "options": [
      {
        "id": "repeater",
        "label": "Повторитель",
        "error_code": ""
      },
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "repeater",
    "explain_short": "Повторитель восстанавливает целостность сигнала на длинных линиях.",
    "explain_full": "Физическое затухание — проблема L1. Повторитель регенерирует сигнал без изменения логики пересылки.",
    "tags": [
      "factory",
      "physical",
      "l1"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_A_12",
    "incident_id": "INC_06",
    "briefing": "Операторы вставили хаб между офисной и дата-центровой линиями.",
    "prompt": "Выберите правильную замену для стабилизации трафика и сохранения сегментации.",
    "required_evidence": 2,
    "logs": [
      "После изменения резко выросли тревоги широковещания и коллизий",
      "Здесь не требуется межподсеточная маршрутизация",
      "Целевые хосты находятся в одном IP-сегменте"
    ],
    "topology": {
      "nodes": [
        "Office",
        "?",
        "DC Switch"
      ],
      "edges": [
        [
          "Office",
          "?"
        ],
        [
          "?",
          "DC Switch"
        ]
      ],
      "labels": {
        "Office": "10.40.0.0/24",
        "DC Switch": "Одна подсеть"
      }
    },
    "options": [
      {
        "id": "switch",
        "label": "Коммутатор",
        "error_code": ""
      },
      {
        "id": "hub",
        "label": "Концентратор",
        "error_code": "A_L1_BROADCAST"
      },
      {
        "id": "router",
        "label": "Маршрутизатор",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "bridge",
        "label": "Мост",
        "error_code": "A_L2_SEGMENT_LIMIT"
      },
      {
        "id": "patch",
        "label": "Патч-панель",
        "error_code": "A_PASSIVE"
      }
    ],
    "correct_id": "switch",
    "explain_short": "Коммутатор корректен для сегментированной пересылки в одной подсети.",
    "explain_full": "Проблема в L2-широковещании и коллизиях. Коммутатор решает это MAC-пересылкой и снижением шумной заливки.",
    "tags": [
      "broadcast",
      "switch",
      "stability"
    ],
    "time_limit_sec": 120
  }
]
</file>

<file path="data/network_trace_b_levels.json">
[
  {
    "id": "NT_B_01",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 525 KB, окно 64 с. Вычислите скорость в бит/с.",
    "payload_value": 525,
    "payload_unit": "KB",
    "time_sec": 64,
    "ask_unit": "bps",
    "expected_bps": 67200,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_01_OPT1",
        "label": "67200 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_01_OPT2",
        "label": "8400 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_01_OPT3",
        "label": "65625 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_01_OPT4",
        "label": "4300800 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_01_OPT5",
        "label": "67.200 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_01_OPT6",
        "label": "87329 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_01_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 67200 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 525 KB.",
      "Окно до блокировки: 64 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_02",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 256 KB, окно 4 с. Вычислите скорость в бит/с.",
    "payload_value": 256,
    "payload_unit": "KB",
    "time_sec": 4,
    "ask_unit": "bps",
    "expected_bps": 524288,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_02_OPT1",
        "label": "524288 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_02_OPT2",
        "label": "65536 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_02_OPT3",
        "label": "512000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_02_OPT4",
        "label": "2097152 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_02_OPT5",
        "label": "524.288 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_02_OPT6",
        "label": "533804 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_02_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 524288 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 256 KB.",
      "Окно до блокировки: 4 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_03",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 768 KB, окно 3 с. Вычислите скорость в бит/с.",
    "payload_value": 768,
    "payload_unit": "KB",
    "time_sec": 3,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_03_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_03_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_03_OPT3",
        "label": "2048000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_03_OPT4",
        "label": "6291456 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_03_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_03_OPT6",
        "label": "2125601 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_03_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 768 KB.",
      "Окно до блокировки: 3 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_04",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 64 KB, окно 2 с. Вычислите скорость в бит/с.",
    "payload_value": 64,
    "payload_unit": "KB",
    "time_sec": 2,
    "ask_unit": "bps",
    "expected_bps": 262144,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_04_OPT1",
        "label": "262144 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_04_OPT2",
        "label": "32768 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_04_OPT3",
        "label": "256000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_04_OPT4",
        "label": "524288 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_04_OPT5",
        "label": "262.144 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_04_OPT6",
        "label": "264534 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_04_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 262144 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 64 KB.",
      "Окно до блокировки: 2 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_05",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 320 KB, окно 5 с. Вычислите скорость в бит/с.",
    "payload_value": 320,
    "payload_unit": "KB",
    "time_sec": 5,
    "ask_unit": "bps",
    "expected_bps": 524288,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_05_OPT1",
        "label": "524288 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_05_OPT2",
        "label": "65536 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_05_OPT3",
        "label": "512000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_05_OPT4",
        "label": "2621440 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_05_OPT5",
        "label": "524.288 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_05_OPT6",
        "label": "536183 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_05_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 524288 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 320 KB.",
      "Окно до блокировки: 5 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_06",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 1536 KB, окно 6 с. Вычислите скорость в бит/с.",
    "payload_value": 1536,
    "payload_unit": "KB",
    "time_sec": 6,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_06_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_06_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_06_OPT3",
        "label": "2048000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_06_OPT4",
        "label": "12582912 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_06_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_06_OPT6",
        "label": "2154050 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_06_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 1536 KB.",
      "Окно до блокировки: 6 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_07",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 2 MB, окно 8 с. Вычислите скорость в бит/с.",
    "payload_value": 2,
    "payload_unit": "MB",
    "time_sec": 8,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_07_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_07_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_07_OPT3",
        "label": "2000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_07_OPT4",
        "label": "16777216 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_07_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_07_OPT6",
        "label": "2097314 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_07_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 2 MB.",
      "Окно до блокировки: 8 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_08",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 5 MB, окно 10 с. Вычислите скорость в бит/с.",
    "payload_value": 5,
    "payload_unit": "MB",
    "time_sec": 10,
    "ask_unit": "bps",
    "expected_bps": 4194304,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_08_OPT1",
        "label": "4194304 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_08_OPT2",
        "label": "524288 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_08_OPT3",
        "label": "4000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_08_OPT4",
        "label": "41943040 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_08_OPT5",
        "label": "4194.304 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_08_OPT6",
        "label": "4194599 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_08_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 4194304 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 5 MB.",
      "Окно до блокировки: 10 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_09",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 12 MB, окно 48 с. Вычислите скорость в бит/с.",
    "payload_value": 12,
    "payload_unit": "MB",
    "time_sec": 48,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_09_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_09_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_09_OPT3",
        "label": "2000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_09_OPT4",
        "label": "100663296 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_09_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_09_OPT6",
        "label": "2098124 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_09_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 12 MB.",
      "Окно до блокировки: 48 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_10",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 9 MB, окно 36 с. Вычислите скорость в бит/с.",
    "payload_value": 9,
    "payload_unit": "MB",
    "time_sec": 36,
    "ask_unit": "bps",
    "expected_bps": 2097152,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_10_OPT1",
        "label": "2097152 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_10_OPT2",
        "label": "262144 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_10_OPT3",
        "label": "2000000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_10_OPT4",
        "label": "75497472 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_10_OPT5",
        "label": "2097.152 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_10_OPT6",
        "label": "2097881 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_10_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 2097152 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 9 MB.",
      "Окно до блокировки: 36 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "mb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_11",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 600 KB, окно 75 с. Вычислите скорость в бит/с.",
    "payload_value": 600,
    "payload_unit": "KB",
    "time_sec": 75,
    "ask_unit": "bps",
    "expected_bps": 65536,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_11_OPT1",
        "label": "65536 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_11_OPT2",
        "label": "8192 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_11_OPT3",
        "label": "64000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_11_OPT4",
        "label": "4915200 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_11_OPT5",
        "label": "65.536 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_11_OPT6",
        "label": "88561 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_11_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 65536 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 600 KB.",
      "Окно до блокировки: 75 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_12",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 840 KB, окно 64 с. Вычислите скорость в бит/с.",
    "payload_value": 840,
    "payload_unit": "KB",
    "time_sec": 64,
    "ask_unit": "bps",
    "expected_bps": 107520,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_12_OPT1",
        "label": "107520 bps",
        "error_code": ""
      },
      {
        "id": "NT_B_12_OPT2",
        "label": "13440 bps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_12_OPT3",
        "label": "105000 bps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_12_OPT4",
        "label": "6881280 bps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_12_OPT5",
        "label": "107.520 kbps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_12_OPT6",
        "label": "139304 bps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_12_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 107520 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 840 KB.",
      "Окно до блокировки: 64 s.",
      "Требуемый вывод: бит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "bps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_13",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 700 KB, окно 40 с. Вычислите скорость в кбит/с.",
    "payload_value": 700,
    "payload_unit": "KB",
    "time_sec": 40,
    "ask_unit": "kbps",
    "expected_bps": 143360,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_13_OPT1",
        "label": "143.360 kbps",
        "error_code": ""
      },
      {
        "id": "NT_B_13_OPT2",
        "label": "17.920 kbps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_13_OPT3",
        "label": "140.000 kbps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_13_OPT4",
        "label": "5734.400 kbps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_13_OPT5",
        "label": "143360 bps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_13_OPT6",
        "label": "169.700 kbps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_13_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 143360 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 700 KB.",
      "Окно до блокировки: 40 s.",
      "Требуемый вывод: кбит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "kbps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_14",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 1500 KB, окно 48 с. Вычислите скорость в кбит/с.",
    "payload_value": 1500,
    "payload_unit": "KB",
    "time_sec": 48,
    "ask_unit": "kbps",
    "expected_bps": 256000,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_14_OPT1",
        "label": "256.000 kbps",
        "error_code": ""
      },
      {
        "id": "NT_B_14_OPT2",
        "label": "32.000 kbps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_14_OPT3",
        "label": "250.000 kbps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_14_OPT4",
        "label": "12288.000 kbps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_14_OPT5",
        "label": "256000 bps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_14_OPT6",
        "label": "312.028 kbps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_14_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 256000 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 1500 KB.",
      "Окно до блокировки: 48 s.",
      "Требуемый вывод: кбит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "kbps",
      "kb"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_B_15",
    "briefing": "Окно перехвата закрывается. Настройте пропускную способность шлюза до события блокировки.",
    "prompt": "Данные 3 MB, окно 16 с. Вычислите скорость в кбит/с.",
    "payload_value": 3,
    "payload_unit": "MB",
    "time_sec": 16,
    "ask_unit": "kbps",
    "expected_bps": 1572864,
    "pipeline_slots": [
      "kilo",
      "bit",
      "time",
      "out"
    ],
    "modules_pool": [
      {
        "module_id": "KILO_1024",
        "slot_type": "kilo",
        "display": "x1024",
        "k": 1024,
        "is_trap": false
      },
      {
        "module_id": "KILO_1000",
        "slot_type": "kilo",
        "display": "x1000",
        "k": 1000,
        "is_trap": true
      },
      {
        "module_id": "BIT_X8",
        "slot_type": "bit",
        "display": "x8",
        "k": 8,
        "is_trap": false
      },
      {
        "module_id": "BIT_X1",
        "slot_type": "bit",
        "display": "x1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "TIME_DIV",
        "slot_type": "time",
        "display": "/t",
        "k": -1,
        "is_trap": false
      },
      {
        "module_id": "TIME_SKIP",
        "slot_type": "time",
        "display": "/1",
        "k": 1,
        "is_trap": true
      },
      {
        "module_id": "OUT_BPS",
        "slot_type": "out",
        "display": "bps",
        "out_unit": "bps",
        "is_trap": false
      },
      {
        "module_id": "OUT_KBPS",
        "slot_type": "out",
        "display": "kbps",
        "out_unit": "kbps",
        "is_trap": true
      }
    ],
    "options": [
      {
        "id": "NT_B_15_OPT1",
        "label": "1572.864 kbps",
        "error_code": ""
      },
      {
        "id": "NT_B_15_OPT2",
        "label": "196.608 kbps",
        "error_code": "B_MATH_X8"
      },
      {
        "id": "NT_B_15_OPT3",
        "label": "1500.000 kbps",
        "error_code": "B_MATH_1024"
      },
      {
        "id": "NT_B_15_OPT4",
        "label": "25165.824 kbps",
        "error_code": "B_MATH_DIV"
      },
      {
        "id": "NT_B_15_OPT5",
        "label": "1572864 bps",
        "error_code": "B_UNIT_TRAP"
      },
      {
        "id": "NT_B_15_OPT6",
        "label": "1573.151 kbps",
        "error_code": "B_GARBAGE"
      }
    ],
    "correct_id": "NT_B_15_OPT1",
    "explain_short": "Используйте двоичное преобразование и деление на время: 1572864 bps.",
    "explain_full": "Порядок конвейера фиксирован: выберите двоичную базу, переведите байты в биты, разделите на время передачи, затем выведите в требуемых единицах.",
    "logs": [
      "Узел перехвата синхронизирован.",
      "Блок данных подтверждён: 3 MB.",
      "Окно до блокировки: 16 s.",
      "Требуемый вывод: кбит/с."
    ],
    "analyze_lines": [
      "Цепочка перевода: хранилище -> байты -> биты.",
      "Формула скорости: скорость = биты / время."
    ],
    "tags": [
      "net",
      "math",
      "bandwidth",
      "kbps",
      "mb"
    ],
    "time_limit_sec": 120
  }
]
</file>

<file path="icon.svg.import">
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://dwa13v3b7okhp"
path="res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.svg"
dest_files=["res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=false
editor/convert_colors_with_editor_theme=false
</file>

<file path="scenes/case_01/CluesQuestA.gd">
extends Control

const CLUES_DATA_PATH = "res://data/clues_levels.json"
const ITEM_SCENE = preload("res://scenes/ui/ClueItem.tscn")
const BUCKET_SCRIPT = preload("res://scripts/ui/ClueBucketZone.gd")

@onready var title_label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar = $SafeArea/MainVBox/Header/StabilityBar
@onready var briefing_label = $SafeArea/MainVBox/BriefingCard/BriefingLabel
@onready var pool_grid = $SafeArea/MainVBox/WorkArea/PoolCard/VBox/ItemsFlow
@onready var bucket_input = $SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput
@onready var bucket_output = $SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput
@onready var bucket_memory = $SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory
@onready var status_label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_confirm = $SafeArea/MainVBox/BottomBar/BtnConfirm
@onready var btn_back = $SafeArea/MainVBox/Header/BtnBack
@onready var result_popup = $ResultPopup
@onready var dimmer = $Dimmer

@onready var res_label_verdict = $ResultPopup/VBox/VerdictLabel
@onready var res_label_score = $ResultPopup/VBox/ScoreLabel
@onready var res_label_stability = $ResultPopup/VBox/StabilityLabel
@onready var res_btn_retry = $ResultPopup/VBox/HBox/BtnRetry
@onready var res_btn_back = $ResultPopup/VBox/HBox/BtnBack

var level_data: Dictionary = {}
var current_level_idx: int = 0
var drag_count: int = 0
var start_time: int = 0

func _ready():
	_connect_signals()
	_load_level_data()

func _connect_signals():
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	res_btn_retry.pressed.connect(_on_retry_pressed)
	res_btn_back.pressed.connect(_on_back_pressed)

func _load_level_data():
	var file = FileAccess.open(CLUES_DATA_PATH, FileAccess.READ)
	if not file:
		_show_error("Не удалось загрузить данные уровня")
		return

	var json = JSON.new()
	var error = json.parse(file.get_as_text())
	if error != OK:
		_show_error("Ошибка разбора JSON: " + json.get_error_message())
		return

	var data = json.data
	if typeof(data) != TYPE_ARRAY or data.is_empty():
		_show_error("Некорректный формат JSON")
		return

	# Assume first level for A
	level_data = data[0]
	if not _validate_level(level_data):
		_show_error("Проверка данных уровня не пройдена")
		return

	_setup_ui()

func _validate_level(data: Dictionary) -> bool:
	if not data.has_all(["id", "format", "buckets", "items", "scoring_rules"]):
		return false
	if data.format != "MATCHING": return false
	if data.buckets.size() != 3: return false
	if data.items.size() != 8: return false
	return true

func _setup_ui():
	title_label.text = "ДЕЛО №1: УЛИКИ В МУСОРЕ"
	stage_label.text = "ЭТАП A"
	briefing_label.text = level_data.get("briefing", "")
	stability_bar.value = GlobalMetrics.stability

	# Setup Buckets
	if bucket_input.has_method("setup"):
		bucket_input.setup("INPUT", "ВВОД")
	if bucket_output.has_method("setup"):
		bucket_output.setup("OUTPUT", "ВЫВОД")
	if bucket_memory.has_method("setup"):
		bucket_memory.setup("MEMORY", "ПАМЯТЬ")

	# Setup Pool (PoolCard has the script)
	var pool_card = $SafeArea/MainVBox/WorkArea/PoolCard
	if pool_card.has_method("setup"):
		pool_card.setup("POOL", "СВАЛКА")

	_spawn_items()
	start_time = Time.get_ticks_msec()
	drag_count = 0

	result_popup.hide()
	dimmer.hide()
	btn_confirm.disabled = false
	status_label.text = "Рассортируйте улики..."

func _spawn_items():
	# Clear existing items
	for child in pool_grid.get_children():
		child.queue_free()
	for bucket in [bucket_input, bucket_output, bucket_memory]:
		var flow = bucket.get_node_or_null("VBox/ItemsFlow")
		if flow:
			for child in flow.get_children():
				child.queue_free()

	# Spawn new items
	var items = level_data.items.duplicate()
	items.shuffle()

	for item_info in items:
		var item = ITEM_SCENE.instantiate()
		pool_grid.add_child(item)
		item.setup(item_info)

func _on_reset_pressed():
	_spawn_items()
	status_label.text = "Сброс выполнен"
	status_label.add_theme_color_override("font_color", Color("ffb000")) # Theme color
	AudioManager.play("relay")
	drag_count = 0

func _on_confirm_pressed():
	var snapshot = {}
	var assigned_count = 0

	# Check buckets
	for bucket in [bucket_input, bucket_output, bucket_memory]:
		var flow = bucket.get_node_or_null("VBox/ItemsFlow")
		if flow:
			for child in flow.get_children():
				if child.has_method("setup"): # Is ClueItem
					snapshot[child.item_id] = bucket.bucket_id
					assigned_count += 1

	# Check pool
	for child in pool_grid.get_children():
		if child.has_method("setup"):
			snapshot[child.item_id] = "POOL"

	if assigned_count < 8:
		status_label.text = "Не все улики распределены!"
		status_label.add_theme_color_override("font_color", Color(1, 1, 0)) # Yellow
		AudioManager.play("error")
		# Proceed despite warning as per spec

	var result = _calculate_scoring(snapshot)
	_show_result(result, snapshot)

func _calculate_scoring(snapshot: Dictionary) -> Dictionary:
	var correct_count = 0
	for item in level_data.items:
		var iid = item.item_id
		var correct = item.correct_bucket_id
		var actual = snapshot.get(iid, "POOL")
		if actual == correct:
			correct_count += 1

	var points = 0
	var stability_delta = -30
	var verdict = "FAIL"
	var is_fit = false
	var is_correct = false

	if correct_count == 8:
		points = 2
		stability_delta = 0
		verdict = "PERFECT"
		is_fit = true
		is_correct = true
	elif correct_count >= 6:
		points = 1
		stability_delta = -10
		verdict = "PARTIAL"
		is_fit = true
		is_correct = false
	else:
		points = 0
		stability_delta = -30
		verdict = "FAIL"
		is_fit = false
		is_correct = false

	return {
		"points": points,
		"max_points": 2,
		"is_fit": is_fit,
		"is_correct": is_correct,
		"stability_delta": stability_delta,
		"correct_count": correct_count,
		"total_items": 8,
		"verdict_code": verdict
	}

func _show_result(result: Dictionary, snapshot: Dictionary):
	var elapsed_ms = Time.get_ticks_msec() - start_time
	var payload = {
		"quest_id": "CASE_01_CLUES",
		"level_id": level_data.id,
		"stage": "A",
		"format": "MATCHING",
		"match_key": "CL_A_%s_%d" % [level_data.id, GlobalMetrics.session_history.size()],
		"snapshot": snapshot,
		"correct_count": result.correct_count,
		"total_items": result.total_items,
		"points": result.points,
		"max_points": result.max_points,
		"is_fit": result.is_fit,
		"is_correct": result.is_correct,
		"stability_delta": result.stability_delta,
		"verdict_code": result.verdict_code,
		"drag_count": drag_count,
		"elapsed_ms": elapsed_ms
	}
	GlobalMetrics.register_trial(payload)

	dimmer.show()
	result_popup.show()
	res_label_verdict.text = result.verdict_code
	res_label_score.text = "Верно: %d/%d\nБаллы: %d/%d" % [result.correct_count, result.total_items, result.points, result.max_points]
	res_label_stability.text = "Стабильность: %d" % result.stability_delta

	if result.is_correct:
		AudioManager.play("click")
		res_label_verdict.modulate = Color(0, 1, 0)
	elif result.is_fit:
		AudioManager.play("click")
		res_label_verdict.modulate = Color(1, 1, 0)
	else:
		AudioManager.play("error")
		res_label_verdict.modulate = Color(1, 0, 0)

	# Block interaction
	btn_confirm.disabled = true

func _on_retry_pressed():
	result_popup.hide()
	dimmer.hide()
	btn_confirm.disabled = false
	_on_reset_pressed()

func _on_back_pressed():
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _show_error(msg):
	status_label.text = msg
	status_label.add_theme_color_override("font_color", Color(1, 0, 0))
</file>

<file path="scenes/case_01/CluesQuestA.tscn">
[gd_scene load_steps=5 format=3 uid="uid://cluesquesta"]

[ext_resource type="Script" path="res://scenes/case_01/CluesQuestA.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]
[ext_resource type="Script" path="res://scripts/ui/ClueBucketZone.gd" id="3_bucket"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_dimmer"]
bg_color = Color(0, 0, 0, 0.7)

[node name="CluesQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 16

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(60, 60)
layout_mode = 2
text = " < "

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕЛО №1: УЛИКИ В МУСОРЕ"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
text = "ЭТАП A"
horizontal_alignment = 2
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(200, 30)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
text = "Брифинг..."
autowrap_mode = 3

[node name="WorkArea" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 20

[node name="PoolCard" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.6
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/PoolCard"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/PoolCard/VBox"]
layout_mode = 2
text = "СВАЛКА"
horizontal_alignment = 1

[node name="ItemsFlow" type="GridContainer" parent="SafeArea/MainVBox/WorkArea/PoolCard/VBox"]
layout_mode = 2
size_flags_vertical = 3
columns = 2

[node name="BucketsCard" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea"]
layout_mode = 2
size_flags_horizontal = 3

[node name="BucketsVBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BucketInput" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox"]
layout_mode = 2
size_flags_vertical = 3
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput/VBox"]
layout_mode = 2
text = "ВВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketInput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BucketOutput" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox"]
layout_mode = 2
size_flags_vertical = 3
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput/VBox"]
layout_mode = 2
text = "ВЫВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketOutput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BucketMemory" type="PanelContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox"]
layout_mode = 2
size_flags_vertical = 3
script = ExtResource("3_bucket")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory/VBox"]
layout_mode = 2
text = "ПАМЯТЬ"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/WorkArea/BucketsCard/BucketsVBox/BucketMemory/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(120, 60)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(160, 60)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"

[node name="Dimmer" type="Panel" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_dimmer")

[node name="ResultPopup" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -150.0
offset_top = -120.0
offset_right = 150.0
offset_bottom = 120.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBox" type="VBoxContainer" parent="ResultPopup"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="VerdictLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ВЕРДИКТ"
horizontal_alignment = 1

[node name="ScoreLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СЧЁТ"
horizontal_alignment = 1

[node name="StabilityLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СТАБИЛЬНОСТЬ"
horizontal_alignment = 1

[node name="HBox" type="HBoxContainer" parent="ResultPopup/VBox"]
layout_mode = 2
alignment = 1
theme_override_constants/separation = 20

[node name="BtnRetry" type="Button" parent="ResultPopup/VBox/HBox"]
custom_minimum_size = Vector2(100, 50)
layout_mode = 2
text = "ПОВТОРИТЬ"

[node name="BtnBack" type="Button" parent="ResultPopup/VBox/HBox"]
custom_minimum_size = Vector2(100, 50)
layout_mode = 2
text = "В МЕНЮ"
</file>

<file path="scenes/case_08/fr8_final_report_b.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scripts/case_08/fr8_final_report_b.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(1, 0.7, 0.1, 1)
shader_parameter/intensity = 0.13
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="FR8_FinalReportB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.06, 0.06, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(116, 56)
layout_mode = 2
text = "НАЗАД"

[node name="TitleLabel" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #8: ФИНАЛЬНЫЙ ОТЧЁТ [B]"
vertical_alignment = 1

[node name="LevelLabel" type="Label" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(240, 0)
layout_mode = 2
text = "B"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(210, 24)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="BriefingLabel" type="RichTextLabel" parent="SafeArea/MainLayout/BriefingCard"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
text = "Брифинг"
fit_content = false
scroll_active = false

[node name="TimelineCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CardVBox" type="VBoxContainer" parent="SafeArea/MainLayout/TimelineCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="AxisRow" type="HBoxContainer" parent="SafeArea/MainLayout/TimelineCard/CardVBox"]
layout_mode = 2

[node name="AxisLeft" type="Label" parent="SafeArea/MainLayout/TimelineCard/CardVBox/AxisRow"]
layout_mode = 2
text = "ПРОШЛОЕ"

[node name="AxisSpacer" type="Control" parent="SafeArea/MainLayout/TimelineCard/CardVBox/AxisRow"]
layout_mode = 2
size_flags_horizontal = 3

[node name="AxisRight" type="Label" parent="SafeArea/MainLayout/TimelineCard/CardVBox/AxisRow"]
layout_mode = 2
text = "БУДУЩЕЕ"
horizontal_alignment = 2

[node name="CardsRow" type="HBoxContainer" parent="SafeArea/MainLayout/TimelineCard/CardVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "Статус"
autowrap_mode = 2
vertical_alignment = 1

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnReset" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(170, 56)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(220, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПОДТВЕРДИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
disabled = true
text = "ДАЛЕЕ"
</file>

<file path="scenes/case_08/fr8_final_report_c.tscn">
[gd_scene load_steps=7 format=3]

[ext_resource type="Script" path="res://scripts/case_08/fr8_final_report_c.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="PackedScene" path="res://scenes/ui/InspectorPopup.tscn" id="4_popup"]
[ext_resource type="PackedScene" path="res://scenes/ui/InspectBadge.tscn" id="5_badge"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(1, 0.7, 0.1, 1)
shader_parameter/intensity = 0.13
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="FR8_FinalReportC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.06, 0.06, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(116, 56)
layout_mode = 2
text = "НАЗАД"

[node name="TitleLabel" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #8: ФИНАЛЬНЫЙ ОТЧЁТ [C]"
vertical_alignment = 1

[node name="LevelLabel" type="Label" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(240, 0)
layout_mode = 2
text = "C"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(210, 24)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainLayout/BriefingCard"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "Брифинг"
autowrap_mode = 3
vertical_alignment = 1

[node name="Body" type="BoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="CodeCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CodeVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/CodeCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="CodeTitle" type="Label" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "КОД"

[node name="HtmlLabel" type="RichTextLabel" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false
text = "HTML"

[node name="CssLabel" type="RichTextLabel" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
bbcode_enabled = true
fit_content = false
text = "CSS"

[node name="HintRow" type="HBoxContainer" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="InspectBadge" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox/HintRow" instance=ExtResource("5_badge")]
layout_mode = 2

[node name="HintLine" type="Label" parent="SafeArea/MainLayout/Body/CodeCard/CodeVBox/HintRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "Нажмите по селектору для ПРОСМОТРА."
vertical_alignment = 1

[node name="DecryptCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="DecVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/DecryptCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="DecTitle" type="Label" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ДЕШИФРАТОР"

[node name="TargetPreview" type="Label" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 26
text = "Секретный код"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StrengthRow" type="HBoxContainer" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="AttackBar" type="ProgressBar" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
size_flags_horizontal = 3
max_value = 11000.0
show_percentage = false

[node name="DefenseBar" type="ProgressBar" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
size_flags_horizontal = 3
max_value = 11000.0
show_percentage = false

[node name="OptionsVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ExplainLabel" type="Label" parent="SafeArea/MainLayout/Body/DecryptCard/DecVBox"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "Объяснение"
autowrap_mode = 3
vertical_alignment = 1

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "Статус"
autowrap_mode = 2
vertical_alignment = 1

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnReset" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(170, 56)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(220, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПОДТВЕРДИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
disabled = true
text = "ДАЛЕЕ"

[node name="InspectorPopup" parent="." instance=ExtResource("4_popup")]
</file>

<file path="scenes/Decryptor.tscn">
[gd_scene load_steps=3 format=3 uid="uid://bx4x0id1k60k4"]

[ext_resource type="Script" path="res://scenes/Decryptor.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://c4p1o1h01r4g6" path="res://scenes/decryptor/DecryptorUI.tscn" id="2_ui"]

[node name="Дешифратор" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="UI" parent="." instance=ExtResource("2_ui")]
layout_mode = 1
</file>

<file path="scenes/decryptor/MatrixDecryptorUI.tscn">
[gd_scene load_steps=3 format=3]

[ext_resource type="Theme" path="res://ui/theme_terminal_green.tres" id="1_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="2_overlay"]

[node name="MatrixDecryptorUI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("1_theme")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.05, 0.03, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("2_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="Main" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="HeaderBar" type="PanelContainer" parent="SafeArea/Main"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
theme_type_variation = "HeaderPanel"

[node name="HeaderContent" type="HBoxContainer" parent="SafeArea/Main/HeaderBar"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(72, 52)
layout_mode = 2
text = "<"

[node name="ModeChip" type="PanelContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(84, 40)
layout_mode = 2

[node name="ModeLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/ModeChip"]
layout_mode = 2
text = "МАТРИЦА"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Spacer1" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LevelLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
text = "ПРОТОКОЛ C"

[node name="Spacer2" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="StabilityGroup" type="VBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2

[node name="StabilityText" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
custom_minimum_size = Vector2(170, 18)
layout_mode = 2
min_value = 0.0
max_value = 100.0
value = 100.0
percent_visible = false

[node name="Shields" type="HBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ShieldFreq" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "F"

[node name="ShieldLazy" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "L"

[node name="BtnDetails" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(72, 48)
layout_mode = 2
text = "ЛОГ"

[node name="ContentSplit" type="HBoxContainer" parent="SafeArea/Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="LeftPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.45
theme_override_constants/separation = 10

[node name="MatrixPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="MatrixContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="MatrixTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
text = "МАТРИЦА ПОТОКА"

[node name="MatrixBoard" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="RowLabels" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard"]
custom_minimum_size = Vector2(92, 0)
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="MatrixStack" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ColumnLabels" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Grid" type="GridContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 6

[node name="InOutRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="InletTag" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow"]
layout_mode = 2
text = "ВХОД [0,0]"

[node name="OutletTag" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow"]
layout_mode = 2
text = "ВЫХОД [5,5]"

[node name="ConstraintHint" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent"]
layout_mode = 2
text = "Строки используют HEX (00..3F), столбцы — количество+чётность"
autowrap_mode = 3

[node name="RightPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0
theme_override_constants/separation = 10

[node name="StatusPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="StatusContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="StatusTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent"]
layout_mode = 2
text = "СТАТУС ПОТОКА"

[node name="ProgressLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent"]
layout_mode = 2
text = "Открытая зона: 2x2"

[node name="ModeLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent"]
layout_mode = 2
text = "Безопасный режим: ВЫКЛ"

[node name="LiveLogPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="LiveLogContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="LiveLogTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
text = "ЖИВОЙ ТЕРМИНАЛ"

[node name="LiveLogText" type="RichTextLabel" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = false
scroll_following = true

[node name="HintPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="HintContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="HintTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "ПОСЛЕДНЯЯ ДИАГНОСТИКА"

[node name="HintText" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "Диагностики пока нет."
autowrap_mode = 3

[node name="BottomBar" type="PanelContainer" parent="SafeArea/Main"]
layout_mode = 2
theme_type_variation = "HeaderPanel"

[node name="Actions" type="HBoxContainer" parent="SafeArea/Main/BottomBar"]
layout_mode = 2
theme_override_constants/separation = 10
alignment = 1

[node name="BtnHint" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ПОДСКАЗКА"

[node name="BtnCheck" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПРОВЕРИТЬ"
theme_type_variation = "PrimaryButton"

[node name="BtnReset" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "СБРОС"

[node name="ToastLayer" type="CanvasLayer" parent="."]

[node name="Toast" type="PanelContainer" parent="ToastLayer"]
visible = false
layout_mode = 1
anchors_preset = 10
anchor_left = 0.5
anchor_right = 0.5
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = -200
offset_top = -120
offset_right = 200
offset_bottom = -60

[node name="ToastLabel" type="Label" parent="ToastLayer/Toast"]
layout_mode = 2
text = ""
horizontal_alignment = 1
vertical_alignment = 1

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 13
anchor_left = 0.0
anchor_right = 1.0
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -360
offset_bottom = 0

[node name="DetailsContent" type="VBoxContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="DetailsHeader" type="HBoxContainer" parent="DetailsSheet/DetailsContent"]
layout_mode = 2

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsContent/DetailsHeader"]
layout_mode = 2
text = "ДЕТАЛИ"

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsContent/DetailsHeader"]
custom_minimum_size = Vector2(84, 42)
layout_mode = 2
text = "ЗАКРЫТЬ"

[node name="DetailsScroll" type="ScrollContainer" parent="DetailsSheet/DetailsContent"]
layout_mode = 2
custom_minimum_size = Vector2(0, 260)

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsContent/DetailsScroll"]
layout_mode = 2
bbcode_enabled = true
text = ""
</file>

<file path="scenes/MainMenu.tscn">
[gd_scene load_steps=4 format=3 uid="uid://bdk0pnntt5iu8"]

[ext_resource type="Script" path="res://scenes/MainMenu.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://ckh2j4fimo232" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="MainMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.04, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]

[node name="Center" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Menu" type="VBoxContainer" parent="Center"]
custom_minimum_size = Vector2(520, 0)
layout_mode = 2
theme_override_constants/separation = 18
alignment = 1

[node name="Title" type="Label" parent="Center/Menu"]
layout_mode = 2
theme_override_colors/font_color = Color(0.96, 0.96, 0.96, 1)
theme_override_font_sizes/font_size = 56
text = "UNTformatic: Noir Protocol"
horizontal_alignment = 1

[node name="NotebookArea" type="Button" parent="Center/Menu"]
custom_minimum_size = Vector2(520, 64)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "КВЕСТЫ"

[node name="PapersArea" type="Button" parent="Center/Menu"]
custom_minimum_size = Vector2(520, 64)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ОБУЧЕНИЕ"

[node name="LaptopArea" type="Button" parent="Center/Menu"]
custom_minimum_size = Vector2(520, 64)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 22
disabled = true
text = "ЛАБОРАТОРИЯ (СКОРО)"
</file>

<file path="scenes/ui/ClueItem.tscn">
[gd_scene load_steps=2 format=3 uid="uid://clueitem001"]

[ext_resource type="Script" path="res://scripts/ui/ClueItem.gd" id="1_clue"]

[node name="ClueItem" type="Button"]
custom_minimum_size = Vector2(0, 80)
offset_right = 120.0
offset_bottom = 80.0
theme_type_variation = &"FlatButton"
text = "ЭЛЕМЕНТ"
script = ExtResource("1_clue")
</file>

<file path="scenes/ui/DiagnosticsPanelB.tscn">
[gd_scene load_steps=3 format=3 uid="uid://diagnostics_panel_b"]

[ext_resource type="Script" path="res://scripts/ui/DiagnosticsPanelB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]

[node name="DiagnosticsPanelB" type="PanelContainer"]
visible = false
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 16

[node name="Title" type="Label" parent="VBoxContainer"]
layout_mode = 2
text = "ДИАГНОСТИЧЕСКИЙ ТРЕЙС"
horizontal_alignment = 1

[node name="ExplainList" type="RichTextLabel" parent="VBoxContainer"]
layout_mode = 2
fit_content = true

[node name="TraceList" type="RichTextLabel" parent="VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Журнал трассировки..."

[node name="BtnClose" type="Button" parent="VBoxContainer"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scenes/ui/InspectBadge.tscn">
[gd_scene format=3]

[node name="InspectBadge" type="PanelContainer"]
custom_minimum_size = Vector2(92, 28)

[node name="Label" type="Label" parent="."]
layout_mode = 2
text = "ПРОСМОТР"
horizontal_alignment = 1
vertical_alignment = 1
</file>

<file path="scenes/ui/InspectorPopup.tscn">
[gd_scene load_steps=3 format=3]

[ext_resource type="Script" path="res://scripts/ui/InspectorPopup.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]

[node name="InspectorPopup" type="PopupPanel"]
initial_position = 1
size = Vector2i(560, 360)
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Root" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 10

[node name="LblTitle" type="Label" parent="Root"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ПРОСМОТР"
horizontal_alignment = 1

[node name="Info" type="GridContainer" parent="Root"]
layout_mode = 2
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 6
columns = 2

[node name="LblSelectorKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Селектор:"

[node name="LblSelectorValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "-"
autowrap_mode = 3

[node name="LblKindKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Тип:"

[node name="LblKindValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "-"

[node name="LblWeightKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Вес:"

[node name="LblWeightValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "0"

[node name="LblImportantKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "!important:"

[node name="LblImportantValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "НЕТ"

[node name="LblOrderKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Порядок:"

[node name="LblOrderValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "0"

[node name="LblColorKey" type="Label" parent="Root/Info"]
layout_mode = 2
text = "Цвет:"

[node name="LblColorValue" type="Label" parent="Root/Info"]
layout_mode = 2
text = "-"

[node name="BtnClose" type="Button" parent="Root"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scenes/ui/NetItem.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/NetItem.gd" id="1_script"]

[node name="NetItem" type="Button"]
custom_minimum_size = Vector2(0, 92)
size_flags_horizontal = 3
theme_type_variation = &"FlatButton"
theme_override_font_sizes/font_size = 18
text = "Сетевой модуль"
script = ExtResource("1_script")
</file>

<file path="scenes/ui/NetSlot.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/NetSlot.gd" id="1_script"]

[node name="NetSlot" type="PanelContainer"]
custom_minimum_size = Vector2(0, 118)
size_flags_horizontal = 3
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="VBox" type="VBoxContainer" parent="Margin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="TopRow" type="HBoxContainer" parent="Margin/VBox"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="SlotTitle" type="Label" parent="Margin/VBox/TopRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "КАНАЛ 1"
vertical_alignment = 1

[node name="BtnClear" type="Button" parent="Margin/VBox/TopRow"]
custom_minimum_size = Vector2(36, 30)
layout_mode = 2
text = "X"

[node name="ItemLabel" type="Label" parent="Margin/VBox"]
layout_mode = 2
text = "<пусто>"
horizontal_alignment = 1
vertical_alignment = 1
autowrap_mode = 2

[node name="ItemHolder" type="VBoxContainer" parent="Margin/VBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
size_flags_horizontal = 3
</file>

<file path="scenes/ui/network_trace/NetworkTraceDeviceCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/network_trace/network_trace_device_card.gd" id="1_script"]

[node name="NetworkTraceDeviceCard" type="Button"]
custom_minimum_size = Vector2(170, 78)
size_flags_horizontal = 3
text = "УСТРОЙСТВО"
script = ExtResource("1_script")
</file>

<file path="scenes/ui/pipeline/ModuleCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/pipeline/ModuleCard.gd" id="1_script"]

[node name="ModuleCard" type="PanelContainer"]
custom_minimum_size = Vector2(128, 66)
mouse_filter = 1
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 6

[node name="Label" type="Label" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_alignment = 1
vertical_alignment = 1
text = "МОДУЛЬ"
</file>

<file path="scenes/ui/pipeline/PipelineSlot.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/pipeline/PipelineSlot.gd" id="1_script"]

[node name="PipelineSlot" type="PanelContainer"]
custom_minimum_size = Vector2(158, 114)
mouse_filter = 1
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="VBox" type="VBoxContainer" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="LabelSlotTitle" type="Label" parent="Margin/VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "СЛОТ"

[node name="LabelModuleName" type="Label" parent="Margin/VBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
size_flags_horizontal = 3
horizontal_alignment = 1
vertical_alignment = 1
text = "<пусто>"

[node name="BtnClear" type="Button" parent="Margin/VBox"]
custom_minimum_size = Vector2(0, 34)
layout_mode = 2
size_flags_horizontal = 3
text = "ОЧИСТИТЬ"
</file>

<file path="scenes/ui/ResultStamp.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/ResultStamp.gd" id="1_script"]

[node name="ResultStamp" type="Control"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_script")

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="StampPanel" type="PanelContainer" parent="CenterContainer"]
custom_minimum_size = Vector2(300, 112)
layout_mode = 2
modulate = Color(1, 1, 1, 0)

[node name="Margin" type="MarginContainer" parent="CenterContainer/StampPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 14
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 14

[node name="StampLabel" type="Label" parent="CenterContainer/StampPanel/Margin"]
layout_mode = 2
theme_override_font_sizes/font_size = 44
text = "ПОДТВЕРЖДЕНО"
horizontal_alignment = 1
vertical_alignment = 1
</file>

<file path="scenes/ui/subnet/LockIndicator.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/LockIndicator.gd" id="1_script"]

[node name="LockIndicator" type="PanelContainer"]
custom_minimum_size = Vector2(0, 56)
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 6

[node name="LabelState" type="Label" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_alignment = 1
vertical_alignment = 1
theme_override_font_sizes/font_size = 22
text = "ЗАБЛОКИРОВАНО"
</file>

<file path="scenes/ui/subnet/MaskOverlay.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/subnet/MaskOverlay.gd" id="1_script"]

[node name="MaskOverlay" type="PanelContainer"]
custom_minimum_size = Vector2(142, 72)
mouse_filter = 1
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 6

[node name="LabelMask" type="Label" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_alignment = 1
vertical_alignment = 1
text = "МАСКА ?"
</file>

<file path="scenes/ui/TagFragmentItem.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TagFragmentItem.gd" id="1_script"]

[node name="TagFragmentItem" type="Button"]
custom_minimum_size = Vector2(0, 72)
size_flags_horizontal = 3
theme_type_variation = &"FlatButton"
text = "<li>фрагмент</li>"
script = ExtResource("1_script")
</file>

<file path="scenes/ui/TagSlotZone.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TagSlotZone.gd" id="1_script"]

[node name="TagSlotZone" type="PanelContainer"]
custom_minimum_size = Vector2(0, 96)
size_flags_horizontal = 3
script = ExtResource("1_script")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 4

[node name="SlotTitle" type="Label" parent="VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "СЛОТ"
horizontal_alignment = 1

[node name="Center" type="CenterContainer" parent="VBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Items" type="VBoxContainer" parent="VBox/Center"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
</file>

<file path="scenes/ui/TimelineCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/TimelineCard.gd" id="1_script"]

[node name="TimelineCard" type="PanelContainer"]
custom_minimum_size = Vector2(220, 120)
size_flags_horizontal = 3
script = ExtResource("1_script")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="VBox" type="VBoxContainer" parent="Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="Header" type="HBoxContainer" parent="Margin/VBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="StageTitle" type="Label" parent="Margin/VBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 18
text = "Этап"
autowrap_mode = 3
vertical_alignment = 1

[node name="StageHintBtn" type="Button" parent="Margin/VBox/Header"]
custom_minimum_size = Vector2(36, 36)
layout_mode = 2
text = "i"

[node name="Controls" type="HBoxContainer" parent="Margin/VBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 8

[node name="BtnLeft" type="Button" parent="Margin/VBox/Controls"]
custom_minimum_size = Vector2(0, 42)
layout_mode = 2
size_flags_horizontal = 3
text = "<"

[node name="BtnRight" type="Button" parent="Margin/VBox/Controls"]
custom_minimum_size = Vector2(0, 42)
layout_mode = 2
size_flags_horizontal = 3
text = ">"
</file>

<file path="scripts/case_08/fr8_final_report_b.gd">
extends Control

const LEVELS_PATH := "res://data/final_report_b_levels.json"
const SESSION_LEVEL_COUNT := 6
const FR8BData := preload("res://scripts/case_08/fr8b_data.gd")
const FR8BScoring := preload("res://scripts/case_08/fr8b_scoring.gd")
const TIMELINE_CARD_SCENE: PackedScene = preload("res://scenes/ui/TimelineCard.tscn")

const COLOR_OK := Color(0.55, 0.95, 0.62, 1.0)
const COLOR_WARN := Color(1.0, 0.82, 0.35, 1.0)
const COLOR_ERR := Color(1.0, 0.45, 0.45, 1.0)
const COLOR_INFO := Color(0.84, 0.84, 0.84, 1.0)

const TEXT_TITLE := "\u0414\u0415\u041b\u041e #8: \u0424\u0418\u041d\u0410\u041b\u042c\u041d\u042b\u0419 \u041e\u0422\u0427\u0415\u0422 [B]"
const TEXT_BACK := "\u041d\u0410\u0417\u0410\u0414"
const TEXT_RESET := "\u0421\u0411\u0420\u041e\u0421"
const TEXT_CONFIRM := "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TEXT_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TEXT_FINISH := "\u0417\u0410\u0412\u0415\u0420\u0428\u0418\u0422\u042c"

const STATUS_HINT := "\u0412\u044b\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u044d\u0442\u0430\u043f\u044b \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0437\u0430\u0442\u0435\u043c \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c."
const STATUS_NEXT_HINT := "\u041f\u043b\u0430\u043d \u0443\u0442\u0432\u0435\u0440\u0436\u0434\u0451\u043d. \u0416\u043c\u0438\u0442\u0435 \u0414\u0410\u041b\u0415\u0415."
const STATUS_SOLVE_FIRST := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u0435 \u0443\u0440\u043e\u0432\u0435\u043d\u044c."

var levels: Array = []
var current_level_index: int = 0
var level_data: Dictionary = {}

var cards_by_stage_id: Dictionary = {}
var current_order: Array[String] = []
var initial_order: Array[String] = []

var swap_count: int = 0
var reset_count: int = 0
var start_time_ms: int = 0
var time_to_first_action_ms: int = -1

var trial_locked: bool = false
var level_solved: bool = false
var trace: Array = []

@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack
@onready var title_label: Label = $SafeArea/MainLayout/Header/TitleLabel
@onready var level_label: Label = $SafeArea/MainLayout/Header/LevelLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainLayout/Header/StabilityBar
@onready var briefing_label: RichTextLabel = $SafeArea/MainLayout/BriefingCard/BriefingLabel
@onready var cards_row: HBoxContainer = $SafeArea/MainLayout/TimelineCard/CardVBox/CardsRow
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainLayout/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainLayout/BottomBar/BtnConfirm
@onready var btn_next: Button = $SafeArea/MainLayout/BottomBar/BtnNext
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_connect_ui_signals()
	_load_levels()
	if levels.is_empty():
		_show_error("\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0443\u0440\u043e\u0432\u043d\u0438 \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0442\u0447\u0451\u0442\u0430 B.")
		return

	title_label.text = TEXT_TITLE
	btn_back.text = TEXT_BACK
	btn_reset.text = TEXT_RESET
	btn_confirm.text = TEXT_CONFIRM
	btn_next.text = TEXT_NEXT

	var initial_index: int = clamp(GlobalMetrics.current_level_index, 0, max(0, levels.size() - 1))
	_start_level(initial_index)
	_apply_layout_mode()

func _exit_tree() -> void:
	if GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	btn_next.pressed.connect(_on_next_pressed)

func _load_levels() -> void:
	levels = FR8BData.load_levels(LEVELS_PATH)
	if SESSION_LEVEL_COUNT > 0 and levels.size() > SESSION_LEVEL_COUNT:
		var limited: Array = []
		for i in range(SESSION_LEVEL_COUNT):
			limited.append(levels[i])
		levels = limited

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	current_level_index = clamp(index, 0, levels.size() - 1)
	GlobalMetrics.current_level_index = current_level_index
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)

	cards_by_stage_id.clear()
	var base_order: Array[String] = []
	for card_var in level_data.get("cards", []) as Array:
		if typeof(card_var) != TYPE_DICTIONARY:
			continue
		var card_data: Dictionary = card_var as Dictionary
		var stage_id: String = str(card_data.get("stage_id", "")).strip_edges()
		if stage_id.is_empty():
			continue
		cards_by_stage_id[stage_id] = card_data
		base_order.append(stage_id)

	current_order = base_order.duplicate()
	var anti_cheat: Dictionary = level_data.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_cards", false)) and current_order.size() > 1:
		current_order.shuffle()
		if _arrays_equal(current_order, _expected_order()):
			var first_id: String = current_order[0]
			current_order[0] = current_order[1]
			current_order[1] = first_id

	initial_order = current_order.duplicate()
	swap_count = 0
	reset_count = 0
	start_time_ms = Time.get_ticks_msec()
	time_to_first_action_ms = -1
	trace.clear()

	level_label.text = _build_level_label()
	briefing_label.text = str(level_data.get("briefing", ""))

	_log_event("LEVEL_START", {
		"level_id": str(level_data.get("id", "FR8-B")),
		"index": current_level_index
	})
	_reset_attempt(true)
	_update_stability_ui()
	_apply_layout_mode()

func _build_level_label() -> String:
	return "B | %s (%d/%d)" % [
		str(level_data.get("id", "FR8-B")),
		current_level_index + 1,
		levels.size()
	]

func _expected_order() -> Array[String]:
	var out: Array[String] = []
	for stage_var in level_data.get("expected_order", []) as Array:
		out.append(str(stage_var).strip_edges())
	return out

func _is_last_level() -> bool:
	return current_level_index >= levels.size() - 1

func _reset_attempt(is_level_start: bool = false) -> void:
	current_order = initial_order.duplicate()
	if not is_level_start:
		_mark_first_action()
		reset_count += 1

	_log_event("СБРОС", {"level_start": is_level_start})

	trial_locked = false
	level_solved = false
	btn_confirm.disabled = false
	btn_next.disabled = true
	btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT

	_rebuild_cards()
	_set_status(STATUS_HINT, COLOR_INFO)

func _rebuild_cards() -> void:
	for child in cards_row.get_children():
		child.queue_free()

	for i in range(current_order.size()):
		var stage_id: String = current_order[i]
		if not cards_by_stage_id.has(stage_id):
			continue

		var card_node: Node = TIMELINE_CARD_SCENE.instantiate()
		cards_row.add_child(card_node)
		if card_node.has_method("setup"):
			card_node.call("setup", cards_by_stage_id[stage_id])
		if card_node.has_method("set_move_enabled"):
			card_node.call("set_move_enabled", i > 0 and not trial_locked, i < current_order.size() - 1 and not trial_locked)
		if card_node.has_signal("move_requested"):
			card_node.connect("move_requested", Callable(self, "_on_card_move_requested"))
		if card_node.has_signal("hint_requested"):
			card_node.connect("hint_requested", Callable(self, "_on_card_hint_requested"))

	_apply_layout_mode()

func _on_card_move_requested(stage_id: String, dir: int) -> void:
	if trial_locked:
		return

	var index: int = current_order.find(stage_id)
	if index < 0:
		return
	var target_index: int = index + dir
	if target_index < 0 or target_index >= current_order.size():
		return

	_mark_first_action()

	var other_stage: String = current_order[target_index]
	current_order[target_index] = stage_id
	current_order[index] = other_stage
	swap_count += 1

	_log_event("MOVE_CARD", {
		"stage_id": stage_id,
		"from_index": index,
		"to_index": target_index,
		"dir": dir
	})

	_rebuild_cards()
	_set_status(STATUS_HINT, COLOR_INFO)
	if AudioManager != null:
		AudioManager.play("click")

func _on_card_hint_requested(stage_id: String) -> void:
	_mark_first_action()
	_log_event("HINT_REQUESTED", {"stage_id": stage_id})

	var hint_text: String = ""
	if cards_by_stage_id.has(stage_id):
		var card_data: Dictionary = cards_by_stage_id.get(stage_id, {}) as Dictionary
		hint_text = str(card_data.get("hint", "")).strip_edges()

	if hint_text.is_empty():
		_set_status(STATUS_HINT, COLOR_INFO)
	else:
		_set_status(hint_text, COLOR_INFO)

	if AudioManager != null:
		AudioManager.play("click")

func _on_confirm_pressed() -> void:
	if trial_locked:
		return

	_mark_first_action()
	_log_event("CONFIRM_PRESSED", {
		"final_order": current_order.duplicate()
	})

	var evaluation: Dictionary = FR8BScoring.evaluate(level_data, current_order)
	var score: Dictionary = FR8BScoring.resolve_score(level_data, evaluation)
	var feedback_text: String = FR8BScoring.feedback_text(level_data, evaluation)

	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	var tffa_ms: int = elapsed_ms if time_to_first_action_ms < 0 else time_to_first_action_ms
	var level_id: String = str(level_data.get("id", "FR8-B-00"))
	var verdict_code: String = str(score.get("verdict_code", "FAIL"))
	var error_code: String = str(evaluation.get("error_code", "ORDER_MISMATCH"))
	var match_key: String = "FR8_B|%s|%d" % [level_id, GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_08_FINAL_REPORT",
		"stage": "B",
		"level_id": level_id,
		"format": "TIMELINE_SORT",
		"match_key": match_key,
		"initial_order": initial_order.duplicate(),
		"final_order": current_order.duplicate(),
		"violations": (evaluation.get("violations", []) as Array).duplicate(true),
		"error_code": error_code,
		"elapsed_ms": elapsed_ms,
		"time_to_first_action_ms": tffa_ms,
		"swap_count": swap_count,
		"reset_count": reset_count,
		"points": int(score.get("points", 0)),
		"max_points": int(score.get("max_points", 2)),
		"is_fit": bool(score.get("is_fit", false)),
		"is_correct": bool(score.get("is_correct", false)),
		"stability_delta": int(score.get("stability_delta", -25)),
		"verdict_code": verdict_code,
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	if verdict_code == "PERFECT":
		level_solved = true
		trial_locked = true
		btn_confirm.disabled = true
		btn_next.disabled = false
		btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
		_set_status("%s %s" % [feedback_text, STATUS_NEXT_HINT], COLOR_OK)
		_rebuild_cards()
		if AudioManager != null:
			AudioManager.play("relay")
	else:
		level_solved = false
		trial_locked = false
		btn_confirm.disabled = false
		btn_next.disabled = true
		_set_status(feedback_text, COLOR_ERR)
		_trigger_glitch()
		_shake_main_layout()
		if AudioManager != null:
			AudioManager.play("error")

func _on_next_pressed() -> void:
	if not level_solved:
		_set_status(STATUS_SOLVE_FIRST, COLOR_WARN)
		return

	var from_level_id: String = str(level_data.get("id", "FR8-B-00"))
	var from_index: int = current_level_index
	if _is_last_level():
		_log_event("NEXT_PRESSED", {
			"from_level_id": from_level_id,
			"from_index": from_index,
			"to_index": -1
		})
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return

	var to_index: int = current_level_index + 1
	_log_event("NEXT_PRESSED", {
		"from_level_id": from_level_id,
		"from_index": from_index,
		"to_index": to_index
	})
	_start_level(to_index)

func _on_back_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_reset_pressed() -> void:
	_reset_attempt(false)
	if AudioManager != null:
		AudioManager.play("click")

func _on_viewport_size_changed() -> void:
	_apply_layout_mode()

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var count: int = max(1, current_order.size())
	var available_width: float = max(320.0, viewport_size.x - 80.0)
	var card_width: float
	if viewport_size.x > viewport_size.y:
		card_width = clamp(available_width / float(count), 145.0, 230.0)
	else:
		card_width = clamp(available_width / float(count), 108.0, 170.0)

	for child in cards_row.get_children():
		if child is Control:
			var control: Control = child as Control
			control.custom_minimum_size = Vector2(card_width, 120)

func _mark_first_action() -> void:
	if time_to_first_action_ms >= 0:
		return
	time_to_first_action_ms = Time.get_ticks_msec() - start_time_ms

func _arrays_equal(a: Array[String], b: Array[String]) -> bool:
	if a.size() != b.size():
		return false
	for i in range(a.size()):
		if a[i] != b[i]:
			return false
	return true

func _set_status(text_value: String, color_value: Color) -> void:
	status_label.text = text_value
	status_label.modulate = color_value

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for _i in 4:
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _show_error(message: String) -> void:
	_set_status(message, COLOR_ERR)
	btn_confirm.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability
</file>

<file path="scripts/case_08/fr8_final_report_c.gd">
extends Control

const LEVELS_PATH := "res://data/final_report_c_levels.json"
const SESSION_LEVEL_COUNT := 6
const FR8CData := preload("res://scripts/case_08/fr8c_data.gd")
const FR8CScoring := preload("res://scripts/case_08/fr8c_scoring.gd")

const COLOR_OK := Color(0.55, 0.95, 0.62, 1.0)
const COLOR_WARN := Color(1.0, 0.82, 0.35, 1.0)
const COLOR_ERR := Color(1.0, 0.45, 0.45, 1.0)
const COLOR_INFO := Color(0.84, 0.84, 0.84, 1.0)
const COLOR_SELECTED := Color(1.0, 0.9, 0.45, 1.0)

const TEXT_TITLE := "\u0414\u0415\u041b\u041e #8: \u0424\u0418\u041d\u0410\u041b\u042c\u041d\u042b\u0419 \u041e\u0422\u0427\u0415\u0422 [C]"
const TEXT_BACK := "\u041d\u0410\u0417\u0410\u0414"
const TEXT_RESET := "\u0421\u0411\u0420\u041e\u0421"
const TEXT_CONFIRM := "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TEXT_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TEXT_FINISH := "\u0417\u0410\u0412\u0415\u0420\u0428\u0418\u0422\u042c"

const STATUS_HINT := "\u0418\u0437\u0443\u0447\u0438\u0442\u0435 \u043a\u043e\u0434, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0442\u043e\u0433\u043e\u0432\u044b\u0439 \u0446\u0432\u0435\u0442 \u0438 \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c."
const STATUS_INSPECTED := "\u0414\u0430\u043d\u043d\u044b\u0435 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044b."
const STATUS_OPTION_SELECTED := "\u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0432\u044b\u0431\u0440\u0430\u043d. \u041c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0430\u0442\u044c."
const STATUS_NEXT_HINT := "\u041a\u043e\u0434 \u0432\u0437\u043b\u043e\u043c\u0430\u043d. \u0416\u043c\u0438\u0442\u0435 \u0414\u0410\u041b\u0415\u0415."
const STATUS_SOLVE_FIRST := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0440\u0435\u0448\u0438\u0442\u0435 \u0443\u0440\u043e\u0432\u0435\u043d\u044c."
const STATUS_INSPECT_UNAVAILABLE := "\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a."
const EXPLAIN_HINT := "\u0422\u0430\u043f\u043d\u0438\u0442\u0435 \u043f\u043e \u00ab\u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c\u00bb \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0446\u0432\u0435\u0442 \u0438\u0442\u043e\u0433\u043e\u0432\u043e\u0433\u043e \u043f\u0440\u0430\u0432\u0438\u043b\u0430."

var levels: Array = []
var current_level_index: int = 0
var level_data: Dictionary = {}

var selected_option_id: String = ""
var option_buttons: Dictionary = {}
var option_by_id: Dictionary = {}

var inspect_count: int = 0
var reset_count: int = 0
var attempts: int = 0
var start_time_ms: int = 0

var level_solved: bool = false
var trial_locked: bool = false
var trace: Array = []

@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var body: BoxContainer = $SafeArea/MainLayout/Body
@onready var code_card: PanelContainer = $SafeArea/MainLayout/Body/CodeCard
@onready var decrypt_card: PanelContainer = $SafeArea/MainLayout/Body/DecryptCard

@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack
@onready var title_label: Label = $SafeArea/MainLayout/Header/TitleLabel
@onready var level_label: Label = $SafeArea/MainLayout/Header/LevelLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainLayout/Header/StabilityBar

@onready var briefing_label: Label = $SafeArea/MainLayout/BriefingCard/BriefingLabel
@onready var html_label: RichTextLabel = $SafeArea/MainLayout/Body/CodeCard/CodeVBox/HtmlLabel
@onready var css_label: RichTextLabel = $SafeArea/MainLayout/Body/CodeCard/CodeVBox/CssLabel
@onready var target_preview: Label = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/TargetPreview
@onready var attack_bar: ProgressBar = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow/AttackBar
@onready var defense_bar: ProgressBar = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/StrengthRow/DefenseBar
@onready var options_vbox: VBoxContainer = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/OptionsVBox
@onready var explain_label: Label = $SafeArea/MainLayout/Body/DecryptCard/DecVBox/ExplainLabel
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel

@onready var btn_reset: Button = $SafeArea/MainLayout/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainLayout/BottomBar/BtnConfirm
@onready var btn_next: Button = $SafeArea/MainLayout/BottomBar/BtnNext
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay
@onready var inspector_popup: PopupPanel = $InspectorPopup

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_connect_ui_signals()
	_load_levels()
	if levels.is_empty():
		_show_error("\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0443\u0440\u043e\u0432\u043d\u0438 \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0442\u0447\u0451\u0442\u0430 C.")
		return

	title_label.text = TEXT_TITLE
	btn_back.text = TEXT_BACK
	btn_reset.text = TEXT_RESET
	btn_confirm.text = TEXT_CONFIRM
	btn_next.text = TEXT_NEXT

	var initial_index: int = clamp(GlobalMetrics.current_level_index, 0, max(0, levels.size() - 1))
	_start_level(initial_index)
	_apply_layout_mode()

func _exit_tree() -> void:
	if GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	html_label.meta_clicked.connect(_on_meta_clicked)
	css_label.meta_clicked.connect(_on_meta_clicked)

func _load_levels() -> void:
	levels = FR8CData.load_levels(LEVELS_PATH)
	if SESSION_LEVEL_COUNT > 0 and levels.size() > SESSION_LEVEL_COUNT:
		var limited: Array = []
		for i in range(SESSION_LEVEL_COUNT):
			limited.append(levels[i])
		levels = limited

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	current_level_index = clamp(index, 0, levels.size() - 1)
	GlobalMetrics.current_level_index = current_level_index
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)

	selected_option_id = ""
	option_buttons.clear()
	option_by_id.clear()
	inspect_count = 0
	reset_count = 0
	attempts = 0
	trace.clear()
	start_time_ms = Time.get_ticks_msec()

	level_label.text = _build_level_label()
	briefing_label.text = str(level_data.get("briefing", ""))
	target_preview.text = str(level_data.get("target_text", "\u0421\u0435\u043a\u0440\u0435\u0442\u043d\u044b\u0439 \u043a\u043e\u0434"))
	target_preview.modulate = COLOR_INFO

	_build_option_buttons()
	_render_code_window()
	_log_event("LEVEL_START", {
		"level_id": str(level_data.get("id", "FR8-C")),
		"index": current_level_index
	})
	_reset_attempt(true)
	_update_stability_ui()
	_apply_layout_mode()

func _build_level_label() -> String:
	return "C | %s (%d/%d)" % [
		str(level_data.get("id", "FR8-C")),
		current_level_index + 1,
		levels.size()
	]

func _is_last_level() -> bool:
	return current_level_index >= levels.size() - 1

func _build_option_buttons() -> void:
	for child in options_vbox.get_children():
		child.queue_free()
	option_buttons.clear()
	option_by_id.clear()

	for option_var in level_data.get("options", []) as Array:
		if typeof(option_var) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_var as Dictionary
		var option_id: String = str(option_data.get("id", "")).strip_edges()
		if option_id.is_empty():
			continue

		option_by_id[option_id] = option_data

		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 52)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.text = "%s  [%s]" % [
			str(option_data.get("label", option_id)),
			str(option_data.get("value", ""))
		]
		btn.pressed.connect(_on_option_pressed.bind(option_id))
		options_vbox.add_child(btn)
		option_buttons[option_id] = btn

	_refresh_option_state()

func _render_code_window() -> void:
	var html_lines: Array[String] = []
	for line_var in level_data.get("html", []) as Array:
		html_lines.append("[color=#d2d2d2]%s[/color]" % _escape_bbcode(str(line_var)))

	var inline_var: Variant = level_data.get("inline_decl", null)
	if inline_var != null and typeof(inline_var) == TYPE_DICTIONARY:
		html_lines.append("[url=inspect:inline][color=#ffca5f]style=\"color:...\" (проверить)[/color][/url]")

	if html_lines.is_empty():
		html_lines.append("-")
	html_label.text = "\n".join(html_lines)

	var css_lines: Array[String] = []
	var rules: Array = level_data.get("rules", []) as Array
	for i in range(rules.size()):
		var rule_var: Variant = rules[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_var as Dictionary
		var source_id: String = str(rule.get("source_id", "R%s" % str(i + 1))).strip_edges()
		var selector: String = _selector_of(rule)
		var decl: Dictionary = rule.get("decl", {}) as Dictionary
		var color_value: String = str(decl.get("value", "")).strip_edges().to_lower()
		var bb_color: String = _bbcode_color(color_value)
		var important_suffix: String = " !important" if bool(rule.get("important", false)) else ""
		var order_value: int = int(rule.get("order", i + 1))
		var weight_value: int = int(rule.get("weight", 0))

		css_lines.append(
			"[url=inspect:%s][color=#ffca5f]%s[/color][/url] { color: [color=%s]%s[/color]%s; } [color=#8d8d8d]w:%d o:%d[/color]" % [
				source_id,
				_escape_bbcode(selector),
				bb_color,
				_escape_bbcode(color_value),
				important_suffix,
				weight_value,
				order_value
			]
		)

	if css_lines.is_empty():
		css_lines.append("-")
	css_label.text = "\n".join(css_lines)

func _reset_attempt(is_level_start: bool = false) -> void:
	if not is_level_start:
		reset_count += 1
	_log_event("СБРОС", {"level_start": is_level_start})

	selected_option_id = ""
	level_solved = false
	trial_locked = false

	attack_bar.value = 0
	defense_bar.value = 0
	btn_confirm.disabled = true
	btn_next.disabled = true
	btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
	target_preview.modulate = COLOR_INFO
	explain_label.text = EXPLAIN_HINT

	_refresh_option_state()
	_set_status(STATUS_HINT, COLOR_INFO)

func _on_option_pressed(option_id: String) -> void:
	if trial_locked:
		return
	if not option_buttons.has(option_id):
		return

	selected_option_id = option_id
	attack_bar.value = FR8CScoring.preview_attack_strength(level_data, selected_option_id)
	_refresh_option_state()
	_set_status(STATUS_OPTION_SELECTED, COLOR_INFO)
	_log_event("OPTION_SELECTED", {"option_id": option_id})
	if AudioManager != null:
		AudioManager.play("click")

func _refresh_option_state() -> void:
	for option_id_var in option_buttons.keys():
		var option_id: String = str(option_id_var)
		var button: Button = option_buttons.get(option_id, null) as Button
		if button == null:
			continue
		button.modulate = COLOR_SELECTED if option_id == selected_option_id else Color(1, 1, 1, 1)

	var preview_color: Color = COLOR_INFO
	if option_by_id.has(selected_option_id):
		var option: Dictionary = option_by_id.get(selected_option_id, {}) as Dictionary
		preview_color = _color_from_hex(str(option.get("value", "")), COLOR_INFO)
	target_preview.modulate = preview_color

	btn_confirm.disabled = trial_locked or selected_option_id.is_empty()

func _on_meta_clicked(meta: Variant) -> void:
	var meta_value: String = str(meta).strip_edges()
	if not meta_value.begins_with("inspect:"):
		return

	var source_id: String = meta_value.substr("inspect:".length())
	if source_id.is_empty():
		return

	var source_data: Dictionary = FR8CScoring.inspect_source(level_data, source_id)
	if source_data.is_empty():
		_set_status(STATUS_INSPECT_UNAVAILABLE, COLOR_WARN)
		return

	inspect_count += 1
	_log_event("INSPECT", {"source_id": source_id})
	if inspector_popup != null and inspector_popup.has_method("show_inspection"):
		inspector_popup.call("show_inspection", source_data)
	_set_status(STATUS_INSPECTED, COLOR_INFO)
	if AudioManager != null:
		AudioManager.play("click")

func _on_confirm_pressed() -> void:
	if trial_locked:
		return

	if selected_option_id.is_empty():
		_set_status(FR8CScoring.feedback_text(level_data, {"error_code": FR8CScoring.ERROR_EMPTY_CHOICE}), COLOR_WARN)
		return

	attempts += 1
	_log_event("CONFIRM_PRESSED", {
		"selected_option_id": selected_option_id,
		"attempt": attempts
	})

	var evaluation: Dictionary = FR8CScoring.evaluate(level_data, selected_option_id)
	var feedback_text: String = FR8CScoring.feedback_text(level_data, evaluation)
	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	var level_id: String = str(level_data.get("id", "FR8-C-00"))
	var match_key: String = "FR8_C|%s|%d" % [level_id, GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_08_FINAL_REPORT",
		"stage": "C",
		"level_id": level_id,
		"format": "CSS_CASCADE",
		"match_key": match_key,
		"selected_option_id": selected_option_id,
		"correct_option_id": str(evaluation.get("correct_option_id", "")),
		"winner_source_id": str(evaluation.get("winner_source_id", "")),
		"winner": (evaluation.get("winner", {}) as Dictionary).duplicate(true),
		"elapsed_ms": elapsed_ms,
		"inspect_count": inspect_count,
		"reset_count": reset_count,
		"attempts": attempts,
		"points": int(evaluation.get("points", 0)),
		"max_points": int(evaluation.get("max_points", 2)),
		"is_fit": bool(evaluation.get("is_fit", false)),
		"is_correct": bool(evaluation.get("is_correct", false)),
		"stability_delta": int(evaluation.get("stability_delta", -25)),
		"verdict_code": str(evaluation.get("verdict_code", "FAIL")),
		"error_code": str(evaluation.get("error_code", FR8CScoring.ERROR_SPECIFICITY)),
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	attack_bar.value = int(evaluation.get("attack_strength", 0))
	defense_bar.value = int(evaluation.get("defense_strength", 0))
	explain_label.text = feedback_text

	if bool(evaluation.get("is_correct", false)):
		level_solved = true
		trial_locked = true
		btn_confirm.disabled = true
		btn_next.disabled = false
		btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
		_set_status("%s %s" % [feedback_text, STATUS_NEXT_HINT], COLOR_OK)

		var winner_data: Dictionary = evaluation.get("winner", {}) as Dictionary
		target_preview.modulate = _color_from_hex(str(winner_data.get("color", "")), COLOR_OK)
		if AudioManager != null:
			AudioManager.play("relay")
	else:
		level_solved = false
		trial_locked = false
		btn_next.disabled = true
		btn_confirm.disabled = false
		_set_status(feedback_text, COLOR_ERR)
		_trigger_glitch()
		_shake_main_layout()
		if AudioManager != null:
			AudioManager.play("error")

func _on_next_pressed() -> void:
	if not level_solved:
		_set_status(STATUS_SOLVE_FIRST, COLOR_WARN)
		return

	var from_level_id: String = str(level_data.get("id", "FR8-C-00"))
	var from_index: int = current_level_index
	if _is_last_level():
		_log_event("NEXT_PRESSED", {
			"from_level_id": from_level_id,
			"from_index": from_index,
			"to_index": -1
		})
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return

	var to_index: int = current_level_index + 1
	_log_event("NEXT_PRESSED", {
		"from_level_id": from_level_id,
		"from_index": from_index,
		"to_index": to_index
	})
	_start_level(to_index)

func _on_back_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_reset_pressed() -> void:
	_reset_attempt(false)
	if AudioManager != null:
		AudioManager.play("click")

func _on_viewport_size_changed() -> void:
	_apply_layout_mode()

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var landscape: bool = viewport_size.x > viewport_size.y
	body.vertical = not landscape

	if landscape:
		if body.get_child(0) != code_card:
			body.move_child(code_card, 0)
			body.move_child(decrypt_card, 1)
	else:
		if body.get_child(0) != code_card:
			body.move_child(code_card, 0)
			body.move_child(decrypt_card, 1)

func _set_status(text_value: String, color_value: Color) -> void:
	status_label.text = text_value
	status_label.modulate = color_value

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for _i in 4:
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _show_error(message: String) -> void:
	_set_status(message, COLOR_ERR)
	btn_confirm.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _selector_of(rule: Dictionary) -> String:
	var selector: String = str(rule.get("selector", "")).strip_edges()
	if not selector.is_empty():
		return selector
	return str(rule.get(".selector", "")).strip_edges()

func _escape_bbcode(text_value: String) -> String:
	return text_value.replace("[", "[lb]").replace("]", "[rb]")

func _color_from_hex(hex_value: String, fallback: Color) -> Color:
	var value: String = hex_value.strip_edges()
	if value.is_empty():
		return fallback
	return Color.from_string(value, fallback)

func _bbcode_color(color_value: String) -> String:
	var value: String = color_value.strip_edges()
	if value.begins_with("#") and (value.length() == 4 or value.length() == 7 or value.length() == 9):
		return value
	return "#ffffff"
</file>

<file path="scripts/case_08/fr8c_scoring.gd">
extends RefCounted

const ERROR_EMPTY_CHOICE := "EMPTY_CHOICE"
const ERROR_SPECIFICITY := "SPECIFICITY_ERROR"
const ERROR_IMPORTANT := "IMPORTANT_MISSED"
const ERROR_ORDER_TIE := "ORDER_TIE"
const ERROR_INLINE := "INLINE_OVERRIDE"
const ERROR_OK := "OK"

const VERDICT_PERFECT := "PERFECT"
const VERDICT_FAIL := "FAIL"

static func evaluate(level: Dictionary, selected_option_id: String) -> Dictionary:
	var candidates: Array = _build_candidates(level)
	var winner: Dictionary = _pick_winner(candidates)
	var correct_option_id: String = str(level.get("correct_option_id", "")).strip_edges()
	var selected_option: Dictionary = _option_by_id(level, selected_option_id)
	var selected_value: String = str(selected_option.get("value", "")).strip_edges().to_lower()
	var selected_candidate: Dictionary = _top_candidate_for_color(candidates, selected_value)

	var error_code: String = ERROR_OK
	var is_correct: bool = false
	var is_fit: bool = not selected_option.is_empty()

	if not is_fit:
		error_code = ERROR_EMPTY_CHOICE
	else:
		is_correct = selected_option_id.strip_edges() == correct_option_id
		if not is_correct:
			error_code = _infer_error_code(selected_candidate, winner)

	var points: int = 2 if is_correct else 0
	var stability_delta: int = 0 if is_correct else -25
	var verdict_code: String = VERDICT_PERFECT if is_correct else VERDICT_FAIL

	return {
		"error_code": ERROR_OK if is_correct else error_code,
		"is_correct": is_correct,
		"is_fit": is_fit,
		"points": points,
		"max_points": 2,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"correct_option_id": correct_option_id,
		"winner_source_id": str(winner.get("source_id", "")),
		"winner": {
			"important": bool(winner.get("important", false)),
			"weight": int(winner.get("weight", 0)),
			"order": int(winner.get("order", 0)),
			"color": str(winner.get("color", ""))
		},
		"attack_strength": _strength_of(selected_candidate),
		"defense_strength": _strength_of(winner)
	}

static func feedback_text(level: Dictionary, evaluation: Dictionary) -> String:
	var error_code: String = str(evaluation.get("error_code", ERROR_SPECIFICITY))
	var feedback_rules: Dictionary = level.get("feedback_rules", {}) as Dictionary
	if error_code == ERROR_EMPTY_CHOICE:
		return "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0446\u0432\u0435\u0442\u0430."
	if feedback_rules.has(error_code):
		return str(feedback_rules.get(error_code, ""))
	if error_code == ERROR_IMPORTANT:
		return "!important \u043f\u0435\u0440\u0435\u0431\u0438\u0432\u0430\u0435\u0442 \u043e\u0431\u044b\u0447\u043d\u044b\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u0430."
	if error_code == ERROR_INLINE:
		return "Встроенный стиль перекрывает правила из CSS."
	if error_code == ERROR_ORDER_TIE:
		return "\u041f\u0440\u0438 \u0440\u0430\u0432\u043d\u043e\u0439 \u0441\u0438\u043b\u0435 \u043f\u043e\u0431\u0435\u0436\u0434\u0430\u0435\u0442 \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0438\u0434\u0451\u0442 \u043f\u043e\u0437\u0436\u0435."
	if error_code == ERROR_SPECIFICITY:
		return "\u041f\u043e\u0431\u0435\u0434\u0438\u043b \u0431\u043e\u043b\u0435\u0435 \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u0447\u043d\u044b\u0439 \u0441\u0435\u043b\u0435\u043a\u0442\u043e\u0440."
	if feedback_rules.has(ERROR_OK):
		return str(feedback_rules.get(ERROR_OK, ""))
	return "\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u043a\u0430\u0441\u043a\u0430\u0434 \u0438 \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430."

static func inspect_source(level: Dictionary, source_id: String) -> Dictionary:
	var sid: String = source_id.strip_edges()
	if sid.to_lower() == "inline":
		var inline_var: Variant = level.get("inline_decl", null)
		if inline_var == null or typeof(inline_var) != TYPE_DICTIONARY:
			return {}
		var inline_decl: Dictionary = inline_var as Dictionary
		var decl: Dictionary = inline_decl.get("decl", {}) as Dictionary
		return {
			"source_id": str(inline_decl.get("source_id", "INLINE")),
			"selector": "встроенный стиль",
			"kind": str(inline_decl.get("kind", "inline")),
			"weight": int(inline_decl.get("weight", 1000)),
			"important": bool(inline_decl.get("important", false)),
			"order": int(inline_decl.get("order", 10000)),
			"color": str(decl.get("value", ""))
		}

	for i in range((level.get("rules", []) as Array).size()):
		var rule_var: Variant = (level.get("rules", []) as Array)[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_var as Dictionary
		if str(rule.get("source_id", "")).strip_edges() != sid:
			continue
		var decl: Dictionary = rule.get("decl", {}) as Dictionary
		return {
			"source_id": sid,
			"selector": _selector_of(rule),
			"kind": str(rule.get("kind", "")),
			"weight": int(rule.get("weight", 0)),
			"important": bool(rule.get("important", false)),
			"order": int(rule.get("order", i + 1)),
			"color": str(decl.get("value", ""))
		}
	return {}

static func preview_attack_strength(level: Dictionary, selected_option_id: String) -> int:
	var selected_option: Dictionary = _option_by_id(level, selected_option_id)
	if selected_option.is_empty():
		return 0
	var selected_value: String = str(selected_option.get("value", "")).strip_edges().to_lower()
	var selected_candidate: Dictionary = _top_candidate_for_color(_build_candidates(level), selected_value)
	return _strength_of(selected_candidate)

static func _build_candidates(level: Dictionary) -> Array:
	var out: Array = []
	var rules: Array = level.get("rules", []) as Array
	for i in range(rules.size()):
		var rule_var: Variant = rules[i]
		if typeof(rule_var) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_var as Dictionary
		var decl: Dictionary = rule.get("decl", {}) as Dictionary
		out.append({
			"source_id": str(rule.get("source_id", "")).strip_edges(),
			"selector": _selector_of(rule),
			"kind": str(rule.get("kind", "")),
			"weight": int(rule.get("weight", 0)),
			"important": bool(rule.get("important", false)),
			"order": int(rule.get("order", i + 1)),
			"color": str(decl.get("value", "")).strip_edges().to_lower()
		})

	var inline_var: Variant = level.get("inline_decl", null)
	if inline_var != null and typeof(inline_var) == TYPE_DICTIONARY:
		var inline_decl: Dictionary = inline_var as Dictionary
		var inline_decl_data: Dictionary = inline_decl.get("decl", {}) as Dictionary
		out.append({
			"source_id": str(inline_decl.get("source_id", "INLINE")).strip_edges(),
			"selector": "встроенный стиль",
			"kind": str(inline_decl.get("kind", "inline")),
			"weight": int(inline_decl.get("weight", 1000)),
			"important": bool(inline_decl.get("important", false)),
			"order": int(inline_decl.get("order", 10000)),
			"color": str(inline_decl_data.get("value", "")).strip_edges().to_lower()
		})

	return out

static func _pick_winner(candidates: Array) -> Dictionary:
	if candidates.is_empty():
		return {
			"source_id": "",
			"selector": "",
			"kind": "",
			"weight": 0,
			"important": false,
			"order": 0,
			"color": ""
		}

	var winner: Dictionary = candidates[0] as Dictionary
	for i in range(1, candidates.size()):
		if typeof(candidates[i]) != TYPE_DICTIONARY:
			continue
		var candidate: Dictionary = candidates[i] as Dictionary
		if _is_stronger(candidate, winner):
			winner = candidate
	return winner

static func _top_candidate_for_color(candidates: Array, color_value: String) -> Dictionary:
	var color: String = color_value.strip_edges().to_lower()
	if color.is_empty():
		return {}
	var picked: Dictionary = {}
	for candidate_var in candidates:
		if typeof(candidate_var) != TYPE_DICTIONARY:
			continue
		var candidate: Dictionary = candidate_var as Dictionary
		if str(candidate.get("color", "")).to_lower() != color:
			continue
		if picked.is_empty() or _is_stronger(candidate, picked):
			picked = candidate
	return picked

static func _is_stronger(a: Dictionary, b: Dictionary) -> bool:
	var a_imp: bool = bool(a.get("important", false))
	var b_imp: bool = bool(b.get("important", false))
	if a_imp != b_imp:
		return a_imp and not b_imp

	var a_weight: int = int(a.get("weight", 0))
	var b_weight: int = int(b.get("weight", 0))
	if a_weight != b_weight:
		return a_weight > b_weight

	var a_order: int = int(a.get("order", 0))
	var b_order: int = int(b.get("order", 0))
	if a_order != b_order:
		return a_order > b_order
	return false

static func _infer_error_code(selected_candidate: Dictionary, winner: Dictionary) -> String:
	if str(winner.get("source_id", "")).to_upper() == "INLINE":
		if selected_candidate.is_empty() or str(selected_candidate.get("source_id", "")).to_upper() != "INLINE":
			return ERROR_INLINE

	if bool(winner.get("important", false)):
		if selected_candidate.is_empty() or not bool(selected_candidate.get("important", false)):
			return ERROR_IMPORTANT

	if not selected_candidate.is_empty():
		var same_important: bool = bool(selected_candidate.get("important", false)) == bool(winner.get("important", false))
		var same_weight: bool = int(selected_candidate.get("weight", 0)) == int(winner.get("weight", 0))
		if same_important and same_weight and int(selected_candidate.get("order", 0)) != int(winner.get("order", 0)):
			return ERROR_ORDER_TIE
		if int(selected_candidate.get("weight", 0)) != int(winner.get("weight", 0)):
			return ERROR_SPECIFICITY

	return ERROR_SPECIFICITY

static func _option_by_id(level: Dictionary, option_id: String) -> Dictionary:
	var oid: String = option_id.strip_edges()
	if oid.is_empty():
		return {}
	for option_var in level.get("options", []) as Array:
		if typeof(option_var) != TYPE_DICTIONARY:
			continue
		var option: Dictionary = option_var as Dictionary
		if str(option.get("id", "")).strip_edges() == oid:
			return option
	return {}

static func _selector_of(rule: Dictionary) -> String:
	var selector: String = str(rule.get("selector", "")).strip_edges()
	if not selector.is_empty():
		return selector
	return str(rule.get(".selector", "")).strip_edges()

static func _strength_of(candidate: Dictionary) -> int:
	if candidate.is_empty():
		return 0
	var important_bonus: int = 10000 if bool(candidate.get("important", false)) else 0
	return important_bonus + int(candidate.get("weight", 0))
</file>

<file path="scripts/quests/network_trace/NetworkTraceQuestA.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")
const DEVICE_CARD_SCENE: PackedScene = preload("res://scenes/ui/network_trace/NetworkTraceDeviceCard.tscn")

const LEVELS_PATH := "res://data/network_trace_a_levels.json"
const MAX_ATTEMPTS := 3
const DEFAULT_TIME_LIMIT_SEC := 120
const RUN_COOLDOWN_MS := 500
const FAIL_STABILITY_DELTA := -10.0
const HINT_STABILITY_DELTA := -5.0
const PALETTE_GREEN_ID := 0
const PALETTE_AMBER_ID := 1

enum QuestState {
	INIT,
	BRIEFING,
	SOLVING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	SAFE_MODE,
	DIAGNOSTIC
}

@onready var btn_back: Button = $Main/V/Header/BtnBack
@onready var lbl_title: Label = $Main/V/Header/LblTitle
@onready var lbl_meta: Label = $Main/V/Header/LblMeta
@onready var palette_select: OptionButton = $Main/V/Header/PaletteSelect
@onready var body: BoxContainer = $Main/V/Body
@onready var lbl_briefing: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblBriefing
@onready var lbl_prompt: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblPrompt
@onready var log_list: VBoxContainer = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll/LogList
@onready var evidence_row: HBoxContainer = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/EvidenceRow
@onready var topology_board: NetworkTraceTopologyBoardA = $Main/V/Body/MapPane/MapMargin/MapV/TopologyBoard
@onready var palette_box: HBoxContainer = $Main/V/Body/MapPane/MapMargin/MapV/PaletteScroll/Palette
@onready var btn_analyze: Button = $Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnAnalyze
@onready var btn_run_trace: Button = $Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnRunTrace
@onready var btn_reset: Button = $Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnReset
@onready var btn_next: Button = $Main/V/Body/MapPane/MapMargin/MapV/Actions/BtnNext
@onready var lbl_status: Label = $Main/V/Body/MapPane/MapMargin/MapV/LblStatus
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

var levels: Array[Dictionary] = []
var current_level: Dictionary = {}
var current_level_index: int = 0

var state: int = QuestState.INIT
var wrong_count: int = 0
var safe_mode_used: bool = false
var hint_used: bool = false
var level_finished: bool = false
var result_sent: bool = false
var run_in_progress: bool = false
var run_cooldown_until_ms: int = 0
var spam_clicks: int = 0

var level_started_ms: int = 0
var first_action_ms: int = -1
var time_limit_sec: int = DEFAULT_TIME_LIMIT_SEC
var time_left_sec: float = float(DEFAULT_TIME_LIMIT_SEC)
var timer_running: bool = false

var required_evidence: int = 2
var selected_evidence_indices: Array[int] = []
var log_buttons: Array[Button] = []
var evidence_slot_labels: Array[Label] = []

var selected_device_id: String = ""
var selected_error_code: String = ""

var attempts: Array[Dictionary] = []
var task_session: Dictionary = {}
var variant_hash: String = ""

var palette_cards: Array[NetworkTraceDeviceCard] = []

func _ready() -> void:
	_setup_palette_controls()
	_connect_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_layout_mode()

	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)

	if not _load_levels():
		_show_boot_error("Данные Network Trace A отсутствуют или повреждены.")
		return

	_start_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible and not level_finished:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.SOLVING

	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_meta_label()
			_on_timeout()
		else:
			_update_meta_label()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_layout_mode()

func _setup_palette_controls() -> void:
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_run_trace.pressed.connect(_on_run_trace_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	
	topology_board.device_installed.connect(_on_device_installed)
	topology_board.device_removed.connect(_on_device_removed)

func _load_levels() -> bool:
	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		push_error("Cannot open %s" % LEVELS_PATH)
		return false

	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		push_error("Expected array in %s" % LEVELS_PATH)
		return false

	var raw_levels: Array = parsed
	levels.clear()
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
		elif OS.is_debug_build():
			push_error("Invalid Network Trace A level: %s" % str(level.get("id", "UNKNOWN")))
			return false
		else:
			push_warning("Skipping invalid level: %s" % str(level.get("id", "UNKNOWN")))

	return not levels.is_empty()

func _validate_level(level: Dictionary) -> bool:
	var required_keys: Array[String] = [
		"id", "incident_id", "briefing", "prompt", "required_evidence", "logs", "topology", "options", "correct_id", "explain_short", "explain_full", "tags"
	]
	for key in required_keys:
		if not level.has(key):
			return false

	if typeof(level.get("logs")) != TYPE_ARRAY:
		return false
	if typeof(level.get("options")) != TYPE_ARRAY:
		return false
	if typeof(level.get("topology")) != TYPE_DICTIONARY:
		return false

	var logs: Array = level.get("logs", [])
	if logs.size() < 3:
		return false

	var required_count: int = int(level.get("required_evidence", 0))
	if required_count <= 0 or required_count > logs.size():
		return false

	var options: Array = level.get("options", [])
	if options.size() < 4 or options.size() > 6:
		return false

	var ids: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		if not option.has("id") or not option.has("label") or not option.has("error_code"):
			return false
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or ids.has(option_id):
			return false
		ids[option_id] = true

	var correct_id: String = str(level.get("correct_id", ""))
	if not ids.has(correct_id):
		return false

	var topology: Dictionary = level.get("topology", {})
	if typeof(topology.get("nodes", [])) != TYPE_ARRAY:
		return false
	if typeof(topology.get("edges", [])) != TYPE_ARRAY:
		return false

	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))
	btn_run_trace.disabled = true
	btn_analyze.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true
	timer_running = false

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	if index >= levels.size():
		index = 0
	current_level_index = index
	current_level = levels[index].duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))

	state = QuestState.BRIEFING
	wrong_count = 0
	safe_mode_used = false
	hint_used = false
	level_finished = false
	result_sent = false
	run_in_progress = false
	run_cooldown_until_ms = 0
	spam_clicks = 0
	selected_device_id = ""
	selected_error_code = ""
	selected_evidence_indices.clear()
	attempts.clear()

	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	time_limit_sec = int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC))
	time_left_sec = float(time_limit_sec)
	timer_running = true

	required_evidence = int(current_level.get("required_evidence", 2))

	task_session = {
		"task_id": str(current_level.get("id", "NT_A_UNKNOWN")),
		"variant_hash": variant_hash,
		"started_at_ticks": level_started_ms,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	lbl_title.text = "СЕТЕВОЙ СЛЕД | A"
	btn_next.visible = false
	btn_next.disabled = false
	btn_analyze.text = "АНАЛИЗ"
	btn_analyze.disabled = true
	btn_run_trace.disabled = true
	btn_reset.disabled = true
	diagnostics_panel.visible = false

	_render_text_blocks()
	_build_log_items()
	_build_evidence_slots()
	_setup_topology()
	_build_palette()
	_set_tools_unlocked(false)

	lbl_status.text = "Соберите улики (%d/%d), чтобы разблокировать инструменты." % [selected_evidence_indices.size(), required_evidence]
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))

	_update_meta_label()
	_log_event("task_start", {"level": str(current_level.get("id", ""))})

func _render_text_blocks() -> void:
	lbl_briefing.clear()
	lbl_briefing.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n%s" % str(current_level.get("briefing", "")))

	lbl_prompt.clear()
	lbl_prompt.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n%s" % str(current_level.get("prompt", "")))

func _build_log_items() -> void:
	for child in log_list.get_children():
		child.queue_free()
	log_buttons.clear()

	var logs: Array = current_level.get("logs", [])
	for idx in range(logs.size()):
		var log_line: String = str(logs[idx])
		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 48)
		btn.toggle_mode = true
		btn.text = "[%d] %s" % [idx + 1, log_line]
		btn.pressed.connect(_on_log_pressed.bind(idx))
		log_list.add_child(btn)
		log_buttons.append(btn)

func _build_evidence_slots() -> void:
	for child in evidence_row.get_children():
		child.queue_free()
	evidence_slot_labels.clear()

	for idx in range(required_evidence):
		var slot_panel: PanelContainer = PanelContainer.new()
		slot_panel.custom_minimum_size = Vector2(0, 54)
		slot_panel.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		var slot_label: Label = Label.new()
		slot_label.text = "УЛИКА %d" % (idx + 1)
		slot_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		slot_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		slot_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
		slot_panel.add_child(slot_label)
		evidence_row.add_child(slot_panel)
		evidence_slot_labels.append(slot_label)

	_update_evidence_visuals()

func _setup_topology() -> void:
	var topology: Dictionary = current_level.get("topology", {})
	topology_board.setup_topology(topology)
	topology_board.set_tools_locked(true)

func _build_palette() -> void:
	for child in palette_box.get_children():
		child.queue_free()
	palette_cards.clear()

	var options: Array = current_level.get("options", [])
	for option_var in options:
		var option: Dictionary = option_var
		var card_node: Node = DEVICE_CARD_SCENE.instantiate()
		if card_node is NetworkTraceDeviceCard:
			var card: NetworkTraceDeviceCard = card_node
			card.setup(str(option.get("id", "")), str(option.get("label", "")), str(option.get("error_code", "")))
			card.disabled = true
			palette_box.add_child(card)
			palette_cards.append(card)

func _set_tools_unlocked(unlocked: bool) -> void:
	for card in palette_cards:
		card.disabled = not unlocked
	topology_board.set_tools_locked(not unlocked)

	if not unlocked:
		selected_device_id = ""
		selected_error_code = ""
		btn_run_trace.disabled = true
		btn_reset.disabled = true
		topology_board.clear_installed_device()
	else:
		btn_run_trace.disabled = selected_device_id.is_empty()
		btn_reset.disabled = selected_device_id.is_empty()

func _on_log_pressed(log_index: int) -> void:
	if level_finished:
		return
	_register_first_action()

	if selected_evidence_indices.has(log_index):
		selected_evidence_indices.erase(log_index)
	else:
		selected_evidence_indices.append(log_index)
	selected_evidence_indices.sort()

	for idx in range(log_buttons.size()):
		var btn: Button = log_buttons[idx]
		btn.button_pressed = selected_evidence_indices.has(idx)

	_update_evidence_visuals()
	_log_event("evidence_toggled", {"index": log_index, "count": selected_evidence_indices.size()})

	if selected_evidence_indices.size() >= required_evidence and state == QuestState.BRIEFING:
		state = QuestState.SOLVING
		_set_tools_unlocked(true)
		lbl_status.text = "Инструменты разблокированы. Перетащите устройство в слот и запустите трассировку."
		lbl_status.add_theme_color_override("font_color", Color(0.6, 0.95, 0.7))
	elif selected_evidence_indices.size() < required_evidence:
		state = QuestState.BRIEFING
		_set_tools_unlocked(false)
		lbl_status.text = "Соберите улики (%d/%d), чтобы разблокировать инструменты." % [selected_evidence_indices.size(), required_evidence]
		lbl_status.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))

func _update_evidence_visuals() -> void:
	var logs: Array = current_level.get("logs", [])
	for slot_index in range(evidence_slot_labels.size()):
		var slot_label: Label = evidence_slot_labels[slot_index]
		if slot_index < selected_evidence_indices.size():
			var log_index: int = selected_evidence_indices[slot_index]
			if log_index >= 0 and log_index < logs.size():
				slot_label.text = str(logs[log_index])
			else:
				slot_label.text = "УЛИКА %d" % (slot_index + 1)
		else:
			slot_label.text = "УЛИКА %d" % (slot_index + 1)

func _on_device_installed(device_id: String, _label_text: String, error_code: String) -> void:
	selected_device_id = device_id
	selected_error_code = error_code
	btn_run_trace.disabled = selected_device_id.is_empty() or level_finished
	btn_reset.disabled = selected_device_id.is_empty() or level_finished
	lbl_status.text = "Устройство установлено. Нажмите ЗАПУСТИТЬ ТРАССИРОВКУ."
	lbl_status.add_theme_color_override("font_color", Color(0.75, 0.95, 0.8))
	_log_event("device_installed", {"device_id": device_id})

func _on_device_removed() -> void:
	selected_device_id = ""
	selected_error_code = ""
	btn_run_trace.disabled = true
	btn_reset.disabled = true
	_log_event("device_removed", {})

func _on_run_trace_pressed() -> void:
	if level_finished:
		return
	if run_in_progress:
		spam_clicks += 1
		return
	if selected_evidence_indices.size() < required_evidence:
		lbl_status.text = ERROR_MAP.get_error_tip("A_WRONG_EVIDENCE")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return
	if selected_device_id.is_empty():
		lbl_status.text = "Сначала установите устройство в слот."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return

	var now_ms: int = Time.get_ticks_msec()
	if now_ms < run_cooldown_until_ms:
		spam_clicks += 1
		return
	run_cooldown_until_ms = now_ms + RUN_COOLDOWN_MS

	_register_first_action()
	_play_audio("click")
	_lock_controls_for_trace(true)
	run_in_progress = true

	var is_correct: bool = selected_device_id == str(current_level.get("correct_id", ""))
	var error_code: String = "" if is_correct else selected_error_code
	if error_code.is_empty() and not is_correct:
		error_code = "UNKNOWN"

	var attempt: Dictionary = {
		"device_id": selected_device_id,
		"error_code": error_code,
		"correct": is_correct,
		"t_ms": now_ms - level_started_ms
	}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("run_trace", {
		"device_id": selected_device_id,
		"correct": is_correct,
		"error_code": error_code
	})

	await topology_board.play_trace_animation(is_correct)
	run_in_progress = false
	if level_finished:
		return

	if is_correct:
		_handle_success()
	else:
		_handle_failure(error_code)

	if not level_finished:
		_lock_controls_for_trace(false)
		btn_run_trace.disabled = selected_device_id.is_empty()
		btn_reset.disabled = selected_device_id.is_empty()

func _lock_controls_for_trace(locked: bool) -> void:
	btn_run_trace.disabled = locked
	btn_reset.disabled = locked
	for card in palette_cards:
		card.disabled = locked or state == QuestState.BRIEFING
	topology_board.set_tools_locked(locked or state == QuestState.BRIEFING)

func _handle_success() -> void:
	state = QuestState.FEEDBACK_SUCCESS
	lbl_status.text = "ТРАССИРОВКА OK: путь установлен."
	lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.45))
	_play_audio("relay")
	_log_event("trace_success", {"device_id": selected_device_id})
	_finish_level(true, "success")

func _handle_failure(error_code: String) -> void:
	state = QuestState.FEEDBACK_FAIL
	wrong_count += 1
	_play_audio("error")
	_trigger_glitch()

	var title: String = ERROR_MAP.get_error_title(error_code)
	var tip: String = ERROR_MAP.get_error_tip(error_code)
	lbl_status.text = "%s: %s" % [title, tip]
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.38, 0.38))
	_update_meta_label()

	_log_event("trace_fail", {"error_code": error_code, "wrong_count": wrong_count})

	if wrong_count >= 2 and not safe_mode_used:
		safe_mode_used = true
		state = QuestState.SAFE_MODE
		btn_analyze.disabled = false
		btn_analyze.text = "ДИАГНОСТИКА"
		lbl_status.text = "Безопасный режим включён. Откройте диагностику для полного разбора."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.75, 0.45))

	if wrong_count >= MAX_ATTEMPTS:
		_show_safe_mode_diagnostics("Достигнут лимит попыток")
		_finish_level(false, "attempt_limit")

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	if not safe_mode_used:
		lbl_status.text = "Анализ открывается после 2 неудачных трассировок."
		lbl_status.add_theme_color_override("font_color", Color(0.9, 0.8, 0.45))
		return

	_register_first_action()
	if not hint_used:
		hint_used = true

	_show_safe_mode_diagnostics("Ручная диагностика")

func _show_safe_mode_diagnostics(trigger_reason: String) -> void:
	var lines: Array[String] = []
	lines.append("Дело: %s" % str(current_level.get("id", "UNKNOWN")))
	lines.append("Причина: %s" % trigger_reason)
	if not selected_error_code.is_empty():
		lines.append("Ошибка: %s" % selected_error_code)
		lines.append(ERROR_MAP.get_error_tip(selected_error_code))

	var explain_full: String = str(current_level.get("explain_full", ""))
	if not explain_full.is_empty():
		for line_var in explain_full.split("\n"):
			var text_line: String = line_var.strip_edges()
			if not text_line.is_empty():
				lines.append(text_line)

	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true
	state = QuestState.DIAGNOSTIC
	_log_event("diagnostics_open", {"reason": trigger_reason})

func _on_reset_pressed() -> void:
	if level_finished or run_in_progress:
		return
	_register_first_action()
	topology_board.clear_installed_device()
	lbl_status.text = "Слот очищен. Перетащите новое устройство."
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.86, 0.95))
	_log_event("reset_pressed", {})

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", ""))})
	_start_level(current_level_index + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	var palette_id: int = palette_select.get_item_id(index)
	_apply_palette(palette_id)

func _apply_palette(palette_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(1.0, 0.7, 0.1, 1.0))
	else:
		theme = THEME_GREEN
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(0.0, 1.0, 0.25, 1.0))

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _play_audio(sound_name: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_name)

func _update_meta_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	var minutes: int = total_seconds / 60
	var seconds: int = total_seconds % 60
	lbl_meta.text = "ДЕЛО %s | ОШ %d/%d | %02d:%02d" % [
		str(current_level.get("id", "--")),
		wrong_count,
		MAX_ATTEMPTS,
		minutes,
		seconds
	]

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	# Meta label is refreshed in timer tick and state transitions.
	pass

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _on_timeout() -> void:
	if level_finished:
		return
	selected_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {
		"device_id": selected_device_id,
		"error_code": "TIMEOUT",
		"correct": false,
		"t_ms": Time.get_ticks_msec() - level_started_ms
	}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_show_safe_mode_diagnostics("Тайм-аут")
	_finish_level(false, "timeout")

func _finish_level(is_correct: bool, reason: String) -> void:
	if result_sent:
		return
	result_sent = true
	level_finished = true
	timer_running = false
	btn_run_trace.disabled = true
	btn_reset.disabled = true
	btn_analyze.disabled = true
	btn_next.visible = true
	for card in palette_cards:
		card.disabled = true
	topology_board.set_tools_locked(true)

	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	if not is_correct and reason != "timeout":
		lbl_status.text = str(current_level.get("explain_short", "Проверьте диагностику для деталей."))
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.62, 0.45))

	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = float(wrong_count) * FAIL_STABILITY_DELTA
	if not is_correct and wrong_count == 0:
		stability_delta += FAIL_STABILITY_DELTA
	if hint_used:
		stability_delta += HINT_STABILITY_DELTA

	var evidence_lines: Array[String] = _collect_selected_evidence_lines()
	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": "A",
		"task_id": str(current_level.get("id", "")),
		"incident_id": str(current_level.get("incident_id", "")),
		"match_key": "NETTRACE_A|%s" % str(current_level.get("id", "")),
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"error_code_last": selected_error_code,
		"attempts_count": attempts.size(),
		"attempts": attempts,
		"evidence_selected": evidence_lines,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"safe_mode_used": safe_mode_used,
		"spam_clicks": spam_clicks,
		"time_to_first_action_ms": first_action_ms,
		"hint_used": hint_used,
		"timed_out": reason == "timeout",
		"stability_delta": stability_delta,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _collect_selected_evidence_lines() -> Array[String]:
	var logs: Array = current_level.get("logs", [])
	var out: Array[String] = []
	for index in selected_evidence_indices:
		if index >= 0 and index < logs.size():
			out.append(str(logs[index]))
	return out

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": Time.get_ticks_msec() - level_started_ms,
		"payload": payload
	})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var option_ids: Array[String] = []
	var options: Array = level.get("options", [])
	for option_var in options:
		var option: Dictionary = option_var
		option_ids.append(str(option.get("id", "")))
	option_ids.sort()
	return "%s|%s|%s|%s" % [
		str(level.get("id", "")),
		str(level.get("prompt", "")),
		str(level.get("correct_id", "")),
		",".join(option_ids)
	]

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	body.vertical = viewport_size.x < viewport_size.y
</file>

<file path="scripts/quests/network_trace/NetworkTraceQuestB.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")
const MODULE_CARD_SCENE: PackedScene = preload("res://scenes/ui/pipeline/ModuleCard.tscn")

const LEVELS_PATH: String = "res://data/network_trace_b_levels.json"
const MAX_ATTEMPTS: int = 3
const DEFAULT_TIME_LIMIT_SEC: int = 120
const RUN_COOLDOWN_MS: int = 450
const ANSWER_COOLDOWN_MS: int = 200
const FAIL_STABILITY_DELTA: float = -10.0
const HINT_STABILITY_DELTA: float = -5.0
const PIPELINE_MISMATCH_DELTA: float = -5.0

const PALETTE_GREEN_ID: int = 0
const PALETTE_AMBER_ID: int = 1
const SLOT_TYPES: Array[String] = ["kilo", "bit", "time", "out"]
const DEFAULT_MODULE_POOL: Array = [
	{"module_id": "KILO_1024", "slot_type": "kilo", "display": "x1024", "k": 1024, "is_trap": false},
	{"module_id": "KILO_1000", "slot_type": "kilo", "display": "x1000", "k": 1000, "is_trap": true},
	{"module_id": "BIT_X8", "slot_type": "bit", "display": "x8", "k": 8, "is_trap": false},
	{"module_id": "BIT_X1", "slot_type": "bit", "display": "x1", "k": 1, "is_trap": true},
	{"module_id": "TIME_DIV", "slot_type": "time", "display": "/t", "k": -1, "is_trap": false},
	{"module_id": "TIME_SKIP", "slot_type": "time", "display": "/1", "k": 1, "is_trap": true},
	{"module_id": "OUT_BPS", "slot_type": "out", "display": "bps", "out_unit": "bps", "is_trap": false},
	{"module_id": "OUT_KBPS", "slot_type": "out", "display": "kbps", "out_unit": "kbps", "is_trap": true}
]

enum QuestState { INIT, PIPELINE_BUILD, PIPELINE_READY, CALC_DONE, ANSWERING, FEEDBACK_SUCCESS, FEEDBACK_FAIL, SAFE_MODE, DIAGNOSTIC, DONE }

@onready var btn_back: Button = $Main/V/Header/BtnBack
@onready var lbl_title: Label = $Main/V/Header/LblTitle
@onready var lbl_meta: Label = $Main/V/Header/LblMeta
@onready var stability_bar: ProgressBar = $Main/V/Header/StabilityBar
@onready var palette_select: OptionButton = $Main/V/Header/PaletteSelect
@onready var body: BoxContainer = $Main/V/Body
@onready var lbl_briefing: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblBriefing
@onready var lbl_prompt: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblPrompt
@onready var lbl_payload: Label = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox/LblPayload
@onready var lbl_window: Label = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox/LblWindow
@onready var lbl_target_unit: Label = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox/LblTargetUnit
@onready var btn_analyze: Button = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/BtnAnalyze
@onready var log_text: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll/LogText
@onready var slot_kilo: PipelineSlotControl = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotKilo
@onready var slot_bit: PipelineSlotControl = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotBit
@onready var slot_time: PipelineSlotControl = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotTime
@onready var slot_out: PipelineSlotControl = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard/SlotOut
@onready var module_tray: GridContainer = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/ModuleTrayScroll/ModuleTray
@onready var btn_run_calc: Button = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/BtnRunCalc
@onready var lbl_preview: Label = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/LblPreview
@onready var transfer_bar: ProgressBar = $Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/TransferBar
@onready var lbl_status: Label = $Main/V/Body/AnswersPane/AnswersMargin/AnswersV/LblStatus
@onready var btn_reset: Button = $Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow/BtnReset
@onready var btn_next: Button = $Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow/BtnNext
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

@onready var action_buttons: Array[Button] = [
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn1,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn2,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn3,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn4,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn5,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn6
]

var levels: Array[Dictionary] = []
var current_level: Dictionary = {}
var current_level_index: int = 0
var state: int = QuestState.INIT
var wrong_count: int = 0
var level_started_ms: int = 0
var first_action_ms: int = -1
var time_left_sec: float = float(DEFAULT_TIME_LIMIT_SEC)
var timer_running: bool = false
var run_calc_cooldown_until_ms: int = 0
var answer_cooldown_until_ms: int = 0
var spam_clicks: int = 0
var calc_done: bool = false
var calc_bps: int = -1
var calc_display_value: float = 0.0
var calc_display_unit: String = "bps"
var selected_option_id: String = ""
var last_error_code: String = ""
var safe_mode_used: bool = false
var hint_used: bool = false
var logs_expanded: bool = false
var level_finished: bool = false
var result_sent: bool = false
var pipeline_slots_filled_at_ms: int = -1
var module_moves_count: int = 0
var pipeline_mismatch: bool = false
var selected_tray_module: Dictionary = {}
var selected_module_card: PipelineModuleCard = null
var module_cards: Array[PipelineModuleCard] = []
var attempts: Array[Dictionary] = []
var task_session: Dictionary = {}
var variant_hash: String = ""

func _ready() -> void:
	_setup_runtime_controls()
	_connect_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_layout_mode()
	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not _load_levels():
		_show_boot_error("Данные Network Trace B отсутствуют или повреждены.")
		return
	_start_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible and not level_finished:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.ANSWERING
	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_meta_label()
			_on_timeout()
		else:
			_update_meta_label()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and is_node_ready():
		_apply_layout_mode()

func _setup_runtime_controls() -> void:
	lbl_title.text = "СЕТЕВОЙ СЛЕД | B"
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)
	slot_kilo.setup("kilo", "БАЗА KILO")
	slot_bit.setup("bit", "БАЙТ В БИТ")
	slot_time.setup("time", "ВРЕМЯ")
	slot_out.setup("out", "ЕДИНИЦА ВЫВОДА")
	transfer_bar.value = 0.0
	btn_next.visible = false
	diagnostics_panel.visible = false
	btn_run_calc.disabled = true

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_run_calc.pressed.connect(_on_run_calc_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	var slots: Array[PipelineSlotControl] = [slot_kilo, slot_bit, slot_time, slot_out]
	for slot in slots:
		slot.module_dropped.connect(_on_slot_module_dropped)
		slot.slot_tapped.connect(_on_slot_tapped)
		slot.clear_pressed.connect(_on_slot_clear_pressed)
		slot.bad_drop.connect(_on_slot_bad_drop)
	for idx in range(action_buttons.size()):
		action_buttons[idx].pressed.connect(_on_answer_pressed.bind(idx))

func _load_levels() -> bool:
	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		return false
	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		return false
	levels.clear()
	var raw_levels: Array = parsed
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
	return not levels.is_empty()

func _validate_level(level: Dictionary) -> bool:
	for key in ["id", "briefing", "prompt", "payload_value", "payload_unit", "time_sec", "ask_unit", "expected_bps", "options", "correct_id", "explain_short", "explain_full", "tags"]:
		if not level.has(key):
			return false
	var payload_unit: String = str(level.get("payload_unit", ""))
	if payload_unit != "KB" and payload_unit != "MB":
		return false
	var ask_unit: String = str(level.get("ask_unit", ""))
	if ask_unit != "bps" and ask_unit != "kbps":
		return false
	if int(level.get("payload_value", 0)) <= 0 or int(level.get("time_sec", 0)) <= 0:
		return false
	var options_var: Variant = level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY:
		return false
	var options: Array = options_var
	if options.size() != 6:
		return false
	var ids: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or ids.has(option_id):
			return false
		if not option.has("label") or not option.has("error_code"):
			return false
		ids[option_id] = true
	if not ids.has(str(level.get("correct_id", ""))):
		return false
	var modules_var: Variant = level.get("modules_pool", DEFAULT_MODULE_POOL)
	if typeof(modules_var) != TYPE_ARRAY:
		return false
	var modules: Array = modules_var
	var coverage: Dictionary = {"kilo": false, "bit": false, "time": false, "out": false}
	var module_ids: Dictionary = {}
	for module_var in modules:
		if typeof(module_var) != TYPE_DICTIONARY:
			return false
		var module_data: Dictionary = module_var
		if not module_data.has("module_id") or not module_data.has("slot_type") or not module_data.has("display"):
			return false
		var module_id: String = str(module_data.get("module_id", ""))
		if module_id.is_empty() or module_ids.has(module_id):
			return false
		module_ids[module_id] = true
		var slot_type: String = str(module_data.get("slot_type", ""))
		if not coverage.has(slot_type):
			return false
		coverage[slot_type] = true
		if slot_type == "out":
			var out_unit: String = str(module_data.get("out_unit", ""))
			if out_unit != "bps" and out_unit != "kbps":
				return false
		elif not module_data.has("k"):
			return false
	for slot_key in coverage.keys():
		if not bool(coverage[slot_key]):
			return false
	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))
	for btn in action_buttons:
		btn.disabled = true
	btn_analyze.disabled = true
	btn_run_calc.disabled = true
	btn_reset.disabled = true
	timer_running = false

func _start_level(index: int) -> void:
	if index >= levels.size():
		index = 0
	current_level_index = index
	current_level = levels[index].duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))
	wrong_count = 0
	safe_mode_used = false
	hint_used = false
	logs_expanded = false
	level_finished = false
	result_sent = false
	calc_done = false
	calc_bps = -1
	calc_display_value = 0.0
	calc_display_unit = "bps"
	selected_option_id = ""
	last_error_code = ""
	pipeline_slots_filled_at_ms = -1
	module_moves_count = 0
	pipeline_mismatch = false
	selected_tray_module.clear()
	_set_selected_module_card(null)
	attempts.clear()
	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	time_left_sec = float(int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC)))
	timer_running = true
	task_session = {"task_id": str(current_level.get("id", "NT_B_UNKNOWN")), "variant_hash": variant_hash, "started_at_ticks": level_started_ms, "ended_at_ticks": 0, "attempts": [], "events": []}
	btn_next.visible = false
	btn_analyze.text = "АНАЛИЗ"
	btn_analyze.disabled = false
	diagnostics_panel.visible = false
	_render_terminal_panel()
	_render_options()
	_build_module_tray()
	_reset_pipeline_state()
	lbl_status.text = "Соберите конвейер, запустите расчёт, затем выберите ответ."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.82, 0.82))
	state = QuestState.PIPELINE_BUILD
	_update_meta_label()
	_log_event("task_start", {"level": str(current_level.get("id", ""))})

func _render_terminal_panel() -> void:
	lbl_briefing.clear()
	lbl_briefing.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n%s" % str(current_level.get("briefing", "")))
	lbl_prompt.clear()
	lbl_prompt.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n%s" % str(current_level.get("prompt", "")))
	lbl_payload.text = "Данные: %s %s" % [str(current_level.get("payload_value", 0)), str(current_level.get("payload_unit", "KB"))]
	lbl_window.text = "Окно: %s с" % str(current_level.get("time_sec", 0))
	lbl_target_unit.text = "Целевая единица: %s" % str(current_level.get("ask_unit", "bps"))
	_render_log_text()

func _render_log_text() -> void:
	var lines: Array[String] = []
	var logs_var: Variant = current_level.get("logs", [])
	if typeof(logs_var) == TYPE_ARRAY:
		for line_var in logs_var:
			lines.append(str(line_var))
	if logs_expanded:
		var extra_var: Variant = current_level.get("analyze_lines", [])
		if typeof(extra_var) == TYPE_ARRAY:
			for line_var in extra_var:
				lines.append(str(line_var))
	var text: String = ""
	for line in lines:
		text += "- %s\n" % line
	log_text.text = text

func _render_options() -> void:
	var options_variant: Variant = current_level.get("options", [])
	if typeof(options_variant) != TYPE_ARRAY:
		return
	var options: Array = options_variant
	for idx in range(action_buttons.size()):
		var btn: Button = action_buttons[idx]
		var option: Dictionary = options[idx]
		btn.text = str(option.get("label", ""))
		btn.set_meta("option_id", str(option.get("id", "")))
		btn.set_meta("error_code", str(option.get("error_code", "")))
		btn.disabled = true

func _build_module_tray() -> void:
	for card in module_cards:
		if is_instance_valid(card):
			card.queue_free()
	module_cards.clear()
	var modules: Array[Dictionary] = _get_module_pool_for_level()
	for module_data in modules:
		var card_variant: Variant = MODULE_CARD_SCENE.instantiate()
		var card: PipelineModuleCard = card_variant as PipelineModuleCard
		if card == null:
			continue
		module_tray.add_child(card)
		card.setup(module_data)
		card.module_selected.connect(_on_module_card_selected)
		card.module_drag_started.connect(_on_module_drag_started)
		module_cards.append(card)

func _get_module_pool_for_level() -> Array[Dictionary]:
	var out: Array[Dictionary] = []
	var modules_var: Variant = current_level.get("modules_pool", null)
	if typeof(modules_var) == TYPE_ARRAY:
		var modules: Array = modules_var
		for module_var in modules:
			if typeof(module_var) == TYPE_DICTIONARY:
				var module_data: Dictionary = module_var
				out.append(module_data.duplicate(true))
	if out.is_empty():
		for module_var in DEFAULT_MODULE_POOL:
			var module_data: Dictionary = module_var
			out.append(module_data.duplicate(true))
	return out

func _reset_pipeline_state() -> void:
	slot_kilo.clear_module()
	slot_bit.clear_module()
	slot_time.clear_module()
	slot_out.clear_module()
	calc_done = false
	calc_bps = -1
	calc_display_value = 0.0
	calc_display_unit = "bps"
	selected_option_id = ""
	last_error_code = ""
	selected_tray_module.clear()
	_set_selected_module_card(null)
	lbl_preview.text = "СКОРОСТЬ = ???"
	transfer_bar.value = 0.0
	btn_run_calc.disabled = true
	_enable_answer_buttons(false)
	state = QuestState.PIPELINE_BUILD

func _on_module_card_selected(module_data: Dictionary, sender: Node) -> void:
	if level_finished:
		return
	_register_first_action()
	_play_audio("click")
	selected_tray_module = module_data.duplicate(true)
	_set_selected_module_card(sender as PipelineModuleCard)
	lbl_status.text = "Модуль выбран. Нажмите подходящий слот."
	lbl_status.add_theme_color_override("font_color", Color(0.84, 0.91, 1.0))
	_log_event("module_selected", {"module_id": str(module_data.get("module_id", ""))})

func _on_module_drag_started(module_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	selected_tray_module = module_data.duplicate(true)
	_set_selected_module_card(null)
	_log_event("module_drag_started", {"module_id": str(module_data.get("module_id", ""))})

func _on_slot_tapped(slot_type: String) -> void:
	if level_finished:
		return
	_register_first_action()
	if selected_tray_module.is_empty():
		lbl_status.text = "Сначала выберите модуль из лотка."
		lbl_status.add_theme_color_override("font_color", Color(0.95, 0.86, 0.68))
		return
	_place_module_into_slot(slot_type, selected_tray_module, "tap")

func _on_slot_module_dropped(slot_type: String, module_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	_place_module_into_slot(slot_type, module_data, "drag")

func _on_slot_bad_drop(slot_type: String, module_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	var slot: PipelineSlotControl = _get_slot(slot_type)
	if slot != null:
		slot.flash_bad_drop()
	_play_audio("error")
	last_error_code = "B_PIPELINE_BAD_DROP"
	lbl_status.text = "Неверный разъём для этого модуля."
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
	_log_event("pipeline_bad_drop", {"slot": slot_type, "module_id": str(module_data.get("module_id", ""))})

func _on_slot_clear_pressed(slot_type: String) -> void:
	if level_finished:
		return
	_register_first_action()
	var slot: PipelineSlotControl = _get_slot(slot_type)
	if slot == null or not slot.has_module():
		return
	var removed_id: String = slot.get_module_id()
	slot.clear_module()
	module_moves_count += 1
	_play_audio("click")
	if calc_done:
		calc_done = false
		calc_bps = -1
		lbl_preview.text = "СКОРОСТЬ = ???"
		_enable_answer_buttons(false)
	lbl_status.text = "Конвейер изменён. Запустите расчёт снова."
	lbl_status.add_theme_color_override("font_color", Color(0.92, 0.88, 0.62))
	_log_event("pipeline_clear", {"slot": slot_type, "module_id": removed_id})
	_update_pipeline_gate()

func _place_module_into_slot(slot_type: String, module_data: Dictionary, source: String) -> void:
	var target_slot: PipelineSlotControl = _get_slot(slot_type)
	if target_slot == null:
		return
	if str(module_data.get("slot_type", "")) != slot_type:
		target_slot.flash_bad_drop()
		_on_slot_bad_drop(slot_type, module_data)
		return
	target_slot.set_module(module_data)
	module_moves_count += 1
	selected_tray_module.clear()
	_set_selected_module_card(null)
	_play_audio("click")
	if calc_done:
		calc_done = false
		calc_bps = -1
		lbl_preview.text = "СКОРОСТЬ = ???"
		_enable_answer_buttons(false)
	lbl_status.text = "Модуль установлен. Продолжайте сборку."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.92, 0.86))
	_log_event("pipeline_set", {"slot": slot_type, "module_id": str(module_data.get("module_id", "")), "source": source})
	_update_pipeline_gate()

func _set_selected_module_card(card: PipelineModuleCard) -> void:
	selected_module_card = card
	for module_card in module_cards:
		if is_instance_valid(module_card):
			module_card.set_selected(module_card == selected_module_card)

func _get_slot(slot_type: String) -> PipelineSlotControl:
	match slot_type:
		"kilo":
			return slot_kilo
		"bit":
			return slot_bit
		"time":
			return slot_time
		"out":
			return slot_out
		_:
			return null

func _update_pipeline_gate() -> void:
	var ready: bool = _pipeline_ready()
	btn_run_calc.disabled = (not ready) or level_finished
	if ready and pipeline_slots_filled_at_ms < 0:
		pipeline_slots_filled_at_ms = Time.get_ticks_msec() - level_started_ms
		lbl_status.text = "КОНВЕЙЕР ЗАФИКСИРОВАН. Запустите расчёт."
		lbl_status.add_theme_color_override("font_color", Color(0.72, 0.95, 0.86))
		_log_event("pipeline_complete", {"t_ms": pipeline_slots_filled_at_ms})
	if not calc_done:
		state = QuestState.PIPELINE_READY if ready else QuestState.PIPELINE_BUILD

func _pipeline_ready() -> bool:
	return slot_kilo.has_module() and slot_bit.has_module() and slot_time.has_module() and slot_out.has_module()

func _on_run_calc_pressed() -> void:
	if level_finished:
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < run_calc_cooldown_until_ms:
		spam_clicks += 1
		_log_event("run_calc_spam", {})
		return
	if not _pipeline_ready():
		_record_pipeline_incomplete("run_calc_without_pipeline")
		lbl_status.text = ERROR_MAP.get_error_tip("B_PIPELINE_INCOMPLETE")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return
	run_calc_cooldown_until_ms = now_ms + RUN_COOLDOWN_MS
	_register_first_action()
	_play_audio("click")
	calc_bps = _calculate_bps_from_pipeline()
	calc_display_unit = _current_output_unit()
	calc_display_value = float(calc_bps) / 1000.0 if calc_display_unit == "kbps" else float(calc_bps)
	calc_done = true
	lbl_preview.text = "СКОРОСТЬ = %s" % _format_rate(calc_bps, calc_display_unit)
	lbl_status.text = "Расчёт завершён. Выберите финальный ответ."
	lbl_status.add_theme_color_override("font_color", Color(0.68, 0.95, 0.72))
	_enable_answer_buttons(true)
	state = QuestState.ANSWERING
	_log_event("run_calc", {"calc_bps": calc_bps, "display_unit": calc_display_unit, "display_value": calc_display_value, "pipeline_correct": _is_pipeline_correct(), "pipeline_error": _derive_pipeline_error_code()})

func _calculate_bps_from_pipeline() -> int:
	var payload_value: int = int(current_level.get("payload_value", 0))
	var payload_unit: String = str(current_level.get("payload_unit", "KB"))
	var kilo_base: int = int(slot_kilo.get_module().get("k", 1024))
	var bit_mult: int = int(slot_bit.get_module().get("k", 8))
	var use_time_division: bool = _time_division_enabled(slot_time.get_module())
	var time_sec: int = int(current_level.get("time_sec", 1))
	var bytes_total: int = payload_value * kilo_base
	if payload_unit == "MB":
		bytes_total *= kilo_base
	var bits_total: int = bytes_total * bit_mult
	var divisor: int = time_sec if use_time_division else 1
	if divisor <= 0:
		divisor = 1
	return int(round(float(bits_total) / float(divisor)))

func _time_division_enabled(time_module: Dictionary) -> bool:
	if str(time_module.get("module_id", "")) == "TIME_DIV":
		return true
	return int(time_module.get("k", 1)) < 0

func _current_output_unit() -> String:
	var out_unit: String = str(slot_out.get_module().get("out_unit", "bps"))
	return "kbps" if out_unit == "kbps" else "bps"

func _derive_pipeline_error_code() -> String:
	if not _pipeline_ready():
		return "B_PIPELINE_INCOMPLETE"
	if int(slot_bit.get_module().get("k", 8)) != 8:
		return "B_MATH_X8"
	if int(slot_kilo.get_module().get("k", 1024)) != 1024:
		return "B_MATH_1024"
	if not _time_division_enabled(slot_time.get_module()):
		return "B_MATH_DIV"
	if _current_output_unit() != str(current_level.get("ask_unit", "bps")):
		return "B_UNIT_TRAP"
	return ""

func _is_pipeline_correct() -> bool:
	return _derive_pipeline_error_code().is_empty()

func _on_answer_pressed(index: int) -> void:
	if level_finished or index < 0 or index >= action_buttons.size():
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < answer_cooldown_until_ms:
		spam_clicks += 1
		return
	answer_cooldown_until_ms = now_ms + ANSWER_COOLDOWN_MS
	_register_first_action()
	if state != QuestState.ANSWERING or not calc_done:
		_record_pipeline_incomplete("answer_before_calc")
		lbl_status.text = ERROR_MAP.get_error_tip("B_PIPELINE_INCOMPLETE")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.55, 0.45))
		return
	var btn: Button = action_buttons[index]
	selected_option_id = str(btn.get_meta("option_id", ""))
	if selected_option_id.is_empty():
		return
	_play_audio("click")
	_enable_answer_buttons(false)
	var answer_correct: bool = selected_option_id == str(current_level.get("correct_id", ""))
	var pipeline_correct: bool = _is_pipeline_correct()
	pipeline_mismatch = answer_correct and not pipeline_correct
	if answer_correct:
		last_error_code = "B_PIPELINE_MISMATCH" if pipeline_mismatch else ""
	else:
		last_error_code = str(btn.get_meta("error_code", "UNKNOWN"))
		if last_error_code.is_empty():
			last_error_code = _derive_pipeline_error_code()
	var attempt: Dictionary = {"option_id": selected_option_id, "error_code": last_error_code, "correct": answer_correct, "pipeline_correct": pipeline_correct, "pipeline_mismatch": pipeline_mismatch, "calc_bps": calc_bps, "t_ms": now_ms - level_started_ms}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("answer_selected", attempt)
	await _simulate_transfer(answer_correct)
	if answer_correct:
		_handle_success(pipeline_mismatch)
	else:
		_handle_failure(last_error_code)
	if not level_finished and (state == QuestState.ANSWERING or state == QuestState.SAFE_MODE):
		_enable_answer_buttons(true)

func _simulate_transfer(success: bool) -> void:
	transfer_bar.value = 0.0
	var expected_bps: int = int(current_level.get("expected_bps", 1))
	var target: float = 100.0
	if not success:
		var ratio: float = float(calc_bps) / maxf(1.0, float(expected_bps))
		target = clampf(ratio * 100.0, 40.0, 80.0)
	var tween: Tween = create_tween()
	tween.tween_property(transfer_bar, "value", target, 1.2)
	await tween.finished

func _handle_success(has_pipeline_mismatch: bool) -> void:
	state = QuestState.FEEDBACK_SUCCESS
	if has_pipeline_mismatch:
		lbl_status.text = "Ответ принят. Отмечено расхождение в конвейере."
		lbl_status.add_theme_color_override("font_color", Color(0.98, 0.82, 0.56))
	else:
		lbl_status.text = "ЗАГРУЗКА ЗАВЕРШЕНА. %s" % str(current_level.get("explain_short", ""))
		lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.45))
	_play_audio("relay")
	_finish_level(true, "success_with_mismatch" if has_pipeline_mismatch else "success")

func _handle_failure(error_code: String) -> void:
	state = QuestState.FEEDBACK_FAIL
	wrong_count += 1
	_play_audio("error")
	_trigger_glitch()
	lbl_status.text = "%s: %s" % [ERROR_MAP.get_error_title(error_code), ERROR_MAP.get_error_tip(error_code)]
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.4, 0.4))
	_update_meta_label()
	if wrong_count >= 2 and not safe_mode_used:
		safe_mode_used = true
		btn_analyze.text = "ДИАГНОСТИКА"
		lbl_status.text = "Безопасный режим разблокирован. Откройте диагностику."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.75, 0.45))
	if wrong_count >= MAX_ATTEMPTS:
		_show_diagnostics("attempt_limit")
		_finish_level(false, "attempt_limit")
	else:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.ANSWERING

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	_register_first_action()
	_play_audio("click")
	if safe_mode_used:
		if not hint_used:
			hint_used = true
		_show_diagnostics("manual")
		state = QuestState.DIAGNOSTIC
		return
	if logs_expanded:
		lbl_status.text = "Строки анализа уже раскрыты."
		lbl_status.add_theme_color_override("font_color", Color(0.9, 0.85, 0.65))
		return
	logs_expanded = true
	hint_used = true
	_render_log_text()
	lbl_status.text = "Дополнительная телеметрия разблокирована."
	lbl_status.add_theme_color_override("font_color", Color(0.72, 0.95, 0.86))
	_log_event("analyze_reveal", {})

func _show_diagnostics(reason: String) -> void:
	var lines: Array[String] = []
	lines.append("Дело: %s" % str(current_level.get("id", "")))
	lines.append("Причина: %s" % reason)
	lines.append("Конвейер собран к: %d мс" % pipeline_slots_filled_at_ms)
	lines.append("Перемещений модулей: %d" % module_moves_count)
	lines.append("Кило: %s" % slot_kilo.get_module_id())
	lines.append("Бит: %s" % slot_bit.get_module_id())
	lines.append("Время: %s" % slot_time.get_module_id())
	lines.append("Выход: %s" % slot_out.get_module_id())
	if calc_bps >= 0:
		lines.append("Рассчитано: %s" % _format_rate(calc_bps, calc_display_unit))
	lines.append("Ожидается: %d bps" % int(current_level.get("expected_bps", 0)))
	lines.append("Конвейер корректен: %s" % ("да" if _is_pipeline_correct() else "нет"))
	var pipeline_error: String = _derive_pipeline_error_code()
	if not pipeline_error.is_empty():
		lines.append("Ошибка конвейера: %s" % pipeline_error)
		lines.append(ERROR_MAP.get_error_tip(pipeline_error))
	if not last_error_code.is_empty():
		lines.append("Ошибка ответа: %s" % last_error_code)
		lines.append(ERROR_MAP.get_error_tip(last_error_code))
		for detail in ERROR_MAP.detail_messages(last_error_code):
			lines.append(detail)
	var explain_full: String = str(current_level.get("explain_full", ""))
	if not explain_full.is_empty():
		for explain_line_var in explain_full.split("\n"):
			var explain_line: String = explain_line_var.strip_edges()
			if not explain_line.is_empty():
				lines.append(explain_line)
	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true
	_log_event("diagnostics_open", {"reason": reason})

func _on_reset_pressed() -> void:
	if level_finished:
		return
	_register_first_action()
	_play_audio("click")
	_reset_pipeline_state()
	lbl_status.text = "Конвейер сброшен. Соберите и запустите снова."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.86, 0.96))
	_log_event("reset_pressed", {})

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", ""))})
	_start_level(current_level_index + 1)

func _on_back_pressed() -> void:
	_play_audio("click")
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	_apply_palette(palette_select.get_item_id(index))

func _apply_palette(palette_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(1.0, 0.69, 0.0, 1.0))
	else:
		theme = THEME_GREEN
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(0.0, 1.0, 0.25, 1.0))

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _play_audio(sound_name: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_name)

func _update_meta_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	var stability_value: float = 100.0
	if GlobalMetrics != null:
		stability_value = float(GlobalMetrics.stability)
	lbl_meta.text = "ДЕЛО %s | ОШ %d/%d | T-%02d:%02d" % [str(current_level.get("id", "--")), wrong_count, MAX_ATTEMPTS, total_seconds / 60, total_seconds % 60]
	stability_bar.value = stability_value

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_meta_label()

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _record_pipeline_incomplete(source: String) -> void:
	var attempt: Dictionary = {"option_id": "", "error_code": "B_PIPELINE_INCOMPLETE", "correct": false, "pipeline_correct": false, "pipeline_mismatch": false, "calc_bps": calc_bps, "t_ms": Time.get_ticks_msec() - level_started_ms, "source": source}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("pipeline_incomplete", {"source": source})

func _on_timeout() -> void:
	if level_finished:
		return
	last_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {"option_id": "TIMEOUT", "error_code": "TIMEOUT", "correct": false, "pipeline_correct": _is_pipeline_correct(), "pipeline_mismatch": false, "calc_bps": calc_bps, "t_ms": Time.get_ticks_msec() - level_started_ms}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_show_diagnostics("timeout")
	_finish_level(false, "timeout")

func _finish_level(is_correct: bool, reason: String) -> void:
	if result_sent:
		return
	result_sent = true
	level_finished = true
	timer_running = false
	state = QuestState.DONE
	btn_analyze.disabled = true
	btn_run_calc.disabled = true
	btn_reset.disabled = true
	_enable_answer_buttons(false)
	btn_next.visible = true
	for card in module_cards:
		if is_instance_valid(card):
			card.mouse_filter = Control.MOUSE_FILTER_IGNORE
	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {"is_correct": is_correct, "reason": reason})
	if not is_correct and reason != "timeout":
		lbl_status.text = str(current_level.get("explain_short", "Проверьте диагностику."))
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.62, 0.45))
	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = float(wrong_count) * FAIL_STABILITY_DELTA
	if not is_correct and wrong_count == 0:
		stability_delta += FAIL_STABILITY_DELTA
	if hint_used:
		stability_delta += HINT_STABILITY_DELTA
	if pipeline_mismatch:
		stability_delta += PIPELINE_MISMATCH_DELTA
	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": "B",
		"task_id": str(current_level.get("id", "")),
		"match_key": "NETTRACE_B|%s" % str(current_level.get("id", "")),
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"payload_value": int(current_level.get("payload_value", 0)),
		"payload_unit": str(current_level.get("payload_unit", "KB")),
		"time_sec": int(current_level.get("time_sec", 0)),
		"ask_unit": str(current_level.get("ask_unit", "bps")),
		"expected_bps": int(current_level.get("expected_bps", 0)),
		"pipeline_slots_filled_at_ms": pipeline_slots_filled_at_ms,
		"module_moves_count": module_moves_count,
		"pipeline_selected": {"kilo_module_id": slot_kilo.get_module_id(), "bit_module_id": slot_bit.get_module_id(), "time_module_id": slot_time.get_module_id(), "out_module_id": slot_out.get_module_id()},
		"pipeline_correct": _is_pipeline_correct(),
		"pipeline_mismatch": pipeline_mismatch,
		"calc_bps": calc_bps,
		"calc_display_value": calc_display_value,
		"calc_display_unit": calc_display_unit,
		"selected_option_id": selected_option_id,
		"error_code_last": last_error_code,
		"attempts": attempts,
		"attempts_count": attempts.size(),
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"safe_mode_used": safe_mode_used,
		"time_to_first_action_ms": first_action_ms,
		"spam_clicks": spam_clicks,
		"hint_used": hint_used,
		"timed_out": reason == "timeout",
		"stability_delta": stability_delta,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _enable_answer_buttons(enabled: bool) -> void:
	for btn in action_buttons:
		btn.disabled = not enabled or level_finished

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({"name": name, "t_ms": Time.get_ticks_msec() - level_started_ms, "payload": payload})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var option_ids: Array[String] = []
	var options_var: Variant = level.get("options", [])
	if typeof(options_var) == TYPE_ARRAY:
		var options: Array = options_var
		for option_var in options:
			var option: Dictionary = option_var
			option_ids.append(str(option.get("id", "")))
	option_ids.sort()
	return "%s|%s|%s|%s|%s|%s" % [str(level.get("id", "")), str(level.get("payload_value", 0)), str(level.get("payload_unit", "KB")), str(level.get("time_sec", 0)), str(level.get("ask_unit", "bps")), ",".join(option_ids)]

func _format_rate(value_bps: int, ask_unit: String) -> String:
	if ask_unit == "kbps":
		return "%.3f kbps" % (float(value_bps) / 1000.0)
	return "%d bps" % value_bps

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	body.vertical = viewport_size.x < viewport_size.y
	module_tray.columns = 2 if body.vertical else 4
</file>

<file path="scripts/quests/network_trace/NetworkTraceQuestC.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")
const BIT_CELL_SCENE: PackedScene = preload("res://scenes/ui/subnet/BitCell.tscn")

const LEVELS_PATH: String = "res://data/network_trace_c_levels.json"
const MAX_ATTEMPTS: int = 3
const DEFAULT_TIME_LIMIT_SEC: int = 120
const APPLY_COOLDOWN_MS: int = 400
const ANSWER_COOLDOWN_MS: int = 200
const FAIL_STABILITY_DELTA: float = -10.0
const HINT_STABILITY_DELTA: float = -5.0
const SPAM_STABILITY_DELTA: float = -2.0
const PALETTE_GREEN_ID: int = 0
const PALETTE_AMBER_ID: int = 1

enum QuestState { INIT, BOARD_LOCKED, MASK_PLACED, AND_APPLIED, ANSWERED, SAFE_MODE, DIAGNOSTIC, DONE }

@onready var btn_back: Button = $Main/V/Header/BtnBack
@onready var lbl_title: Label = $Main/V/Header/LblTitle
@onready var lbl_meta: Label = $Main/V/Header/LblMeta
@onready var palette_select: OptionButton = $Main/V/Header/PaletteSelect
@onready var body: BoxContainer = $Main/V/Body
@onready var lbl_briefing: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblBriefing
@onready var lbl_prompt: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LblPrompt
@onready var lbl_target_ip: Label = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox/LblTargetIp
@onready var lbl_target_cidr: Label = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox/LblTargetCidr
@onready var lbl_target_ask: Label = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox/LblTargetAsk
@onready var log_text: RichTextLabel = $Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll/LogText
@onready var lock_indicator: NetworkLockIndicator = $Main/V/Body/BoardPane/BoardMargin/BoardV/LockIndicator
@onready var row_ip: HBoxContainer = $Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowIpLine/RowIp
@onready var row_mask: HBoxContainer = $Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine/MaskDropTarget/RowMask
@onready var mask_drop_target: SubnetMaskDropTarget = $Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine/MaskDropTarget
@onready var row_res_line: HBoxContainer = $Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine
@onready var row_res: HBoxContainer = $Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine/RowRes
@onready var mask_overlay: SubnetMaskOverlay = $Main/V/Body/BoardPane/BoardMargin/BoardV/MaskTray/MaskOverlay
@onready var ruler: SubnetRulerControl = $Main/V/Body/BoardPane/BoardMargin/BoardV/Ruler
@onready var btn_analyze: Button = $Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions/BtnAnalyze
@onready var btn_apply_and: Button = $Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions/BtnApplyAnd
@onready var btn_reset: Button = $Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions/BtnReset
@onready var lbl_status: Label = $Main/V/Body/AnswersPane/AnswersMargin/AnswersV/LblStatus
@onready var btn_next: Button = $Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow/BtnNext
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

@onready var action_buttons: Array[Button] = [
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn1,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn2,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn3,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn4,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn5,
	$Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid/ActionBtn6
]

var row_ip_cells: Array[SubnetBitCell] = []
var row_mask_cells: Array[SubnetBitCell] = []
var row_res_cells: Array[SubnetBitCell] = []

var levels: Array[Dictionary] = []
var current_level: Dictionary = {}
var current_level_index: int = 0
var state: int = QuestState.INIT

var level_started_ms: int = 0
var first_action_ms: int = -1
var time_left_sec: float = float(DEFAULT_TIME_LIMIT_SEC)
var timer_running: bool = false

var wrong_count: int = 0
var level_finished: bool = false
var result_sent: bool = false
var safe_mode_used: bool = false
var hint_used: bool = false

var mask_placed: bool = false
var and_applied: bool = false
var and_result_last: int = -1
var pending_mask_data: Dictionary = {}

var mask_moves_count: int = 0
var apply_count: int = 0
var reset_count: int = 0
var analyze_count: int = 0
var not_applied_clicks: int = 0
var spam_clicks: int = 0

var apply_cooldown_until_ms: int = 0
var answer_cooldown_until_ms: int = 0

var selected_option_id: String = ""
var last_error_code: String = ""
var attempts: Array[Dictionary] = []
var task_session: Dictionary = {}
var variant_hash: String = ""

func _ready() -> void:
	_setup_runtime_controls()
	_connect_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_layout_mode()
	_build_bit_rows()

	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)

	if not _load_levels():
		_show_boot_error("Данные Network Trace C отсутствуют или повреждены.")
		return

	_start_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible and not level_finished:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.AND_APPLIED

	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_meta_label()
			_on_timeout()
		else:
			_update_meta_label()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and is_node_ready():
		_apply_layout_mode()

func _setup_runtime_controls() -> void:
	lbl_title.text = "СЕТЕВОЙ СЛЕД | C"
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)
	btn_next.visible = false
	btn_analyze.disabled = true
	btn_apply_and.disabled = true
	diagnostics_panel.visible = false

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_apply_and.pressed.connect(_on_apply_and_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_next.pressed.connect(_on_next_pressed)

	mask_overlay.mask_selected.connect(_on_mask_selected)
	mask_overlay.mask_drag_started.connect(_on_mask_drag_started)
	mask_drop_target.mask_dropped.connect(_on_mask_dropped)
	mask_drop_target.bad_drop.connect(_on_mask_bad_drop)
	mask_drop_target.target_tapped.connect(_on_mask_target_tapped)

	for idx in range(action_buttons.size()):
		action_buttons[idx].pressed.connect(_on_answer_pressed.bind(idx))

func _build_bit_rows() -> void:
	row_ip_cells = _create_row_cells(row_ip)
	row_mask_cells = _create_row_cells(row_mask)
	row_res_cells = _create_row_cells(row_res)

func _create_row_cells(container: HBoxContainer) -> Array[SubnetBitCell]:
	for child in container.get_children():
		child.queue_free()
	var out: Array[SubnetBitCell] = []
	for _i in range(8):
		var cell_variant: Variant = BIT_CELL_SCENE.instantiate()
		var cell: SubnetBitCell = cell_variant as SubnetBitCell
		if cell == null:
			continue
		container.add_child(cell)
		cell.set_empty()
		out.append(cell)
	return out

func _load_levels() -> bool:
	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		return false
	var parsed: Variant = JSON.parse_string(file.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		return false
	levels.clear()
	var raw_levels: Array = parsed
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
	return not levels.is_empty()

func _validate_level(level: Dictionary) -> bool:
	var required_keys: Array[String] = [
		"id", "briefing", "prompt", "target_ip", "cidr", "ip_last", "mask_last", "step", "expected_network_last", "options", "correct_id", "explain_short", "explain_full", "tags"
	]
	for key in required_keys:
		if not level.has(key):
			return false

	var cidr: int = int(level.get("cidr", 0))
	if cidr < 25 or cidr > 28:
		return false

	var ip_last: int = int(level.get("ip_last", -1))
	var mask_last: int = int(level.get("mask_last", -1))
	var step: int = int(level.get("step", 0))
	var expected_last: int = int(level.get("expected_network_last", -1))
	if ip_last < 0 or ip_last > 255:
		return false
	if mask_last < 0 or mask_last > 255:
		return false
	if expected_last < 0 or expected_last > 255:
		return false

	var mask_from_cidr: int = _mask_last_from_cidr(cidr)
	if mask_last != mask_from_cidr:
		return false
	var expected_step: int = 256 - mask_last
	if step != expected_step:
		return false
	if (ip_last & mask_last) != expected_last:
		return false

	var options_var: Variant = level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY:
		return false
	var options: Array = options_var
	if options.size() < 4 or options.size() > 6:
		return false

	var ids_seen: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		if not option.has("id") or not option.has("label") or not option.has("error_code"):
			return false
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or ids_seen.has(option_id):
			return false
		ids_seen[option_id] = true

	if not ids_seen.has(str(level.get("correct_id", ""))):
		return false

	if typeof(level.get("tags", [])) != TYPE_ARRAY:
		return false

	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.32, 0.32))
	btn_analyze.disabled = true
	btn_apply_and.disabled = true
	btn_reset.disabled = true
	_enable_answer_buttons(false)
	timer_running = false

func _start_level(index: int) -> void:
	if levels.is_empty():
		return
	if index >= levels.size():
		index = 0

	current_level_index = index
	current_level = levels[index].duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))

	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	time_left_sec = float(int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC)))
	timer_running = true

	wrong_count = 0
	level_finished = false
	result_sent = false
	safe_mode_used = false
	hint_used = false
	mask_placed = false
	and_applied = false
	and_result_last = -1
	pending_mask_data.clear()
	mask_moves_count = 0
	apply_count = 0
	reset_count = 0
	analyze_count = 0
	not_applied_clicks = 0
	spam_clicks = 0
	apply_cooldown_until_ms = 0
	answer_cooldown_until_ms = 0
	selected_option_id = ""
	last_error_code = ""
	attempts.clear()

	task_session = {
		"task_id": str(current_level.get("id", "NT_C_UNKNOWN")),
		"variant_hash": variant_hash,
		"started_at_ticks": level_started_ms,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	mask_overlay.setup(int(current_level.get("cidr", 26)), int(current_level.get("mask_last", 192)))
	mask_overlay.set_selected(false)
	mask_overlay.mouse_filter = Control.MOUSE_FILTER_STOP
	mask_drop_target.mouse_filter = Control.MOUSE_FILTER_STOP
	lock_indicator.set_locked()
	ruler.configure(int(current_level.get("step", 64)), int(current_level.get("ip_last", 0)))
	ruler.reset_state()
	row_res_line.visible = false

	_set_row_bits(row_ip_cells, int(current_level.get("ip_last", 0)))
	_clear_row(row_mask_cells)
	_clear_row(row_res_cells)

	btn_next.visible = false
	btn_analyze.disabled = true
	btn_analyze.text = "АНАЛИЗ"
	btn_apply_and.disabled = true
	diagnostics_panel.visible = false

	_render_terminal()
	_render_options()
	_enable_answer_buttons(false)

	state = QuestState.BOARD_LOCKED
	lbl_status.text = "Установите маску и нажмите ПРИМЕНИТЬ И."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.84, 0.82))
	_update_meta_label()
	_log_event("task_start", {"level": str(current_level.get("id", ""))})

func _render_terminal() -> void:
	lbl_briefing.clear()
	lbl_briefing.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n%s" % str(current_level.get("briefing", "")))
	lbl_prompt.clear()
	lbl_prompt.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n%s" % str(current_level.get("prompt", "")))
	lbl_target_ip.text = "IP: %s" % str(current_level.get("target_ip", "--"))
	lbl_target_cidr.text = "CIDR: /%d" % int(current_level.get("cidr", 0))
	lbl_target_ask.text = "ЗАПРОС: ID сети (последний октет)"

	var lines: Array[String] = []
	lines.append("ДОСТУП ЗАПРЕЩЁН: неверный сегмент")
	lines.append("Трасса узла: %s" % str(current_level.get("target_ip", "--")))
	lines.append("Профиль маски: /%d" % int(current_level.get("cidr", 0)))
	lines.append("Используйте побитовое AND, чтобы открыть сетевой замок")
	lines.append("Шаг сегмента: %d" % int(current_level.get("step", 0)))
	var expected_last: int = int(current_level.get("expected_network_last", 0))
	lines.append("Целевая сеть заканчивается на .%d" % (mini(255, expected_last + int(current_level.get("step", 0)) - 1)))

	var text_value: String = ""
	for line in lines:
		text_value += "- %s\n" % line
	log_text.text = text_value

func _render_options() -> void:
	var options_var: Variant = current_level.get("options", [])
	if typeof(options_var) != TYPE_ARRAY:
		return
	var options: Array = options_var
	for idx in range(action_buttons.size()):
		var btn: Button = action_buttons[idx]
		if idx < options.size():
			var option_var: Variant = options[idx]
			if typeof(option_var) != TYPE_DICTIONARY:
				btn.visible = false
				btn.disabled = true
				continue
			var option: Dictionary = option_var
			btn.visible = true
			btn.text = str(option.get("label", ""))
			btn.set_meta("option_id", str(option.get("id", "")))
			btn.set_meta("error_code", str(option.get("error_code", "")))
			btn.disabled = true
		else:
			btn.visible = false
			btn.disabled = true
			btn.text = ""
			btn.set_meta("option_id", "")
			btn.set_meta("error_code", "")

func _on_mask_selected(mask_data: Dictionary, sender: Node) -> void:
	if level_finished:
		return
	_register_first_action()
	pending_mask_data = mask_data.duplicate(true)
	mask_overlay.set_selected(sender == mask_overlay)
	_play_audio("click")
	lbl_status.text = "Маска выбрана. Нажмите строку маски или перетащите маску на неё."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.9, 1.0))
	_log_event("mask_selected", {"cidr": int(mask_data.get("cidr", 0))})

func _on_mask_drag_started(mask_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	pending_mask_data = mask_data.duplicate(true)
	mask_overlay.set_selected(false)
	_log_event("mask_drag_started", {"cidr": int(mask_data.get("cidr", 0))})

func _on_mask_target_tapped() -> void:
	if level_finished:
		return
	_register_first_action()
	if pending_mask_data.is_empty():
		lbl_status.text = "Сначала выберите маску."
		lbl_status.add_theme_color_override("font_color", Color(0.95, 0.84, 0.6))
		return
	_apply_mask_placement(pending_mask_data, "tap")

func _on_mask_dropped(mask_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	_apply_mask_placement(mask_data, "drag")

func _on_mask_bad_drop(_data: Dictionary) -> void:
	if level_finished:
		return
	_register_first_action()
	mask_drop_target.flash_bad_drop()
	last_error_code = "C_BAD_DROP"
	_play_audio("error")
	lbl_status.text = ERROR_MAP.get_error_tip("C_BAD_DROP")
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.56, 0.46))
	_log_event("mask_bad_drop", {})

func _apply_mask_placement(mask_data: Dictionary, source: String) -> void:
	var cidr_value: int = int(mask_data.get("cidr", -1))
	var mask_last_value: int = int(mask_data.get("mask_last", -1))
	if cidr_value != int(current_level.get("cidr", -2)) or mask_last_value != int(current_level.get("mask_last", -3)):
		_on_mask_bad_drop({})
		return

	mask_placed = true
	and_applied = false
	and_result_last = -1
	mask_moves_count += 1
	pending_mask_data.clear()
	mask_overlay.set_selected(false)
	_set_row_bits(row_mask_cells, mask_last_value)
	_clear_row(row_res_cells)
	row_res_line.visible = false
	ruler.reset_state()
	lock_indicator.set_ready()
	btn_apply_and.disabled = false
	_enable_answer_buttons(false)
	state = QuestState.MASK_PLACED
	_play_audio("click")
	lbl_status.text = "Маска установлена. Нажмите ПРИМЕНИТЬ И."
	lbl_status.add_theme_color_override("font_color", Color(0.72, 0.95, 0.86))
	_log_event("mask_placed", {"source": source, "mask_last": mask_last_value})

func _on_apply_and_pressed() -> void:
	if level_finished:
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < apply_cooldown_until_ms:
		spam_clicks += 1
		return
	apply_cooldown_until_ms = now_ms + APPLY_COOLDOWN_MS
	_register_first_action()
	if not mask_placed:
		last_error_code = "C_NOT_APPLIED"
		lbl_status.text = ERROR_MAP.get_error_tip("C_NOT_APPLIED")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.56, 0.46))
		return

	apply_count += 1
	_play_audio("click")
	await _play_and_animation()
	and_result_last = int(current_level.get("ip_last", 0)) & int(current_level.get("mask_last", 0))
	and_applied = true
	state = QuestState.AND_APPLIED
	row_res_line.visible = true
	ruler.configure(int(current_level.get("step", 64)), int(current_level.get("ip_last", 0)))
	ruler.set_result(and_result_last)
	ruler.pulse_marker(1000)
	lock_indicator.set_applied()
	_enable_answer_buttons(true)
	lbl_status.text = "Операция И выполнена. Выберите ID сети."
	lbl_status.add_theme_color_override("font_color", Color(0.66, 0.95, 0.74))
	_log_event("and_applied", {"result": and_result_last})

func _play_and_animation() -> void:
	var ip_bits: Array[int] = _byte_to_bits(int(current_level.get("ip_last", 0)))
	var mask_bits: Array[int] = _byte_to_bits(int(current_level.get("mask_last", 0)))
	for idx in range(mini(8, row_res_cells.size())):
		row_ip_cells[idx].pulse(Color(1.0, 1.0, 0.72, 1.0), 0.1)
		row_mask_cells[idx].pulse(Color(0.92, 0.95, 1.0, 1.0), 0.1)
		var result_bit: int = ip_bits[idx] & mask_bits[idx]
		row_res_cells[idx].set_bit(result_bit)
		row_res_cells[idx].pulse(Color(0.55, 1.0, 0.68, 1.0), 0.12)
		await get_tree().create_timer(0.035).timeout

func _on_answer_pressed(index: int) -> void:
	if level_finished or index < 0 or index >= action_buttons.size():
		return
	var now_ms: int = Time.get_ticks_msec()
	if now_ms < answer_cooldown_until_ms:
		spam_clicks += 1
		return
	answer_cooldown_until_ms = now_ms + ANSWER_COOLDOWN_MS

	if not and_applied:
		not_applied_clicks += 1
		last_error_code = "C_NOT_APPLIED"
		lbl_status.text = ERROR_MAP.get_error_tip("C_NOT_APPLIED")
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.56, 0.46))
		_log_event("answer_before_apply", {"count": not_applied_clicks})
		return

	_register_first_action()
	var btn: Button = action_buttons[index]
	selected_option_id = str(btn.get_meta("option_id", ""))
	if selected_option_id.is_empty():
		return

	_play_audio("click")
	var is_correct: bool = selected_option_id == str(current_level.get("correct_id", ""))
	var error_code: String = ""
	if not is_correct:
		error_code = str(btn.get_meta("error_code", ""))
		if error_code.is_empty():
			error_code = "UNKNOWN"
	last_error_code = error_code

	var attempt: Dictionary = {
		"option_id": selected_option_id,
		"error_code": error_code,
		"correct": is_correct,
		"t_ms": now_ms - level_started_ms
	}
	attempts.append(attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt)
	task_session["attempts"] = session_attempts
	_log_event("answer_selected", attempt)

	if is_correct:
		_handle_success()
	else:
		_handle_failure(error_code)

func _handle_success() -> void:
	state = QuestState.ANSWERED
	lock_indicator.set_open()
	lbl_status.text = "ЗАМОК ОТКРЫТ. %s" % str(current_level.get("explain_short", ""))
	lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.48))
	_play_audio("relay")
	_finish_level(true, "success")

func _handle_failure(error_code: String) -> void:
	wrong_count += 1
	state = QuestState.ANSWERED
	lock_indicator.set_error()
	_play_audio("error")
	_trigger_glitch()

	lbl_status.text = "%s: %s" % [ERROR_MAP.get_error_title(error_code), ERROR_MAP.get_error_tip(error_code)]
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.4, 0.4))
	_update_meta_label()
	_log_event("answer_fail", {"error_code": error_code, "wrong_count": wrong_count})

	if wrong_count >= 1:
		btn_analyze.disabled = false
	if wrong_count >= 2 and not safe_mode_used:
		safe_mode_used = true
		state = QuestState.SAFE_MODE
		btn_analyze.text = "ДИАГНОСТИКА"
		lbl_status.text = "Безопасный режим разблокирован. Откройте диагностику."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.74, 0.44))

	if wrong_count >= MAX_ATTEMPTS:
		_show_diagnostics("attempt_limit")
		_finish_level(false, "attempt_limit")
	else:
		state = QuestState.SAFE_MODE if safe_mode_used else QuestState.AND_APPLIED

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	if wrong_count < 1 and not safe_mode_used:
		lbl_status.text = "Анализ открывается после первой ошибки."
		lbl_status.add_theme_color_override("font_color", Color(0.92, 0.84, 0.58))
		return

	_register_first_action()
	analyze_count += 1
	hint_used = true
	_play_audio("click")
	_show_diagnostics("manual")
	state = QuestState.DIAGNOSTIC

func _show_diagnostics(reason: String) -> void:
	var ip_last: int = int(current_level.get("ip_last", 0))
	var mask_last: int = int(current_level.get("mask_last", 0))
	var and_value: int = ip_last & mask_last
	var step: int = int(current_level.get("step", 64))
	var network_last: int = ip_last - (ip_last % step)
	var range_end: int = mini(255, network_last + step - 1)

	var lines: Array[String] = []
	lines.append("Дело: %s" % str(current_level.get("id", "")))
	lines.append("Причина: %s" % reason)
	lines.append("Последний октет IP: %d (%s)" % [ip_last, _byte_to_binary(ip_last)])
	lines.append("Последний октет MASK: %d (%s)" % [mask_last, _byte_to_binary(mask_last)])
	lines.append("Результат AND: %d (%s)" % [and_value, _byte_to_binary(and_value)])
	lines.append("Шаг: %d" % step)
	lines.append("Сегмент: %d..%d" % [network_last, range_end])
	lines.append("Ожидаемая сеть: %d" % int(current_level.get("expected_network_last", 0)))
	if not last_error_code.is_empty():
		lines.append("Последняя ошибка: %s" % last_error_code)
		lines.append(ERROR_MAP.get_error_tip(last_error_code))
		for detail in ERROR_MAP.detail_messages(last_error_code):
			lines.append(detail)

	var explain_full: String = str(current_level.get("explain_full", ""))
	if not explain_full.is_empty():
		for line_var in explain_full.split("\n"):
			var line_text: String = line_var.strip_edges()
			if not line_text.is_empty():
				lines.append(line_text)

	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true
	_log_event("diagnostics_open", {"reason": reason})

func _on_reset_pressed() -> void:
	if level_finished:
		return
	_register_first_action()
	reset_count += 1
	mask_placed = false
	and_applied = false
	and_result_last = -1
	pending_mask_data.clear()
	mask_overlay.set_selected(false)
	_clear_row(row_mask_cells)
	_clear_row(row_res_cells)
	row_res_line.visible = false
	btn_apply_and.disabled = true
	_enable_answer_buttons(false)
	lock_indicator.set_locked()
	ruler.reset_state()
	diagnostics_panel.visible = false
	state = QuestState.BOARD_LOCKED
	_play_audio("click")
	lbl_status.text = "Поле сброшено. Установите маску и примените И."
	lbl_status.add_theme_color_override("font_color", Color(0.82, 0.86, 0.95))
	_log_event("reset_pressed", {})

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", ""))})
	_start_level(current_level_index + 1)

func _on_back_pressed() -> void:
	_play_audio("click")
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	_apply_palette(palette_select.get_item_id(index))

func _apply_palette(palette_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(1.0, 0.7, 0.08, 1.0))
		if has_node("CanvasModulate"):
			var tint_amber: CanvasModulate = $CanvasModulate
			tint_amber.color = Color(1.0, 0.95, 0.9, 1.0)
	else:
		theme = THEME_GREEN
		if shader_material != null:
			shader_material.set_shader_parameter("tint_color", Color(0.0, 1.0, 0.25, 1.0))
		if has_node("CanvasModulate"):
			var tint_green: CanvasModulate = $CanvasModulate
			tint_green.color = Color(0.9, 1.0, 0.94, 1.0)

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _play_audio(sound_name: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_name)

func _update_meta_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	lbl_meta.text = "ДЕЛО %s | ОШ %d/%d | T-%02d:%02d" % [
		str(current_level.get("id", "--")),
		wrong_count,
		MAX_ATTEMPTS,
		total_seconds / 60,
		total_seconds % 60
	]

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_meta_label()

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _on_timeout() -> void:
	if level_finished:
		return
	last_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {
		"option_id": "TIMEOUT",
		"error_code": "TIMEOUT",
		"correct": false,
		"t_ms": Time.get_ticks_msec() - level_started_ms
	}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_show_diagnostics("timeout")
	_finish_level(false, "timeout")

func _finish_level(is_correct: bool, reason: String) -> void:
	if result_sent:
		return
	result_sent = true
	level_finished = true
	timer_running = false
	state = QuestState.DONE

	btn_analyze.disabled = true
	btn_apply_and.disabled = true
	btn_reset.disabled = true
	_enable_answer_buttons(false)
	btn_next.visible = true
	mask_overlay.mouse_filter = Control.MOUSE_FILTER_IGNORE
	mask_drop_target.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	if not is_correct and reason != "timeout":
		lbl_status.text = str(current_level.get("explain_short", "Проверьте диагностику."))
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.62, 0.45))

	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = float(wrong_count) * FAIL_STABILITY_DELTA
	if not is_correct and wrong_count == 0:
		stability_delta += FAIL_STABILITY_DELTA
	if hint_used:
		stability_delta += HINT_STABILITY_DELTA
	if spam_clicks >= 4:
		stability_delta += SPAM_STABILITY_DELTA

	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": "C",
		"task_id": str(current_level.get("id", "")),
		"match_key": "NETTRACE_C|%s" % str(current_level.get("id", "")),
		"variant_hash": variant_hash,
		"target_ip": str(current_level.get("target_ip", "")),
		"cidr": int(current_level.get("cidr", 0)),
		"ip_last": int(current_level.get("ip_last", 0)),
		"mask_last": int(current_level.get("mask_last", 0)),
		"step": int(current_level.get("step", 0)),
		"expected_network_last": int(current_level.get("expected_network_last", 0)),
		"mask_placed": mask_placed,
		"and_applied": and_applied,
		"and_result_last": and_result_last,
		"board_actions": {
			"mask_moves_count": mask_moves_count,
			"apply_count": apply_count,
			"reset_count": reset_count,
			"analyze_count": analyze_count,
			"not_applied_clicks": not_applied_clicks
		},
		"attempts": attempts,
		"selected_option_id": selected_option_id,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"error_code_last": "" if is_correct else last_error_code,
		"attempts_count": attempts.size(),
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"safe_mode_used": safe_mode_used,
		"time_to_first_action_ms": first_action_ms,
		"hint_used": hint_used,
		"timed_out": reason == "timeout",
		"spam_clicks": spam_clicks,
		"stability_delta": stability_delta,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _enable_answer_buttons(enabled: bool) -> void:
	for btn in action_buttons:
		if btn.visible:
			btn.disabled = not enabled or level_finished

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": Time.get_ticks_msec() - level_started_ms,
		"payload": payload
	})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var ids: Array[String] = []
	var options_var: Variant = level.get("options", [])
	if typeof(options_var) == TYPE_ARRAY:
		var options: Array = options_var
		for option_var in options:
			if typeof(option_var) != TYPE_DICTIONARY:
				continue
			var option: Dictionary = option_var
			ids.append(str(option.get("id", "")))
	ids.sort()
	return "%s|%s|%s|%s|%s|%s" % [
		str(level.get("id", "")),
		str(level.get("target_ip", "")),
		str(level.get("cidr", 0)),
		str(level.get("ip_last", 0)),
		str(level.get("mask_last", 0)),
		",".join(ids)
	]

func _mask_last_from_cidr(cidr: int) -> int:
	var host_bits: int = 32 - cidr
	if host_bits < 0 or host_bits > 8:
		return -1
	var value: int = 256 - int(pow(2.0, float(host_bits)))
	return clampi(value, 0, 255)

func _set_row_bits(cells: Array[SubnetBitCell], octet_value: int) -> void:
	var bits: Array[int] = _byte_to_bits(octet_value)
	for idx in range(mini(cells.size(), bits.size())):
		cells[idx].set_bit(bits[idx])

func _clear_row(cells: Array[SubnetBitCell]) -> void:
	for cell in cells:
		cell.set_empty()

func _byte_to_bits(value: int) -> Array[int]:
	var safe_value: int = clampi(value, 0, 255)
	var bits: Array[int] = []
	for shift in range(7, -1, -1):
		bits.append((safe_value >> shift) & 1)
	return bits

func _byte_to_binary(value: int) -> String:
	var bits: Array[int] = _byte_to_bits(value)
	var parts: PackedStringArray = PackedStringArray()
	for bit in bits:
		parts.append(str(bit))
	return "".join(parts)

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	body.vertical = viewport_size.x < viewport_size.y
</file>

<file path="scripts/ui/ConnectorOverlay.gd">
extends Control

const ANCHOR_CENTER := "center"
const ANCHOR_EDGE := "edge"
const ORIENTATION_AUTO := "auto"
const ORIENTATION_HORIZONTAL := "horizontal"
const ORIENTATION_VERTICAL := "vertical"

var _links: Array = []
var _anchor_root: Control
var _watched_controls: Array = []
var _anchor_mode: String = ANCHOR_CENTER
var _orientation: String = ORIENTATION_AUTO

@export var line_color: Color = Color(0.88, 0.64, 0.16, 0.9)
@export var line_width: float = 3.0
@export var arrow_size: float = 10.0

func _ready() -> void:
	mouse_filter = Control.MOUSE_FILTER_IGNORE
	set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)

func set_anchor_mode(anchor_mode: String, orientation: String = ORIENTATION_AUTO) -> void:
	_anchor_mode = anchor_mode.to_lower()
	_orientation = orientation.to_lower()
	queue_redraw()

func set_endpoints(from_control: Control, to_control: Control, anchor_root: Control) -> void:
	set_links([{"from": from_control, "to": to_control}], anchor_root, _anchor_mode, _orientation)

func set_links(links: Array, anchor_root: Control, anchor_mode: String = ANCHOR_CENTER, orientation: String = ORIENTATION_AUTO) -> void:
	_disconnect_signals()
	_links.clear()
	_anchor_root = anchor_root
	_anchor_mode = anchor_mode.to_lower()
	_orientation = orientation.to_lower()
	for link_v in links:
		if typeof(link_v) != TYPE_DICTIONARY:
			continue
		var link: Dictionary = link_v as Dictionary
		var from_control: Control = link.get("from", null) as Control
		var to_control: Control = link.get("to", null) as Control
		if is_instance_valid(from_control) and is_instance_valid(to_control):
			_links.append({"from": from_control, "to": to_control})
			_connect_signal_safe(from_control)
			_connect_signal_safe(to_control)
	if is_instance_valid(_anchor_root):
		_connect_signal_safe(_anchor_root)
	queue_redraw()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED or what == NOTIFICATION_TRANSFORM_CHANGED or what == NOTIFICATION_VISIBILITY_CHANGED:
		queue_redraw()

func _draw() -> void:
	for link_v in _links:
		if typeof(link_v) != TYPE_DICTIONARY:
			continue
		var link: Dictionary = link_v as Dictionary
		var from_control: Control = link.get("from", null) as Control
		var to_control: Control = link.get("to", null) as Control
		if not _can_draw_connector(from_control, to_control):
			continue
		var points: Dictionary = _resolve_points(from_control.get_global_rect(), to_control.get_global_rect())
		var from_global: Vector2 = points.get("from", Vector2.ZERO)
		var to_global: Vector2 = points.get("to", Vector2.ZERO)
		var from_point: Vector2 = _global_to_local(from_global)
		var to_point: Vector2 = _global_to_local(to_global)
		draw_line(from_point, to_point, line_color, line_width, true)
		_draw_arrow(from_point, to_point)

func _resolve_points(from_rect: Rect2, to_rect: Rect2) -> Dictionary:
	if _anchor_mode != ANCHOR_EDGE:
		return {
			"from": from_rect.get_center(),
			"to": to_rect.get_center()
		}
	var orientation: String = _resolved_orientation(from_rect, to_rect)
	if orientation == ORIENTATION_VERTICAL:
		return {
			"from": Vector2(from_rect.get_center().x, from_rect.end.y),
			"to": Vector2(to_rect.get_center().x, to_rect.position.y)
		}
	return {
		"from": Vector2(from_rect.end.x, from_rect.get_center().y),
		"to": Vector2(to_rect.position.x, to_rect.get_center().y)
	}

func _resolved_orientation(from_rect: Rect2, to_rect: Rect2) -> String:
	if _orientation == ORIENTATION_HORIZONTAL or _orientation == ORIENTATION_VERTICAL:
		return _orientation
	var delta: Vector2 = to_rect.get_center() - from_rect.get_center()
	return ORIENTATION_HORIZONTAL if absf(delta.x) >= absf(delta.y) else ORIENTATION_VERTICAL

func _draw_arrow(from_point: Vector2, to_point: Vector2) -> void:
	var direction: Vector2 = (to_point - from_point).normalized()
	if direction.length() <= 0.0:
		return
	var normal: Vector2 = Vector2(-direction.y, direction.x)
	var tip: Vector2 = to_point
	var base: Vector2 = tip - direction * arrow_size
	var left: Vector2 = base + normal * (arrow_size * 0.45)
	var right: Vector2 = base - normal * (arrow_size * 0.45)
	draw_line(tip, left, line_color, line_width, true)
	draw_line(tip, right, line_color, line_width, true)

func _global_to_local(point: Vector2) -> Vector2:
	return get_global_transform_with_canvas().affine_inverse() * point

func _can_draw_connector(from_control: Control, to_control: Control) -> bool:
	return is_instance_valid(from_control) and is_instance_valid(to_control) and from_control.visible and to_control.visible

func _connect_signal_safe(node: Control) -> void:
	if not is_instance_valid(node):
		return
	if not _watched_controls.has(node):
		_watched_controls.append(node)
	if not node.resized.is_connected(_on_endpoint_changed):
		node.resized.connect(_on_endpoint_changed)
	if not node.visibility_changed.is_connected(_on_endpoint_changed):
		node.visibility_changed.connect(_on_endpoint_changed)

func _disconnect_signals() -> void:
	for node_v in _watched_controls:
		var node: Control = node_v as Control
		_disconnect_signal_safe(node)
	_watched_controls.clear()

func _disconnect_signal_safe(node: Control) -> void:
	if not is_instance_valid(node):
		return
	if node.resized.is_connected(_on_endpoint_changed):
		node.resized.disconnect(_on_endpoint_changed)
	if node.visibility_changed.is_connected(_on_endpoint_changed):
		node.visibility_changed.disconnect(_on_endpoint_changed)

func _on_endpoint_changed() -> void:
	queue_redraw()
</file>

<file path="scripts/ui/DiagnosticsPanelB.gd">
extends PanelContainer

@onready var trace_label = $VBoxContainer/TraceList
@onready var explain_label = $VBoxContainer/ExplainList
@onready var btn_close = $VBoxContainer/BtnClose

func _ready():
	btn_close.pressed.connect(_on_close_pressed)

func setup(explain_lines: Array, trace_steps: Array):
	# Explain
	var txt = "[b]АНАЛИЗ:[/b]\n"
	for line in explain_lines:
		txt += "- " + str(line) + "\n"
	explain_label.text = txt

	# Trace
	var trace_txt = ""
	if trace_steps.is_empty():
		trace_txt = "Трассировка недоступна."
	else:
		for step in trace_steps:
			# Trace format: i=1 | s: 0 -> 1
			trace_txt += "i=%s | s: %s -> %s\n" % [
				str(step.get("i", "?")),
				str(step.get("s_before", "?")),
				str(step.get("s_after", "?"))
			]
	trace_label.text = trace_txt

func _on_close_pressed():
	visible = false
</file>

<file path="scripts/ui/DiagnosticsPanelC.gd">
extends PanelContainer

@onready var lbl_title: Label = $Root/LblTitle
@onready var text_body: RichTextLabel = $Root/Body
@onready var btn_close: Button = $Root/BtnClose

func _ready() -> void:
	btn_close.pressed.connect(_on_close_pressed)

func setup(title: String, lines: Array) -> void:
	lbl_title.text = title
	var out := ""
	for line_var in lines:
		out += "- %s\n" % str(line_var)
	text_body.text = out

func _on_close_pressed() -> void:
	visible = false
</file>

<file path="scripts/ui/InspectorPopup.gd">
extends PopupPanel

@onready var lbl_title: Label = $Root/LblTitle
@onready var lbl_selector: Label = $Root/Info/LblSelectorValue
@onready var lbl_kind: Label = $Root/Info/LblKindValue
@onready var lbl_weight: Label = $Root/Info/LblWeightValue
@onready var lbl_important: Label = $Root/Info/LblImportantValue
@onready var lbl_order: Label = $Root/Info/LblOrderValue
@onready var lbl_color: Label = $Root/Info/LblColorValue
@onready var btn_close: Button = $Root/BtnClose

func _ready() -> void:
	btn_close.pressed.connect(_on_close_pressed)

func show_inspection(source_data: Dictionary) -> void:
	var source_id: String = str(source_data.get("source_id", "UNKNOWN"))
	var selector: String = str(source_data.get("selector", "-"))
	var kind: String = str(source_data.get("kind", "-"))
	var weight: int = int(source_data.get("weight", 0))
	var important: bool = bool(source_data.get("important", false))
	var order: int = int(source_data.get("order", 0))
	var color_value: String = str(source_data.get("color", "")).strip_edges()

	lbl_title.text = "ПРОСМОТР | %s" % source_id
	lbl_selector.text = selector
	lbl_kind.text = kind
	lbl_weight.text = str(weight)
	lbl_important.text = "ДА" if important else "НЕТ"
	lbl_order.text = str(order)
	lbl_color.text = color_value if not color_value.is_empty() else "-"

	if not color_value.is_empty():
		lbl_color.modulate = Color.from_string(color_value, Color(1, 1, 1, 1))
	else:
		lbl_color.modulate = Color(1, 1, 1, 1)

	popup_centered_ratio(0.42)

func _on_close_pressed() -> void:
	hide()
</file>

<file path="scripts/ui/NetItem.gd">
extends Button

signal drag_started(option_id: String, source: String, from_slot: int)

var option_id: String = ""
var option_label: String = ""
var source: String = "PALETTE"
var from_slot: int = -1

var _locked: bool = false
var _feedback_state: String = "neutral"

func setup(option_data: Dictionary) -> void:
	option_id = str(option_data.get("option_id", "")).strip_edges()
	option_label = str(option_data.get("label", option_id))
	text = option_label
	tooltip_text = "Модуль: %s\n%s" % [option_label, str(option_data.get("why", ""))]
	custom_minimum_size = Vector2(0, 88)
	set_source("PALETTE", -1)
	set_feedback_state("neutral")
	set_locked(false)

func set_source(p_source: String, p_from_slot: int) -> void:
	source = p_source
	from_slot = p_from_slot

func set_locked(locked: bool) -> void:
	_locked = locked
	disabled = locked
	_apply_visual_state()

func set_feedback_state(state: String) -> void:
	_feedback_state = state
	_apply_visual_state()

func _get_drag_data(_at_position: Vector2) -> Variant:
	if _locked or option_id == "":
		return null

	drag_started.emit(option_id, source, from_slot)

	var preview: Button = duplicate() as Button
	preview.disabled = true
	preview.modulate.a = 0.9
	var holder: Control = Control.new()
	holder.add_child(preview)
	preview.position = -0.5 * preview.size
	set_drag_preview(holder)

	return {
		"kind": "NET_ITEM",
		"option_id": option_id,
		"source": source,
		"from_slot": from_slot,
		"node_path": str(get_path())
	}

func _apply_visual_state() -> void:
	var tone: Color = Color(1.0, 1.0, 1.0, 1.0)
	match _feedback_state:
		"correct":
			tone = Color(1.05, 1.05, 1.05, 1.0)
		"wrong":
			tone = Color(1.12, 0.84, 0.86, 1.0)
		"missing":
			tone = Color(1.08, 0.98, 0.9, 1.0)
		_:
			tone = Color(1.0, 1.0, 1.0, 1.0)

	if _locked and _feedback_state == "neutral":
		tone = Color(0.82, 0.82, 0.82, 1.0)

	self_modulate = tone
</file>

<file path="scripts/ui/NetSlot.gd">
extends PanelContainer

signal slot_changed(slot_index: int, option_id: String, prev_option_id: String)
signal slot_cleared(slot_index: int, prev_option_id: String)

@export var slot_index: int = 1
@export var title_path: NodePath = NodePath("Margin/VBox/TopRow/SlotTitle")
@export var item_label_path: NodePath = NodePath("Margin/VBox/ItemLabel")
@export var item_holder_path: NodePath = NodePath("Margin/VBox/ItemHolder")
@export var clear_button_path: NodePath = NodePath("Margin/VBox/TopRow/BtnClear")

var current_option_id: String = ""

var _locked: bool = false
var _drag_hovered: bool = false
var _feedback_state: String = "neutral"

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _item_label: Label = get_node_or_null(item_label_path) as Label
@onready var _item_holder: Control = get_node_or_null(item_holder_path) as Control
@onready var _btn_clear: Button = get_node_or_null(clear_button_path) as Button

func _ready() -> void:
	if is_instance_valid(_btn_clear):
		_btn_clear.pressed.connect(_on_clear_pressed)

	mouse_exited.connect(func() -> void:
		_drag_hovered = false
		_apply_visual_state()
	)

	set_slot_title(slot_index)
	set_current_option("", "")
	set_locked(false)
	_apply_visual_state()

func set_slot_title(index: int) -> void:
	slot_index = index
	if is_instance_valid(_title_label):
		_title_label.text = "КАНАЛ %d" % slot_index

func set_locked(locked: bool) -> void:
	_locked = locked
	_update_clear_button_state()
	_apply_visual_state()

func set_feedback_state(state: String) -> void:
	_feedback_state = state
	_apply_visual_state()

func set_current_option(option_id: String, option_label: String = "") -> void:
	current_option_id = option_id
	if is_instance_valid(_item_label):
		if current_option_id == "":
			_item_label.text = "<пусто>"
		elif option_label != "":
			_item_label.text = option_label
		else:
			_item_label.text = current_option_id
	_update_clear_button_state()
	_apply_visual_state()

func attach_item_control(item_control: Control) -> void:
	if not is_instance_valid(_item_holder):
		return
	if item_control.get_parent() != _item_holder:
		item_control.reparent(_item_holder)
	item_control.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	item_control.size_flags_vertical = Control.SIZE_EXPAND_FILL
	item_control.custom_minimum_size = Vector2(0, 80)
	if is_instance_valid(_item_label):
		_item_label.text = ""
	_pulse()
	_update_clear_button_state()

func clear_item_holder() -> void:
	if not is_instance_valid(_item_holder):
		return
	for child in _item_holder.get_children():
		_item_holder.remove_child(child)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if _locked:
		return false
	if typeof(data) != TYPE_DICTIONARY:
		return false

	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "NET_ITEM":
		return false

	var controller: Node = _get_controller()
	if controller != null and bool(controller.call("is_input_locked")):
		return false

	_drag_hovered = true
	_apply_visual_state()
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	_drag_hovered = false
	_apply_visual_state()
	if typeof(data) != TYPE_DICTIONARY:
		return

	var payload: Dictionary = data as Dictionary
	var controller: Node = _get_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_drop_to_slot", slot_index, payload)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		_flash_reject()
		return

	var new_option_id: String = str(result.get("option_id", ""))
	var prev_option_id: String = str(result.get("prev_option_id", ""))
	var label: String = str(result.get("label", new_option_id))
	set_current_option(new_option_id, label)
	slot_changed.emit(slot_index, new_option_id, prev_option_id)

func _on_clear_pressed() -> void:
	if _locked:
		return
	var controller: Node = _get_controller()
	if controller == null:
		return

	var result_variant: Variant = controller.call("handle_clear_slot", slot_index)
	if typeof(result_variant) != TYPE_DICTIONARY:
		return
	var result: Dictionary = result_variant as Dictionary
	if not bool(result.get("success", false)):
		return

	var prev_option_id: String = str(result.get("prev_option_id", ""))
	set_current_option("", "")
	slot_cleared.emit(slot_index, prev_option_id)

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		_drag_hovered = false
		_apply_visual_state()

func _get_controller() -> Node:
	return get_tree().get_first_node_in_group("resus_c_controller")

func _update_clear_button_state() -> void:
	if not is_instance_valid(_btn_clear):
		return
	_btn_clear.disabled = _locked or current_option_id == ""

func _apply_visual_state() -> void:
	var tone: Color = Color(1.0, 1.0, 1.0, 1.0)
	match _feedback_state:
		"correct":
			tone = Color(1.05, 1.05, 1.05, 1.0)
		"wrong":
			tone = Color(1.12, 0.84, 0.86, 1.0)
		"missing":
			tone = Color(1.08, 0.98, 0.9, 1.0)
		_:
			tone = Color(1.0, 1.0, 1.0, 1.0)

	if _drag_hovered:
		tone = Color(tone.r * 1.05, tone.g * 1.05, tone.b * 1.05, tone.a)

	if _locked and _feedback_state == "neutral":
		tone = Color(0.85, 0.85, 0.85, 1.0)

	self_modulate = tone

func _pulse() -> void:
	var tween: Tween = create_tween()
	scale = Vector2(1.02, 1.02)
	tween.tween_property(self, "scale", Vector2.ONE, 0.1)

func _flash_reject() -> void:
	self_modulate = Color(1.12, 0.84, 0.86, 1.0)
	var tween: Tween = create_tween()
	tween.tween_property(self, "self_modulate", Color(1.0, 1.0, 1.0, 1.0), 0.12)
</file>

<file path="scripts/ui/network_trace/topology_board_a.gd">
extends Control
class_name NetworkTraceTopologyBoardA

signal device_installed(device_id: String, label_text: String, error_code: String)
signal device_removed
signal trace_animation_finished(success: bool)

const SLOT_NODE_NAME := "?"

var node_names: Array[String] = []
var edge_pairs: Array = []
var node_labels: Dictionary = {}
var node_positions: Dictionary = {}

var slot_size: Vector2 = Vector2(170.0, 90.0)
var tools_locked: bool = true

var installed_device_id: String = ""
var installed_device_label: String = ""
var installed_error_code: String = ""

var packet_visible: bool = false
var packet_progress: float = 0.0
var packet_path: Array[Vector2] = []
var trace_success: bool = true
var trace_tween: Tween = null

func _ready() -> void:
	mouse_filter = MOUSE_FILTER_STOP
	_recalculate_layout()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		_recalculate_layout()
		queue_redraw()

func setup_topology(data: Dictionary) -> void:
	node_names.clear()
	edge_pairs.clear()
	node_labels.clear()
	node_positions.clear()

	var nodes_variant: Variant = data.get("nodes", [])
	if typeof(nodes_variant) == TYPE_ARRAY:
		var nodes_array: Array = nodes_variant
		for node_var in nodes_array:
			node_names.append(str(node_var))

	var edges_variant: Variant = data.get("edges", [])
	if typeof(edges_variant) == TYPE_ARRAY:
		var edges_array: Array = edges_variant
		for edge_var in edges_array:
			if typeof(edge_var) != TYPE_ARRAY:
				continue
			var edge_array: Array = edge_var
			if edge_array.size() < 2:
				continue
			edge_pairs.append([str(edge_array[0]), str(edge_array[1])])

	var labels_variant: Variant = data.get("labels", {})
	if typeof(labels_variant) == TYPE_DICTIONARY:
		node_labels = (labels_variant as Dictionary).duplicate(true)

	if node_names.is_empty():
		node_names = ["SRC", SLOT_NODE_NAME, "DST"]
		edge_pairs = [["SRC", SLOT_NODE_NAME], [SLOT_NODE_NAME, "DST"]]

	_recalculate_layout()
	clear_installed_device()
	queue_redraw()

func set_tools_locked(locked: bool) -> void:
	tools_locked = locked

func has_device_installed() -> bool:
	return not installed_device_id.is_empty()

func get_installed_device_id() -> String:
	return installed_device_id

func get_installed_error_code() -> String:
	return installed_error_code

func clear_installed_device() -> void:
	var had_device: bool = has_device_installed()
	installed_device_id = ""
	installed_device_label = ""
	installed_error_code = ""
	packet_visible = false
	packet_progress = 0.0
	queue_redraw()
	if had_device:
		device_removed.emit()

func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if tools_locked:
		return false
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var drag_data: Dictionary = data
	if str(drag_data.get("type", "")) != "network_trace_device":
		return false
	return _slot_rect().grow(12.0).has_point(at_position)

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	if typeof(data) != TYPE_DICTIONARY:
		return
	var drag_data: Dictionary = data
	installed_device_id = str(drag_data.get("device_id", ""))
	installed_device_label = str(drag_data.get("label", ""))
	installed_error_code = str(drag_data.get("error_code", ""))
	queue_redraw()
	device_installed.emit(installed_device_id, installed_device_label, installed_error_code)

func play_trace_animation(success: bool) -> void:
	if trace_tween != null:
		trace_tween.kill()

	if packet_path.size() < 2:
		trace_animation_finished.emit(success)
		return

	trace_success = success
	packet_visible = true
	packet_progress = 0.0
	queue_redraw()

	var end_progress: float = 1.0 if success else 0.52
	trace_tween = create_tween()
	trace_tween.tween_method(Callable(self, "_set_packet_progress"), 0.0, end_progress, 1.15)
	await trace_tween.finished

	if not success:
		await get_tree().create_timer(0.15).timeout

	packet_visible = false
	packet_progress = 0.0
	queue_redraw()
	trace_animation_finished.emit(success)

func _set_packet_progress(value: float) -> void:
	packet_progress = clampf(value, 0.0, 1.0)
	queue_redraw()

func _recalculate_layout() -> void:
	node_positions.clear()
	if node_names.is_empty():
		packet_path.clear()
		return

	var count: int = node_names.size()
	var width_available: float = maxf(120.0, size.x - 64.0)
	var x_start: float = (size.x - width_available) * 0.5
	var y_line: float = size.y * 0.44

	if count == 1:
		node_positions[node_names[0]] = Vector2(size.x * 0.5, y_line)
	else:
		var step: float = width_available / float(count - 1)
		for idx in range(count):
			var node_name: String = node_names[idx]
			var pos: Vector2 = Vector2(x_start + float(idx) * step, y_line)
			node_positions[node_name] = pos

	_build_packet_path()

func _build_packet_path() -> void:
	packet_path.clear()
	if node_names.size() < 2:
		return

	var start_name: String = node_names[0]
	var end_name: String = node_names[node_names.size() - 1]
	var slot_center: Vector2 = _slot_center()

	var start_pos: Vector2 = node_positions.get(start_name, Vector2(size.x * 0.15, size.y * 0.45))
	var end_pos: Vector2 = node_positions.get(end_name, Vector2(size.x * 0.85, size.y * 0.45))

	packet_path.append(start_pos)
	if slot_center.distance_to(start_pos) > 1.0 and slot_center.distance_to(end_pos) > 1.0:
		packet_path.append(slot_center)
	packet_path.append(end_pos)

func _slot_center() -> Vector2:
	if node_positions.has(SLOT_NODE_NAME):
		return node_positions[SLOT_NODE_NAME]
	return Vector2(size.x * 0.5, size.y * 0.44)

func _slot_rect() -> Rect2:
	var center: Vector2 = _slot_center()
	return Rect2(center - slot_size * 0.5, slot_size)

func _draw() -> void:
	draw_rect(Rect2(Vector2.ZERO, size), Color(0.06, 0.09, 0.08, 0.35), true)
	draw_rect(Rect2(Vector2.ZERO, size), Color(0.2, 0.45, 0.3, 0.45), false, 2.0)

	for edge_var in edge_pairs:
		if typeof(edge_var) != TYPE_ARRAY:
			continue
		var edge: Array = edge_var
		if edge.size() < 2:
			continue
		var from_name: String = str(edge[0])
		var to_name: String = str(edge[1])
		if not node_positions.has(from_name) or not node_positions.has(to_name):
			continue
		var from_pos: Vector2 = node_positions[from_name]
		var to_pos: Vector2 = node_positions[to_name]
		draw_line(from_pos, to_pos, Color(0.35, 0.7, 0.55, 0.9), 3.0)

	for node_name_var in node_names:
		var node_name: String = str(node_name_var)
		if not node_positions.has(node_name):
			continue
		var node_pos: Vector2 = node_positions[node_name]
		if node_name == SLOT_NODE_NAME:
			continue
		draw_circle(node_pos, 16.0, Color(0.12, 0.25, 0.2, 1.0))
		draw_arc(node_pos, 16.0, 0.0, TAU, 24, Color(0.3, 0.85, 0.6, 0.75), 2.0)
		_draw_centered_text(node_name, node_pos + Vector2(0.0, 36.0), 160.0, Color(0.83, 0.98, 0.9, 1.0), 15)
		if node_labels.has(node_name):
			_draw_centered_text(str(node_labels[node_name]), node_pos + Vector2(0.0, 54.0), 220.0, Color(0.65, 0.75, 0.7, 1.0), 13)

	var slot_rect: Rect2 = _slot_rect()
	draw_rect(slot_rect, Color(0.08, 0.12, 0.1, 0.95), true)
	draw_rect(slot_rect, Color(0.95, 0.75, 0.25, 0.9), false, 3.0)
	if tools_locked:
		_draw_centered_text("ЗАБЛОКИРОВАНО", slot_rect.get_center() + Vector2(0.0, 6.0), slot_rect.size.x - 8.0, Color(0.95, 0.45, 0.4, 1.0), 18)
	elif installed_device_id.is_empty():
		_draw_centered_text("ПОМЕСТИТЕ УСТРОЙСТВО", slot_rect.get_center() + Vector2(0.0, 6.0), slot_rect.size.x - 8.0, Color(0.95, 0.95, 0.8, 1.0), 18)
	else:
		_draw_centered_text(installed_device_label, slot_rect.get_center() + Vector2(0.0, 0.0), slot_rect.size.x - 8.0, Color(0.75, 1.0, 0.82, 1.0), 18)

	if packet_visible and packet_path.size() >= 2:
		var packet_pos: Vector2 = _point_on_path(packet_progress)
		var packet_color: Color = Color(0.4, 1.0, 0.45, 1.0) if trace_success else Color(1.0, 0.35, 0.35, 1.0)
		draw_circle(packet_pos, 9.0, packet_color)
		draw_arc(packet_pos, 12.0, 0.0, TAU, 20, Color(packet_color.r, packet_color.g, packet_color.b, 0.35), 2.0)

func _point_on_path(progress: float) -> Vector2:
	if packet_path.is_empty():
		return Vector2.ZERO
	if packet_path.size() == 1:
		return packet_path[0]

	var distances: Array[float] = []
	var total_length: float = 0.0
	for idx in range(packet_path.size() - 1):
		var segment_length: float = packet_path[idx].distance_to(packet_path[idx + 1])
		distances.append(segment_length)
		total_length += segment_length

	if total_length <= 0.001:
		return packet_path[packet_path.size() - 1]

	var target_distance: float = clampf(progress, 0.0, 1.0) * total_length
	var accumulated: float = 0.0
	for idx in range(distances.size()):
		var segment_length: float = distances[idx]
		if accumulated + segment_length >= target_distance:
			var local_t: float = 0.0
			if segment_length > 0.001:
				local_t = (target_distance - accumulated) / segment_length
			return packet_path[idx].lerp(packet_path[idx + 1], local_t)
		accumulated += segment_length

	return packet_path[packet_path.size() - 1]

func _draw_centered_text(text_value: String, center: Vector2, width: float, color: Color, font_size: int) -> void:
	var font: Font = get_theme_default_font()
	if font == null:
		return
	var draw_pos: Vector2 = Vector2(center.x - width * 0.5, center.y)
	draw_string(font, draw_pos, text_value, HORIZONTAL_ALIGNMENT_CENTER, width, font_size, color)
</file>

<file path="scripts/ui/pipeline/PipelineSlot.gd">
extends PanelContainer
class_name PipelineSlotControl

signal module_dropped(slot_type: String, module_data: Dictionary)
signal slot_tapped(slot_type: String)
signal clear_pressed(slot_type: String)
signal bad_drop(slot_type: String, module_data: Dictionary)

@onready var label_slot_title: Label = $Margin/VBox/LabelSlotTitle
@onready var label_module_name: Label = $Margin/VBox/LabelModuleName
@onready var btn_clear: Button = $Margin/VBox/BtnClear

var slot_type: String = ""
var current_module: Dictionary = {}

func _ready() -> void:
	btn_clear.pressed.connect(_on_clear_pressed)
	_update_visual_state()

func setup(p_slot_type: String, title: String) -> void:
	slot_type = p_slot_type
	label_slot_title.text = title
	clear_module()

func has_module() -> bool:
	return not current_module.is_empty()

func get_module() -> Dictionary:
	return current_module.duplicate(true)

func get_module_id() -> String:
	if current_module.is_empty():
		return ""
	return str(current_module.get("module_id", ""))

func set_module(module_data: Dictionary) -> void:
	current_module = module_data.duplicate(true)
	label_module_name.text = str(current_module.get("display", "?"))
	_update_visual_state()

func clear_module() -> void:
	current_module.clear()
	label_module_name.text = "<пусто>"
	_update_visual_state()

func flash_bad_drop() -> void:
	modulate = Color(1.0, 0.55, 0.55, 1.0)
	var tween: Tween = create_tween()
	tween.tween_property(self, "modulate", Color(1.0, 1.0, 1.0, 1.0), 0.2)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	var module_data: Dictionary = _extract_module_data(data)
	if module_data.is_empty():
		return false
	return str(module_data.get("slot_type", "")) == slot_type

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	var module_data: Dictionary = _extract_module_data(data)
	if module_data.is_empty():
		return

	if str(module_data.get("slot_type", "")) != slot_type:
		emit_signal("bad_drop", slot_type, module_data)
		return

	emit_signal("module_dropped", slot_type, module_data)

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("slot_tapped", slot_type)
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("slot_tapped", slot_type)

func _on_clear_pressed() -> void:
	emit_signal("clear_pressed", slot_type)

func _extract_module_data(data: Variant) -> Dictionary:
	if typeof(data) != TYPE_DICTIONARY:
		return {}

	var drop_data: Dictionary = data
	if str(drop_data.get("kind", "")) != "pipeline_module":
		return {}

	var module_variant: Variant = drop_data.get("module", {})
	if typeof(module_variant) != TYPE_DICTIONARY:
		return {}

	var module_data: Dictionary = module_variant
	return module_data.duplicate(true)

func _update_visual_state() -> void:
	btn_clear.disabled = current_module.is_empty()
	if current_module.is_empty():
		modulate = Color(1.0, 1.0, 1.0, 1.0)
	else:
		modulate = Color(0.86, 1.0, 0.9, 1.0)
</file>

<file path="scripts/ui/ResultStamp.gd">
extends Control

@onready var stamp_panel: PanelContainer = $CenterContainer/StampPanel
@onready var stamp_label: Label = $CenterContainer/StampPanel/Margin/StampLabel

var _active_tween: Tween

func _ready() -> void:
	visible = false
	mouse_filter = Control.MOUSE_FILTER_IGNORE

func show_result(is_correct: bool) -> void:
	if _active_tween != null and _active_tween.is_running():
		_active_tween.kill()

	visible = true
	modulate = Color(1, 1, 1, 1)
	stamp_panel.modulate = Color(1, 1, 1, 0)
	stamp_panel.scale = Vector2(0.8, 0.8)

	if is_correct:
		stamp_label.text = "ПОДТВЕРЖДЕНО"
		stamp_label.add_theme_color_override("font_color", Color(0.75, 1.0, 0.72))
	else:
		stamp_label.text = "ОТКЛОНЕНО"
		stamp_label.add_theme_color_override("font_color", Color(1.0, 0.65, 0.62))

	_active_tween = create_tween()
	_active_tween.set_parallel(true)
	_active_tween.tween_property(stamp_panel, "modulate:a", 1.0, 0.12)
	_active_tween.tween_property(stamp_panel, "scale", Vector2(1.0, 1.0), 0.16)
	_active_tween.set_parallel(false)
	_active_tween.tween_interval(0.28)
	_active_tween.tween_property(stamp_panel, "modulate:a", 0.0, 0.72)
	_active_tween.finished.connect(func() -> void:
		visible = false
	)
</file>

<file path="scripts/ui/ResusDropZone.gd">
extends PanelContainer

signal item_placed(item_id: String, to_bucket: String, from_bucket: String)

@export var title_path: NodePath = NodePath("VBox/BucketTitle")
@export var items_container_path: NodePath = NodePath("VBox/ItemsFlow")

var bucket_id: String = ""

@onready var _title_label: Label = get_node_or_null(title_path) as Label
@onready var _items_container: Control = get_node_or_null(items_container_path) as Control

func _ready() -> void:
	mouse_exited.connect(func() -> void:
		modulate = Color(1, 1, 1, 1)
	)

func setup(p_bucket_id: String, p_label_text: String) -> void:
	bucket_id = p_bucket_id.to_upper()
	if is_instance_valid(_title_label):
		_title_label.text = p_label_text

func get_items_container() -> Control:
	return _items_container

func clear_items() -> void:
	if not is_instance_valid(_items_container):
		return
	for child in _items_container.get_children():
		child.queue_free()

func add_item_control(item_control: Control) -> void:
	if not is_instance_valid(_items_container):
		return
	_items_container.add_child(item_control)
	if item_control.has_method("set_zone_id"):
		item_control.call("set_zone_id", bucket_id)
	else:
		item_control.set_meta("zone_id", bucket_id)

func _can_drop_data(_at_position: Vector2, data: Variant) -> bool:
	if typeof(data) != TYPE_DICTIONARY:
		return false
	var payload: Dictionary = data as Dictionary
	if str(payload.get("kind", "")) != "RESUS_ITEM":
		return false
	modulate = Color(1.08, 1.03, 1.03, 1.0)
	return true

func _drop_data(_at_position: Vector2, data: Variant) -> void:
	modulate = Color(1, 1, 1, 1)
	if typeof(data) != TYPE_DICTIONARY:
		return
	var payload: Dictionary = data as Dictionary
	var source_path: String = str(payload.get("source_path", ""))
	if source_path == "":
		return
	var source_node: Node = get_node_or_null(source_path)
	if source_node == null or not is_instance_valid(_items_container):
		return

	var from_bucket: String = str(payload.get("from_zone", source_node.get_meta("zone_id", "PILE")))
	source_node.reparent(_items_container)
	if source_node.has_method("set_zone_id"):
		source_node.call("set_zone_id", bucket_id)
	else:
		source_node.set_meta("zone_id", bucket_id)

	if source_node is Control:
		var control_node: Control = source_node as Control
		var tween: Tween = create_tween()
		control_node.scale = Vector2(1.05, 1.05)
		tween.tween_property(control_node, "scale", Vector2.ONE, 0.1)

	item_placed.emit(str(payload.get("item_id", "")), bucket_id, from_bucket)
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END and not is_drag_successful():
		modulate = Color(1, 1, 1, 1)
</file>

<file path="scripts/ui/subnet/LockIndicator.gd">
extends PanelContainer
class_name NetworkLockIndicator

var label_state: Label = null

func _ready() -> void:
	_ensure_label()
	set_locked()

func set_locked() -> void:
	_apply_state("ЗАБЛОКИРОВАНО", Color(1.0, 0.58, 0.42, 1.0), Color(0.2, 0.08, 0.08, 0.9))

func set_ready() -> void:
	_apply_state("МАСКА УСТАНОВЛЕНА", Color(0.95, 0.88, 0.55, 1.0), Color(0.18, 0.16, 0.08, 0.9))

func set_applied() -> void:
	_apply_state("И ПРИМЕНЕНО", Color(0.62, 0.95, 1.0, 1.0), Color(0.08, 0.14, 0.18, 0.9))

func set_open() -> void:
	_apply_state("ОТКРЫТО", Color(0.4, 1.0, 0.6, 1.0), Color(0.08, 0.18, 0.1, 0.9))

func set_error() -> void:
	_apply_state("ОТКЛОНЕНО", Color(1.0, 0.4, 0.4, 1.0), Color(0.22, 0.05, 0.05, 0.9))

func _apply_state(text_value: String, font_color: Color, bg_color: Color) -> void:
	_ensure_label()
	if label_state != null:
		label_state.text = text_value
		label_state.add_theme_color_override("font_color", font_color)
	self_modulate = bg_color

func _ensure_label() -> void:
	if label_state == null:
		label_state = get_node_or_null("Margin/LabelState") as Label
</file>

<file path="scripts/ui/subnet/MaskOverlay.gd">
extends PanelContainer
class_name SubnetMaskOverlay

signal mask_selected(mask_data: Dictionary, sender: Node)
signal mask_drag_started(mask_data: Dictionary)

var label_mask: Label = null
var mask_data: Dictionary = {}

func _ready() -> void:
	_ensure_label()
	_refresh_label()

func setup(cidr: int, mask_last: int) -> void:
	mask_data = {
		"cidr": cidr,
		"mask_last": mask_last,
		"display": "/%d" % cidr
	}
	_refresh_label()
	set_selected(false)
	tooltip_text = "маска /%d (последний октет %d)" % [cidr, mask_last]

func get_mask_data() -> Dictionary:
	return mask_data.duplicate(true)

func set_selected(active: bool) -> void:
	if active:
		modulate = Color(1.0, 0.95, 0.72, 1.0)
	else:
		modulate = Color(1.0, 1.0, 1.0, 1.0)

func _get_drag_data(_at_position: Vector2) -> Variant:
	if mask_data.is_empty():
		return null

	emit_signal("mask_drag_started", mask_data.duplicate(true))

	var preview_panel: PanelContainer = PanelContainer.new()
	preview_panel.custom_minimum_size = Vector2(128.0, 52.0)
	var preview_margin: MarginContainer = MarginContainer.new()
	preview_margin.add_theme_constant_override("margin_left", 8)
	preview_margin.add_theme_constant_override("margin_top", 6)
	preview_margin.add_theme_constant_override("margin_right", 8)
	preview_margin.add_theme_constant_override("margin_bottom", 6)
	var preview_label: Label = Label.new()
	preview_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	preview_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	preview_label.text = "МАСКА %s" % str(mask_data.get("display", ""))
	preview_margin.add_child(preview_label)
	preview_panel.add_child(preview_margin)
	set_drag_preview(preview_panel)

	return {
		"kind": "subnet_mask_overlay",
		"mask": mask_data.duplicate(true)
	}

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_LEFT and mouse_event.pressed:
			emit_signal("mask_selected", mask_data.duplicate(true), self)
			accept_event()
		return

	if event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			emit_signal("mask_selected", mask_data.duplicate(true), self)
			accept_event()

func _ensure_label() -> void:
	if label_mask == null:
		label_mask = get_node_or_null("Margin/LabelMask") as Label

func _refresh_label() -> void:
	_ensure_label()
	if label_mask == null:
		return
	if mask_data.is_empty():
		label_mask.text = "МАСКА ?"
	else:
		label_mask.text = "МАСКА %s" % str(mask_data.get("display", ""))
</file>

<file path="scripts/ui/subnet/SubnetRuler.gd">
extends Control
class_name SubnetRulerControl

var step: int = 64
var ip_last: int = 0
var network_last: int = -1
var applied: bool = false
var pulse_until_ms: int = 0

func _ready() -> void:
	set_process(false)
	queue_redraw()

func configure(new_step: int, new_ip_last: int) -> void:
	step = maxi(1, new_step)
	ip_last = clampi(new_ip_last, 0, 255)
	queue_redraw()

func set_result(new_network_last: int) -> void:
	network_last = clampi(new_network_last, 0, 255)
	applied = true
	queue_redraw()

func reset_state() -> void:
	network_last = -1
	applied = false
	pulse_until_ms = 0
	set_process(false)
	queue_redraw()

func pulse_marker(duration_ms: int = 1000) -> void:
	pulse_until_ms = Time.get_ticks_msec() + maxi(0, duration_ms)
	set_process(true)
	queue_redraw()

func current_segment_text() -> String:
	if not applied or network_last < 0:
		return "СЕГМЕНТ: --"
	var segment_end: int = mini(255, network_last + step - 1)
	return "СЕГМЕНТ: %d..%d | ID СЕТИ: %d" % [network_last, segment_end, network_last]

func _process(_delta: float) -> void:
	if pulse_until_ms <= Time.get_ticks_msec():
		set_process(false)
	queue_redraw()

func _draw() -> void:
	var bg_rect: Rect2 = Rect2(Vector2.ZERO, size)
	draw_rect(bg_rect, Color(0.06, 0.08, 0.07, 0.48), true)
	draw_rect(bg_rect, Color(0.24, 0.42, 0.32, 0.55), false, 2.0)

	if size.x < 80.0 or size.y < 60.0:
		return

	var left: float = 18.0
	var right: float = size.x - 18.0
	var axis_y: float = size.y * 0.5
	var axis_width: float = maxf(10.0, right - left)
	draw_line(Vector2(left, axis_y), Vector2(right, axis_y), Color(0.65, 0.85, 0.72, 0.95), 2.0)

	var grid_step: int = 32
	for value in range(0, 257, grid_step):
		var x_pos: float = _x_for_value(float(value), left, axis_width)
		draw_line(Vector2(x_pos, axis_y - 8.0), Vector2(x_pos, axis_y + 8.0), Color(0.4, 0.6, 0.5, 0.8), 1.0)
		if value % 64 == 0:
			_draw_text_centered(str(value), Vector2(x_pos, axis_y + 26.0), 64.0, 13, Color(0.7, 0.86, 0.74, 0.95))

	for boundary in range(0, 257, step):
		var boundary_x: float = _x_for_value(float(boundary), left, axis_width)
		draw_line(Vector2(boundary_x, axis_y - 18.0), Vector2(boundary_x, axis_y + 18.0), Color(0.92, 0.82, 0.42, 0.55), 1.5)

	if applied and network_last >= 0:
		var seg_start: float = _x_for_value(float(network_last), left, axis_width)
		var seg_end: int = mini(256, network_last + step)
		var seg_end_x: float = _x_for_value(float(seg_end), left, axis_width)
		var seg_rect: Rect2 = Rect2(Vector2(seg_start, axis_y - 16.0), Vector2(maxf(2.0, seg_end_x - seg_start), 32.0))
		draw_rect(seg_rect, Color(0.25, 0.55, 0.35, 0.42), true)
		draw_rect(seg_rect, Color(0.48, 0.92, 0.62, 0.8), false, 2.0)

	var marker_x: float = _x_for_value(float(ip_last), left, axis_width)
	var pulse_alpha: float = 0.0
	if pulse_until_ms > Time.get_ticks_msec():
		pulse_alpha = 0.2 + 0.2 * (0.5 + 0.5 * sin(float(Time.get_ticks_msec()) * 0.02))
	draw_line(Vector2(marker_x, axis_y - 24.0), Vector2(marker_x, axis_y + 24.0), Color(1.0, 0.85, 0.25, 0.95), 2.0)
	draw_circle(Vector2(marker_x, axis_y - 26.0), 5.0, Color(1.0, 0.85, 0.25, 1.0))
	if pulse_alpha > 0.0:
		draw_circle(Vector2(marker_x, axis_y - 26.0), 10.0, Color(1.0, 0.85, 0.25, pulse_alpha))

	_draw_text_centered("IP %d" % ip_last, Vector2(marker_x, axis_y - 34.0), 90.0, 13, Color(0.96, 0.92, 0.78, 1.0))
	_draw_text_centered(current_segment_text(), Vector2(size.x * 0.5, size.y - 10.0), size.x - 20.0, 15, Color(0.62, 0.95, 0.72, 1.0))

func _x_for_value(value: float, left: float, width_value: float) -> float:
	return left + (clampf(value, 0.0, 256.0) / 256.0) * width_value

func _draw_text_centered(text_value: String, center: Vector2, width_value: float, font_size: int, color: Color) -> void:
	var font: Font = get_theme_default_font()
	if font == null:
		return
	var draw_pos: Vector2 = Vector2(center.x - width_value * 0.5, center.y)
	draw_string(font, draw_pos, text_value, HORIZONTAL_ALIGNMENT_CENTER, width_value, font_size, color)
</file>

<file path="ui/overlays/NoirOverlay.gd">
extends CanvasLayer

@export_range(0.0, 1.0, 0.01) var intensity: float = 0.18
@export var fx_quality: int = 1
@export var tint_color: Color = Color(0.93, 0.93, 0.93, 1.0)

@onready var crt_overlay: ColorRect = $CRT_Overlay

var _shader_material: ShaderMaterial

func _ready() -> void:
	_shader_material = crt_overlay.material as ShaderMaterial
	if _shader_material == null:
		return
	_shader_material.set_shader_parameter("tint_color", tint_color)
	_shader_material.set_shader_parameter("intensity", intensity)
	_shader_material.set_shader_parameter("fx_quality", fx_quality)
	_shader_material.set_shader_parameter("glitch_strength", 0.0)

func glitch_burst(strength: float = 0.7, duration: float = 0.2) -> void:
	if _shader_material == null:
		return
	var burst_strength: float = clampf(strength, 0.0, 2.0)
	var burst_duration: float = maxf(0.05, duration)
	_shader_material.set_shader_parameter("glitch_strength", burst_strength)
	var tween := create_tween()
	tween.tween_method(
		func(value: float) -> void:
			_shader_material.set_shader_parameter("glitch_strength", value),
		burst_strength,
		0.0,
		burst_duration
	)
</file>

<file path="ui/overlays/NoirOverlay.tscn">
[gd_scene load_steps=4 format=3]

[ext_resource type="Script" path="res://ui/overlays/NoirOverlay.gd" id="1_script"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="2_shader"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("2_shader")
shader_parameter/tint_color = Color(0.93, 0.93, 0.93, 1)
shader_parameter/intensity = 0.18
shader_parameter/fx_quality = 1
shader_parameter/glitch_strength = 0.0

[node name="NoirOverlay" type="CanvasLayer"]
layer = 100
script = ExtResource("1_script")

[node name="CRT_Overlay" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 0)
</file>

<file path="data/final_report_a_levels.json">
[
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-L01",
        "bucket":  "newbie",
        "briefing":  "Архив поврежден. Соберите список улик.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "LIST_BASIC",
        "allowed_containers":  [
                                   "ul",
                                   "ol"
                               ],
        "allowed_inner_kinds":  [
                                    "LI_ITEM"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_ul",
                              "label":  "\u003cul\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cul\u003e"
                          },
                          {
                              "fragment_id":  "li_a",
                              "label":  "\u003cli\u003eЛог A\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eЛог A\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_b",
                              "label":  "\u003cli\u003eЛог B\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eЛог B\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_c",
                              "label":  "\u003cli\u003eЛог C\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eЛог C\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "close_ul",
                              "label":  "\u003c/ul\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/ul\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eшум\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eшум\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_ul",
                                  "li_a",
                                  "li_b",
                                  "li_c",
                                  "close_ul",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-L02",
        "bucket":  "newbie",
        "briefing":  "Восстановите нумерованный список действий.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "LIST_BASIC",
        "allowed_containers":  [
                                   "ul",
                                   "ol"
                               ],
        "allowed_inner_kinds":  [
                                    "LI_ITEM"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_ol",
                              "label":  "\u003col\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003col\u003e"
                          },
                          {
                              "fragment_id":  "li_1",
                              "label":  "\u003cli\u003eШаг 1\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eШаг 1\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_2",
                              "label":  "\u003cli\u003eШаг 2\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eШаг 2\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "li_3",
                              "label":  "\u003cli\u003eШаг 3\u003c/li\u003e",
                              "kind":  "LI_ITEM",
                              "token":  "\u003cli\u003eШаг 3\u003c/li\u003e"
                          },
                          {
                              "fragment_id":  "close_ol",
                              "label":  "\u003c/ol\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/ol\u003e"
                          },
                          {
                              "fragment_id":  "noise_p",
                              "label":  "\u003cp\u003eшум\u003c/p\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cp\u003eшум\u003c/p\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_ol",
                                  "li_1",
                                  "li_2",
                                  "li_3",
                                  "close_ol",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-N01",
        "bucket":  "newbie",
        "briefing":  "Соберите базовое меню стартапа.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "NAV_MENU",
        "allowed_containers":  [
                                   "nav"
                               ],
        "allowed_inner_kinds":  [
                                    "LINK",
                                    "LI_ITEM",
                                    "TEXT_BLOCK",
                                    "NAV_LIST_OPEN",
                                    "NAV_LIST_CLOSE"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_nav",
                              "label":  "\u003cnav\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cnav\u003e"
                          },
                          {
                              "fragment_id":  "a_home",
                              "label":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "a_mvp",
                              "label":  "\u003ca href=\"#mvp\"\u003eMVP\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#mvp\"\u003eMVP\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "a_team",
                              "label":  "\u003ca href=\"#team\"\u003eКоманда\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#team\"\u003eКоманда\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "close_nav",
                              "label":  "\u003c/nav\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/nav\u003e"
                          },
                          {
                              "fragment_id":  "noise_span",
                              "label":  "\u003cspan\u003eреклама\u003c/span\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cspan\u003eреклама\u003c/span\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_nav",
                                  "a_home",
                                  "a_mvp",
                                  "a_team",
                                  "close_nav",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-N02",
        "bucket":  "newbie",
        "briefing":  "Меню инвесторской страницы: оставьте только нужные ссылки.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "NAV_MENU",
        "allowed_containers":  [
                                   "nav"
                               ],
        "allowed_inner_kinds":  [
                                    "LINK",
                                    "LI_ITEM",
                                    "TEXT_BLOCK",
                                    "NAV_LIST_OPEN",
                                    "NAV_LIST_CLOSE"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_nav",
                              "label":  "\u003cnav\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cnav\u003e"
                          },
                          {
                              "fragment_id":  "a_home",
                              "label":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#home\"\u003eГлавная\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "a_invest",
                              "label":  "\u003ca href=\"#invest\"\u003eИнвестировать\u003c/a\u003e",
                              "kind":  "LINK",
                              "token":  "\u003ca href=\"#invest\"\u003eИнвестировать\u003c/a\u003e"
                          },
                          {
                              "fragment_id":  "close_nav",
                              "label":  "\u003c/nav\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/nav\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eбаннер\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eбаннер\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_nav",
                                  "a_home",
                                  "a_invest",
                                  "close_nav",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-T01",
        "bucket":  "newbie",
        "briefing":  "Соберите протокол входов в таблице.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "TABLE_LOG",
        "allowed_containers":  [
                                   "table"
                               ],
        "allowed_inner_kinds":  [
                                    "TR_ROW"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_table",
                              "label":  "\u003ctable\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003ctable\u003e"
                          },
                          {
                              "fragment_id":  "row_ok_1201",
                              "label":  "\u003ctr\u003e\u003ctd\u003e12:01\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003e12:01\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_deny_1203",
                              "label":  "\u003ctr\u003e\u003ctd\u003e12:03\u003c/td\u003e\u003ctd\u003eОТКАЗ\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003e12:03\u003c/td\u003e\u003ctd\u003eОТКАЗ\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_ok_1210",
                              "label":  "\u003ctr\u003e\u003ctd\u003e12:10\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003e12:10\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "close_table",
                              "label":  "\u003c/table\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/table\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eстрока\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eстрока\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_table",
                                  "row_ok_1201",
                                  "row_deny_1203",
                                  "row_ok_1210",
                                  "close_table",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-T02",
        "bucket":  "newbie",
        "briefing":  "Ловушка: контейнер table должен закрываться корректно.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "TABLE_LOG",
        "allowed_containers":  [
                                   "table"
                               ],
        "allowed_inner_kinds":  [
                                    "TR_ROW"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_table",
                              "label":  "\u003ctable\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003ctable\u003e"
                          },
                          {
                              "fragment_id":  "row_1",
                              "label":  "\u003ctr\u003e\u003ctd\u003eХост-1\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003eХост-1\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_2",
                              "label":  "\u003ctr\u003e\u003ctd\u003eХост-2\u003c/td\u003e\u003ctd\u003eПРЕДУПРЕЖДЕНИЕ\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003eХост-2\u003c/td\u003e\u003ctd\u003eПРЕДУПРЕЖДЕНИЕ\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "row_3",
                              "label":  "\u003ctr\u003e\u003ctd\u003eХост-3\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e",
                              "kind":  "TR_ROW",
                              "token":  "\u003ctr\u003e\u003ctd\u003eХост-3\u003c/td\u003e\u003ctd\u003eОК\u003c/td\u003e\u003c/tr\u003e"
                          },
                          {
                              "fragment_id":  "close_table",
                              "label":  "\u003c/table\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/table\u003e"
                          },
                          {
                              "fragment_id":  "close_ul",
                              "label":  "\u003c/ul\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/ul\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_table",
                                  "row_1",
                                  "row_2",
                                  "row_3",
                                  "close_table",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-F01",
        "bucket":  "newbie",
        "briefing":  "Соберите простую форму допроса: надпись + поле ввода + кнопка.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FORM_SIMPLE",
        "allowed_containers":  [
                                   "form"
                               ],
        "allowed_inner_kinds":  [
                                    "FORM_FIELD",
                                    "BUTTON",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_form",
                              "label":  "\u003cform\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cform\u003e"
                          },
                          {
                              "fragment_id":  "label_name",
                              "label":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e"
                          },
                          {
                              "fragment_id":  "input_name",
                              "label":  "\u003cinput id=\"n\" /\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003cinput id=\"n\" /\u003e"
                          },
                          {
                              "fragment_id":  "button_submit",
                              "label":  "\u003cbutton\u003eПодтвердить\u003c/button\u003e",
                              "kind":  "BUTTON",
                              "token":  "\u003cbutton\u003eПодтвердить\u003c/button\u003e"
                          },
                          {
                              "fragment_id":  "close_form",
                              "label":  "\u003c/form\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/form\u003e"
                          },
                          {
                              "fragment_id":  "noise_p",
                              "label":  "\u003cp\u003eзаметка\u003c/p\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cp\u003eзаметка\u003c/p\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_form",
                                  "label_name",
                                  "input_name",
                                  "button_submit",
                                  "close_form",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-F02",
        "bucket":  "newbie",
        "briefing":  "Форма с двумя полями, но без усложнения механики.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FORM_SIMPLE",
        "allowed_containers":  [
                                   "form"
                               ],
        "allowed_inner_kinds":  [
                                    "FORM_FIELD",
                                    "BUTTON",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6",
                      "S7"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_form",
                              "label":  "\u003cform\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cform\u003e"
                          },
                          {
                              "fragment_id":  "label_name",
                              "label":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003clabel for=\"n\"\u003eИмя\u003c/label\u003e"
                          },
                          {
                              "fragment_id":  "input_name",
                              "label":  "\u003cinput id=\"n\" /\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003cinput id=\"n\" /\u003e"
                          },
                          {
                              "fragment_id":  "label_code",
                              "label":  "\u003clabel for=\"c\"\u003eКод\u003c/label\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003clabel for=\"c\"\u003eКод\u003c/label\u003e"
                          },
                          {
                              "fragment_id":  "input_code",
                              "label":  "\u003cinput id=\"c\" /\u003e",
                              "kind":  "FORM_FIELD",
                              "token":  "\u003cinput id=\"c\" /\u003e"
                          },
                          {
                              "fragment_id":  "button_send",
                              "label":  "\u003cbutton\u003eОтправить\u003c/button\u003e",
                              "kind":  "BUTTON",
                              "token":  "\u003cbutton\u003eОтправить\u003c/button\u003e"
                          },
                          {
                              "fragment_id":  "close_form",
                              "label":  "\u003c/form\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/form\u003e"
                          },
                          {
                              "fragment_id":  "noise_div",
                              "label":  "\u003cdiv\u003eреклама\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eреклама\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_form",
                                  "label_name",
                                  "input_name",
                                  "label_code",
                                  "input_code",
                                  "button_send",
                                  "close_form"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-A01",
        "bucket":  "newbie",
        "briefing":  "Соберите служебную заметку отчета.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "ARTICLE_NOTE",
        "allowed_containers":  [
                                   "article"
                               ],
        "allowed_inner_kinds":  [
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_article",
                              "label":  "\u003carticle\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003carticle\u003e"
                          },
                          {
                              "fragment_id":  "h1_final",
                              "label":  "\u003ch1\u003eФинальный отчёт\u003c/h1\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003ch1\u003eФинальный отчёт\u003c/h1\u003e"
                          },
                          {
                              "fragment_id":  "p_evidence",
                              "label":  "\u003cp\u003eУлики восстановлены.\u003c/p\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cp\u003eУлики восстановлены.\u003c/p\u003e"
                          },
                          {
                              "fragment_id":  "small_case",
                              "label":  "\u003csmall\u003e#case08\u003c/small\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003csmall\u003e#case08\u003c/small\u003e"
                          },
                          {
                              "fragment_id":  "close_article",
                              "label":  "\u003c/article\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/article\u003e"
                          },
                          {
                              "fragment_id":  "close_nav",
                              "label":  "\u003c/nav\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/nav\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_article",
                                  "h1_final",
                                  "p_evidence",
                                  "small_case",
                                  "close_article",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           },
        "required_tags_all":  [
                                  "h1",
                                  "p"
                              ]
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-A02",
        "bucket":  "newbie",
        "briefing":  "Ловушка: в отчете отсутствует обязательный заголовок.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "ARTICLE_NOTE",
        "allowed_containers":  [
                                   "article"
                               ],
        "allowed_inner_kinds":  [
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_article",
                              "label":  "\u003carticle\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003carticle\u003e"
                          },
                          {
                              "fragment_id":  "p_body",
                              "label":  "\u003cp\u003eФинальная заметка.\u003c/p\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cp\u003eФинальная заметка.\u003c/p\u003e"
                          },
                          {
                              "fragment_id":  "p_extra",
                              "label":  "\u003cp\u003eПриложение.\u003c/p\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cp\u003eПриложение.\u003c/p\u003e"
                          },
                          {
                              "fragment_id":  "small_note",
                              "label":  "\u003csmall\u003e#архив\u003c/small\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003csmall\u003e#архив\u003c/small\u003e"
                          },
                          {
                              "fragment_id":  "close_article",
                              "label":  "\u003c/article\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/article\u003e"
                          },
                          {
                              "fragment_id":  "noise_nav",
                              "label":  "\u003cnav\u003eменю\u003c/nav\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cnav\u003eменю\u003c/nav\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_article",
                                  "p_body",
                                  "small_note",
                                  "close_article",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           },
        "required_tags_all":  [
                                  "h1",
                                  "p"
                              ]
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-M01",
        "bucket":  "newbie",
        "briefing":  "Соберите фото-улику: изображение + подпись.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FIGURE_MEDIA",
        "allowed_containers":  [
                                   "figure"
                               ],
        "allowed_inner_kinds":  [
                                    "MEDIA",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_figure",
                              "label":  "\u003cfigure\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cfigure\u003e"
                          },
                          {
                              "fragment_id":  "img_main",
                              "label":  "\u003cimg src=\"evidence.png\" /\u003e",
                              "kind":  "MEDIA",
                              "token":  "\u003cimg src=\"evidence.png\" /\u003e"
                          },
                          {
                              "fragment_id":  "caption_main",
                              "label":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e"
                          },
                          {
                              "fragment_id":  "close_figure",
                              "label":  "\u003c/figure\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/figure\u003e"
                          },
                          {
                              "fragment_id":  "li_fake",
                              "label":  "\u003cli\u003eфейк\u003c/li\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cli\u003eфейк\u003c/li\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_figure",
                                  "img_main",
                                  "caption_main",
                                  "close_figure",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    },
    {
        "quest_id":  "CASE_08_FINAL_REPORT",
        "schema_version":  "1.2.0",
        "id":  "FR8-A-M02",
        "bucket":  "newbie",
        "briefing":  "Ловушка: подпись должна находиться внутри figure.",
        "format":  "TAG_ORDERING",
        "validator_profile":  "FIGURE_MEDIA",
        "allowed_containers":  [
                                   "figure"
                               ],
        "allowed_inner_kinds":  [
                                    "MEDIA",
                                    "TEXT_BLOCK"
                                ],
        "slots":  [
                      "S1",
                      "S2",
                      "S3",
                      "S4",
                      "S5",
                      "S6"
                  ],
        "fragments":  [
                          {
                              "fragment_id":  "open_figure",
                              "label":  "\u003cfigure\u003e",
                              "kind":  "CONTAINER_OPEN",
                              "token":  "\u003cfigure\u003e"
                          },
                          {
                              "fragment_id":  "img_cam",
                              "label":  "\u003cimg src=\"cam12.png\" /\u003e",
                              "kind":  "MEDIA",
                              "token":  "\u003cimg src=\"cam12.png\" /\u003e"
                          },
                          {
                              "fragment_id":  "caption_cam",
                              "label":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e",
                              "kind":  "TEXT_BLOCK",
                              "token":  "\u003cfigcaption\u003eКамера 12\u003c/figcaption\u003e"
                          },
                          {
                              "fragment_id":  "close_figure",
                              "label":  "\u003c/figure\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/figure\u003e"
                          },
                          {
                              "fragment_id":  "open_div",
                              "label":  "\u003cdiv\u003eподпись\u003c/div\u003e",
                              "kind":  "FOREIGN",
                              "token":  "\u003cdiv\u003eподпись\u003c/div\u003e"
                          },
                          {
                              "fragment_id":  "close_div",
                              "label":  "\u003c/div\u003e",
                              "kind":  "CONTAINER_CLOSE",
                              "token":  "\u003c/div\u003e"
                          }
                      ],
        "expected_sequence":  [
                                  "open_figure",
                                  "img_cam",
                                  "caption_cam",
                                  "close_figure",
                                  "(EMPTY)",
                                  "(EMPTY)"
                              ],
        "scoring_model":  {
                              "rules":  [
                                            {
                                                "code":  "PERFECT",
                                                "min_state":  "ORDER_OK",
                                                "points":  2,
                                                "stability_delta":  0,
                                                "verdict_code":  "PERFECT"
                                            },
                                            {
                                                "code":  "PARTIAL",
                                                "min_state":  "SYNTAX_OK",
                                                "points":  1,
                                                "stability_delta":  -10,
                                                "verdict_code":  "PARTIAL"
                                            },
                                            {
                                                "code":  "FAIL",
                                                "min_state":  "ANY",
                                                "points":  0,
                                                "stability_delta":  -30,
                                                "verdict_code":  "FAIL"
                                            }
                                        ],
                              "default_rule":  {
                                                   "code":  "EMPTY_CONFIRM",
                                                   "points":  0,
                                                   "stability_delta":  -50,
                                                   "verdict_code":  "EMPTY"
                                               }
                          },
        "feedback_rules":  {
                               "UNBALANCED_TAG":  "Контейнер разорван: начало и конец структуры не совпадают.",
                               "HIERARCHY_VIOLATION":  "Чужеродный элемент внутри контейнера.",
                               "REQUIRED_TAG_MISSING":  "Обязательный элемент отсутствует внутри контейнера.",
                               "ORDER_MISMATCH":  "Синтаксис жив, но порядок улик нарушен.",
                               "OK":  "Улики восстановлены. Файл читаем."
                           }
    }
]
</file>

<file path="data/network_trace_c_levels.json">
[
  {
    "id": "NT_C_01",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.1.13/25. Найдите ID сети (последний октет).",
    "target_ip": "192.168.1.13",
    "cidr": 25,
    "ip_last": 13,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /25 равен 128. 13 находится в диапазоне 0..127, значит сеть — 0.",
    "explain_full": "Последний октет IP=13 (00001101). Последний октет маски (/25)=128 (10000000). AND=00000000=0. Границы сегмента используют шаг 128: 0..127.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_02",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.1.142/25. Найдите ID сети (последний октет).",
    "target_ip": "192.168.1.142",
    "cidr": 25,
    "ip_last": 142,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /25 равен 128. 142 находится в диапазоне 128..255, значит сеть — 128.",
    "explain_full": "Последний октет IP=142 (10001110). Последний октет маски (/25)=128 (10000000). AND=10000000=128. Границы сегмента используют шаг 128: 128..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_03",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 10.0.5.190/25. Найдите ID сети (последний октет).",
    "target_ip": "10.0.5.190",
    "cidr": 25,
    "ip_last": 190,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /25 равен 128. 190 находится в диапазоне 128..255, значит сеть — 128.",
    "explain_full": "Последний октет IP=190 (10111110). Последний октет маски (/25)=128 (10000000). AND=10000000=128. Границы сегмента используют шаг 128: 128..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_04",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 172.16.8.233/25. Найдите ID сети (последний октет).",
    "target_ip": "172.16.8.233",
    "cidr": 25,
    "ip_last": 233,
    "mask_last": 128,
    "step": 128,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /25 равен 128. 233 находится в диапазоне 128..255, значит сеть — 128.",
    "explain_full": "Последний октет IP=233 (11101001). Последний октет маски (/25)=128 (10000000). AND=10000000=128. Границы сегмента используют шаг 128: 128..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_05",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.10.12/26. Найдите ID сети (последний октет).",
    "target_ip": "192.168.10.12",
    "cidr": 26,
    "ip_last": 12,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /26 равен 64. 12 находится в диапазоне 0..63, значит сеть — 0.",
    "explain_full": "Последний октет IP=12 (00001100). Последний октет маски (/26)=192 (11000000). AND=00000000=0. Границы сегмента используют шаг 64: 0..63.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_06",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.168.10.77/26. Найдите ID сети (последний октет).",
    "target_ip": "192.168.10.77",
    "cidr": 26,
    "ip_last": 77,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 64,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": ""
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "96",
        "label": "96",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "64",
    "explain_short": "Шаг /26 равен 64. 77 находится в диапазоне 64..127, значит сеть — 64.",
    "explain_full": "Последний октет IP=77 (01001101). Последний октет маски (/26)=192 (11000000). AND=01000000=64. Границы сегмента используют шаг 64: 64..127.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_07",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 10.44.7.130/26. Найдите ID сети (последний октет).",
    "target_ip": "10.44.7.130",
    "cidr": 26,
    "ip_last": 130,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /26 равен 64. 130 находится в диапазоне 128..191, значит сеть — 128.",
    "explain_full": "Последний октет IP=130 (10000010). Последний октет маски (/26)=192 (11000000). AND=10000000=128. Границы сегмента используют шаг 64: 128..191.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_08",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 10.44.7.191/26. Найдите ID сети (последний октет).",
    "target_ip": "10.44.7.191",
    "cidr": 26,
    "ip_last": 191,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 128,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": ""
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "128",
    "explain_short": "Шаг /26 равен 64. 191 находится в диапазоне 128..191, значит сеть — 128.",
    "explain_full": "Последний октет IP=191 (10111111). Последний октет маски (/26)=192 (11000000). AND=10000000=128. Границы сегмента используют шаг 64: 128..191.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_09",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 203.0.113.200/26. Найдите ID сети (последний октет).",
    "target_ip": "203.0.113.200",
    "cidr": 26,
    "ip_last": 200,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 192,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": ""
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "192",
    "explain_short": "Шаг /26 равен 64. 200 находится в диапазоне 192..255, значит сеть — 192.",
    "explain_full": "Последний октет IP=200 (11001000). Последний октет маски (/26)=192 (11000000). AND=11000000=192. Границы сегмента используют шаг 64: 192..255.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_10",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 203.0.113.63/26. Найдите ID сети (последний октет).",
    "target_ip": "203.0.113.63",
    "cidr": 26,
    "ip_last": 63,
    "mask_last": 192,
    "step": 64,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "128",
        "label": "128",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /26 равен 64. 63 находится в диапазоне 0..63, значит сеть — 0.",
    "explain_full": "Последний октет IP=63 (00111111). Последний октет маски (/26)=192 (11000000). AND=00000000=0. Границы сегмента используют шаг 64: 0..63.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_11",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 198.51.100.17/27. Найдите ID сети (последний октет).",
    "target_ip": "198.51.100.17",
    "cidr": 27,
    "ip_last": 17,
    "mask_last": 224,
    "step": 32,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "16",
        "label": "16",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /27 равен 32. 17 находится в диапазоне 0..31, значит сеть — 0.",
    "explain_full": "Последний октет IP=17 (00010001). Последний октет маски (/27)=224 (11100000). AND=00000000=0. Границы сегмента используют шаг 32: 0..31.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_12",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 198.51.100.94/27. Найдите ID сети (последний октет).",
    "target_ip": "198.51.100.94",
    "cidr": 27,
    "ip_last": 94,
    "mask_last": 224,
    "step": 32,
    "expected_network_last": 64,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "64",
        "label": "64",
        "error_code": ""
      },
      {
        "id": "96",
        "label": "96",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      }
    ],
    "correct_id": "64",
    "explain_short": "Шаг /27 равен 32. 94 находится в диапазоне 64..95, значит сеть — 64.",
    "explain_full": "Последний октет IP=94 (01011110). Последний октет маски (/27)=224 (11100000). AND=01000000=64. Границы сегмента используют шаг 32: 64..95.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_13",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 172.20.4.222/27. Найдите ID сети (последний октет).",
    "target_ip": "172.20.4.222",
    "cidr": 27,
    "ip_last": 222,
    "mask_last": 224,
    "step": 32,
    "expected_network_last": 192,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "192",
        "label": "192",
        "error_code": ""
      },
      {
        "id": "224",
        "label": "224",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "208",
        "label": "208",
        "error_code": "C_BAD_STEP"
      }
    ],
    "correct_id": "192",
    "explain_short": "Шаг /27 равен 32. 222 находится в диапазоне 192..223, значит сеть — 192.",
    "explain_full": "Последний октет IP=222 (11011110). Последний октет маски (/27)=224 (11100000). AND=11000000=192. Границы сегмента используют шаг 32: 192..223.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_14",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.0.2.14/28. Найдите ID сети (последний октет).",
    "target_ip": "192.0.2.14",
    "cidr": 28,
    "ip_last": 14,
    "mask_last": 240,
    "step": 16,
    "expected_network_last": 0,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": ""
      },
      {
        "id": "16",
        "label": "16",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "240",
        "label": "240",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      },
      {
        "id": "8",
        "label": "8",
        "error_code": "C_BAD_STEP"
      },
      {
        "id": "32",
        "label": "32",
        "error_code": "C_BOUNDARY_SHIFT"
      }
    ],
    "correct_id": "0",
    "explain_short": "Шаг /28 равен 16. 14 находится в диапазоне 0..15, значит сеть — 0.",
    "explain_full": "Последний октет IP=14 (00001110). Последний октет маски (/28)=240 (11110000). AND=00000000=0. Границы сегмента используют шаг 16: 0..15.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  },
  {
    "id": "NT_C_15",
    "briefing": "Защищённый сегмент принимает трафик только из правильной подсети.",
    "prompt": "Цель 192.0.2.173/28. Найдите ID сети (последний октет).",
    "target_ip": "192.0.2.173",
    "cidr": 28,
    "ip_last": 173,
    "mask_last": 240,
    "step": 16,
    "expected_network_last": 160,
    "options": [
      {
        "id": "0",
        "label": "0",
        "error_code": "C_L24_FALLBACK"
      },
      {
        "id": "144",
        "label": "144",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "160",
        "label": "160",
        "error_code": ""
      },
      {
        "id": "176",
        "label": "176",
        "error_code": "C_BOUNDARY_SHIFT"
      },
      {
        "id": "240",
        "label": "240",
        "error_code": "C_MASK_VAL"
      },
      {
        "id": "255",
        "label": "255",
        "error_code": "C_BROADCAST"
      }
    ],
    "correct_id": "160",
    "explain_short": "Шаг /28 равен 16. 173 находится в диапазоне 160..175, значит сеть — 160.",
    "explain_full": "Последний октет IP=173 (10101101). Последний октет маски (/28)=240 (11110000). AND=10100000=160. Границы сегмента используют шаг 16: 160..175.",
    "tags": [
      "net",
      "cidr",
      "subnet",
      "bitwise"
    ],
    "time_limit_sec": 120
  }
]
</file>

<file path="data/quest_c_levels.json">
[
  {
    "id": "C-01",
    "bucket": "newbie",
    "briefing": "Найдите ошибку границы цикла.",
    "expected_s": 15,
    "actual_s": 10,
    "code_lines": [
      "s = 0",
      "for i in range(5):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(6):", "result_s": 15 },
        { "option_id": "B", "replace_line": "for i in range(1, 5):", "result_s": 10 },
        { "option_id": "C", "replace_line": "for i in range(7):", "result_s": 21 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "range(5) даёт 0..4, сумма равна 10.",
      "Нужно включить 5, чтобы получить 15."
    ]
  },
  {
    "id": "C-02",
    "bucket": "newbie",
    "briefing": "Граничный оператор в условии неверный.",
    "expected_s": 12,
    "actual_s": 9,
    "code_lines": [
      "s = 0",
      "for i in range(1, 6):",
      "    if i > 3:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i >= 3:", "result_s": 12 },
        { "option_id": "B", "replace_line": "    if i > 4:", "result_s": 5 },
        { "option_id": "C", "replace_line": "    if i >= 4:", "result_s": 9 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущее условие пропускает i = 3.",
      "С учётом i = 3 получаем 3 + 4 + 5 = 12."
    ]
  },
  {
    "id": "C-03",
    "bucket": "newbie",
    "briefing": "Значение шага в range слишком велико.",
    "expected_s": 20,
    "actual_s": 18,
    "code_lines": [
      "s = 0",
      "for i in range(0, 10, 3):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(0, 10, 2):", "result_s": 20 },
        { "option_id": "B", "replace_line": "for i in range(0, 10, 4):", "result_s": 12 },
        { "option_id": "C", "replace_line": "for i in range(0, 8, 2):", "result_s": 12 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущая последовательность: 0, 3, 6, 9.",
      "С шагом 2: 0, 2, 4, 6, 8 -> сумма 20."
    ]
  },
  {
    "id": "C-04",
    "bucket": "newbie",
    "briefing": "Аккумулятор использует неверное выражение.",
    "expected_s": 6,
    "actual_s": 12,
    "code_lines": [
      "s = 0",
      "for i in range(4):",
      "    s += i * 2"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 6 },
        { "option_id": "B", "replace_line": "    s += i * 3", "result_s": 18 },
        { "option_id": "C", "replace_line": "    s += i + 2", "result_s": 14 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущая формула удваивает каждый член.",
      "Базовая сумма цикла для 0..3 равна 6."
    ]
  },
  {
    "id": "C-05",
    "bucket": "newbie",
    "briefing": "Проверка равенства должна быть проверкой диапазона.",
    "expected_s": 6,
    "actual_s": 2,
    "code_lines": [
      "s = 0",
      "for i in range(6):",
      "    if i == 2:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i <= 3:", "result_s": 6 },
        { "option_id": "B", "replace_line": "    if i < 3:", "result_s": 3 },
        { "option_id": "C", "replace_line": "    if i >= 3:", "result_s": 12 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущий код добавляет только одно значение (2).",
      "Нужно 0 + 1 + 2 + 3 = 6."
    ]
  },
  {
    "id": "C-06",
    "bucket": "newbie",
    "briefing": "Логический оператор вызывает избыточный отбор.",
    "expected_s": 1,
    "actual_s": 5,
    "code_lines": [
      "s = 0",
      "for i in range(6):",
      "    if i % 2 == 0 or i > 2:",
      "        s += 1"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 2 == 0 and i > 2:", "result_s": 1 },
        { "option_id": "B", "replace_line": "    if i % 2 == 0:", "result_s": 3 },
        { "option_id": "C", "replace_line": "    if i > 2:", "result_s": 3 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "OR слишком широк для этого фильтра.",
      "Только i = 4 удовлетворяет обоим условиям."
    ]
  },
  {
    "id": "C-07",
    "bucket": "stalker",
    "briefing": "Неверная верхняя граница цикла.",
    "expected_s": 20,
    "actual_s": 27,
    "code_lines": [
      "s = 0",
      "for i in range(2, 8):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(2, 7):", "result_s": 20 },
        { "option_id": "B", "replace_line": "for i in range(1, 7):", "result_s": 21 },
        { "option_id": "C", "replace_line": "for i in range(3, 8):", "result_s": 25 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущий диапазон включает одно лишнее значение.",
      "Диапазон 2..6 даёт ожидаемые 20."
    ]
  },
  {
    "id": "C-08",
    "bucket": "stalker",
    "briefing": "Неверный знак в убывающем цикле.",
    "expected_s": 5,
    "actual_s": 0,
    "code_lines": [
      "s = 0",
      "for i in range(5, 0, 1):",
      "    s += 1"
    ],
    "bug": {
      "correct_line_index": 1,
      "fix_options": [
        { "option_id": "A", "replace_line": "for i in range(5, 0, -1):", "result_s": 5 },
        { "option_id": "B", "replace_line": "for i in range(5, 1, -1):", "result_s": 4 },
        { "option_id": "C", "replace_line": "for i in range(6, 0, -1):", "result_s": 6 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Положительный шаг при start > stop не выполняется.",
      "Для обратного отсчёта нужен отрицательный шаг."
    ]
  },
  {
    "id": "C-09",
    "bucket": "stalker",
    "briefing": "Проверяется неверный остаток по модулю.",
    "expected_s": 4,
    "actual_s": 3,
    "code_lines": [
      "s = 0",
      "for i in range(10):",
      "    if i % 3 == 1:",
      "        s += 1"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 3 == 0:", "result_s": 4 },
        { "option_id": "B", "replace_line": "    if i % 3 == 2:", "result_s": 3 },
        { "option_id": "C", "replace_line": "    if i % 3 != 0:", "result_s": 6 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Нужны кратные 3.",
      "В 0..9 это 0, 3, 6, 9."
    ]
  },
  {
    "id": "C-10",
    "bucket": "stalker",
    "briefing": "Аккумулятор стартует с неверного значения.",
    "expected_s": 15,
    "actual_s": 16,
    "code_lines": [
      "s = 1",
      "for i in range(1, 6):",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 0,
      "fix_options": [
        { "option_id": "A", "replace_line": "s = 0", "result_s": 15 },
        { "option_id": "B", "replace_line": "s = 2", "result_s": 17 },
        { "option_id": "C", "replace_line": "s = 5", "result_s": 20 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Тело цикла верное.",
      "Начальное значение накопителя должно быть нулём."
    ]
  },
  {
    "id": "C-11",
    "bucket": "stalker",
    "briefing": "Оператор обновления инвертирован.",
    "expected_s": 10,
    "actual_s": -10,
    "code_lines": [
      "s = 0",
      "for i in range(1, 5):",
      "    s -= i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 10 },
        { "option_id": "B", "replace_line": "    s *= i", "result_s": 0 },
        { "option_id": "C", "replace_line": "    s = i", "result_s": 4 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Вычитание меняет знак ожидаемого результата.",
      "Сложение возвращает ожидаемую сумму."
    ]
  },
  {
    "id": "C-12",
    "bucket": "stalker",
    "briefing": "Отрицание в проверке чётности неверно.",
    "expected_s": 6,
    "actual_s": 9,
    "code_lines": [
      "s = 0",
      "for i in range(6):",
      "    if i % 2 != 0:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 2 == 0:", "result_s": 6 },
        { "option_id": "B", "replace_line": "    if i % 2 != 0:", "result_s": 9 },
        { "option_id": "C", "replace_line": "    if i > 2:", "result_s": 12 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущая ветка суммирует нечётные значения.",
      "Ожидаемое значение требует чётных."
    ]
  },
  {
    "id": "C-13",
    "bucket": "master",
    "briefing": "Составное условие исключает границу.",
    "expected_s": 18,
    "actual_s": 12,
    "code_lines": [
      "s = 0",
      "for i in range(1, 8):",
      "    if i > 2 and i < 6:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i > 2 and i <= 6:", "result_s": 18 },
        { "option_id": "B", "replace_line": "    if i >= 2 and i <= 6:", "result_s": 20 },
        { "option_id": "C", "replace_line": "    if i > 3 and i <= 6:", "result_s": 15 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущее условие отсекает i = 6.",
      "Нужна включающая верхняя граница."
    ]
  },
  {
    "id": "C-14",
    "bucket": "master",
    "briefing": "Неверная арифметика в накоплении.",
    "expected_s": 12,
    "actual_s": 6,
    "code_lines": [
      "s = 0",
      "for i in range(0, 8, 2):",
      "    s += i / 2"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 12 },
        { "option_id": "B", "replace_line": "    s += i * 2", "result_s": 24 },
        { "option_id": "C", "replace_line": "    s += i / 4", "result_s": 3 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Деление уменьшает каждый вклад вдвое.",
      "Нужна прямая аккумуляция i."
    ]
  },
  {
    "id": "C-15",
    "bucket": "master",
    "briefing": "Сдвинутый член в обновлении ломает цель.",
    "expected_s": 15,
    "actual_s": 10,
    "code_lines": [
      "s = 0",
      "for i in range(1, 6):",
      "    s += i - 1"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 15 },
        { "option_id": "B", "replace_line": "    s += i + 1", "result_s": 20 },
        { "option_id": "C", "replace_line": "    s += i - 2", "result_s": 5 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Вычитание 1 из каждого члена занижает сумму.",
      "Используйте исходное i для ожидаемой суммы."
    ]
  },
  {
    "id": "C-16",
    "bucket": "master",
    "briefing": "Управление потоком останавливает цикл слишком рано.",
    "expected_s": 45,
    "actual_s": 39,
    "code_lines": [
      "s = 0",
      "for i in range(1, 10):",
      "    if i == 6:",
      "        continue",
      "    s += i"
    ],
    "bug": {
      "correct_line_index": 3,
      "fix_options": [
        { "option_id": "A", "replace_line": "        pass", "result_s": 45 },
        { "option_id": "B", "replace_line": "        break", "result_s": 15 },
        { "option_id": "C", "replace_line": "        s += 0", "result_s": 39 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "continue исключает i = 6 из суммы.",
      "В этой ветке переход не нужен."
    ]
  },
  {
    "id": "C-17",
    "bucket": "master",
    "briefing": "Использовано присваивание вместо накопления.",
    "expected_s": 15,
    "actual_s": 5,
    "code_lines": [
      "s = 0",
      "for i in range(1, 6):",
      "    s = i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    s += i", "result_s": 15 },
        { "option_id": "B", "replace_line": "    s *= i", "result_s": 0 },
        { "option_id": "C", "replace_line": "    s = s + 1", "result_s": 5 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "Текущий код перезаписывает s на каждой итерации.",
      "Нужно аддитивное обновление."
    ]
  },
  {
    "id": "C-18",
    "bucket": "master",
    "briefing": "Финальный логический оператор в условии неверный.",
    "expected_s": 6,
    "actual_s": 15,
    "code_lines": [
      "s = 0",
      "for i in range(1, 8):",
      "    if i % 2 == 0 or i % 3 == 0:",
      "        s += i"
    ],
    "bug": {
      "correct_line_index": 2,
      "fix_options": [
        { "option_id": "A", "replace_line": "    if i % 2 == 0 and i % 3 == 0:", "result_s": 6 },
        { "option_id": "B", "replace_line": "    if i % 2 == 0:", "result_s": 12 },
        { "option_id": "C", "replace_line": "    if i % 3 == 0:", "result_s": 9 }
      ],
      "correct_option_id": "A"
    },
    "explain_short": [
      "OR захватывает слишком много лишних значений.",
      "AND оставляет только числа, делящиеся и на 2, и на 3."
    ]
  }
]
</file>

<file path="project.godot">
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="UNTformatic"
run/main_scene="res://scenes/MainMenu.tscn"
config/features=PackedStringArray("4.3", "Mobile")
config/icon="res://icon.svg"

[autoload]

GlobalMetrics="*res://scripts/GlobalMetrics.gd"
AudioManager="*res://scripts/AudioManager.gd"

[display]

window/size/viewport_width=1280
window/size/viewport_height=720
window/stretch/mode="canvas_items"
window/stretch/aspect="expand"
window/handheld/orientation=4

[input_devices]

pointing/emulate_touch_from_mouse=true

[rendering]

renderer/rendering_method="compatibility"
textures/vram_compression/import_etc2_astc=true
environment/defaults/default_clear_color=Color(0.06, 0.07, 0.08, 1)
</file>

<file path="scenes/case_01/DigitalResusQuestA.tscn">
[gd_scene load_steps=8 format=3]

[ext_resource type="Script" path="res://scenes/case_01/DigitalResusQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="Script" path="res://scripts/ui/ResusDropZone.gd" id="3_drop"]
[ext_resource type="Script" path="res://scripts/ui/ResusPileZone.gd" id="4_pile"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="5_noir"]
[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_dimmer"]
bg_color = Color(0, 0, 0, 0.65)

[node name="DigitalResusQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)
[node name="NoirOverlay" parent="." instance=ExtResource("5_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(72, 72)
layout_mode = 2
text = "<"

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(220, 28)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
text = "Брифинг"
autowrap_mode = 3

[node name="SystemCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="SystemVBox" type="VBoxContainer" parent="SafeArea/MainVBox/SystemCard"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="MonitorFrame" type="PanelContainer" parent="SafeArea/MainVBox/SystemCard/SystemVBox"]
custom_minimum_size = Vector2(0, 150)
layout_mode = 2

[node name="MonitorScreen" type="ColorRect" parent="SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.03, 1)

[node name="MonitorLabel" type="Label" parent="SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame"]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -110.0
offset_top = -16.0
offset_right = 110.0
offset_bottom = 16.0
grow_horizontal = 2
grow_vertical = 2
text = "NO SIGNAL"
horizontal_alignment = 1
vertical_alignment = 1

[node name="BootConsole" type="RichTextLabel" parent="SafeArea/MainVBox/SystemCard/SystemVBox"]
custom_minimum_size = Vector2(0, 180)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="ZonesCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ZonesVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="ZoneInput" type="PanelContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
script = ExtResource("3_drop")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput/VBox"]
layout_mode = 2
text = "ВВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ZoneOutput" type="PanelContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
script = ExtResource("3_drop")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput/VBox"]
layout_mode = 2
text = "ВЫВОД"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ZoneMemory" type="PanelContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
script = ExtResource("3_drop")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory/VBox"]
layout_mode = 2
text = "ПАМЯТЬ"

[node name="ItemsFlow" type="HFlowContainer" parent="SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="PartsPileCard" type="PanelContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("4_pile")
items_container_path = NodePath("VBox/Scroll/PartsGrid")

[node name="VBox" type="VBoxContainer" parent="SafeArea/MainVBox/PartsPileCard"]
layout_mode = 2

[node name="BucketTitle" type="Label" parent="SafeArea/MainVBox/PartsPileCard/VBox"]
layout_mode = 2
text = "ДЕТАЛИ"

[node name="Scroll" type="ScrollContainer" parent="SafeArea/MainVBox/PartsPileCard/VBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PartsGrid" type="GridContainer" parent="SafeArea/MainVBox/PartsPileCard/VBox/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(160, 72)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(180, 72)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"

[node name="Dimmer" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.65)
mouse_filter = 2

[node name="ResultPopup" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -190.0
offset_top = -140.0
offset_right = 190.0
offset_bottom = 140.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBox" type="VBoxContainer" parent="ResultPopup"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="VerdictLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ВЕРДИКТ"
horizontal_alignment = 1

[node name="ScoreLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СЧЁТ"
horizontal_alignment = 1

[node name="StabilityLabel" type="Label" parent="ResultPopup/VBox"]
layout_mode = 2
text = "СТАБИЛЬНОСТЬ"
horizontal_alignment = 1

[node name="Buttons" type="HBoxContainer" parent="ResultPopup/VBox"]
layout_mode = 2
alignment = 1
theme_override_constants/separation = 12

[node name="BtnRetry" type="Button" parent="ResultPopup/VBox/Buttons"]
custom_minimum_size = Vector2(140, 56)
layout_mode = 2
text = "ПОВТОРИТЬ"

[node name="BtnBack" type="Button" parent="ResultPopup/VBox/Buttons"]
custom_minimum_size = Vector2(140, 56)
layout_mode = 2
text = "НАЗАД"
</file>

<file path="scenes/case_01/DigitalResusQuestB.gd">
extends Control

const LEVELS_PATH := "res://data/clues_levels.json"
const CONFIG_CARD_SCENE := preload("res://scenes/ui/ConfigCard.tscn")
const ResusData := preload("res://scripts/case_01/ResusData.gd")
const ResusScoring := preload("res://scripts/case_01/ResusScoring.gd")

const COLOR_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_WARN := Color(0.86, 0.73, 0.56, 1.0)
const COLOR_ERR := Color(0.93, 0.34, 0.38, 1.0)

var stage_b_data: Dictionary = {}
var options_by_id: Dictionary = {}
var option_cards_by_id: Dictionary = {}

var selected_option_id: String = ""
var trace: Array = []
var stage_started_ms: int = 0
var time_to_first_select_ms: int = -1
var selection_count: int = 0
var attempt_index: int = 0
var input_locked: bool = false

@onready var title_label: Label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label: Label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainVBox/Header/StabilityBar
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack

@onready var context_label: Label = $SafeArea/MainVBox/ContextCard/ContextVBox/ContextLabel
@onready var budget_label: Label = $SafeArea/MainVBox/ContextCard/ContextVBox/BudgetRow/BudgetValue

@onready var options_vbox: VBoxContainer = $SafeArea/MainVBox/OptionsCard/Scroll/OptionsVBox

@onready var diagnostic_card: PanelContainer = $SafeArea/MainVBox/DiagnosticCard
@onready var diag_headline: Label = $SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox/DiagHeadline
@onready var diag_body: RichTextLabel = $SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox/DiagBody
@onready var diag_hint: Label = $SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox/DiagHint

@onready var status_label: Label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainVBox/BottomBar/BtnConfirm

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)

	stage_b_data = ResusData.load_stage_b(LEVELS_PATH)
	if stage_b_data.is_empty():
		_show_error("Этап B не загрузился: проверьте данные уровня.")
		return

	_setup_ui()
	_begin_attempt()

func _setup_ui() -> void:
	title_label.text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
	stage_label.text = "ЭТАП B"
	btn_reset.text = "СБРОС"
	btn_confirm.text = "ПОДТВЕРДИТЬ"

	context_label.text = str(stage_b_data.get("context", ""))
	budget_label.text = "%d$" % int(stage_b_data.get("budget", 0))
	_update_stability_ui()
	_build_option_cards()

func _build_option_cards() -> void:
	for child in options_vbox.get_children():
		child.queue_free()
	options_by_id.clear()
	option_cards_by_id.clear()

	var budget: int = int(stage_b_data.get("budget", 0))
	var options: Array = stage_b_data.get("options", []) as Array
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", ""))
		if option_id == "":
			continue
		options_by_id[option_id] = option_data

		var card_node: Node = CONFIG_CARD_SCENE.instantiate()
		if not (card_node is PanelContainer):
			continue
		var card: PanelContainer = card_node as PanelContainer
		options_vbox.add_child(card)
		if card.has_method("setup"):
			card.call("setup", option_data, budget)
		if card.has_signal("selected"):
			card.connect("selected", Callable(self, "_on_option_selected"))
		option_cards_by_id[option_id] = card

func _begin_attempt() -> void:
	selected_option_id = ""
	trace.clear()
	selection_count = 0
	time_to_first_select_ms = -1
	stage_started_ms = Time.get_ticks_msec()
	input_locked = false
	btn_confirm.disabled = true
	diagnostic_card.visible = true
	status_label.text = "Выберите конфигурацию и проверьте прогноз до подтверждения."
	status_label.modulate = COLOR_WARN
	_update_selection_visuals()
	_set_option_lock_state(false)
	_show_preview()

func _on_option_selected(option_id: String) -> void:
	if input_locked:
		return
	selected_option_id = option_id
	selection_count += 1
	if time_to_first_select_ms < 0:
		time_to_first_select_ms = Time.get_ticks_msec() - stage_started_ms
	_log_event("SELECT_OPTION", {
		"option_id": option_id,
		"selection_index": selection_count
	})
	_update_selection_visuals()
	btn_confirm.disabled = false
	status_label.text = "Выбрано: %s" % option_id
	status_label.modulate = COLOR_WARN
	_show_preview()
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _update_selection_visuals() -> void:
	for option_id_v in option_cards_by_id.keys():
		var option_id: String = str(option_id_v)
		var card_v: Variant = option_cards_by_id[option_id]
		if card_v == null:
			continue
		if card_v.has_method("set_selected_state"):
			card_v.call("set_selected_state", option_id == selected_option_id)

func _set_option_lock_state(locked: bool) -> void:
	for card_v in option_cards_by_id.values():
		if card_v == null:
			continue
		if card_v.has_method("set_locked"):
			card_v.call("set_locked", locked)

func _on_confirm_pressed() -> void:
	if input_locked:
		return
	_log_event("CONFIRM_PRESSED", {
		"option_id": selected_option_id,
		"has_selection": selected_option_id != ""
	})

	var snapshot: Dictionary = {"selected_option_id": selected_option_id}
	var result: Dictionary = ResusScoring.calculate_stage_b_result(stage_b_data, snapshot)
	_register_trial(result)
	_show_diagnostic(result)
	_update_stability_ui()
	attempt_index += 1

	input_locked = true
	_set_option_lock_state(true)
	btn_confirm.disabled = true

	if bool(result.get("is_correct", false)):
		if has_node("/root/AudioManager"):
			AudioManager.play("relay")
	else:
		if has_node("/root/AudioManager"):
			AudioManager.play("error")

func _on_reset_pressed() -> void:
	_log_event("RESET_PRESSED", {"prev_option_id": selected_option_id})
	if input_locked:
		_begin_attempt()
		return
	selected_option_id = ""
	_update_selection_visuals()
	btn_confirm.disabled = true
	_show_preview()
	status_label.text = "Выбор сброшен."
	status_label.modulate = COLOR_WARN
	if has_node("/root/AudioManager"):
		AudioManager.play("click")

func _show_preview() -> void:
	diagnostic_card.visible = true
	if selected_option_id == "":
		diag_headline.text = "Прогноз конфигурации"
		diag_headline.modulate = COLOR_WARN
		diag_body.text = "\n".join([
			"- Рендер-поток: ?",
			"- Бюджет: ?",
			"- Узкое место: ?"
		])
		diag_hint.text = "Выберите один вариант, чтобы увидеть прогноз."
		diag_hint.modulate = COLOR_WARN
		return

	var option_data: Dictionary = _selected_option_data()
	var preview: Dictionary = _build_preview(option_data)
	var render_stream: String = str(preview.get("render_stream", "WARNING"))
	var budget_status: String = str(preview.get("budget_status", "UNKNOWN"))
	var bottleneck: String = str(preview.get("bottleneck", "UNKNOWN"))
	var total_price: int = int(option_data.get("total_price", 0))
	var budget: int = int(stage_b_data.get("budget", 0))

	diag_headline.text = "Прогноз до подтверждения"
	diag_headline.modulate = _render_status_color(render_stream)
	diag_body.text = "\n".join([
		"- Рендер-поток: %s" % render_stream,
		"- Бюджет: %d$ / %d$ (%s)" % [total_price, budget, budget_status],
		"- Узкое место: %s" % bottleneck
	])
	diag_hint.text = str(preview.get("hint", ""))
	diag_hint.modulate = COLOR_WARN if render_stream != "OK" else COLOR_OK

func _build_preview(option_data: Dictionary) -> Dictionary:
	var budget: int = int(stage_b_data.get("budget", 0))
	var total_price: int = int(option_data.get("total_price", 0))
	var cpu_price: int = _part_price(option_data, "CPU")
	var ram_price: int = _part_price(option_data, "RAM")
	var gpu_price: int = _part_price(option_data, "GPU")

	var render_stream: String = "OK"
	var budget_status: String = "IN_RANGE"
	var bottleneck: String = "NONE"
	var hint: String = "Конфигурация выглядит сбалансированно."

	if total_price > budget:
		render_stream = "FAIL"
		budget_status = "OVER"
		bottleneck = "BUDGET"
		hint = "Превышение бюджета даже при нормальной производительности."
	elif cpu_price >= 500 and ram_price <= 120:
		render_stream = "WARNING"
		bottleneck = "RAM"
		hint = "Сильный CPU упирается в слабую RAM."
	elif cpu_price <= 220 and ram_price <= 140 and gpu_price <= 180:
		render_stream = "FAIL"
		bottleneck = "CPU"
		hint = "Конфигурация слишком слабая для цели."
	elif ram_price <= 140:
		render_stream = "WARNING"
		bottleneck = "RAM"
		hint = "Есть риск ограничения по памяти."
	elif gpu_price > 0 and gpu_price <= 180:
		render_stream = "WARNING"
		bottleneck = "GPU"
		hint = "Рендер будет работать, но есть запас для GPU."

	return {
		"render_stream": render_stream,
		"budget_status": budget_status,
		"bottleneck": bottleneck,
		"hint": hint
	}

func _part_price(option_data: Dictionary, key: String) -> int:
	var parts: Array = option_data.get("parts", []) as Array
	for part_v in parts:
		if typeof(part_v) != TYPE_DICTIONARY:
			continue
		var part: Dictionary = part_v as Dictionary
		if str(part.get("k", "")).to_upper() == key.to_upper():
			return int(part.get("price", 0))
	return 0

func _render_status_color(render_stream: String) -> Color:
	match render_stream:
		"OK":
			return COLOR_OK
		"WARNING":
			return COLOR_WARN
		_:
			return COLOR_ERR

func _selected_option_data() -> Dictionary:
	return options_by_id.get(selected_option_id, {}) as Dictionary

func _register_trial(result: Dictionary) -> void:
	var elapsed_ms: int = Time.get_ticks_msec() - stage_started_ms
	var option_data: Dictionary = _selected_option_data()
	var preview: Dictionary = _build_preview(option_data) if not option_data.is_empty() else {}
	var payload: Dictionary = {
		"quest_id": "CASE_01_DIGITAL_RESUS",
		"stage": "B",
		"format": "SINGLE_CHOICE_CONTEXT",
		"level_id": str(stage_b_data.get("id", "CASE01_B_01")),
		"match_key": "CASE01_B_%d" % attempt_index,
		"context": str(stage_b_data.get("context", "")),
		"budget": int(stage_b_data.get("budget", 0)),
		"selected_option_id": selected_option_id,
		"total_price": int(option_data.get("total_price", 0)),
		"selection_count": selection_count,
		"time_to_first_select_ms": max(-1, time_to_first_select_ms),
		"elapsed_ms": elapsed_ms,
		"points": int(result.get("points", 0)),
		"max_points": int(result.get("max_points", 2)),
		"is_correct": bool(result.get("is_correct", false)),
		"is_fit": bool(result.get("is_fit", false)),
		"stability_delta": int(result.get("stability_delta", 0)),
		"verdict_code": str(result.get("verdict_code", "WRONG")),
		"error_code": str(result.get("error_code", "UNKNOWN")),
		"diagnostic_headline": str(result.get("diagnostic_headline", "")),
		"diagnostic_details": (result.get("diagnostic_details", []) as Array).duplicate(),
		"preview_render_stream": str(preview.get("render_stream", "UNKNOWN")),
		"preview_budget_status": str(preview.get("budget_status", "UNKNOWN")),
		"preview_bottleneck": str(preview.get("bottleneck", "UNKNOWN")),
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)

func _show_diagnostic(result: Dictionary) -> void:
	diagnostic_card.visible = true
	var is_correct: bool = bool(result.get("is_correct", false))
	var headline: String = str(result.get("diagnostic_headline", ""))
	var details: Array = result.get("diagnostic_details", []) as Array
	var option_data: Dictionary = _selected_option_data()
	var preview: Dictionary = _build_preview(option_data) if not option_data.is_empty() else {}

	diag_headline.text = headline
	diag_headline.modulate = COLOR_OK if is_correct else COLOR_ERR

	var detail_lines: Array[String] = []
	detail_lines.append("- Рендер-поток: %s" % str(preview.get("render_stream", "UNKNOWN")))
	detail_lines.append("- Бюджет: %d$ / %d$" % [int(option_data.get("total_price", 0)), int(stage_b_data.get("budget", 0))])
	detail_lines.append("- Узкое место: %s" % str(preview.get("bottleneck", "UNKNOWN")))
	detail_lines.append("")
	for detail_v in details:
		detail_lines.append("- %s" % str(detail_v))
	diag_body.text = "\n".join(detail_lines)

	var hint_text: String = ""
	var budget: int = int(stage_b_data.get("budget", 0))
	var total_price: int = int(option_data.get("total_price", 0))
	if total_price > budget:
		hint_text = "Превышение бюджета: +%d$." % (total_price - budget)
	elif selected_option_id == "":
		hint_text = "Сначала выберите один вариант."
	else:
		hint_text = "Можно сделать сброс и проверить другую конфигурацию."
	diag_hint.text = hint_text
	diag_hint.modulate = COLOR_WARN

	status_label.text = "Разбор зафиксирован. Для новой попытки нажмите СБРОС."
	status_label.modulate = COLOR_OK if is_correct else COLOR_WARN

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - stage_started_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _show_error(message: String) -> void:
	status_label.text = message
	status_label.modulate = COLOR_ERR
	btn_confirm.disabled = true
	btn_reset.disabled = true
	await get_tree().create_timer(1.2).timeout
	_on_back_pressed()
</file>

<file path="scenes/case_01/DigitalResusQuestB.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/case_01/DigitalResusQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="DigitalResusQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(72, 72)
layout_mode = 2
text = "<"

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ЗАГОЛОВОК"
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
text = "B"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(220, 28)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="ContextCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="ContextVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContextCard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ContextLabel" type="Label" parent="SafeArea/MainVBox/ContextCard/ContextVBox"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
text = "Контекст"
autowrap_mode = 2

[node name="BudgetRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContextCard/ContextVBox"]
layout_mode = 2

[node name="BudgetLabel" type="Label" parent="SafeArea/MainVBox/ContextCard/ContextVBox/BudgetRow"]
layout_mode = 2
text = "Бюджет:"

[node name="BudgetValue" type="Label" parent="SafeArea/MainVBox/ContextCard/ContextVBox/BudgetRow"]
layout_mode = 2
text = "0$"

[node name="OptionsCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Scroll" type="ScrollContainer" parent="SafeArea/MainVBox/OptionsCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="OptionsVBox" type="VBoxContainer" parent="SafeArea/MainVBox/OptionsCard/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="DiagnosticCard" type="PanelContainer" parent="SafeArea/MainVBox"]
visible = false
custom_minimum_size = Vector2(0, 170)
layout_mode = 2

[node name="DiagnosticVBox" type="VBoxContainer" parent="SafeArea/MainVBox/DiagnosticCard"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="DiagHeadline" type="Label" parent="SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Заголовок"

[node name="DiagBody" type="RichTextLabel" parent="SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox"]
custom_minimum_size = Vector2(0, 82)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="DiagHint" type="Label" parent="SafeArea/MainVBox/DiagnosticCard/DiagnosticVBox"]
layout_mode = 2
text = "Подсказка"
autowrap_mode = 2

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(160, 72)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(220, 72)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"
</file>

<file path="scenes/case_01/DigitalResusQuestC.gd">
extends Control

const LEVELS_PATH := "res://data/clues_levels.json"
const NET_ITEM_SCENE := preload("res://scenes/ui/NetItem.tscn")
const ResusData := preload("res://scripts/case_01/ResusData.gd")
const ResusScoring := preload("res://scripts/case_01/ResusScoring.gd")

const COLOR_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_WARN := Color(0.86, 0.73, 0.56, 1.0)
const COLOR_ERR := Color(0.93, 0.34, 0.38, 1.0)

var stage_c_data: Dictionary = {}
var option_by_id: Dictionary = {}
var correct_set: Dictionary = {}
var option_order: Array[String] = []

var item_nodes_by_option: Dictionary = {}
var slot_item_by_index: Dictionary = {}
var slots: Array[String] = ["", "", ""]

var trace: Array = []
var stage_started_ms: int = 0
var attempt_index: int = 0
var drag_count: int = 0
var slot_change_count: int = 0
var unique_used_set: Dictionary = {}
var time_to_first_action_ms: int = -1
var input_locked: bool = false

@onready var title_label: Label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label: Label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainVBox/Header/StabilityBar
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack

@onready var prompt_label: Label = $SafeArea/MainVBox/PromptCard/PromptLabel

@onready var slot_1: Node = $SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/Slot1
@onready var slot_2: Node = $SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/Slot2
@onready var slot_3: Node = $SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/Slot3

@onready var collisions_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/CollisionsRow/CollisionsValue
@onready var eavesdrop_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/EavesdropRow/EavesdropValue
@onready var filtering_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/FilteringRow/FilteringValue
@onready var media_value: Label = $SafeArea/MainVBox/RiskCard/RiskVBox/MediaRow/MediaValue

@onready var palette_flow: GridContainer = $SafeArea/MainVBox/PaletteCard/PaletteVBox/Scroll/PaletteFlow

@onready var explanation_card: PanelContainer = $SafeArea/MainVBox/ExplanationCard
@onready var expl_headline: Label = $SafeArea/MainVBox/ExplanationCard/ExplVBox/ExplHeadline
@onready var expl_details: RichTextLabel = $SafeArea/MainVBox/ExplanationCard/ExplVBox/ExplDetails
@onready var expl_why: RichTextLabel = $SafeArea/MainVBox/ExplanationCard/ExplVBox/ExplWhy

@onready var status_label: Label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_analyze: Button = $SafeArea/MainVBox/BottomBar/BtnAnalyze

var _slot_nodes: Array[Node] = []

func _ready() -> void:
	add_to_group("resus_c_controller")

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_slot_nodes = [slot_1, slot_2, slot_3]

	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)

	stage_c_data = ResusData.load_stage_c(LEVELS_PATH)
	if stage_c_data.is_empty():
		_show_error("Данные этапа C некорректны. Возврат в меню.")
		return

	_setup_ui()
	_begin_attempt()
	_on_viewport_size_changed()

func _setup_ui() -> void:
	title_label.text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
	stage_label.text = "ЭТАП C"
	btn_reset.text = "СБРОС"
	btn_analyze.text = "АНАЛИЗ"
	prompt_label.text = str(stage_c_data.get("prompt", ""))

	_build_option_catalog()
	_build_palette()
	_setup_slots()
	_update_risk_dashboard()
	_update_stability_ui()

func _build_option_catalog() -> void:
	option_by_id.clear()
	correct_set.clear()
	option_order.clear()

	var options: Array = stage_c_data.get("options", []) as Array
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", "")).strip_edges()
		if option_id == "":
			continue
		option_by_id[option_id] = option_data
		option_order.append(option_id)
		if bool(option_data.get("is_correct", false)):
			correct_set[option_id] = true

func _build_palette() -> void:
	for child in palette_flow.get_children():
		child.queue_free()
	item_nodes_by_option.clear()

	for option_id in option_order:
		var option_data: Dictionary = option_by_id.get(option_id, {}) as Dictionary
		var node_v: Variant = NET_ITEM_SCENE.instantiate()
		if not (node_v is Control):
			continue
		var item_node: Control = node_v as Control
		palette_flow.add_child(item_node)
		if item_node.has_method("setup"):
			item_node.call("setup", option_data)
		if item_node.has_method("set_source"):
			item_node.call("set_source", "PALETTE", -1)
		if item_node.has_signal("drag_started"):
			item_node.connect("drag_started", Callable(self, "_on_item_drag_started"))
		item_nodes_by_option[option_id] = item_node

	_sort_palette_items()

func _setup_slots() -> void:
	for i in range(_slot_nodes.size()):
		var slot_node: Node = _slot_nodes[i]
		if slot_node == null:
			continue
		if slot_node.has_method("set_slot_title"):
			slot_node.call("set_slot_title", i + 1)
		if slot_node.has_method("set_current_option"):
			slot_node.call("set_current_option", "", "")
		if slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", "neutral")
		if slot_node.has_method("set_locked"):
			slot_node.call("set_locked", false)

func _begin_attempt() -> void:
	trace.clear()
	drag_count = 0
	slot_change_count = 0
	unique_used_set.clear()
	time_to_first_action_ms = -1
	stage_started_ms = Time.get_ticks_msec()
	input_locked = false

	explanation_card.visible = false
	btn_analyze.disabled = false

	slots = ["", "", ""]
	slot_item_by_index.clear()

	for option_id in option_order:
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if not (item_v is Control):
			continue
		var item_node: Control = item_v as Control
		if item_node.get_parent() != palette_flow:
			item_node.reparent(palette_flow)
		if item_node.has_method("set_source"):
			item_node.call("set_source", "PALETTE", -1)
		if item_node.has_method("set_feedback_state"):
			item_node.call("set_feedback_state", "neutral")
		if item_node.has_method("set_locked"):
			item_node.call("set_locked", false)

	_sort_palette_items()

	for i in range(_slot_nodes.size()):
		var slot_node: Node = _slot_nodes[i]
		if slot_node == null:
			continue
		if slot_node.has_method("set_current_option"):
			slot_node.call("set_current_option", "", "")
		if slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", "neutral")
		if slot_node.has_method("set_locked"):
			slot_node.call("set_locked", false)

	_update_status_line("Соберите защищённый периметр")
	_update_risk_dashboard()
	_update_stability_ui()

func is_input_locked() -> bool:
	return input_locked

func handle_drop_to_slot(slot_index: int, data: Dictionary) -> Dictionary:
	if input_locked:
		return {"success": false}
	if not _is_slot_index_valid(slot_index):
		return {"success": false}
	if str(data.get("kind", "")) != "NET_ITEM":
		return {"success": false}

	var option_id: String = str(data.get("option_id", "")).strip_edges()
	if option_id == "" or not option_by_id.has(option_id):
		return {"success": false}

	var source_path: String = str(data.get("node_path", ""))
	var source_node: Node = get_node_or_null(source_path)
	if source_node == null:
		var fallback_node: Variant = item_nodes_by_option.get(option_id, null)
		if fallback_node is Node:
			source_node = fallback_node as Node
	if source_node == null or not (source_node is Control):
		return {"success": false}

	var from_slot: int = int(data.get("from_slot", -1))
	var target_idx: int = slot_index - 1
	var prev_option_id: String = slots[target_idx]

	if from_slot == slot_index and prev_option_id == option_id:
		return {
			"success": true,
			"option_id": option_id,
			"prev_option_id": prev_option_id,
			"label": str((option_by_id.get(option_id, {}) as Dictionary).get("label", option_id))
		}

	if from_slot >= 1 and from_slot <= 3 and from_slot != slot_index:
		_clear_slot_state(from_slot)

	var prev_node_v: Variant = slot_item_by_index.get(slot_index, null)
	if prev_node_v is Control and prev_node_v != source_node:
		_move_item_to_palette(prev_node_v as Control)

	_attach_item_to_slot(source_node as Control, slot_index)
	slots[target_idx] = option_id
	slot_item_by_index[slot_index] = source_node

	_mark_first_action()
	slot_change_count += 1
	unique_used_set[option_id] = true
	_log_event("SLOT_CHANGED", {
		"slot_index": slot_index,
		"option_id": option_id,
		"prev_option_id": prev_option_id
	})
	_update_status_line("")
	_update_risk_dashboard()
	_play_sfx("click")

	return {
		"success": true,
		"option_id": option_id,
		"prev_option_id": prev_option_id,
		"label": str((option_by_id.get(option_id, {}) as Dictionary).get("label", option_id))
	}

func handle_clear_slot(slot_index: int) -> Dictionary:
	if input_locked:
		return {"success": false}
	if not _is_slot_index_valid(slot_index):
		return {"success": false}

	var idx: int = slot_index - 1
	var prev_option_id: String = slots[idx]
	if prev_option_id == "":
		return {"success": false}

	var prev_node_v: Variant = slot_item_by_index.get(slot_index, null)
	if prev_node_v is Control:
		_move_item_to_palette(prev_node_v as Control)

	_clear_slot_state(slot_index)
	_mark_first_action()
	slot_change_count += 1
	_log_event("SLOT_CLEARED", {
		"slot_index": slot_index,
		"prev_option_id": prev_option_id
	})
	_update_status_line("")
	_update_risk_dashboard()
	_play_sfx("click")

	return {
		"success": true,
		"prev_option_id": prev_option_id
	}

func _attach_item_to_slot(item_node: Control, slot_index: int) -> void:
	var slot_node: Node = _get_slot_node(slot_index)
	if slot_node == null:
		return
	if slot_node.has_method("attach_item_control"):
		slot_node.call("attach_item_control", item_node)
	if item_node.has_method("set_source"):
		item_node.call("set_source", "SLOT", slot_index)
	if item_node.has_method("set_locked"):
		item_node.call("set_locked", input_locked)

func _move_item_to_palette(item_node: Control) -> void:
	if item_node.get_parent() != palette_flow:
		item_node.reparent(palette_flow)
	if item_node.has_method("set_source"):
		item_node.call("set_source", "PALETTE", -1)
	if item_node.has_method("set_locked"):
		item_node.call("set_locked", input_locked)
	if not input_locked and item_node.has_method("set_feedback_state"):
		item_node.call("set_feedback_state", "neutral")
	_sort_palette_items()

func _clear_slot_state(slot_index: int) -> void:
	if not _is_slot_index_valid(slot_index):
		return
	var idx: int = slot_index - 1
	slots[idx] = ""
	slot_item_by_index.erase(slot_index)

	var slot_node: Node = _get_slot_node(slot_index)
	if slot_node == null:
		return
	if slot_node.has_method("set_current_option"):
		slot_node.call("set_current_option", "", "")
	if not input_locked and slot_node.has_method("set_feedback_state"):
		slot_node.call("set_feedback_state", "neutral")

func _on_item_drag_started(option_id: String, source: String, from_slot: int) -> void:
	if input_locked:
		return
	_mark_first_action()
	drag_count += 1
	_log_event("DRAG_START", {
		"option_id": option_id,
		"source": source,
		"from_slot": from_slot
	})

func _on_analyze_pressed() -> void:
	if input_locked:
		return

	var filled_slots: int = _filled_slots_count()
	var unique_used_count: int = unique_used_set.size()
	_log_event("ANALYZE_PRESSED", {
		"filled_slots": filled_slots,
		"unique_used_count": unique_used_count
	})

	var selected_ids: Array[String] = _collect_selected_ids()
	var snapshot: Dictionary = {
		"slots": slots.duplicate(),
		"selected": selected_ids.duplicate(),
		"unique_used_count": unique_used_count
	}
	var result: Dictionary = ResusScoring.calculate_stage_c_result(stage_c_data, snapshot)
	var risk: Dictionary = _calculate_risk(slots)

	_register_trial(result, risk)
	_show_explanation(result, risk)
	_apply_result_highlight(result)
	_update_stability_ui()

	input_locked = true
	btn_analyze.disabled = true
	_set_input_locked(true)

	if bool(result.get("is_correct", false)):
		_play_sfx("relay")
	elif bool(result.get("is_fit", false)):
		_play_sfx("click")
	else:
		_play_sfx("error")

func _on_reset_pressed() -> void:
	_log_event("RESET_PRESSED", {
		"prev_filled_slots": _filled_slots_count()
	})
	_begin_attempt()
	_play_sfx("click")

func _set_input_locked(locked: bool) -> void:
	for slot_node in _slot_nodes:
		if slot_node != null and slot_node.has_method("set_locked"):
			slot_node.call("set_locked", locked)
	for item_v in item_nodes_by_option.values():
		if item_v is Node and item_v.has_method("set_locked"):
			(item_v as Node).call("set_locked", locked)

func _show_explanation(result: Dictionary, risk: Dictionary) -> void:
	explanation_card.visible = true

	var verdict_code: String = str(result.get("verdict_code", "FAIL"))
	expl_headline.text = str(result.get("feedback_headline", verdict_code))
	if verdict_code == "PERFECT":
		expl_headline.modulate = COLOR_OK
	elif verdict_code == "GOOD" or verdict_code == "NOISY":
		expl_headline.modulate = COLOR_WARN
	else:
		expl_headline.modulate = COLOR_ERR

	var detail_lines: Array[String] = []
	for detail_v in (result.get("feedback_details", []) as Array):
		detail_lines.append("- %s" % str(detail_v))
	detail_lines.append("")
	detail_lines.append("Сборка сети дала риск-профиль: коллизии=%s | перехват=%s | фильтрация=%s | среда=%s" % [
		_translate_risk_value(str(risk.get("collisions", "MID"))),
		_translate_risk_value(str(risk.get("eavesdrop", "MID"))),
		_translate_risk_value(str(risk.get("filtering", "OFF"))),
		_translate_risk_value(str(risk.get("media", "UNKNOWN")))
	])
	expl_details.text = "\n".join(detail_lines)

	var why_lines: Array[String] = []
	var strategy_flags: Array = result.get("strategy_flags", []) as Array
	var missing_required: Array = result.get("missing_required", []) as Array
	var wrong_selected: int = int(result.get("wrong_selected", 0))

	why_lines.append("Почему это важно:")
	if str(risk.get("filtering", "OFF")) == "OFF":
		why_lines.append("- Без фильтрации трафика периметр остается уязвимым для внешних соединений.")
	else:
		why_lines.append("- Фильтрация включена: риск несанкционированного доступа ниже.")

	if missing_required.is_empty() and wrong_selected == 0:
		why_lines.append("- Выбраны все критически важные элементы периметра.")
	elif not missing_required.is_empty():
		why_lines.append("- Не хватает ключевых звеньев: %s." % ", ".join(_to_string_array(missing_required)))
	else:
		why_lines.append("- Есть лишние или шумные выборы, они повышают общий риск периметра.")

	if strategy_flags.has("TOUCHED_ALL_OPTIONS"):
		why_lines.append("")
		why_lines.append("Зафиксирована переборная стратегия (использованы все варианты).")

	var explain_selected: Array = result.get("explain_selected", []) as Array
	if not explain_selected.is_empty():
		why_lines.append("")
		why_lines.append("Разбор выбранных элементов:")
		for explain_v in explain_selected:
			if typeof(explain_v) != TYPE_DICTIONARY:
				continue
			var explain_item: Dictionary = explain_v as Dictionary
			var marker: String = "[OK]" if bool(explain_item.get("is_correct", false)) else "[X]"
			why_lines.append("%s %s: %s" % [
				marker,
				str(explain_item.get("label", explain_item.get("option_id", "?"))),
				str(explain_item.get("why", ""))
			])

	expl_why.text = "\n".join(why_lines)

	status_label.text = "Результат: %s | Установлено: %d/3" % [verdict_code, _filled_slots_count()]
	status_label.modulate = expl_headline.modulate

func _apply_result_highlight(result: Dictionary) -> void:
	for i in range(1, 4):
		var slot_node: Node = _get_slot_node(i)
		if slot_node != null and slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", "neutral")

	for option_id in option_order:
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if item_v is Node and (item_v as Node).has_method("set_feedback_state"):
			(item_v as Node).call("set_feedback_state", "neutral")

	for i in range(3):
		var option_id: String = slots[i]
		if option_id == "":
			continue
		var state: String = "correct" if correct_set.has(option_id) else "wrong"
		var slot_node: Node = _get_slot_node(i + 1)
		if slot_node != null and slot_node.has_method("set_feedback_state"):
			slot_node.call("set_feedback_state", state)
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if item_v is Node and (item_v as Node).has_method("set_feedback_state"):
			(item_v as Node).call("set_feedback_state", state)

	for missing_id_v in (result.get("missing_required", []) as Array):
		var missing_id: String = str(missing_id_v)
		if _is_option_in_slots(missing_id):
			continue
		var missing_node_v: Variant = item_nodes_by_option.get(missing_id, null)
		if missing_node_v is Node and (missing_node_v as Node).has_method("set_feedback_state"):
			(missing_node_v as Node).call("set_feedback_state", "missing")

func _register_trial(result: Dictionary, risk: Dictionary) -> void:
	var elapsed_ms: int = Time.get_ticks_msec() - stage_started_ms
	var selected_ids: Array[String] = _collect_selected_ids()
	var payload: Dictionary = {
		"quest_id": "CASE_01_DIGITAL_RESUS",
		"stage": "C",
		"format": "MULTI_CHOICE_SLOTS",
		"level_id": str(stage_c_data.get("id", "CASE01_C_01")),
		"match_key": "CASE01_C_%d" % attempt_index,
		"prompt": str(stage_c_data.get("prompt", "")),
		"slots": slots.duplicate(),
		"selected": selected_ids.duplicate(),
		"selected_count": int(result.get("selected_count", selected_ids.size())),
		"correct_selected": int(result.get("correct_selected", 0)),
		"wrong_selected": int(result.get("wrong_selected", 0)),
		"risk": risk.duplicate(),
		"points": int(result.get("points", 0)),
		"max_points": int(result.get("max_points", 2)),
		"is_correct": bool(result.get("is_correct", false)),
		"is_fit": bool(result.get("is_fit", false)),
		"stability_delta": int(result.get("stability_delta", 0)),
		"verdict_code": str(result.get("verdict_code", "FAIL")),
		"missing_required": _to_string_array(result.get("missing_required", []) as Array),
		"drag_count": drag_count,
		"slot_change_count": slot_change_count,
		"unique_used_count": unique_used_set.size(),
		"strategy_flags": _to_string_array(result.get("strategy_flags", []) as Array),
		"time_to_first_action_ms": max(-1, time_to_first_action_ms),
		"elapsed_ms": elapsed_ms,
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	attempt_index += 1

func _update_status_line(prefix: String) -> void:
	if input_locked:
		return
	var filled: int = _filled_slots_count()
	var used_unique: int = unique_used_set.size()
	if prefix.strip_edges() == "":
		status_label.text = "Установлено: %d/3 | Использовано уникальных: %d" % [filled, used_unique]
	else:
		status_label.text = "%s | Установлено: %d/3 | Использовано уникальных: %d" % [prefix, filled, used_unique]
	status_label.modulate = COLOR_WARN

func _update_risk_dashboard() -> void:
	var risk: Dictionary = _calculate_risk(slots)
	var collisions_raw: String = str(risk.get("collisions", "MID"))
	var eavesdrop_raw: String = str(risk.get("eavesdrop", "MID"))
	var filtering_raw: String = str(risk.get("filtering", "OFF"))
	var media_raw: String = str(risk.get("media", "UNKNOWN"))

	collisions_value.text = _translate_risk_value(collisions_raw)
	eavesdrop_value.text = _translate_risk_value(eavesdrop_raw)
	filtering_value.text = _translate_risk_value(filtering_raw)
	media_value.text = _translate_risk_value(media_raw)

	collisions_value.modulate = _risk_color("collisions", collisions_raw)
	eavesdrop_value.modulate = _risk_color("eavesdrop", eavesdrop_raw)
	filtering_value.modulate = _risk_color("filtering", filtering_raw)
	media_value.modulate = _risk_color("media", media_raw)

func _translate_risk_value(value: String) -> String:
	match value:
		"LOW":
			return "НИЗКИЙ"
		"MID":
			return "СРЕДНИЙ"
		"HIGH":
			return "ВЫСОКИЙ"
		"ON":
			return "ВКЛ"
		"OFF":
			return "ВЫКЛ"
		"NEUTRAL":
			return "НЕЙТРАЛЬНО"
		"UNKNOWN":
			return "НЕИЗВЕСТНО"
		"FIBER":
			return "ОПТИКА"
		"COAX":
			return "КОАКСИАЛ"
		_:
			return value

func _calculate_risk(slot_values: Array[String]) -> Dictionary:
	var selected_set: Dictionary = {}
	for option_id in slot_values:
		if option_id == "":
			continue
		selected_set[option_id] = true

	var collisions: String = "MID"
	if selected_set.has("HUB"):
		collisions = "HIGH"
	elif selected_set.has("SWITCH"):
		collisions = "LOW"

	var filtering: String = "ON" if selected_set.has("FIREWALL") else "OFF"

	var eavesdrop: String = "MID"
	if selected_set.has("FIBER"):
		eavesdrop = "LOW"
	elif selected_set.has("COAX"):
		eavesdrop = "HIGH"

	var media: String = "UNKNOWN"
	if selected_set.has("FIBER"):
		media = "FIBER"
	elif selected_set.has("COAX"):
		media = "COAX"

	return {
		"collisions": collisions,
		"eavesdrop": eavesdrop,
		"filtering": filtering,
		"media": media
	}

func _risk_color(kind: String, value: String) -> Color:
	match kind:
		"collisions", "eavesdrop":
			if value == "LOW":
				return COLOR_OK
			if value == "MID":
				return COLOR_WARN
			return COLOR_ERR
		"filtering":
			return COLOR_OK if value == "ON" else COLOR_ERR
		"media":
			if value == "FIBER":
				return COLOR_OK
			if value == "UNKNOWN":
				return COLOR_WARN
			return COLOR_ERR
		_:
			return COLOR_WARN

func _collect_selected_ids() -> Array[String]:
	var selected_set: Dictionary = {}
	for option_id in slots:
		if option_id == "":
			continue
		selected_set[option_id] = true
	var selected_ids: Array[String] = []
	for option_id_v in selected_set.keys():
		selected_ids.append(str(option_id_v))
	selected_ids.sort()
	return selected_ids

func _filled_slots_count() -> int:
	var count: int = 0
	for option_id in slots:
		if option_id != "":
			count += 1
	return count

func _is_option_in_slots(option_id: String) -> bool:
	for current in slots:
		if current == option_id:
			return true
	return false

func _sort_palette_items() -> void:
	var move_index: int = 0
	for option_id in option_order:
		var item_v: Variant = item_nodes_by_option.get(option_id, null)
		if not (item_v is Node):
			continue
		var item_node: Node = item_v as Node
		if item_node.get_parent() != palette_flow:
			continue
		palette_flow.move_child(item_node, move_index)
		move_index += 1

func _is_slot_index_valid(slot_index: int) -> bool:
	return slot_index >= 1 and slot_index <= 3

func _get_slot_node(slot_index: int) -> Node:
	if not _is_slot_index_valid(slot_index):
		return null
	return _slot_nodes[slot_index - 1]

func _mark_first_action() -> void:
	if time_to_first_action_ms < 0:
		time_to_first_action_ms = Time.get_ticks_msec() - stage_started_ms

func _to_string_array(values: Array) -> Array[String]:
	var out: Array[String] = []
	for value_v in values:
		out.append(str(value_v))
	return out

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - stage_started_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _play_sfx(event_name: String) -> void:
	if has_node("/root/AudioManager"):
		AudioManager.play(event_name)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _on_viewport_size_changed() -> void:
	var size: Vector2 = get_viewport_rect().size
	var compact: bool = size.x < 900.0 or size.x < size.y
	palette_flow.columns = 1 if compact else 2

	for slot_node in _slot_nodes:
		if slot_node is Control:
			(slot_node as Control).custom_minimum_size = Vector2(0, 96 if compact else 110)

	btn_reset.custom_minimum_size = Vector2(150, 72 if compact else 64)
	btn_analyze.custom_minimum_size = Vector2(190, 72 if compact else 64)

func _show_error(message: String) -> void:
	status_label.text = message
	status_label.modulate = COLOR_ERR
	btn_analyze.disabled = true
	btn_reset.disabled = true
	await get_tree().create_timer(1.2).timeout
	_on_back_pressed()
</file>

<file path="scenes/case_01/DigitalResusQuestC.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/case_01/DigitalResusQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://scenes/ui/NetSlot.tscn" id="3_slot"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="4_noir"]

[node name="DigitalResusQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.06, 0.07, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("4_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(72, 72)
layout_mode = 2
text = "<"

[node name="TitleLabel" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕЛО"
vertical_alignment = 1

[node name="StageLabel" type="Label" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(112, 0)
layout_mode = 2
text = "ЭТАП C"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(220, 28)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="PromptCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="PromptLabel" type="Label" parent="SafeArea/MainVBox/PromptCard"]
custom_minimum_size = Vector2(0, 82)
layout_mode = 2
text = "ЗАДАНИЕ"
autowrap_mode = 2

[node name="DiagramCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="DiagramVBox" type="VBoxContainer" parent="SafeArea/MainVBox/DiagramCard"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="DiagramTitle" type="Label" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox"]
layout_mode = 2
text = "СХЕМА ПЕРИМЕТРА"

[node name="DiagramRow" type="HBoxContainer" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 8

[node name="PcNode" type="PanelContainer" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow"]
custom_minimum_size = Vector2(100, 110)
layout_mode = 2

[node name="PcLabel" type="Label" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/PcNode"]
layout_mode = 2
text = "ПК"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Slot1" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow" instance=ExtResource("3_slot")]
layout_mode = 2
size_flags_horizontal = 3
slot_index = 1

[node name="Slot2" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow" instance=ExtResource("3_slot")]
layout_mode = 2
size_flags_horizontal = 3
slot_index = 2

[node name="Slot3" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow" instance=ExtResource("3_slot")]
layout_mode = 2
size_flags_horizontal = 3
slot_index = 3

[node name="ServerNode" type="PanelContainer" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow"]
custom_minimum_size = Vector2(120, 110)
layout_mode = 2

[node name="ServerLabel" type="Label" parent="SafeArea/MainVBox/DiagramCard/DiagramVBox/DiagramRow/ServerNode"]
layout_mode = 2
text = "СЕРВЕР"
horizontal_alignment = 1
vertical_alignment = 1

[node name="RiskCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="RiskVBox" type="VBoxContainer" parent="SafeArea/MainVBox/RiskCard"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="RiskTitle" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2
text = "ПАНЕЛЬ РИСКОВ"

[node name="CollisionsRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="CollisionsLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/CollisionsRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "КОЛЛИЗИИ"

[node name="CollisionsValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/CollisionsRow"]
layout_mode = 2
text = "СРЕДНИЙ"

[node name="EavesdropRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="EavesdropLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/EavesdropRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ПЕРЕХВАТ"

[node name="EavesdropValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/EavesdropRow"]
layout_mode = 2
text = "СРЕДНИЙ"

[node name="FilteringRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="FilteringLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/FilteringRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ФИЛЬТРАЦИЯ"

[node name="FilteringValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/FilteringRow"]
layout_mode = 2
text = "ВЫКЛ"

[node name="MediaRow" type="HBoxContainer" parent="SafeArea/MainVBox/RiskCard/RiskVBox"]
layout_mode = 2

[node name="MediaLabel" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/MediaRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "СРЕДА"

[node name="MediaValue" type="Label" parent="SafeArea/MainVBox/RiskCard/RiskVBox/MediaRow"]
layout_mode = 2
text = "НЕИЗВЕСТНО"

[node name="PaletteCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="PaletteVBox" type="VBoxContainer" parent="SafeArea/MainVBox/PaletteCard"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="PaletteTitle" type="Label" parent="SafeArea/MainVBox/PaletteCard/PaletteVBox"]
layout_mode = 2
text = "ПАЛИТРА ОБОРУДОВАНИЯ"

[node name="Scroll" type="ScrollContainer" parent="SafeArea/MainVBox/PaletteCard/PaletteVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PaletteFlow" type="GridContainer" parent="SafeArea/MainVBox/PaletteCard/PaletteVBox/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
columns = 2
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8

[node name="ExplanationCard" type="PanelContainer" parent="SafeArea/MainVBox"]
visible = false
custom_minimum_size = Vector2(0, 180)
layout_mode = 2

[node name="ExplVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ExplanationCard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ExplHeadline" type="Label" parent="SafeArea/MainVBox/ExplanationCard/ExplVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ЗАГОЛОВОК"

[node name="ExplDetails" type="RichTextLabel" parent="SafeArea/MainVBox/ExplanationCard/ExplVBox"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="ExplWhy" type="RichTextLabel" parent="SafeArea/MainVBox/ExplanationCard/ExplVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
fit_content = false
scroll_active = true
text = ""
autowrap_mode = 2

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
text = "СТАТУС"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(150, 72)
layout_mode = 2
text = "СБРОС"

[node name="BtnAnalyze" type="Button" parent="SafeArea/MainVBox/BottomBar"]
custom_minimum_size = Vector2(190, 72)
layout_mode = 2
text = "АНАЛИЗ"
</file>

<file path="scenes/case_08/fr8_final_report_a.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scripts/case_08/fr8_final_report_a.gd" id="1_script"]
[ext_resource type="Theme" uid="uid://bc6epa3jyjbri" path="res://ui/theme_terminal_amber.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="PackedScene" path="res://scenes/ui/TagPileZone.tscn" id="4_pile"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(1, 0.7, 0.1, 1)
shader_parameter/intensity = 0.13
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="FR8_FinalReportA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.06, 0.06, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 1)

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(116, 56)
layout_mode = 2
text = "НАЗАД"

[node name="TitleLabel" type="Label" parent="SafeArea/MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #8"
vertical_alignment = 1

[node name="LevelLabel" type="Label" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(200, 0)
layout_mode = 2
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/MainLayout/Header"]
custom_minimum_size = Vector2(210, 24)
layout_mode = 2
size_flags_vertical = 4
value = 100.0
show_percentage = false

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainLayout"]
layout_mode = 2

[node name="BriefingLabel" type="Label" parent="SafeArea/MainLayout/BriefingCard"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "Брифинг"
autowrap_mode = 3

[node name="Body" type="BoxContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="FragmentsCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="CardVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/FragmentsCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="FragmentsTitle" type="Label" parent="SafeArea/MainLayout/Body/FragmentsCard/CardVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СКЛАД ФРАГМЕНТОВ"

[node name="PileZone" parent="SafeArea/MainLayout/Body/FragmentsCard/CardVBox" instance=ExtResource("4_pile")]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EditorCard" type="PanelContainer" parent="SafeArea/MainLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.2

[node name="CardVBox" type="VBoxContainer" parent="SafeArea/MainLayout/Body/EditorCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="EditorTitle" type="Label" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕДАКТОР"

[node name="CodePreviewCard" type="PanelContainer" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
custom_minimum_size = Vector2(0, 140)
layout_mode = 2
size_flags_horizontal = 3

[node name="CodePreview" type="RichTextLabel" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox/CodePreviewCard"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
bbcode_enabled = true
text = "[code]S1 ____[/code]"
fit_content = false
scroll_active = false

[node name="SlotsTitle" type="Label" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СЛОТЫ"

[node name="SlotsGrid" type="GridContainer" parent="SafeArea/MainLayout/Body/EditorCard/CardVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 3

[node name="BottomBar" type="HBoxContainer" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2
theme_override_constants/separation = 10

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "Статус"
autowrap_mode = 2
vertical_alignment = 1

[node name="BtnReset" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(150, 56)
layout_mode = 2
text = "СБРОС"

[node name="BtnConfirm" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(220, 56)
layout_mode = 2
text = "ПОДТВЕРДИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/MainLayout/BottomBar"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
disabled = true
text = "ДАЛЕЕ"
</file>

<file path="scenes/LogicQuestB.tscn">
[gd_scene load_steps=8 format=3 uid="uid://c856hihjj58j"]

[ext_resource type="Script" path="res://scenes/LogicQuestB.gd" id="1_script"]

[sub_resource type="SystemFont" id="SystemFont_1"]
font_names = PackedStringArray("Courier New", "Consolas", "Liberation Mono")

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_header"]
bg_color = Color(0.1, 0.1, 0.1, 1)
border_width_bottom = 2
border_color = Color(0.3, 0.3, 0.3, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_slot_normal"]
bg_color = Color(0.05, 0.05, 0.05, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.3, 0.3, 0.3, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_slot_active"]
bg_color = Color(0.1, 0.1, 0.1, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(1, 0.8, 0, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_controls"]
bg_color = Color(0.1, 0.1, 0.1, 1)
border_width_top = 2
border_color = Color(0.3, 0.3, 0.3, 1)

[sub_resource type="Environment" id="Environment_glow"]
background_mode = 3
glow_enabled = true
glow_intensity = 0.8
glow_strength = 1.0
glow_blend_mode = 1

[node name="LogicQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="MainLayout" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2

[node name="HeaderPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_header")

[node name="HeaderMargin" type="MarginContainer" parent="MainLayout/HeaderPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 5

[node name="HeaderHBox" type="HBoxContainer" parent="MainLayout/HeaderPanel/HeaderMargin"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
text = "<"

[node name="StabilityLabel" type="Label" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0.2, 1, 0.2, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 20
text = "СТАБИЛЬНОСТЬ: 100%"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StatsLabel" type="Label" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.6, 0.6, 0.6, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 16
text = "ДЕЛО: 01"

[node name="StoryPanel" type="PanelContainer" parent="MainLayout"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="StoryMargin" type="MarginContainer" parent="MainLayout/StoryPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 10

[node name="StoryText" type="RichTextLabel" parent="MainLayout/StoryPanel/StoryMargin"]
layout_mode = 2
theme_override_fonts/normal_font = SubResource("SystemFont_1")
theme_override_font_sizes/normal_font_size = 16
bbcode_enabled = true
text = "Брифинг миссии..."
fit_content = true

[node name="BoardContainer" type="Control" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="Switches" type="VBoxContainer" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 20.0
offset_top = 20.0
offset_right = 100.0
offset_bottom = 340.0
theme_override_constants/separation = 20

[node name="InputA_Btn" type="Button" parent="MainLayout/BoardContainer/Switches"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
toggle_mode = true
text = "A: 0"

[node name="InputB_Btn" type="Button" parent="MainLayout/BoardContainer/Switches"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
toggle_mode = true
text = "B: 0"

[node name="InputC_Btn" type="Button" parent="MainLayout/BoardContainer/Switches"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
toggle_mode = true
text = "C: 0"

[node name="Layouts" type="Control" parent="MainLayout/BoardContainer"]
anchors_preset = 0
offset_right = 40.0
offset_bottom = 40.0

[node name="Layout_Cascade_Top" type="Node2D" parent="MainLayout/BoardContainer/Layouts"]
visible = false

[node name="Wire_A_S1" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Top"]
points = PackedVector2Array(100, 50, 150, 50, 150, 80, 200, 80)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_B_S1" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Top"]
points = PackedVector2Array(100, 130, 150, 130, 150, 100, 200, 100)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_S1_S2" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Top"]
points = PackedVector2Array(320, 90, 360, 90, 360, 160, 400, 160)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_C_S2" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Top"]
points = PackedVector2Array(100, 210, 360, 210, 360, 180, 400, 180)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_S2_Out" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Top"]
points = PackedVector2Array(520, 170, 600, 170)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Layout_Cascade_Bottom" type="Node2D" parent="MainLayout/BoardContainer/Layouts"]
visible = false

[node name="Wire_A_S2" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom"]
points = PackedVector2Array(100, 50, 360, 50, 360, 80, 400, 80)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_B_S1" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom"]
points = PackedVector2Array(100, 130, 150, 130, 150, 160, 200, 160)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_C_S1" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom"]
points = PackedVector2Array(100, 210, 150, 210, 150, 180, 200, 180)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_S1_S2" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom"]
points = PackedVector2Array(320, 170, 360, 170, 360, 100, 400, 100)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Wire_S2_Out" type="Line2D" parent="MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom"]
points = PackedVector2Array(520, 90, 600, 90)
width = 3.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Slots" type="Control" parent="MainLayout/BoardContainer"]
anchors_preset = 0
offset_right = 40.0
offset_bottom = 40.0

[node name="Slot1" type="Button" parent="MainLayout/BoardContainer/Slots"]
custom_minimum_size = Vector2(120, 80)
layout_mode = 0
offset_left = 200.0
offset_top = 50.0
offset_right = 320.0
offset_bottom = 130.0
theme_override_styles/normal = SubResource("StyleBoxFlat_slot_normal")
theme_override_styles/hover = SubResource("StyleBoxFlat_slot_active")
theme_override_styles/pressed = SubResource("StyleBoxFlat_slot_active")
theme_override_styles/focus = SubResource("StyleBoxFlat_slot_active")

[node name="Symbol" type="Label" parent="MainLayout/BoardContainer/Slots/Slot1"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0.5, 0.5, 0.5, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 32
text = "?"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Slot2" type="Button" parent="MainLayout/BoardContainer/Slots"]
custom_minimum_size = Vector2(120, 80)
layout_mode = 0
offset_left = 400.0
offset_top = 130.0
offset_right = 520.0
offset_bottom = 210.0
theme_override_styles/normal = SubResource("StyleBoxFlat_slot_normal")
theme_override_styles/hover = SubResource("StyleBoxFlat_slot_active")
theme_override_styles/pressed = SubResource("StyleBoxFlat_slot_active")
theme_override_styles/focus = SubResource("StyleBoxFlat_slot_active")

[node name="Symbol" type="Label" parent="MainLayout/BoardContainer/Slots/Slot2"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0.5, 0.5, 0.5, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 32
text = "?"
horizontal_alignment = 1
vertical_alignment = 1

[node name="InterLamp" type="ColorRect" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 340.0
offset_top = 85.0
offset_right = 350.0
offset_bottom = 95.0
color = Color(0.1, 0.1, 0.1, 1)

[node name="OutputLamp" type="ColorRect" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 600.0
offset_top = 130.0
offset_right = 680.0
offset_bottom = 210.0
color = Color(0.1, 0.1, 0.1, 1)

[node name="Label" type="Label" parent="MainLayout/BoardContainer/OutputLamp"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 24
text = "F"
horizontal_alignment = 1
vertical_alignment = 1

[node name="SelectorPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_controls")

[node name="Margin" type="MarginContainer" parent="MainLayout/SelectorPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="GateGrid" type="GridContainer" parent="MainLayout/SelectorPanel/Margin"]
layout_mode = 2
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 10
columns = 4

[node name="BtnAND" type="Button" parent="MainLayout/SelectorPanel/Margin/GateGrid"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = SubResource("SystemFont_1")
text = "&"

[node name="BtnOR" type="Button" parent="MainLayout/SelectorPanel/Margin/GateGrid"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = SubResource("SystemFont_1")
text = "1"

[node name="BtnNOT" type="Button" parent="MainLayout/SelectorPanel/Margin/GateGrid"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = SubResource("SystemFont_1")
text = "¬"

[node name="BtnXOR" type="Button" parent="MainLayout/SelectorPanel/Margin/GateGrid"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = SubResource("SystemFont_1")
text = "⊕"

[node name="BtnNAND" type="Button" parent="MainLayout/SelectorPanel/Margin/GateGrid"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = SubResource("SystemFont_1")
text = "|"

[node name="BtnNOR" type="Button" parent="MainLayout/SelectorPanel/Margin/GateGrid"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = SubResource("SystemFont_1")
text = "↓"

[node name="ControlsPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_controls")

[node name="Margin" type="MarginContainer" parent="MainLayout/ControlsPanel"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="HBox" type="HBoxContainer" parent="MainLayout/ControlsPanel/Margin"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 1

[node name="BtnHint" type="Button" parent="MainLayout/ControlsPanel/Margin/HBox"]
custom_minimum_size = Vector2(100, 60)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
text = "ПОДСКАЗКА"

[node name="BtnVerdict" type="Button" parent="MainLayout/ControlsPanel/Margin/HBox"]
custom_minimum_size = Vector2(160, 60)
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 20
text = "ВЕРДИКТ"

[node name="BtnNext" type="Button" parent="MainLayout/ControlsPanel/Margin/HBox"]
visible = false
custom_minimum_size = Vector2(160, 60)
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0, 1, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 20
text = "ДАЛЕЕ >"

[node name="FeedbackLabel" type="Label" parent="MainLayout/ControlsPanel/Margin/HBox"]
visible = false
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.3, 0.3, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
text = "Ошибка"

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_glow")

[node name="ClickPlayer" type="AudioStreamPlayer" parent="."]

[node name="GameOverPanel" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Overlay" type="ColorRect" parent="GameOverPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.1, 0, 0, 0.9)

[node name="CenterContainer" type="CenterContainer" parent="GameOverPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBox" type="VBoxContainer" parent="GameOverPanel/CenterContainer"]
custom_minimum_size = Vector2(600, 0)
layout_mode = 2
theme_override_constants/separation = 20

[node name="Title" type="Label" parent="GameOverPanel/CenterContainer/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 32
text = "СБОЙ СИСТЕМЫ"
horizontal_alignment = 1

[node name="RestartButton" type="Button" parent="GameOverPanel/CenterContainer/VBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 24
text = "ПЕРЕЗАПУСК"

[connection signal="pressed" from="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/BtnBack" to="." method="_on_back_button_pressed"]
[connection signal="toggled" from="MainLayout/BoardContainer/Switches/InputA_Btn" to="." method="_on_input_a_toggled"]
[connection signal="toggled" from="MainLayout/BoardContainer/Switches/InputB_Btn" to="." method="_on_input_b_toggled"]
[connection signal="toggled" from="MainLayout/BoardContainer/Switches/InputC_Btn" to="." method="_on_input_c_toggled"]
[connection signal="pressed" from="MainLayout/BoardContainer/Slots/Slot1" to="." method="_on_slot1_pressed"]
[connection signal="pressed" from="MainLayout/BoardContainer/Slots/Slot2" to="." method="_on_slot2_pressed"]
[connection signal="pressed" from="MainLayout/SelectorPanel/Margin/GateGrid/BtnAND" to="." method="_on_gate_btn_pressed" binds= ["AND"]]
[connection signal="pressed" from="MainLayout/SelectorPanel/Margin/GateGrid/BtnOR" to="." method="_on_gate_btn_pressed" binds= ["OR"]]
[connection signal="pressed" from="MainLayout/SelectorPanel/Margin/GateGrid/BtnNOT" to="." method="_on_gate_btn_pressed" binds= ["NOT"]]
[connection signal="pressed" from="MainLayout/SelectorPanel/Margin/GateGrid/BtnXOR" to="." method="_on_gate_btn_pressed" binds= ["XOR"]]
[connection signal="pressed" from="MainLayout/SelectorPanel/Margin/GateGrid/BtnNAND" to="." method="_on_gate_btn_pressed" binds= ["NAND"]]
[connection signal="pressed" from="MainLayout/SelectorPanel/Margin/GateGrid/BtnNOR" to="." method="_on_gate_btn_pressed" binds= ["NOR"]]
[connection signal="pressed" from="MainLayout/ControlsPanel/Margin/HBox/BtnHint" to="." method="_on_hint_pressed"]
[connection signal="pressed" from="MainLayout/ControlsPanel/Margin/HBox/BtnVerdict" to="." method="_on_verdict_pressed"]
[connection signal="pressed" from="MainLayout/ControlsPanel/Margin/HBox/BtnNext" to="." method="_on_next_button_pressed"]
[connection signal="pressed" from="GameOverPanel/CenterContainer/VBox/RestartButton" to="." method="_on_restart_pressed"]
</file>

<file path="scenes/LogicQuestC.gd">
extends Control

# --- CONSTANTS & DATA ---
const CASES_C := [
	{
		"id": "C1_01",
		"story": "Главный сервер шумит. Убери лишние вентили, иначе ИИ заметит патч.",
		"vars": ["A","B","C"],
		"expr_start": ["OR", ["AND","A","B"], ["AND","A","C"]],
		"target_gates": 3,
		"options": [
			{
				"label": "A ∧ (B ∨ C)",
				"expr": ["AND","A", ["OR","B","C"]],
				"explain": "Дистрибутивность: вынесли общий множитель A."
			},
			{
				"label": "(A ∨ B) ∧ C",
				"expr": ["AND", ["OR","A","B"], "C"],
				"explain": "Похоже по словам, но неэквивалентно исходнику."
			},
			{
				"label": "A ∨ (B ∧ C)",
				"expr": ["OR","A", ["AND","B","C"]],
				"explain": "Другая логика: здесь A может сделать истину без B."
			}
		]
	},

	{
		"id": "C1_02",
		"story": "Защита дублирует проверку. Иногда проще значит безопаснее.",
		"vars": ["A","B"],
		"expr_start": ["OR", "A", ["AND","A","B"]],
		"target_gates": 1,
		"options": [
			{
				"label": "A",
				"expr": "A",
				"explain": "Поглощение: A ∨ (A ∧ B) = A."
			},
			{
				"label": "A ∧ B",
				"expr": ["AND","A","B"],
				"explain": "Слишком строго: теряешь случаи, где A=1 и B=0."
			},
			{
				"label": "A ∨ B",
				"expr": ["OR","A","B"],
				"explain": "Слишком широко: добавляет случаи, где A=0 и B=1."
			}
		]
	},

	{
		"id": "C1_03",
		"story": "ИИ сервера любит отрицания. Сделай так, чтобы он запутался меньше.",
		"vars": ["A","B"],
		"expr_start": ["NOT", ["AND","A","B"]],
		"target_gates": 3,
		"options": [
			{
				"label": "¬A ∨ ¬B",
				"expr": ["OR", ["NOT","A"], ["NOT","B"]],
				"explain": "Закон де Моргана: ¬(A ∧ B) = ¬A ∨ ¬B."
			},
			{
				"label": "¬A ∧ ¬B",
				"expr": ["AND", ["NOT","A"], ["NOT","B"]],
				"explain": "Это де Морган, но для ¬(A ∨ B), а не для ∧."
			},
			{
				"label": "A ∨ B",
				"expr": ["OR","A","B"],
				"explain": "Вообще без отрицания. Контрпример поймает быстро."
			}
		]
	},

	{
		"id": "C1_04",
		"story": "Сканер защиты видит лишний шум в скобках. Упрости без потери смысла.",
		"vars": ["A","B"],
		"expr_start": ["NOT", ["OR","A","B"]],
		"target_gates": 3,
		"options": [
			{
				"label": "¬A ∧ ¬B",
				"expr": ["AND", ["NOT","A"], ["NOT","B"]],
				"explain": "Де Морган: ¬(A ∨ B) = ¬A ∧ ¬B."
			},
			{
				"label": "¬A ∨ ¬B",
				"expr": ["OR", ["NOT","A"], ["NOT","B"]],
				"explain": "Это де Морган, но для ¬(A ∧ B)."
			},
			{
				"label": "A ∧ B",
				"expr": ["AND","A","B"],
				"explain": "Потеря отрицания меняет смысл полностью."
			}
		]
	},

	{
		"id": "C1_05",
		"story": "Двойная маскировка всегда палится. Сними лишний слой.",
		"vars": ["A"],
		"expr_start": ["NOT", ["NOT","A"]],
		"target_gates": 0,
		"options": [
			{
				"label": "A",
				"expr": "A",
				"explain": "Двойное отрицание: ¬¬A = A."
			},
			{
				"label": "¬A",
				"expr": ["NOT","A"],
				"explain": "Ты снял только один слой. Это другое."
			},
			{
				"label": "0 (ЛОЖЬ)",
				"expr": false,
				"explain": "Нет, ¬¬A не превращает всё в ложь."
			}
		]
	},

	{
		"id": "C1_06",
		"story": "Два разных пути защиты ведут к одному и тому же пропуску. Склей их.",
		"vars": ["A","B"],
		"expr_start": ["OR", ["AND","A","B"], ["AND", ["NOT","A"], "B"]],
		"target_gates": 1,
		"options": [
			{
				"label": "B",
				"expr": "B",
				"explain": "Склеивание: (A∧B) ∨ (¬A∧B) = B."
			},
			{
				"label": "A",
				"expr": "A",
				"explain": "Контрпример: при A=0, B=1 исходник даёт 1, а A даёт 0."
			},
			{
				"label": "A ∨ B",
				"expr": ["OR","A","B"],
				"explain": "Слишком широко: добавляет случаи, где B=0 и A=1."
			}
		]
	}
]

# --- NODES ---
@onready var stats_label = $MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/StatsLabel
@onready var stability_label = $MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/StabilityLabel
@onready var story_text = $MainLayout/StoryPanel/Margin/StoryText

@onready var expr_panel = $MainLayout/ExprPanel
@onready var expr_text = $MainLayout/ExprPanel/Margin/VBox/ExprText
@onready var load_label = $MainLayout/ExprPanel/Margin/VBox/LoadHBox/LoadLabel
@onready var load_bar = $MainLayout/ExprPanel/Margin/VBox/LoadHBox/LoadBar

@onready var patch_list = $MainLayout/PatchPanel/Margin/VBox/PatchList
@onready var feedback_panel = $MainLayout/FeedbackPanel
@onready var feedback_text = $MainLayout/FeedbackPanel/Margin/FeedbackText

@onready var btn_hint = $MainLayout/BottomBar/BtnHint
@onready var btn_next = $MainLayout/BottomBar/BtnNext

@onready var safe_overlay = $SafeModeOverlay
@onready var safe_label = $SafeModeOverlay/Label
@onready var lock_overlay = $LockOverlay
@onready var game_over_panel = $GameOverPanel
@onready var audio_player = $AudioStreamPlayer

# --- STATE ---
var current_case_idx := 0
var current_case := {}
var attempts := 0
var is_locked := false
var is_complete := false
var case_started_ms: int = 0
var first_action_ms: int = -1
var patch_press_count: int = 0
var hints_used: int = 0

func _ready():
	GlobalMetrics.stability_changed.connect(_update_stability_ui)
	_update_stability_ui(GlobalMetrics.stability, 0)
	load_case(0)

# --- LOADING CASE ---
func load_case(idx: int):
	if idx >= CASES_C.size():
		idx = 0 # Loop or finish? Let's loop for now.

	current_case_idx = idx
	current_case = CASES_C[idx]
	attempts = 0
	is_complete = false
	is_locked = false
	case_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	patch_press_count = 0
	hints_used = 0

	# Reset UI
	stats_label.text = "ДЕЛО: %02d" % (idx + 1)
	story_text.text = current_case.story

	# Expression
	var start_expr = current_case.expr_start
	expr_text.text = _format_expr(start_expr)

	# Load
	var current_load = count_gates(start_expr)
	var target_load = current_case.target_gates
	load_bar.max_value = max(current_load, target_load) + 2 # Some headroom
	load_bar.value = current_load
	load_label.text = "НАГРУЗКА: %d / %d" % [current_load, target_load]

	# Patches
	_create_patch_buttons(current_case.options)

	# Feedback
	feedback_panel.visible = true
	feedback_text.text = "[center]Выберите патч, чтобы снизить нагрузку.[/center]"
	feedback_text.modulate = Color(0.7, 0.7, 0.7)

	btn_next.visible = false
	btn_hint.disabled = false
	safe_overlay.visible = false
	lock_overlay.visible = false

	# Reset visual styles
	expr_panel.modulate = Color.WHITE

func _create_patch_buttons(options: Array):
	for child in patch_list.get_children():
		child.queue_free()

	for i in range(options.size()):
		var opt = options[i]
		var btn = Button.new()
		btn.custom_minimum_size = Vector2(0, 72)
		btn.text_overrun_behavior = TextServer.OVERRUN_NO_TRIM
		btn.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
		btn.alignment = HORIZONTAL_ALIGNMENT_LEFT

		# Multi-line text: Expression (Big) \n Label (Small)
		# Since button text styling is limited, we'll just use text.
		# Ideally we'd use rich text or a container, but plain button is robust.
		btn.text = opt.label

		# Store data
		btn.set_meta("option_idx", i)
		btn.pressed.connect(_on_patch_pressed.bind(btn))

		# Theme overrides for larger font
		btn.add_theme_font_size_override("font_size", 20)
		# Could add a StyleBox here if needed

		patch_list.add_child(btn)

# --- INTERACTION ---
func _on_patch_pressed(btn: Button):
	if is_locked or is_complete: return
	_mark_first_action()
	patch_press_count += 1

	_lock_ui(1.0) # Short lock to prevent double clicks

	var opt_idx = btn.get_meta("option_idx")
	var option = current_case.options[opt_idx]
	var chosen_expr = option.expr

	# 1. Check Equivalence
	var eq_res = equivalent(current_case.expr_start, chosen_expr, current_case.vars)

	if not eq_res.ok:
		_handle_fail(eq_res, option)
	else:
		_handle_success(chosen_expr, option)

func _handle_fail(eq_res, option):
	attempts += 1
	var penalty = 10.0 + (attempts * 5.0) # 15, 20, 25...

	# Feedback
	var env_str = ""
	for k in eq_res.counterexample:
		env_str += "%s=%d " % [k, 1 if eq_res.counterexample[k] else 0]

	feedback_text.text = "[color=#E24B4B]НЕЭКВИВАЛЕНТНО[/color]\nКонтрпример: %s\nИсходное: %s | Патч: %s" % [
		env_str,
		"1" if eq_res.orig else "0",
		"1" if eq_res.new else "0"
	]

	# Shake effect
	var tween = create_tween()
	tween.tween_property(feedback_panel, "position:x", feedback_panel.position.x + 10, 0.05)
	tween.tween_property(feedback_panel, "position:x", feedback_panel.position.x - 10, 0.05)
	tween.tween_property(feedback_panel, "position:x", feedback_panel.position.x, 0.05)

	_apply_penalty(penalty)
	_register_trial("NOT_EQUIVALENT", false, {
		"selected_label": str(option.get("label", "")),
		"counterexample": eq_res.counterexample,
		"orig_value": bool(eq_res.orig),
		"new_value": bool(eq_res.new)
	})

	if attempts >= 3:
		_enter_safe_mode()
	else:
		_lock_ui(2.0) # Penalty lock

func _handle_success(new_expr, option):
	is_complete = true

	# Load check (optional strictness)
	var new_load = count_gates(new_expr)
	load_bar.value = new_load
	load_label.text = "НАГРУЗКА: %d / %d" % [new_load, current_case.target_gates]

	# Visual Success
	feedback_text.text = "[color=#38E06B]ПАТЧ ПРИМЕНЁН: ЭКВИВАЛЕНТНО[/color]\n%s" % option.explain
	expr_text.text = _format_expr(new_expr) # Update main display

	var tween = create_tween()
	tween.tween_property(expr_panel, "modulate", Color(0.5, 1.5, 0.5), 0.2)
	tween.tween_property(expr_panel, "modulate", Color.WHITE, 0.3)

	# Disable buttons visually
	for child in patch_list.get_children():
		child.disabled = true

	btn_next.visible = true
	btn_hint.disabled = true
	_register_trial("SUCCESS", true, {
		"selected_label": str(option.get("label", "")),
		"new_load": count_gates(new_expr),
		"target_load": int(current_case.get("target_gates", 0))
	})

func _enter_safe_mode():
	is_complete = true # Treat as done but failed
	safe_overlay.visible = true

	# Find correct option
	var correct_idx = -1
	for i in range(current_case.options.size()):
		var opt = current_case.options[i]
		# We assume there is at least one correct answer.
		# Ideally we check data, but for now we run check or rely on knowledge.
		# The Prompt data implies one correct answer usually.
		# Let's brute force check again to find the correct one or trust data?
		# Trust data: usually the first one or we scan.
		var res = equivalent(current_case.expr_start, opt.expr, current_case.vars)
		if res.ok:
			correct_idx = i
			break

	# Highlight correct
	if correct_idx != -1:
		var btn = patch_list.get_child(correct_idx)
		btn.modulate = Color(0, 1, 0)
		feedback_text.text = "[color=#FFFF00]БЕЗОПАСНЫЙ РЕЖИМ[/color]\nВерный патч: %s\n%s" % [
			current_case.options[correct_idx].label,
			current_case.options[correct_idx].explain
		]

	# Disable others
	for child in patch_list.get_children():
		child.disabled = true

	btn_next.visible = true

func _lock_ui(time: float):
	is_locked = true
	lock_overlay.visible = true
	lock_overlay.text = "СИСТЕМА ЗАБЛОКИРОВАНА\n%.1fс" % time

	var timer = get_tree().create_timer(time)
	await timer.timeout

	if not is_complete: # Only unlock if not finished
		is_locked = false
		lock_overlay.visible = false

# --- LOGIC ENGINE ---

# Recursive Evaluation
func eval_expr(expr, env: Dictionary) -> bool:
	# 1. Boolean constant
	if typeof(expr) == TYPE_BOOL:
		return expr

	# 2. Variable (String)
	if typeof(expr) == TYPE_STRING:
		return env.get(expr, false)

	# 3. Array ["OP", arg1, ...]
	if typeof(expr) == TYPE_ARRAY:
		var op = expr[0]
		match op:
			"AND":
				# Can handle multiple args: ["AND", A, B, C]
				for i in range(1, expr.size()):
					if not eval_expr(expr[i], env):
						return false
				return true
			"OR":
				for i in range(1, expr.size()):
					if eval_expr(expr[i], env):
						return true
				return false
			"NOT":
				return not eval_expr(expr[1], env)
			"XOR":
				# Binary usually
				return eval_expr(expr[1], env) != eval_expr(expr[2], env)

	return false

# Gate Counting
func count_gates(expr) -> int:
	if typeof(expr) == TYPE_ARRAY:
		var count = 1 # The operator itself
		for i in range(1, expr.size()):
			count += count_gates(expr[i])
		return count
	return 0 # Vars/Consts don't count

# Brute-force Equivalence
func equivalent(expr1, expr2, vars: Array) -> Dictionary:
	var num_vars = vars.size()
	var combinations = 1 << num_vars # 2^n

	for i in range(combinations):
		var env = {}
		for bit in range(num_vars):
			# If bit is set, var is true
			env[vars[bit]] = (i & (1 << bit)) != 0

		var val1 = eval_expr(expr1, env)
		var val2 = eval_expr(expr2, env)

		if val1 != val2:
			return {
				"ok": false,
				"counterexample": env,
				"orig": val1,
				"new": val2
			}

	return {"ok": true}

# Formatting
func _format_expr(expr) -> String:
	if typeof(expr) == TYPE_STRING:
		return "[b]%s[/b]" % expr
	if typeof(expr) == TYPE_BOOL:
		return "1" if expr else "0"
	if typeof(expr) == TYPE_ARRAY:
		var op = expr[0]
		match op:
			"NOT":
				return "¬%s" % _format_sub(expr[1])
			"AND":
				var s = ""
				for i in range(1, expr.size()):
					if i > 1: s += " ∧ "
					s += _format_sub(expr[i])
				return s
			"OR":
				var s = ""
				for i in range(1, expr.size()):
					if i > 1: s += " ∨ "
					s += _format_sub(expr[i])
				return s
	return "?"

func _format_sub(expr) -> String:
	# Add parens if it's a complex op
	if typeof(expr) == TYPE_ARRAY and expr[0] != "NOT": # NOT usually binds tight
		return "(%s)" % _format_expr(expr)
	return _format_expr(expr)

# --- GLOBAL HELPERS ---
func _apply_penalty(amt: float):
	GlobalMetrics.stability = max(0.0, GlobalMetrics.stability - amt)
	GlobalMetrics.stability_changed.emit(GlobalMetrics.stability, -amt)
	if GlobalMetrics.stability <= 0:
		_game_over()

func _update_stability_ui(val, _diff):
	stability_label.text = "СТАБИЛЬНОСТЬ: %d%%" % int(val)
	if val < 40:
		stability_label.add_theme_color_override("font_color", Color.RED)
	else:
		stability_label.add_theme_color_override("font_color", Color(0.2, 0.9, 0.4))

func _game_over():
	game_over_panel.visible = true

func _on_next_pressed():
	load_case(current_case_idx + 1)

func _on_hint_pressed():
	_mark_first_action()
	hints_used += 1
	_apply_penalty(5.0)
	# Just highlight the correct answer slightly or give text hint?
	# Let's give text hint from logic
	var correct_opt = null
	for opt in current_case.options:
		if equivalent(current_case.expr_start, opt.expr, current_case.vars).ok:
			correct_opt = opt
			break

	if correct_opt:
		feedback_text.text = "[color=#88CCFF]ПОДСКАЗКА: ищите %s[/color]" % correct_opt.label.substr(0, 5) + "..."

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - case_started_ms

func _register_trial(verdict_code: String, is_correct: bool, extra: Dictionary = {}) -> void:
	var case_id: String = str(current_case.get("id", "C_00"))
	var variant_hash: String = str(hash(JSON.stringify(current_case.get("expr_start", []))))
	var payload: Dictionary = TrialV2.build("LOGIC_QUEST", "C", case_id, "PATCH_SELECT", variant_hash)
	var elapsed_ms: int = int(max(0, Time.get_ticks_msec() - case_started_ms))
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_correct
	payload["is_fit"] = is_correct
	payload["stability_delta"] = 0
	payload["verdict_code"] = verdict_code
	payload["attempts"] = attempts
	payload["patch_press_count"] = patch_press_count
	payload["hints_used"] = hints_used
	payload["target_gates"] = int(current_case.get("target_gates", 0))
	for key in extra.keys():
		payload[key] = extra[key]
	GlobalMetrics.register_trial(payload)

func _on_back_pressed():
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_restart_pressed():
	GlobalMetrics.stability = 100.0
	GlobalMetrics.stability_changed.emit(100.0, 0)
	game_over_panel.visible = false
	load_case(current_case_idx)
</file>

<file path="scenes/LogicQuestC.tscn">
[gd_scene load_steps=10 format=3 uid="uid://c2k856hihjj58"]

[ext_resource type="Script" path="res://scenes/LogicQuestC.gd" id="1_script"]

[sub_resource type="SystemFont" id="SystemFont_mono"]
font_names = PackedStringArray("Courier New", "Consolas", "Liberation Mono", "Monospace")

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_bg"]
bg_color = Color(0.043, 0.051, 0.063, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_header"]
bg_color = Color(0.08, 0.09, 0.11, 1)
border_width_bottom = 2
border_color = Color(0.16, 0.18, 0.21, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_panel"]
bg_color = Color(0.08, 0.09, 0.11, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.16, 0.18, 0.21, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_feedback"]
bg_color = Color(0.06, 0.07, 0.08, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.2, 0.2, 0.2, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_overlay"]
bg_color = Color(0, 0, 0, 0.85)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_safe"]
bg_color = Color(0, 0.2, 0, 0.9)
border_width_bottom = 4
border_color = Color(0, 1, 0, 1)

[sub_resource type="Environment" id="Environment_glow"]
background_mode = 3
glow_enabled = true
glow_intensity = 0.5
glow_strength = 0.9
glow_blend_mode = 1

[node name="LogicQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="Background" type="Panel" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_bg")

[node name="MainLayout" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 12

[node name="HeaderPanel" type="PanelContainer" parent="MainLayout"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_header")

[node name="HeaderMargin" type="MarginContainer" parent="MainLayout/HeaderPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 8

[node name="HeaderHBox" type="HBoxContainer" parent="MainLayout/HeaderPanel/HeaderMargin"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
custom_minimum_size = Vector2(48, 48)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 24
text = "<"

[node name="Spacer1" type="Control" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="StabilityLabel" type="Label" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.22, 0.88, 0.42, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 20
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="Spacer2" type="Control" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="StatsLabel" type="Label" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 0.5, 0.6, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 16
text = "ДЕЛО: 01"

[node name="StoryPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_panel")

[node name="Margin" type="MarginContainer" parent="MainLayout/StoryPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 16

[node name="StoryText" type="RichTextLabel" parent="MainLayout/StoryPanel/Margin"]
layout_mode = 2
theme_override_colors/default_color = Color(0.8, 0.85, 0.9, 1)
theme_override_fonts/normal_font = SubResource("SystemFont_mono")
theme_override_font_sizes/normal_font_size = 18
bbcode_enabled = true
text = "Здесь будет текст истории..."
fit_content = true

[node name="ExprPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_panel")

[node name="Margin" type="MarginContainer" parent="MainLayout/ExprPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 16

[node name="VBox" type="VBoxContainer" parent="MainLayout/ExprPanel/Margin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="HeaderLabel" type="Label" parent="MainLayout/ExprPanel/Margin/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 0.6, 0.7, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 14
text = "МОДУЛЬ БЕЗОПАСНОСТИ: УСЛОВИЕ"

[node name="ExprText" type="RichTextLabel" parent="MainLayout/ExprPanel/Margin/VBox"]
layout_mode = 2
theme_override_fonts/normal_font = SubResource("SystemFont_mono")
theme_override_font_sizes/normal_font_size = 28
bbcode_enabled = true
text = "[b]A[/b] AND ([b]B[/b] OR [b]C[/b])"
fit_content = true

[node name="LoadHBox" type="HBoxContainer" parent="MainLayout/ExprPanel/Margin/VBox"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="LoadLabel" type="Label" parent="MainLayout/ExprPanel/Margin/VBox/LoadHBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
text = "НАГРУЗКА: 6/4"

[node name="LoadBar" type="ProgressBar" parent="MainLayout/ExprPanel/Margin/VBox/LoadHBox"]
custom_minimum_size = Vector2(0, 24)
layout_mode = 2
size_flags_horizontal = 3
max_value = 10.0
step = 1.0
value = 6.0
show_percentage = false

[node name="PatchPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3
theme_override_styles/panel = SubResource("StyleBoxFlat_panel")

[node name="Margin" type="MarginContainer" parent="MainLayout/PatchPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 16

[node name="VBox" type="VBoxContainer" parent="MainLayout/PatchPanel/Margin"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="HeaderLabel" type="Label" parent="MainLayout/PatchPanel/Margin/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5, 0.6, 0.7, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 14
text = "ДОСТУПНЫЕ ПАТЧИ"

[node name="PatchList" type="VBoxContainer" parent="MainLayout/PatchPanel/Margin/VBox"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="FeedbackPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_feedback")

[node name="Margin" type="MarginContainer" parent="MainLayout/FeedbackPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="FeedbackText" type="RichTextLabel" parent="MainLayout/FeedbackPanel/Margin"]
layout_mode = 2
theme_override_fonts/normal_font = SubResource("SystemFont_mono")
theme_override_font_sizes/normal_font_size = 16
bbcode_enabled = true
text = "Выберите патч, чтобы снизить нагрузку."
fit_content = true

[node name="BottomBar" type="HBoxContainer" parent="MainLayout"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnHint" type="Button" parent="MainLayout/BottomBar"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 20
text = "ПОДСКАЗКА"

[node name="BtnNext" type="Button" parent="MainLayout/BottomBar"]
visible = false
custom_minimum_size = Vector2(160, 0)
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0, 1, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 24
text = "ДАЛЕЕ >"

[node name="Spacer" type="Control" parent="MainLayout/BottomBar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="SafeModeOverlay" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 10
anchor_right = 1.0
offset_bottom = 40.0
grow_horizontal = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_safe")

[node name="Label" type="Label" parent="SafeModeOverlay"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 18
text = "БЕЗОПАСНЫЙ РЕЖИМ: ПРАВИЛЬНЫЙ ПАТЧ ПОДСВЕЧЕН"
horizontal_alignment = 1
vertical_alignment = 1

[node name="LockOverlay" type="Label" parent="."]
visible = false
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -100.0
grow_horizontal = 2
grow_vertical = 0
theme_override_colors/font_color = Color(1, 0.8, 0.4, 1)
theme_override_colors/font_shadow_color = Color(0, 0, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 24
text = "СИСТЕМА ЗАБЛОКИРОВАНА
2s"
horizontal_alignment = 1
vertical_alignment = 1

[node name="GameOverPanel" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Overlay" type="Panel" parent="GameOverPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_overlay")

[node name="CenterContainer" type="CenterContainer" parent="GameOverPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBox" type="VBoxContainer" parent="GameOverPanel/CenterContainer"]
custom_minimum_size = Vector2(300, 0)
layout_mode = 2
theme_override_constants/separation = 24

[node name="Title" type="Label" parent="GameOverPanel/CenterContainer/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.9, 0.3, 0.3, 1)
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 32
text = "КРИТИЧЕСКИЙ СБОЙ"
horizontal_alignment = 1

[node name="RestartButton" type="Button" parent="GameOverPanel/CenterContainer/VBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_mono")
theme_override_font_sizes/font_size = 24
text = "ПЕРЕЗАПУСК"

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_glow")

[node name="AudioStreamPlayer" type="AudioStreamPlayer" parent="."]

[connection signal="pressed" from="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/BtnBack" to="." method="_on_back_pressed"]
[connection signal="pressed" from="MainLayout/BottomBar/BtnHint" to="." method="_on_hint_pressed"]
[connection signal="pressed" from="MainLayout/BottomBar/BtnNext" to="." method="_on_next_pressed"]
[connection signal="pressed" from="GameOverPanel/CenterContainer/VBox/RestartButton" to="." method="_on_restart_pressed"]
</file>

<file path="scenes/NetworkTraceQuest.gd">
extends Control

const THEME_GREEN: Theme = preload("res://ui/theme_terminal_green.tres")
const THEME_AMBER: Theme = preload("res://ui/theme_terminal_amber.tres")
const ERROR_MAP = preload("res://scripts/ssot/network_trace_errors.gd")

const DATA_PATHS: Dictionary = {
	"A": "res://data/network_trace_a_levels.json",
	"B": "res://data/network_trace_b_levels.json",
	"C": "res://data/network_trace_c_levels.json"
}

const ACTION_BUTTON_NAMES: Array[String] = [
	"ActionBtn1",
	"ActionBtn2",
	"ActionBtn3",
	"ActionBtn4",
	"ActionBtn5",
	"ActionBtn6"
]

const MAX_ATTEMPTS := 3
const DEFAULT_TIME_LIMIT_SEC := 120
const OPTION_COOLDOWN_MS := 200
const HINT_STABILITY_PENALTY := -5.0
const FAIL_STABILITY_PENALTY := -10.0
const PALETTE_GREEN_ID := 0
const PALETTE_AMBER_ID := 1
const FX_LOW_ID := 0
const FX_HIGH_ID := 1

enum QuestState {
	INIT,
	BRIEFING,
	SOLVING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	SAFE_MODE,
	DIAGNOSTIC
}

@export_enum("A", "B", "C") var complexity_name: String = "A"

@onready var main_layout: VBoxContainer = $MainMargin/MainLayout
@onready var btn_back: Button = $MainMargin/MainLayout/HeaderRow/BtnBack
@onready var lbl_case: Label = $MainMargin/MainLayout/HeaderRow/LblCase
@onready var lbl_session: Label = $MainMargin/MainLayout/HeaderRow/LblSession
@onready var palette_select: OptionButton = $MainMargin/MainLayout/SettingsRow/PaletteSelect
@onready var fx_select: OptionButton = $MainMargin/MainLayout/SettingsRow/FxSelect
@onready var lbl_timer: Label = $MainMargin/MainLayout/SettingsRow/LblTimer
@onready var progress_bar: ProgressBar = $MainMargin/MainLayout/BarsRow/ProgressBar
@onready var stability_bar: ProgressBar = $MainMargin/MainLayout/BarsRow/StabilityBar
@onready var lbl_attempts: Label = $MainMargin/MainLayout/BarsRow/LblAttempts
@onready var body_landscape: HBoxContainer = $MainMargin/MainLayout/BodyLandscape
@onready var body_portrait: VBoxContainer = $MainMargin/MainLayout/BodyPortrait
@onready var terminal_pane: PanelContainer = $MainMargin/MainLayout/BodyLandscape/TerminalPane
@onready var actions_pane: PanelContainer = $MainMargin/MainLayout/BodyLandscape/ActionsPane
@onready var terminal_scroll: ScrollContainer = $MainMargin/MainLayout/BodyLandscape/TerminalPane/TerminalMargin/TerminalScroll
@onready var terminal_text: RichTextLabel = $MainMargin/MainLayout/BodyLandscape/TerminalPane/TerminalMargin/TerminalScroll/TerminalText
@onready var options_grid: GridContainer = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/OptionsGrid
@onready var lbl_status: Label = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/LblStatus
@onready var btn_analyze: Button = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/BottomRow/BtnAnalyze
@onready var btn_hint: Button = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/BottomRow/BtnHint
@onready var btn_next: Button = $MainMargin/MainLayout/BodyLandscape/ActionsPane/ActionsMargin/ActionsVBox/BottomRow/BtnNext
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanel
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

var action_buttons: Array[Button] = []
var levels: Array = []
var ordered_options: Array = []
var current_level: Dictionary = {}
var current_level_index := 0
var variant_hash := ""
var state: int = QuestState.INIT

var attempts: Array = []
var task_session: Dictionary = {}
var wrong_count := 0
var level_started_ms := 0
var first_action_ms := -1
var option_unlock_at_ms := 0
var time_limit_sec := DEFAULT_TIME_LIMIT_SEC
var time_left_sec := 0.0
var timer_running := false
var safe_mode := false
var hint_used := false
var level_finished := false
var last_error_code := ""
var current_layout := "landscape"

func _ready() -> void:
	complexity_name = complexity_name.to_upper()
	if not DATA_PATHS.has(complexity_name):
		complexity_name = "A"

	_collect_action_buttons()
	_setup_runtime_controls()
	_connect_runtime_signals()
	_apply_palette(PALETTE_GREEN_ID)
	_apply_fx_quality(FX_LOW_ID)
	_update_stability_bar()
	_apply_layout_mode()

	if GlobalMetrics != null and not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)

	if not _load_levels_for_complexity(complexity_name):
		_show_boot_error("Данные уровней недоступны для сложности %s." % complexity_name)
		return

	_load_level(0)

func _exit_tree() -> void:
	if GlobalMetrics != null and GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.disconnect(_on_stability_changed)

func _process(delta: float) -> void:
	if state == QuestState.DIAGNOSTIC and not diagnostics_panel.visible:
		if level_finished:
			state = QuestState.FEEDBACK_FAIL
		elif safe_mode:
			state = QuestState.SAFE_MODE
		else:
			state = QuestState.SOLVING

	if timer_running and not level_finished:
		time_left_sec -= delta
		if time_left_sec <= 0.0:
			time_left_sec = 0.0
			_update_timer_label()
			_on_timeout()
		else:
			_update_timer_label()

	if option_unlock_at_ms > 0 and Time.get_ticks_msec() >= option_unlock_at_ms:
		option_unlock_at_ms = 0
		if _can_pick_option():
			_set_option_buttons_enabled(true)

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_layout_mode()

func _collect_action_buttons() -> void:
	action_buttons.clear()
	for button_name in ACTION_BUTTON_NAMES:
		var node: Node = options_grid.get_node(button_name)
		if node is Button:
			action_buttons.append(node as Button)

func _setup_runtime_controls() -> void:
	palette_select.clear()
	palette_select.add_item("ЗЕЛЁНЫЙ", PALETTE_GREEN_ID)
	palette_select.add_item("ЯНТАРНЫЙ", PALETTE_AMBER_ID)
	palette_select.select(PALETTE_GREEN_ID)

	fx_select.clear()
	fx_select.add_item("FX НИЗКИЙ", FX_LOW_ID)
	fx_select.add_item("FX ВЫСОКИЙ", FX_HIGH_ID)
	fx_select.select(FX_LOW_ID)

	btn_next.visible = false
	diagnostics_panel.visible = false

func _connect_runtime_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	palette_select.item_selected.connect(_on_palette_selected)
	fx_select.item_selected.connect(_on_fx_selected)

	for idx in range(action_buttons.size()):
		action_buttons[idx].pressed.connect(_on_action_pressed.bind(idx))

func _load_levels_for_complexity(level_key: String) -> bool:
	var path: String = str(DATA_PATHS[level_key])
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("NetworkTrace missing data file: %s" % path)
		return false

	var parsed: Variant = JSON.parse_string(file.get_as_text())
	var raw_levels: Array = []
	if typeof(parsed) == TYPE_ARRAY:
		raw_levels = parsed
	elif typeof(parsed) == TYPE_DICTIONARY:
		var parsed_dict: Dictionary = parsed
		raw_levels = parsed_dict.get("levels", [])
	else:
		push_error("NetworkTrace invalid JSON shape: %s" % path)
		return false

	var valid_levels: Array = []
	for level_var in raw_levels:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if validate_level(level):
			valid_levels.append(level)
		elif OS.is_debug_build():
			push_error("Invalid NetworkTrace level: %s" % str(level.get("id", "UNKNOWN")))
			return false
		else:
			push_warning("Skipping invalid NetworkTrace level: %s" % str(level.get("id", "UNKNOWN")))

	levels = valid_levels
	return levels.size() > 0

func validate_levels(levels_to_check: Array) -> bool:
	for level_var in levels_to_check:
		if typeof(level_var) != TYPE_DICTIONARY:
			return false
		if not validate_level(level_var):
			return false
	return true

func validate_level(level: Dictionary) -> bool:
	var required_keys: Array[String] = ["id", "briefing", "prompt", "options", "correct_id", "explain_short", "explain_full", "tags"]
	for key in required_keys:
		if not level.has(key):
			return false

	if typeof(level.get("options")) != TYPE_ARRAY:
		return false
	if typeof(level.get("tags")) != TYPE_ARRAY:
		return false

	var options: Array = level.get("options", [])
	if options.size() < 4 or options.size() > 6:
		return false

	var option_ids: Dictionary = {}
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			return false
		var option: Dictionary = option_var
		var option_required: Array[String] = ["id", "label", "error_code"]
		for option_key in option_required:
			if not option.has(option_key):
				return false
		var option_id: String = str(option.get("id", ""))
		if option_id.is_empty() or option_ids.has(option_id):
			return false
		option_ids[option_id] = true

	var correct_id: String = str(level.get("correct_id", ""))
	if not option_ids.has(correct_id):
		return false

	if level.has("ui_order"):
		if typeof(level.get("ui_order")) != TYPE_ARRAY:
			return false
		var order: Array = level.get("ui_order", [])
		for id_var in order:
			var id_str: String = str(id_var)
			if not option_ids.has(id_str):
				return false

	if level.has("time_limit_sec"):
		var limit_val: int = int(level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC))
		if limit_val <= 0:
			return false

	return true

func _show_boot_error(message: String) -> void:
	lbl_status.text = message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))
	_set_option_buttons_enabled(false)
	btn_analyze.disabled = true
	btn_hint.disabled = true
	btn_next.disabled = true
	timer_running = false

func _load_level(index: int) -> void:
	if levels.is_empty():
		return

	if index >= levels.size():
		index = 0
	current_level_index = index
	current_level = (levels[index] as Dictionary).duplicate(true)
	variant_hash = str(hash(_build_variant_key(current_level)))
	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	option_unlock_at_ms = 0
	wrong_count = 0
	safe_mode = false
	hint_used = false
	level_finished = false
	last_error_code = ""
	attempts = []

	time_limit_sec = int(current_level.get("time_limit_sec", DEFAULT_TIME_LIMIT_SEC))
	time_left_sec = float(time_limit_sec)
	timer_running = true

	state = QuestState.BRIEFING

	var level_id: String = str(current_level.get("id", "NT_UNKNOWN"))
	task_session = {
		"task_id": level_id,
		"variant_hash": variant_hash,
		"started_at_ticks": level_started_ms,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	lbl_case.text = "СЕТЕВОЙ СЛЕД | %s" % complexity_name
	lbl_session.text = "СЕСС %04d" % (randi() % 10000)
	lbl_attempts.text = "ОШ 0/%d" % MAX_ATTEMPTS
	btn_next.visible = false
	btn_next.disabled = false
	btn_analyze.disabled = true
	btn_hint.disabled = false
	diagnostics_panel.visible = false

	if levels.size() <= 1:
		progress_bar.value = 100.0
	else:
		progress_bar.value = (float(current_level_index) / float(levels.size() - 1)) * 100.0

	_update_timer_label()
	_update_stability_bar()
	_render_terminal_content()
	_setup_option_buttons()
	_set_option_buttons_enabled(true)

	lbl_status.text = "Выберите действие." 
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))

	state = QuestState.SOLVING
	_log_event("task_start", {
		"complexity": complexity_name,
		"layout": current_layout
	})

func _render_terminal_content() -> void:
	var briefing: String = str(current_level.get("briefing", ""))
	var prompt: String = str(current_level.get("prompt", ""))
	var explain_short: String = str(current_level.get("explain_short", ""))
	var tags_arr: Array = current_level.get("tags", [])
	var tag_line := ""
	if not tags_arr.is_empty():
		tag_line = "\n[color=#6f8f6f]ТЕГИ:[/color] %s" % ", ".join(_stringify_array(tags_arr))

	terminal_text.clear()
	terminal_text.append_text("[color=#7a7a7a]ИНСТРУКТАЖ[/color]\n")
	terminal_text.append_text("%s\n\n" % briefing)
	terminal_text.append_text("[color=#9de6b3]ЗАДАНИЕ[/color]\n")
	terminal_text.append_text("%s\n" % prompt)
	if not explain_short.is_empty():
		terminal_text.append_text("\n[color=#a1a1a1]ПРИМЕЧАНИЕ[/color]\n%s\n" % explain_short)
	if not tag_line.is_empty():
		terminal_text.append_text(tag_line)
	terminal_scroll.scroll_vertical = 0

func _setup_option_buttons() -> void:
	ordered_options = _ordered_options_for_level(current_level)
	for idx in range(action_buttons.size()):
		var btn: Button = action_buttons[idx]
		if idx < ordered_options.size():
			var option: Dictionary = ordered_options[idx]
			btn.visible = true
			btn.disabled = false
			btn.text = str(option.get("label", ""))
			btn.set_meta("option_id", str(option.get("id", "")))
			btn.set_meta("option_error", str(option.get("error_code", "")))
		else:
			btn.visible = false
			btn.disabled = true
			btn.text = ""
			btn.set_meta("option_id", "")
			btn.set_meta("option_error", "")

func _ordered_options_for_level(level: Dictionary) -> Array:
	var options: Array = level.get("options", [])
	var ordered: Array = []

	if level.has("ui_order"):
		var option_map: Dictionary = {}
		for option_var in options:
			if typeof(option_var) == TYPE_DICTIONARY:
				var option_dict: Dictionary = option_var
				option_map[str(option_dict.get("id", ""))] = option_dict
		var id_order: Array = level.get("ui_order", [])
		for id_var in id_order:
			var option_id: String = str(id_var)
			if option_map.has(option_id):
				ordered.append(option_map[option_id])
		for option_var in options:
			var option_dict: Dictionary = option_var
			if not ordered.has(option_dict):
				ordered.append(option_dict)
	else:
		for option_var in options:
			ordered.append(option_var)

	return ordered

func _on_action_pressed(button_index: int) -> void:
	if not _can_pick_option():
		return
	if button_index < 0 or button_index >= action_buttons.size():
		return

	var btn: Button = action_buttons[button_index]
	var option_id: String = str(btn.get_meta("option_id", ""))
	if option_id.is_empty():
		return

	_register_first_action()
	_play_audio("click")

	_set_option_buttons_enabled(false)
	option_unlock_at_ms = Time.get_ticks_msec() + OPTION_COOLDOWN_MS

	var option: Dictionary = _find_option(option_id)
	var is_correct: bool = option_id == str(current_level.get("correct_id", ""))
	var error_code: String = "" if is_correct else str(option.get("error_code", "UNKNOWN"))
	last_error_code = error_code

	var now_ms: int = Time.get_ticks_msec()
	var attempt_entry: Dictionary = {
		"id": option_id,
		"label": str(option.get("label", "")),
		"correct": is_correct,
		"error_code": error_code,
		"t_ms": now_ms - level_started_ms
	}
	attempts.append(attempt_entry)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(attempt_entry)
	task_session["attempts"] = session_attempts

	_log_event("answer_selected", {
		"option_id": option_id,
		"correct": is_correct,
		"error_code": error_code
	})

	if is_correct:
		_handle_success()
	else:
		_handle_failure(error_code)

func _handle_success() -> void:
	state = QuestState.FEEDBACK_SUCCESS
	lbl_status.text = "Верно. Путь связи подтверждён."
	lbl_status.add_theme_color_override("font_color", Color(0.35, 1.0, 0.45))
	_set_option_buttons_enabled(false)
	btn_analyze.disabled = true
	btn_hint.disabled = true
	btn_next.visible = true
	_play_audio("relay")
	_finish_level(true, "success")

func _handle_failure(error_code: String) -> void:
	wrong_count += 1
	lbl_attempts.text = "ОШ %d/%d" % [wrong_count, MAX_ATTEMPTS]
	state = QuestState.FEEDBACK_FAIL

	var short_message: String = ERROR_MAP.short_message(error_code)
	lbl_status.text = "Ошибка: %s" % short_message
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.4, 0.4))

	_play_audio("error")
	_trigger_glitch()
	_shake_main_layout()

	if wrong_count >= 2 and not safe_mode:
		_enter_safe_mode()

	if wrong_count >= MAX_ATTEMPTS:
		_finish_level(false, "attempt_limit")
	elif safe_mode:
		state = QuestState.SAFE_MODE
	else:
		state = QuestState.SOLVING

func _enter_safe_mode() -> void:
	safe_mode = true
	state = QuestState.SAFE_MODE
	btn_analyze.disabled = false
	lbl_status.text = "Безопасный режим разблокирован. Доступен анализ."
	lbl_status.add_theme_color_override("font_color", Color(1.0, 0.7, 0.35))
	_log_event("safe_mode_enabled", {"wrong_count": wrong_count})

func _on_analyze_pressed() -> void:
	if level_finished:
		return
	if not safe_mode:
		lbl_status.text = "Анализ открывается после 2 ошибок."
		lbl_status.add_theme_color_override("font_color", Color(0.9, 0.8, 0.4))
		return

	_register_first_action()
	if not hint_used:
		hint_used = true
		_log_event("hint_used", {"source": "analyze"})

	var lines: Array[String] = []
	lines.append("Уровень: %s" % str(current_level.get("id", "UNKNOWN")))
	if not last_error_code.is_empty():
		lines.append("Последняя ошибка: %s" % last_error_code)
		lines.append(ERROR_MAP.short_message(last_error_code))
		for detail_line in ERROR_MAP.detail_messages(last_error_code):
			lines.append(detail_line)

	var full_explain: String = str(current_level.get("explain_full", ""))
	if not full_explain.is_empty():
		for explain_line in full_explain.split("\n"):
			var trimmed: String = explain_line.strip_edges()
			if not trimmed.is_empty():
				lines.append(trimmed)

	_show_diagnostics(lines)
	state = QuestState.DIAGNOSTIC
	_log_event("diagnostic_open", {"error_code": last_error_code})

func _on_hint_pressed() -> void:
	if level_finished:
		return

	_register_first_action()
	if not hint_used:
		hint_used = true
		_log_event("hint_used", {"source": "hint_button"})

	var hint_text: String = str(current_level.get("explain_short", "Подсказка недоступна."))
	lbl_status.text = "Подсказка: %s" % hint_text
	lbl_status.add_theme_color_override("font_color", Color(0.8, 0.9, 1.0))

func _on_next_pressed() -> void:
	if not level_finished:
		return
	_log_event("next_pressed", {"from": str(current_level.get("id", "UNKNOWN"))})
	_load_level(current_level_index + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_palette_selected(index: int) -> void:
	var item_id: int = palette_select.get_item_id(index)
	_apply_palette(item_id)

func _on_fx_selected(index: int) -> void:
	var item_id: int = fx_select.get_item_id(index)
	_apply_fx_quality(item_id)

func _apply_palette(palette_id: int) -> void:
	if palette_id == PALETTE_AMBER_ID:
		theme = THEME_AMBER
		_set_overlay_tint(Color(1.0, 0.69, 0.0, 1.0))
	else:
		theme = THEME_GREEN
		_set_overlay_tint(Color(0.0, 1.0, 0.25, 1.0))

func _apply_fx_quality(fx_id: int) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("fx_quality", 1 if fx_id == FX_HIGH_ID else 0)
	shader_material.set_shader_parameter("glitch_strength", 0.0)

func _set_overlay_tint(color: Color) -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("tint_color", color)

func _update_timer_label() -> void:
	var total_seconds: int = maxi(0, int(ceil(time_left_sec)))
	var minutes: int = total_seconds / 60
	var seconds: int = total_seconds % 60
	lbl_timer.text = "%02d:%02d" % [minutes, seconds]

func _update_stability_bar() -> void:
	if GlobalMetrics != null:
		stability_bar.value = float(GlobalMetrics.stability)

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_bar()

func _set_option_buttons_enabled(enabled: bool) -> void:
	for btn in action_buttons:
		if btn.visible:
			btn.disabled = not enabled

func _can_pick_option() -> bool:
	if level_finished:
		return false
	if option_unlock_at_ms > 0:
		return false
	return state == QuestState.SOLVING or state == QuestState.SAFE_MODE

func _find_option(option_id: String) -> Dictionary:
	var options: Array = current_level.get("options", [])
	for option_var in options:
		if typeof(option_var) != TYPE_DICTIONARY:
			continue
		var option: Dictionary = option_var
		if str(option.get("id", "")) == option_id:
			return option
	return {}

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _finish_level(is_correct: bool, end_reason: String) -> void:
	if level_finished and task_session.get("ended_at_ticks", 0) != 0:
		return

	level_finished = true
	timer_running = false
	_set_option_buttons_enabled(false)
	btn_analyze.disabled = not safe_mode
	btn_hint.disabled = true
	btn_next.visible = true

	if not is_correct:
		var explain_short: String = str(current_level.get("explain_short", ""))
		if not explain_short.is_empty():
			lbl_status.text = explain_short
			lbl_status.add_theme_color_override("font_color", Color(1.0, 0.6, 0.45))

	if end_reason == "timeout":
		lbl_status.text = "Время вышло. Окно трассировки закрыто."
		lbl_status.add_theme_color_override("font_color", Color(1.0, 0.3, 0.3))

	var end_tick: int = Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_tick
	_log_event("task_end", {
		"is_correct": is_correct,
		"reason": end_reason,
		"safe_mode": safe_mode
	})

	var elapsed_ms: int = end_tick - level_started_ms
	var stability_delta: float = 0.0
	if not is_correct:
		stability_delta += FAIL_STABILITY_PENALTY
	if hint_used:
		stability_delta += HINT_STABILITY_PENALTY

	var level_id: String = str(current_level.get("id", "NT_UNKNOWN"))
	var payload: Dictionary = {
		"quest": "network_trace",
		"stage": complexity_name,
		"match_key": "NETTRACE_%s|%s" % [complexity_name, level_id],
		"task_id": level_id,
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"safe_mode": safe_mode,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"error_code": "" if is_correct else last_error_code,
		"attempts": attempts,
		"task_session": task_session,
		"stability_delta": stability_delta,
		"hint_used": hint_used,
		"timed_out": end_reason == "timeout",
		"time_to_first_action_ms": first_action_ms,
		"layout": current_layout,
		"ui_vw": int(size.x),
		"ui_vh": int(size.y)
	}
	GlobalMetrics.register_trial(payload)

func _on_timeout() -> void:
	if level_finished:
		return

	last_error_code = "TIMEOUT"
	var timeout_attempt: Dictionary = {
		"id": "TIMEOUT",
		"label": "TIMEOUT",
		"correct": false,
		"error_code": "TIMEOUT",
		"t_ms": Time.get_ticks_msec() - level_started_ms
	}
	attempts.append(timeout_attempt)
	var session_attempts: Array = task_session.get("attempts", [])
	session_attempts.append(timeout_attempt)
	task_session["attempts"] = session_attempts
	_play_audio("error")
	_trigger_glitch()
	_finish_level(false, "timeout")

func _show_diagnostics(lines: Array[String]) -> void:
	if diagnostics_panel.has_method("setup"):
		diagnostics_panel.call("setup", "ДИАГНОСТИКА", lines)
	diagnostics_panel.visible = true

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(v: float) -> void: shader_material.set_shader_parameter("glitch_strength", v), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for i in range(4):
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _play_audio(sound_key: String) -> void:
	if AudioManager != null:
		AudioManager.play(sound_key)

func _log_event(event_name: String, data: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": event_name,
		"t_ms": Time.get_ticks_msec() - level_started_ms,
		"payload": data
	})
	task_session["events"] = events

func _build_variant_key(level: Dictionary) -> String:
	var ids: Array[String] = []
	var options: Array = level.get("options", [])
	for option_var in options:
		var option: Dictionary = option_var
		ids.append(str(option.get("id", "")))
	ids.sort()
	return "%s|%s|%s|%s" % [
		str(level.get("id", "NT_UNKNOWN")),
		str(level.get("prompt", "")),
		str(level.get("correct_id", "")),
		",".join(ids)
	]

func _stringify_array(input: Array) -> Array[String]:
	var out: Array[String] = []
	for value in input:
		out.append(str(value))
	return out

func _apply_layout_mode() -> void:
	if terminal_pane == null or actions_pane == null:
		return
	if body_landscape == null or body_portrait == null:
		return

	var viewport_size: Vector2 = get_viewport_rect().size
	var portrait: bool = viewport_size.x < viewport_size.y

	if portrait:
		if terminal_pane.get_parent() != body_portrait:
			var parent_a: Node = terminal_pane.get_parent()
			if parent_a != null:
				parent_a.remove_child(terminal_pane)
			body_portrait.add_child(terminal_pane)
		if actions_pane.get_parent() != body_portrait:
			var parent_b: Node = actions_pane.get_parent()
			if parent_b != null:
				parent_b.remove_child(actions_pane)
			body_portrait.add_child(actions_pane)
		body_landscape.visible = false
		body_portrait.visible = true
		current_layout = "portrait"
	else:
		if terminal_pane.get_parent() != body_landscape:
			var parent_c: Node = terminal_pane.get_parent()
			if parent_c != null:
				parent_c.remove_child(terminal_pane)
			body_landscape.add_child(terminal_pane)
		if actions_pane.get_parent() != body_landscape:
			var parent_d: Node = actions_pane.get_parent()
			if parent_d != null:
				parent_d.remove_child(actions_pane)
			body_landscape.add_child(actions_pane)
		body_portrait.visible = false
		body_landscape.visible = true
		current_layout = "landscape"

	terminal_pane.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	actions_pane.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	terminal_pane.size_flags_vertical = Control.SIZE_EXPAND_FILL
	actions_pane.size_flags_vertical = Control.SIZE_EXPAND_FILL
</file>

<file path="scenes/NetworkTraceQuestA.tscn">
[gd_scene load_steps=7 format=3 uid="uid://dnn0a5mgt8u1a"]

[ext_resource type="Script" path="res://scripts/quests/network_trace/NetworkTraceQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_terminal_green.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="4_diag_panel"]
[ext_resource type="Script" path="res://scripts/ui/network_trace/topology_board_a.gd" id="5_topology"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(0, 1, 0.25, 1)
shader_parameter/intensity = 0.12
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="NetworkTraceQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.04, 0.06, 0.05, 1)

[node name="CanvasModulate" type="CanvasModulate" parent="."]
color = Color(0.88, 1, 0.9, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 0)

[node name="Main" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="V" type="VBoxContainer" parent="Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="Main/V"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="Main/V/Header"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "НАЗАД"

[node name="LblTitle" type="Label" parent="Main/V/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 26
text = "СЕТЕВОЙ СЛЕД | A"

[node name="LblMeta" type="Label" parent="Main/V/Header"]
custom_minimum_size = Vector2(360, 48)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ДЕЛО -- | ОШ 0/3 | 02:00"
horizontal_alignment = 2
vertical_alignment = 1

[node name="PaletteSelect" type="OptionButton" parent="Main/V/Header"]
custom_minimum_size = Vector2(150, 52)
layout_mode = 2

[node name="Body" type="BoxContainer" parent="Main/V"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="TerminalPane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.55

[node name="TerminalMargin" type="MarginContainer" parent="Main/V/Body/TerminalPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="TerminalV" type="VBoxContainer" parent="Main/V/Body/TerminalPane/TerminalMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblBriefing" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 84)
layout_mode = 2
fit_content = false
bbcode_enabled = true
scroll_active = false

[node name="LblPrompt" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 76)
layout_mode = 2
fit_content = false
bbcode_enabled = true
scroll_active = false

[node name="LogScroll" type="ScrollContainer" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
size_flags_vertical = 3

[node name="LogList" type="VBoxContainer" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="EvidenceLabel" type="Label" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "УЛИКИ"

[node name="EvidenceRow" type="HBoxContainer" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 66)
layout_mode = 2
theme_override_constants/separation = 6

[node name="MapPane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.15

[node name="MapMargin" type="MarginContainer" parent="Main/V/Body/MapPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="MapV" type="VBoxContainer" parent="Main/V/Body/MapPane/MapMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="TopologyBoard" type="Control" parent="Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 240)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("5_topology")

[node name="PaletteLabel" type="Label" parent="Main/V/Body/MapPane/MapMargin/MapV"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ПАЛИТРА УСТРОЙСТВ"

[node name="PaletteScroll" type="ScrollContainer" parent="Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 94)
layout_mode = 2
horizontal_scroll_mode = 1
vertical_scroll_mode = 0

[node name="Palette" type="HBoxContainer" parent="Main/V/Body/MapPane/MapMargin/MapV/PaletteScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 8

[node name="Actions" type="HBoxContainer" parent="Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnAnalyze" type="Button" parent="Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "АНАЛИЗ"

[node name="BtnRunTrace" type="Button" parent="Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ЗАПУСТИТЬ ТРАССИРОВКУ"

[node name="BtnReset" type="Button" parent="Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "СБРОС"

[node name="BtnNext" type="Button" parent="Main/V/Body/MapPane/MapMargin/MapV/Actions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
visible = false
text = "ДАЛЕЕ"

[node name="LblStatus" type="Label" parent="Main/V/Body/MapPane/MapMargin/MapV"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Статус"

[node name="DiagnosticsPanel" parent="." instance=ExtResource("4_diag_panel")]
layout_mode = 1
anchor_left = 0.1
anchor_top = 0.12
anchor_right = 0.9
anchor_bottom = 0.9
</file>

<file path="scenes/NetworkTraceQuestB.tscn">
[gd_scene load_steps=7 format=3 uid="uid://bc7hh137v5i1q"]

[ext_resource type="Script" path="res://scripts/quests/network_trace/NetworkTraceQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_terminal_green.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="4_diag_panel"]
[ext_resource type="PackedScene" path="res://scenes/ui/pipeline/PipelineSlot.tscn" id="5_pipeline_slot"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(0, 1, 0.25, 1)
shader_parameter/intensity = 0.12
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="NetworkTraceQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.04, 0.06, 0.05, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 0)

[node name="Main" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="V" type="VBoxContainer" parent="Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="Main/V"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnBack" type="Button" parent="Main/V/Header"]
custom_minimum_size = Vector2(118, 58)
layout_mode = 2
text = "НАЗАД"

[node name="LblTitle" type="Label" parent="Main/V/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "СЕТЕВОЙ СЛЕД | B"

[node name="LblMeta" type="Label" parent="Main/V/Header"]
custom_minimum_size = Vector2(340, 52)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ДЕЛО -- | ОШ 0/3 | T-02:00"
horizontal_alignment = 2
vertical_alignment = 1

[node name="StabilityBar" type="ProgressBar" parent="Main/V/Header"]
custom_minimum_size = Vector2(140, 38)
layout_mode = 2
max_value = 100.0
value = 100.0
show_percentage = false

[node name="PaletteSelect" type="OptionButton" parent="Main/V/Header"]
custom_minimum_size = Vector2(130, 52)
layout_mode = 2

[node name="Body" type="BoxContainer" parent="Main/V"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="TerminalPane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.4

[node name="TerminalMargin" type="MarginContainer" parent="Main/V/Body/TerminalPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="TerminalV" type="VBoxContainer" parent="Main/V/Body/TerminalPane/TerminalMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblBriefing" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 76)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="LblPrompt" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="InterceptBox" type="VBoxContainer" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="LblPayload" type="Label" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox"]
layout_mode = 2
text = "Данные: --"

[node name="LblWindow" type="Label" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox"]
layout_mode = 2
text = "Окно: --"

[node name="LblTargetUnit" type="Label" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/InterceptBox"]
layout_mode = 2
text = "Целевая единица: --"

[node name="BtnAnalyze" type="Button" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="LogScroll" type="ScrollContainer" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LogText" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll"]
custom_minimum_size = Vector2(0, 190)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
fit_content = false
selection_enabled = true
autowrap_mode = 2

[node name="ConsolePane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.35

[node name="ConsoleMargin" type="MarginContainer" parent="Main/V/Body/ConsolePane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="ConsoleV" type="VBoxContainer" parent="Main/V/Body/ConsolePane/ConsoleMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblConsoleTitle" type="Label" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "КОНСОЛЬ ШЛЮЗА"

[node name="PipelineBoard" type="GridContainer" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="SlotKilo" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("5_pipeline_slot")]
layout_mode = 2

[node name="SlotBit" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("5_pipeline_slot")]
layout_mode = 2

[node name="SlotTime" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("5_pipeline_slot")]
layout_mode = 2

[node name="SlotOut" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/PipelineBoard" instance=ExtResource("5_pipeline_slot")]
layout_mode = 2

[node name="LblModuleTray" type="Label" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ЛОТОК МОДУЛЕЙ"

[node name="ModuleTrayScroll" type="ScrollContainer" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 166)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ModuleTray" type="GridContainer" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV/ModuleTrayScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 4

[node name="BtnRunCalc" type="Button" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "ЗАПУСТИТЬ РАСЧЁТ"

[node name="LblPreview" type="Label" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "СКОРОСТЬ = ???"

[node name="TransferBar" type="ProgressBar" parent="Main/V/Body/ConsolePane/ConsoleMargin/ConsoleV"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="AnswersPane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="AnswersMargin" type="MarginContainer" parent="Main/V/Body/AnswersPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="AnswersV" type="VBoxContainer" parent="Main/V/Body/AnswersPane/AnswersMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="OptionsGrid" type="GridContainer" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="ActionBtn1" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn2" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn3" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn4" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn5" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn6" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="LblStatus" type="Label" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Статус"

[node name="BottomRow" type="HBoxContainer" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnNext" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
visible = false
text = "ДАЛЕЕ"

[node name="DiagnosticsPanel" parent="." instance=ExtResource("4_diag_panel")]
layout_mode = 1
anchor_left = 0.1
anchor_top = 0.12
anchor_right = 0.9
anchor_bottom = 0.9
</file>

<file path="scenes/radio_intercept/RadioQuestA.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/radio_intercept/RadioQuestA.gd" id="1_script"]

[node name="RadioQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootPanel" type="Panel" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="VBox" type="VBoxContainer" parent="RootPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 20

[node name="HeaderBar" type="HBoxContainer" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
alignment = 1

[node name="BackBtn" type="Button" parent="RootPanel/VBox/HeaderBar"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
text = "НАЗАД"

[node name="Spacer" type="Control" parent="RootPanel/VBox/HeaderBar"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2

[node name="TaskLabel" type="Label" parent="RootPanel/VBox/HeaderBar"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Перехват... Мощность алфавита: 128"

[node name="OscilloBox" type="PanelContainer" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 280)
layout_mode = 2

[node name="OscilloArea" type="Control" parent="RootPanel/VBox/OscilloBox"]
layout_mode = 2
clip_contents = true

[node name="OscilloNode" type="Node2D" parent="RootPanel/VBox/OscilloBox/OscilloArea"]

[node name="OscLine" type="Line2D" parent="RootPanel/VBox/OscilloBox/OscilloArea/OscilloNode"]
width = 3.0
default_color = Color(0, 0.8, 0.4, 1)
antialiased = true

[node name="TunerRow" type="HBoxContainer" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
alignment = 1

[node name="BitsLabel" type="Label" parent="RootPanel/VBox/TunerRow"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Биты: 1"

[node name="BitsSlider" type="HSlider" parent="RootPanel/VBox/TunerRow"]
custom_minimum_size = Vector2(400, 0)
layout_mode = 2
size_flags_vertical = 4
min_value = 1.0
max_value = 10.0
value = 1.0

[node name="ButtonsRow" type="HBoxContainer" parent="RootPanel/VBox"]
layout_mode = 2
theme_override_constants/separation = 40
alignment = 1

[node name="HintButton" type="Button" parent="RootPanel/VBox/ButtonsRow"]
custom_minimum_size = Vector2(200, 60)
layout_mode = 2
text = "Ассистент"

[node name="ConfirmButton" type="Button" parent="RootPanel/VBox/ButtonsRow"]
custom_minimum_size = Vector2(200, 60)
layout_mode = 2
text = "Подтвердить"

[node name="HintLabel" type="Label" parent="RootPanel/VBox"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.8, 0.2, 1)
horizontal_alignment = 1

[connection signal="pressed" from="SafeArea/RootPanel/VBox/HeaderBar/BackBtn" to="." method="_on_back_pressed"]
[connection signal="value_changed" from="SafeArea/RootPanel/VBox/TunerRow/BitsSlider" to="." method="_on_slider_value_changed"]
[connection signal="pressed" from="SafeArea/RootPanel/VBox/ButtonsRow/HintButton" to="." method="_on_hint_pressed"]
[connection signal="pressed" from="SafeArea/RootPanel/VBox/ButtonsRow/ConfirmButton" to="." method="_on_confirm_pressed"]
</file>

<file path="scenes/ui/ConfigCard.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/ConfigCard.gd" id="1_script"]

[node name="ConfigCard" type="PanelContainer"]
custom_minimum_size = Vector2(0, 118)
size_flags_horizontal = 3
mouse_filter = 1
script = ExtResource("1_script")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 2
mouse_filter = 2
theme_override_constants/separation = 4

[node name="Title" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
theme_override_font_sizes/font_size = 22
text = "Конфигурация"

[node name="Price" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
text = "Бюджет: 0$"

[node name="Parts" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
text = "Детали"
autowrap_mode = 2

[node name="Tags" type="Label" parent="VBox"]
layout_mode = 2
mouse_filter = 2
theme_override_font_sizes/font_size = 14
text = "Метки"
autowrap_mode = 2
</file>

<file path="scenes/ui/DiagnosticsPanelC.tscn">
[gd_scene load_steps=3 format=3 uid="uid://diagnostics_panel_c_new"]

[ext_resource type="Script" path="res://scripts/ui/DiagnosticsPanelC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]

[node name="DiagnosticsPanelC" type="PanelContainer"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.15
anchor_top = 0.2
anchor_right = 0.85
anchor_bottom = 0.8
offset_left = 0.0
offset_top = 0.0
offset_right = 0.0
offset_bottom = 0.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
mouse_filter = 0
script = ExtResource("1_script")

[node name="Root" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 12

[node name="LblTitle" type="Label" parent="Root"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДИАГНОСТИКА"
horizontal_alignment = 1

[node name="Body" type="RichTextLabel" parent="Root"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "..."

[node name="BtnClose" type="Button" parent="Root"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scenes/ui/FixMenuC.tscn">
[gd_scene load_steps=3 format=3 uid="uid://fix_menu_c_new"]

[ext_resource type="Script" path="res://scripts/ui/FixMenuC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]

[node name="FixMenuC" type="PopupPanel"]
initial_position = 1
size = Vector2i(860, 420)
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Root" type="VBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 12

[node name="LblTitle" type="Label" parent="Root"]
layout_mode = 2
theme_override_font_sizes/font_size = 28
text = "ИСПРАВИТЬ СТРОКУ 01"
horizontal_alignment = 1

[node name="LblOriginal" type="Label" parent="Root"]
layout_mode = 2
autowrap_mode = 2
text = "оригинал: if i > 3:"

[node name="Options" type="VBoxContainer" parent="Root"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnOptA" type="Button" parent="Root/Options"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "A) --"

[node name="BtnOptB" type="Button" parent="Root/Options"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "B) --"

[node name="BtnOptC" type="Button" parent="Root/Options"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "C) --"

[node name="Actions" type="HBoxContainer" parent="Root"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="BtnApply" type="Button" parent="Root/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ПРИМЕНИТЬ"

[node name="BtnClose" type="Button" parent="Root/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ОТМЕНА"
</file>

<file path="scenes/ui/ResusPartItem.tscn">
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/ui/ResusPartItem.gd" id="1_script"]

[node name="ResusPartItem" type="Button"]
custom_minimum_size = Vector2(0, 80)
size_flags_horizontal = 3
theme_type_variation = &"FlatButton"
theme_override_font_sizes/font_size = 18
text = "Деталь"
script = ExtResource("1_script")
</file>

<file path="scripts/case_01/ResusData.gd">
extends RefCounted

const REQUIRED_LEVEL_KEYS: Array[String] = ["id", "briefing", "format", "buckets", "items", "scoring_model", "feedback_rules", "system_state_rules"]
const REQUIRED_BUCKET_IDS: Array[String] = ["INPUT", "OUTPUT", "MEMORY"]
const REQUIRED_PARTS: Array[String] = ["gpu", "ram", "cache"]

static func load_levels(path: String) -> Array:
	var root: Variant = _parse_root(path)
	if typeof(root) == TYPE_NIL:
		return []

	var levels: Array = []
	if typeof(root) == TYPE_ARRAY:
		for level_v in root:
			if typeof(level_v) != TYPE_DICTIONARY:
				continue
			var level_data: Dictionary = level_v as Dictionary
			if validate_level(level_data):
				levels.append(level_data)
	elif typeof(root) == TYPE_DICTIONARY:
		var root_dict: Dictionary = root as Dictionary
		if root_dict.has("stages"):
			var stages: Dictionary = root_dict.get("stages", {}) as Dictionary
			var stage_a: Variant = stages.get("A", null)
			if typeof(stage_a) == TYPE_DICTIONARY:
				var stage_a_data: Dictionary = stage_a as Dictionary
				if validate_level(stage_a_data):
					levels.append(stage_a_data)
	return levels

static func load_stage_b(path: String) -> Dictionary:
	return _load_stage(path, "B")

static func load_stage_c(path: String) -> Dictionary:
	return _load_stage(path, "C")

static func _load_stage(path: String, stage_id: String) -> Dictionary:
	var root: Variant = _parse_root(path)
	if typeof(root) == TYPE_NIL:
		return {}

	var stage_data: Dictionary = {}
	if typeof(root) == TYPE_DICTIONARY:
		var root_dict: Dictionary = root as Dictionary
		stage_data = _extract_stage(root_dict, stage_id)
	elif typeof(root) == TYPE_ARRAY:
		var root_array: Array = root as Array
		for item_v in root_array:
			if typeof(item_v) != TYPE_DICTIONARY:
				continue
			var candidate: Dictionary = item_v as Dictionary
			stage_data = _extract_stage(candidate, stage_id)
			if not stage_data.is_empty():
				break

	if stage_data.is_empty():
		push_error("ResusData: Stage %s section not found" % stage_id)
		return {}

	var is_valid: bool = false
	if stage_id == "B":
		is_valid = validate_stage_b(stage_data)
	elif stage_id == "C":
		is_valid = validate_stage_c(stage_data)
	else:
		push_error("ResusData: unsupported stage id '%s'" % stage_id)
		return {}

	if not is_valid:
		return {}
	return stage_data

static func _parse_root(path: String) -> Variant:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		push_error("ResusData: failed to open %s" % path)
		return null

	var json: JSON = JSON.new()
	var parse_code: int = json.parse(file.get_as_text())
	if parse_code != OK:
		push_error("ResusData: JSON parse error in %s: %s" % [path, json.get_error_message()])
		return null
	return json.data

static func _extract_stage(root_dict: Dictionary, stage_id: String) -> Dictionary:
	if root_dict.has("stages"):
		var stages: Dictionary = root_dict.get("stages", {}) as Dictionary
		var stage_data_v: Variant = stages.get(stage_id, null)
		if typeof(stage_data_v) == TYPE_DICTIONARY:
			return stage_data_v as Dictionary
	if root_dict.has(stage_id) and typeof(root_dict.get(stage_id, null)) == TYPE_DICTIONARY:
		return root_dict.get(stage_id, {}) as Dictionary
	return {}

static func validate_level(level: Dictionary) -> bool:
	for key in REQUIRED_LEVEL_KEYS:
		if not level.has(key):
			push_error("ResusData: missing key '%s' in level %s" % [key, str(level.get("id", "UNKNOWN"))])
			return false

	if str(level.get("format", "")) != "MATCHING":
		push_error("ResusData: unsupported format in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var buckets: Array = level.get("buckets", []) as Array
	if buckets.size() != 3:
		push_error("ResusData: level %s must have exactly 3 buckets" % str(level.get("id", "UNKNOWN")))
		return false

	var bucket_ids: Dictionary = {}
	for bucket_v in buckets:
		if typeof(bucket_v) != TYPE_DICTIONARY:
			return false
		var bucket: Dictionary = bucket_v as Dictionary
		var bucket_id: String = str(bucket.get("bucket_id", "")).to_upper()
		if bucket_id == "" or bucket_ids.has(bucket_id):
			push_error("ResusData: duplicate or empty bucket_id in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		bucket_ids[bucket_id] = true

	for required_bucket in REQUIRED_BUCKET_IDS:
		if not bucket_ids.has(required_bucket):
			push_error("ResusData: bucket %s is required in level %s" % [required_bucket, str(level.get("id", "UNKNOWN"))])
			return false

	var items: Array = level.get("items", []) as Array
	if items.size() != 8:
		push_error("ResusData: level %s must have exactly 8 items" % str(level.get("id", "UNKNOWN")))
		return false

	var item_ids: Dictionary = {}
	for item_v in items:
		if typeof(item_v) != TYPE_DICTIONARY:
			return false
		var item: Dictionary = item_v as Dictionary
		var item_id: String = str(item.get("item_id", ""))
		var label: String = str(item.get("label", ""))
		var correct_bucket_id: String = str(item.get("correct_bucket_id", "")).to_upper()
		if item_id == "" or label == "" or correct_bucket_id == "":
			push_error("ResusData: item contract is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
			return false
		if item_ids.has(item_id):
			push_error("ResusData: duplicate item_id %s in level %s" % [item_id, str(level.get("id", "UNKNOWN"))])
			return false
		if not bucket_ids.has(correct_bucket_id):
			push_error("ResusData: item %s references missing bucket %s" % [item_id, correct_bucket_id])
			return false
		item_ids[item_id] = true

	for mandatory_part in REQUIRED_PARTS:
		if not item_ids.has(mandatory_part):
			push_error("ResusData: mandatory part %s is missing" % mandatory_part)
			return false

	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = scoring_model.get("rules", []) as Array
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	if rules.is_empty() or default_rule.is_empty():
		push_error("ResusData: scoring_model is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	for rule_v in rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			return false
		var rule: Dictionary = rule_v as Dictionary
		if not rule.has_all(["min_correct", "points", "stability_delta", "verdict_code"]):
			push_error("ResusData: scoring rule is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
			return false

	if not default_rule.has_all(["code", "points", "stability_delta", "verdict_code"]):
		push_error("ResusData: default_rule is incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	var system_rules: Dictionary = level.get("system_state_rules", {}) as Dictionary
	if not system_rules.has_all(["monitor_on_if", "ram_ok_if", "fast_type_if"]):
		push_error("ResusData: system_state_rules are incomplete in level %s" % str(level.get("id", "UNKNOWN")))
		return false

	return true

static func validate_stage_b(stage_b: Dictionary) -> bool:
	if str(stage_b.get("format", "")) != "SINGLE_CHOICE_CONTEXT":
		push_error("ResusData: Stage B invalid format")
		return false

	var budget: int = int(stage_b.get("budget", 0))
	if budget <= 0:
		push_error("ResusData: Stage B invalid budget")
		return false

	var options: Array = stage_b.get("options", []) as Array
	if options.size() != 4:
		push_error("ResusData: Stage B must contain exactly 4 options")
		return false

	var option_ids: Dictionary = {}
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			push_error("ResusData: Stage B option must be dictionary")
			return false
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", ""))
		if option_id == "" or option_ids.has(option_id):
			push_error("ResusData: Stage B option_id is missing or duplicated")
			return false
		if not option_data.has_all(["title", "total_price", "parts", "tags"]):
			push_error("ResusData: Stage B option %s is incomplete" % option_id)
			return false
		option_ids[option_id] = true

	var correct_option_id: String = str(stage_b.get("correct_option_id", ""))
	if correct_option_id == "" or not option_ids.has(correct_option_id):
		push_error("ResusData: Stage B correct_option_id is invalid")
		return false

	var feedback_rules: Dictionary = stage_b.get("feedback_rules", {}) as Dictionary
	for option_id_v in option_ids.keys():
		var option_id: String = str(option_id_v)
		if not feedback_rules.has(option_id):
			push_error("ResusData: Stage B feedback rule is missing for %s" % option_id)
			return false

	var scoring_model: Dictionary = stage_b.get("scoring_model", {}) as Dictionary
	if scoring_model.is_empty():
		push_error("ResusData: Stage B scoring_model is missing")
		return false
	if not scoring_model.has_all(["correct_points", "wrong_points", "stability_delta_correct", "stability_delta_wrong", "default_rule"]):
		push_error("ResusData: Stage B scoring_model is incomplete")
		return false
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	if not default_rule.has_all(["when", "points", "stability_delta", "verdict_code"]):
		push_error("ResusData: Stage B default_rule is incomplete")
		return false

	return true

static func validate_stage_c(stage_c: Dictionary) -> bool:
	if str(stage_c.get("format", "")) != "MULTI_CHOICE_SLOTS":
		push_error("ResusData: Stage C invalid format")
		return false

	if int(stage_c.get("max_slots", 0)) != 3:
		push_error("ResusData: Stage C max_slots must be 3")
		return false

	var options: Array = stage_c.get("options", []) as Array
	if options.size() != 5:
		push_error("ResusData: Stage C must contain exactly 5 options")
		return false

	var required_effect_keys: Array[String] = ["collisions", "filtering", "eavesdrop", "media"]
	var option_ids: Dictionary = {}
	var correct_count: int = 0
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			push_error("ResusData: Stage C option must be dictionary")
			return false
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", "")).strip_edges()
		if option_id == "" or option_ids.has(option_id):
			push_error("ResusData: Stage C option_id is missing or duplicated")
			return false
		if not option_data.has_all(["label", "is_correct", "why"]):
			push_error("ResusData: Stage C option %s is incomplete" % option_id)
			return false
		var effects: Dictionary = option_data.get("effects", {}) as Dictionary
		for effect_key in required_effect_keys:
			if not effects.has(effect_key):
				push_error("ResusData: Stage C option %s missing effect '%s'" % [option_id, effect_key])
				return false
		if bool(option_data.get("is_correct", false)):
			correct_count += 1
		option_ids[option_id] = true

	if correct_count != 3:
		push_error("ResusData: Stage C must have exactly 3 correct options")
		return false

	var scoring_model: Dictionary = stage_c.get("scoring_model", {}) as Dictionary
	if scoring_model.is_empty():
		push_error("ResusData: Stage C scoring_model is missing")
		return false
	if not scoring_model.has_all(["rule_2", "rule_1a", "rule_1b", "default_rule", "empty_rule", "select_all_rule"]):
		push_error("ResusData: Stage C scoring_model is incomplete")
		return false

	var feedback_rules: Dictionary = stage_c.get("feedback_rules", {}) as Dictionary
	var required_feedback_keys: Array[String] = ["PERFECT", "GOOD", "NOISY", "FAIL", "EMPTY", "SELECT_ALL"]
	for feedback_key in required_feedback_keys:
		if not feedback_rules.has(feedback_key):
			push_error("ResusData: Stage C feedback rule '%s' is missing" % feedback_key)
			return false

	return true
</file>

<file path="scripts/case_07/da7_cases_c.gd">
extends Node

const SCHEMA_VERSION := "DA7.C.v2"
const LEVEL := "C"

const CASES_C: Array = [
	{
		"id": "DA7-C-01",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_SELECT",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Соберите запрос, который выбирает имена пользователей, где id = 5.",
		"available_blocks": [
			{"id": "b1", "text": "SELECT", "role": "KW_MAIN"},
			{"id": "b2", "text": "name", "role": "IDENT_FIELD"},
			{"id": "b3", "text": "FROM", "role": "KW_FROM"},
			{"id": "b4", "text": "Users", "role": "IDENT_TABLE"},
			{"id": "b5", "text": "WHERE", "role": "KW_WHERE"},
			{"id": "b6", "text": "id=5", "role": "COND_WHERE"},
			{"id": "b7", "text": "DELETE", "role": "KW_DISTRACTOR"},
			{"id": "b8", "text": "TABLE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5", "b6"],
		"rules": {
			"required_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"min_tokens": 6,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b7", "b8"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"order_rules": [
				{"before": "KW_FROM", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "KW_FROM"},
				{"before": "KW_WHERE", "after": "IDENT_TABLE"},
				{"before": "COND_WHERE", "after": "KW_WHERE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-02",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_UPDATE",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Соберите UPDATE-запрос: установите role='admin' для пользователя с id = 5.",
		"available_blocks": [
			{"id": "b1", "text": "UPDATE", "role": "KW_MAIN"},
			{"id": "b2", "text": "Users", "role": "IDENT_TABLE"},
			{"id": "b3", "text": "SET", "role": "KW_SET"},
			{"id": "b4", "text": "role='admin'", "role": "ASSIGN"},
			{"id": "b5", "text": "WHERE", "role": "KW_WHERE"},
			{"id": "b6", "text": "id=5", "role": "COND_WHERE"},
			{"id": "b7", "text": "FROM", "role": "KW_DISTRACTOR"},
			{"id": "b8", "text": "DROP", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5", "b6"],
		"rules": {
			"required_roles": ["KW_MAIN", "IDENT_TABLE", "KW_SET", "ASSIGN"],
			"min_tokens": 6,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b7", "b8"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "IDENT_TABLE", "KW_SET"],
			"order_rules": [
				{"before": "IDENT_TABLE", "after": "KW_MAIN"},
				{"before": "KW_SET", "after": "IDENT_TABLE"},
				{"before": "ASSIGN", "after": "KW_SET"},
				{"before": "KW_WHERE", "after": "ASSIGN"},
				{"before": "COND_WHERE", "after": "KW_WHERE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-03",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_DELETE",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Удалите DEBUG-логи из таблицы Logs.",
		"available_blocks": [
			{"id": "b1", "text": "DELETE", "role": "KW_MAIN"},
			{"id": "b2", "text": "FROM", "role": "KW_FROM"},
			{"id": "b3", "text": "Logs", "role": "IDENT_TABLE"},
			{"id": "b4", "text": "WHERE", "role": "KW_WHERE"},
			{"id": "b5", "text": "level='DEBUG'", "role": "COND_WHERE"},
			{"id": "b6", "text": "TABLE", "role": "DDL_TARGET"},
			{"id": "b7", "text": "CREATE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5"],
		"rules": {
			"required_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"min_tokens": 5,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b6", "b7"],
			"forbidden_roles": ["DDL_TARGET", "KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "KW_FROM", "IDENT_TABLE"],
			"order_rules": [
				{"before": "KW_FROM", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "KW_FROM"},
				{"before": "KW_WHERE", "after": "IDENT_TABLE"},
				{"before": "COND_WHERE", "after": "KW_WHERE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-04",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "SQL_INSERT",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Добавьте пользователя (7, 'Neo') в таблицу Users.",
		"available_blocks": [
			{"id": "b1", "text": "INSERT", "role": "KW_MAIN"},
			{"id": "b2", "text": "INTO", "role": "KW_INTO"},
			{"id": "b3", "text": "Users", "role": "IDENT_TABLE"},
			{"id": "b4", "text": "(id,name)", "role": "FIELD_LIST"},
			{"id": "b5", "text": "VALUES", "role": "KW_VALUES"},
			{"id": "b6", "text": "(7,'Neo')", "role": "VALUE_LIST"},
			{"id": "b7", "text": "WHERE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4", "b5", "b6"],
		"rules": {
			"required_roles": ["KW_MAIN", "KW_INTO", "IDENT_TABLE", "KW_VALUES"],
			"min_tokens": 6,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b7"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "KW_INTO", "IDENT_TABLE"],
			"order_rules": [
				{"before": "KW_INTO", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "KW_INTO"},
				{"before": "FIELD_LIST", "after": "IDENT_TABLE"},
				{"before": "KW_VALUES", "after": "FIELD_LIST"},
				{"before": "VALUE_LIST", "after": "KW_VALUES"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-05",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "DDL_CREATE_TABLE",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Создайте таблицу Archive с одним столбцом id типа INT.",
		"available_blocks": [
			{"id": "b1", "text": "CREATE", "role": "KW_MAIN"},
			{"id": "b2", "text": "TABLE", "role": "DDL_TARGET"},
			{"id": "b3", "text": "Archive", "role": "IDENT_TABLE"},
			{"id": "b4", "text": "(id INT)", "role": "DDL_DEF"},
			{"id": "b5", "text": "WHERE", "role": "KW_DISTRACTOR"},
			{"id": "b6", "text": "DELETE", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3", "b4"],
		"rules": {
			"required_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_TABLE", "DDL_DEF"],
			"min_tokens": 4,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b5", "b6"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_TABLE"],
			"order_rules": [
				{"before": "DDL_TARGET", "after": "KW_MAIN"},
				{"before": "IDENT_TABLE", "after": "DDL_TARGET"},
				{"before": "DDL_DEF", "after": "IDENT_TABLE"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	},
	{
		"id": "DA7-C-06",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_SQL",
		"case_kind": "DDL_CREATE_DB",
		"interaction_type": "ASSEMBLE_BLOCKS",
		"prompt": "Создайте базу данных ArchiveDB.",
		"available_blocks": [
			{"id": "b1", "text": "CREATE", "role": "KW_MAIN"},
			{"id": "b2", "text": "DATABASE", "role": "DDL_TARGET"},
			{"id": "b3", "text": "ArchiveDB", "role": "IDENT_DB"},
			{"id": "b4", "text": "TABLE", "role": "KW_DISTRACTOR"},
			{"id": "b5", "text": "FROM", "role": "KW_DISTRACTOR"}
		],
		"correct_sequence_ids": ["b1", "b2", "b3"],
		"rules": {
			"required_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_DB"],
			"min_tokens": 3,
			"allow_repeat_roles": [],
			"forbidden_block_ids": ["b4", "b5"],
			"forbidden_roles": ["KW_DISTRACTOR"],
			"skeleton_roles": ["KW_MAIN", "DDL_TARGET", "IDENT_DB"],
			"order_rules": [
				{"before": "DDL_TARGET", "after": "KW_MAIN"},
				{"before": "IDENT_DB", "after": "DDL_TARGET"}
			]
		},
		"timing_policy": {"mode": "EXAM", "limit_sec": 120, "on_timeout": "TIMEOUT"},
		"anti_cheat": {"shuffle_blocks": true}
	}
]

static func validate_case_c(case_data: Dictionary) -> bool:
	var case_id: String = str(case_data.get("id", "UNKNOWN"))
	if str(case_data.get("schema_version", "")) != SCHEMA_VERSION:
		push_error("Case %s bad schema version" % case_id)
		return false
	if str(case_data.get("interaction_type", "")) != "ASSEMBLE_BLOCKS":
		push_error("Case %s bad interaction_type" % case_id)
		return false

	var blocks: Array = case_data.get("available_blocks", []) as Array
	var rules: Dictionary = case_data.get("rules", {}) as Dictionary
	var correct_ids: Array = case_data.get("correct_sequence_ids", []) as Array
	if blocks.is_empty() or rules.is_empty() or correct_ids.is_empty():
		push_error("Case %s missing blocks/rules/correct ids" % case_id)
		return false

	var block_by_id: Dictionary = {}
	for block_v in blocks:
		if typeof(block_v) != TYPE_DICTIONARY:
			push_error("Case %s has non-dictionary block" % case_id)
			return false
		var block_data: Dictionary = block_v as Dictionary
		var block_id: String = str(block_data.get("id", ""))
		var block_text: String = str(block_data.get("text", ""))
		var block_role: String = str(block_data.get("role", ""))
		if block_id == "" or block_text == "" or block_role == "" or block_by_id.has(block_id):
			push_error("Case %s has invalid block contract" % case_id)
			return false
		block_by_id[block_id] = block_data

	var required_roles: Array = rules.get("required_roles", []) as Array
	var allow_repeat_roles: Array = rules.get("allow_repeat_roles", []) as Array
	var forbidden_block_ids: Array = rules.get("forbidden_block_ids", []) as Array
	var forbidden_roles: Array = rules.get("forbidden_roles", []) as Array
	var skeleton_roles: Array = rules.get("skeleton_roles", []) as Array
	var order_rules: Array = rules.get("order_rules", []) as Array
	var min_tokens: int = int(rules.get("min_tokens", 0))
	if min_tokens <= 0:
		push_error("Case %s has invalid min_tokens" % case_id)
		return false
	if required_roles.is_empty() or skeleton_roles.is_empty():
		push_error("Case %s rules missing required/skeleton roles" % case_id)
		return false
	if typeof(allow_repeat_roles) != TYPE_ARRAY or typeof(forbidden_block_ids) != TYPE_ARRAY or typeof(forbidden_roles) != TYPE_ARRAY:
		push_error("Case %s rules arrays are malformed" % case_id)
		return false
	for block_id_v in forbidden_block_ids:
		if not block_by_id.has(str(block_id_v)):
			push_error("Case %s forbidden block id %s is unknown" % [case_id, str(block_id_v)])
			return false
	for order_rule_v in order_rules:
		if typeof(order_rule_v) != TYPE_DICTIONARY:
			push_error("Case %s has malformed order rule" % case_id)
			return false
		var order_rule: Dictionary = order_rule_v as Dictionary
		if str(order_rule.get("before", "")) == "" or str(order_rule.get("after", "")) == "":
			push_error("Case %s has incomplete order rule" % case_id)
			return false

	for id_v in correct_ids:
		if not block_by_id.has(str(id_v)):
			push_error("Case %s correct_sequence_ids contains unknown block id %s" % [case_id, str(id_v)])
			return false
	if correct_ids.size() < min_tokens:
		push_error("Case %s correct sequence shorter than min_tokens" % case_id)
		return false

	return true
</file>

<file path="scripts/case_08/fr8_final_report_a.gd">
extends Control

const LEVELS_PATH := "res://data/final_report_a_levels.json"
const FR8Data := preload("res://scripts/case_08/fr8_data.gd")
const FR8Scoring := preload("res://scripts/case_08/fr8_scoring.gd")
const TAG_FRAGMENT_SCENE: PackedScene = preload("res://scenes/ui/TagFragmentItem.tscn")
const TAG_SLOT_SCENE: PackedScene = preload("res://scenes/ui/TagSlotZone.tscn")

const COLOR_OK := Color(0.55, 0.95, 0.62, 1.0)
const COLOR_WARN := Color(1.0, 0.82, 0.35, 1.0)
const COLOR_ERR := Color(1.0, 0.45, 0.45, 1.0)
const COLOR_INFO := Color(0.84, 0.84, 0.84, 1.0)

const TEXT_BACK := "\u041d\u0410\u0417\u0410\u0414"
const TEXT_RESET := "\u0421\u0411\u0420\u041e\u0421"
const TEXT_CONFIRM := "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TEXT_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TEXT_FINISH := "\u0417\u0410\u0412\u0415\u0420\u0428\u0418\u0422\u042c"

const STATUS_HINT := "\u041f\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\u044b \u0432 \u0441\u043b\u043e\u0442\u044b \u0440\u0435\u0434\u0430\u043a\u0442\u043e\u0440\u0430\u2026"
const STATUS_INCOMPLETE := "\u041d\u0435 \u0432\u0441\u0435 \u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\u044b \u0432\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b"
const STATUS_NEXT_HINT := "\u0413\u043e\u0442\u043e\u0432\u043e. \u0416\u043c\u0438\u0442\u0435 \u0414\u0410\u041b\u0415\u0415."
const STATUS_SOLVE_FIRST := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0440\u0435\u0448\u0438\u0442\u0435 \u0443\u0440\u043e\u0432\u0435\u043d\u044c"

var levels: Array = []
var level_data: Dictionary = {}
var fragments_data: Array = []

var slot_ids: Array[String] = []
var expected_sequence: Array[String] = []
var fragment_by_id: Dictionary = {}
var slot_nodes: Dictionary = {}
var fragment_nodes: Dictionary = {}

var current_level_index: int = 0
var start_time_ms: int = 0
var drag_count: int = 0
var swap_count: int = 0
var trace: Array = []

var level_solved: bool = false
var confirm_locked: bool = false

@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var body: BoxContainer = $SafeArea/MainLayout/Body
@onready var fragments_card: PanelContainer = $SafeArea/MainLayout/Body/FragmentsCard
@onready var editor_card: PanelContainer = $SafeArea/MainLayout/Body/EditorCard
@onready var pile_zone: Node = $SafeArea/MainLayout/Body/FragmentsCard/CardVBox/PileZone
@onready var slots_grid: GridContainer = $SafeArea/MainLayout/Body/EditorCard/CardVBox/SlotsGrid
@onready var code_preview: RichTextLabel = $SafeArea/MainLayout/Body/EditorCard/CardVBox/CodePreviewCard/CodePreview
@onready var status_label: Label = $SafeArea/MainLayout/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainLayout/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainLayout/BottomBar/BtnConfirm
@onready var btn_next: Button = $SafeArea/MainLayout/BottomBar/BtnNext
@onready var btn_back: Button = $SafeArea/MainLayout/Header/BtnBack
@onready var title_label: Label = $SafeArea/MainLayout/Header/TitleLabel
@onready var level_label: Label = $SafeArea/MainLayout/Header/LevelLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainLayout/Header/StabilityBar
@onready var briefing_label: Label = $SafeArea/MainLayout/BriefingCard/BriefingLabel
@onready var crt_overlay: ColorRect = $CanvasLayer/CRT_Overlay

func _ready() -> void:
	add_to_group("fr8_drop_controller")
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)

	_connect_ui_signals()
	_load_levels()
	if levels.is_empty():
		_show_error("\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0443\u0440\u043e\u0432\u043d\u0438 \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0442\u0447\u0451\u0442\u0430 A.")
		return

	title_label.text = "\u0414\u0415\u041b\u041e #8: \u0424\u0418\u041d\u0410\u041b\u042c\u041d\u042b\u0419 \u041e\u0422\u0427\u0415\u0422"
	btn_back.text = TEXT_BACK
	btn_reset.text = TEXT_RESET
	btn_confirm.text = TEXT_CONFIRM
	btn_next.text = TEXT_NEXT

	var initial_index: int = clamp(GlobalMetrics.current_level_index, 0, max(0, levels.size() - 1))
	_start_level(initial_index)
	_on_viewport_size_changed()

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	btn_next.pressed.connect(_on_next_pressed)

func _load_levels() -> void:
	levels = FR8Data.load_levels(LEVELS_PATH)

func _start_level(index: int) -> void:
	if levels.is_empty():
		return

	current_level_index = clamp(index, 0, levels.size() - 1)
	GlobalMetrics.current_level_index = current_level_index
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)
	fragments_data = (level_data.get("fragments", []) as Array).duplicate(true)

	slot_ids.clear()
	for slot_var in level_data.get("slots", []) as Array:
		slot_ids.append(str(slot_var))

	expected_sequence = FR8Scoring.normalize_expected_sequence(level_data)
	fragment_by_id.clear()
	for fragment_var in fragments_data:
		if typeof(fragment_var) != TYPE_DICTIONARY:
			continue
		var fragment_data: Dictionary = fragment_var as Dictionary
		fragment_by_id[str(fragment_data.get("fragment_id", ""))] = fragment_data

	level_label.text = _build_level_label()
	briefing_label.text = str(level_data.get("briefing", ""))

	if pile_zone.has_method("setup"):
		pile_zone.call("setup", "PILE", "\u0421\u041a\u041b\u0410\u0414 \u0424\u0420\u0410\u0413\u041c\u0415\u041d\u0422\u041e\u0412")
	_connect_zone_signal(pile_zone)

	_build_slot_nodes()
	_reset_attempt(true)

func _build_level_label() -> String:
	return "A | %s (%d/%d)" % [
		str(level_data.get("id", "FR8-A")),
		current_level_index + 1,
		levels.size()
	]

func _is_last_level() -> bool:
	return current_level_index >= levels.size() - 1

func _build_slot_nodes() -> void:
	for child in slots_grid.get_children():
		child.queue_free()
	slot_nodes.clear()

	for slot_id in slot_ids:
		var slot_node: Node = TAG_SLOT_SCENE.instantiate()
		slots_grid.add_child(slot_node)
		if slot_node.has_method("setup"):
			slot_node.call("setup", slot_id, slot_id)
		_connect_zone_signal(slot_node)
		slot_nodes[slot_id] = slot_node

func _connect_zone_signal(zone_node: Node) -> void:
	if zone_node == null:
		return
	if not zone_node.has_signal("item_placed"):
		return
	var callback: Callable = Callable(self, "_on_item_placed")
	if not zone_node.is_connected("item_placed", callback):
		zone_node.connect("item_placed", callback)

func _reset_attempt(is_level_start: bool = false) -> void:
	for slot_id in slot_ids:
		var slot_node: Node = slot_nodes.get(slot_id, null)
		if slot_node != null and slot_node.has_method("clear_items"):
			slot_node.call("clear_items")

	if pile_zone.has_method("clear_items"):
		pile_zone.call("clear_items")

	_spawn_fragments_into_pile()

	start_time_ms = Time.get_ticks_msec()
	drag_count = 0
	swap_count = 0
	trace.clear()
	_log_event("СБРОС", {"level_start": is_level_start})

	level_solved = false
	confirm_locked = false
	btn_confirm.disabled = false
	btn_next.disabled = true
	btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT

	_set_status(STATUS_HINT, COLOR_INFO)
	_update_code_preview()
	_update_slot_feedback()
	_update_stability_ui()

func _spawn_fragments_into_pile() -> void:
	fragment_nodes.clear()
	var shuffled_fragments: Array = fragments_data.duplicate(true)
	shuffled_fragments.shuffle()

	for fragment_var in shuffled_fragments:
		if typeof(fragment_var) != TYPE_DICTIONARY:
			continue
		var fragment_data: Dictionary = fragment_var as Dictionary
		var item_node: Node = TAG_FRAGMENT_SCENE.instantiate()
		if not (item_node is Control):
			continue

		if item_node.has_method("setup"):
			item_node.call("setup", fragment_data)
		item_node.set_meta("fragment_id", str(fragment_data.get("fragment_id", "")))
		if item_node.has_signal("drag_started"):
			item_node.connect("drag_started", Callable(self, "_on_drag_started"))

		if pile_zone.has_method("add_item_control"):
			pile_zone.call("add_item_control", item_node)

		var fragment_id: String = str(fragment_data.get("fragment_id", ""))
		if not fragment_id.is_empty():
			fragment_nodes[fragment_id] = item_node

func _on_drag_started(fragment_id: String, from_zone: String) -> void:
	drag_count += 1
	_log_event("DRAG_START", {
		"fragment_id": fragment_id,
		"from_zone": from_zone
	})

func _on_item_placed(fragment_id: String, to_zone: String, from_zone: String) -> void:
	_log_event("ITEM_PLACED", {
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"to_zone": to_zone
	})
	_update_code_preview()
	_update_slot_feedback()
	_set_status(STATUS_HINT, COLOR_INFO)

func handle_drop_to_slot(target_zone_id: String, payload: Dictionary) -> Dictionary:
	if not slot_nodes.has(target_zone_id):
		return {"success": false}

	var parsed: Dictionary = _parse_payload(payload)
	if parsed.is_empty():
		return {"success": false}

	var fragment_id: String = str(parsed.get("fragment_id", ""))
	var from_zone: String = str(parsed.get("from_zone", "PILE"))

	if _fragment_zone(fragment_id) == target_zone_id:
		return {"success": false}

	var target_existing_id: String = _fragment_in_slot(target_zone_id)
	var swapped: bool = false
	if not target_existing_id.is_empty() and target_existing_id != fragment_id:
		var return_zone: String = from_zone
		if not _zone_exists(return_zone) or return_zone == target_zone_id:
			return_zone = "PILE"
		if not _move_fragment_to_zone(target_existing_id, return_zone):
			return {"success": false}
		swapped = true

	if not _move_fragment_to_zone(fragment_id, target_zone_id):
		return {"success": false}

	if swapped:
		swap_count += 1

	return {
		"success": true,
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"to_zone": target_zone_id,
		"swapped": swapped
	}

func handle_drop_to_pile(payload: Dictionary) -> Dictionary:
	var parsed: Dictionary = _parse_payload(payload)
	if parsed.is_empty():
		return {"success": false}

	var fragment_id: String = str(parsed.get("fragment_id", ""))
	var from_zone: String = str(parsed.get("from_zone", "PILE"))
	if _fragment_zone(fragment_id) == "PILE":
		return {"success": false}

	if not _move_fragment_to_zone(fragment_id, "PILE"):
		return {"success": false}

	return {
		"success": true,
		"fragment_id": fragment_id,
		"from_zone": from_zone,
		"to_zone": "PILE",
		"swapped": false
	}

func _parse_payload(payload: Dictionary) -> Dictionary:
	if str(payload.get("kind", "")) != "TAG_FRAGMENT":
		return {}
	var fragment_id: String = str(payload.get("fragment_id", "")).strip_edges()
	if fragment_id.is_empty() or not fragment_nodes.has(fragment_id):
		return {}
	return {
		"fragment_id": fragment_id,
		"from_zone": str(payload.get("from_zone", "PILE"))
	}

func _zone_exists(zone_id: String) -> bool:
	if zone_id == "PILE":
		return true
	return slot_nodes.has(zone_id)

func _zone_by_id(zone_id: String) -> Node:
	if zone_id == "PILE":
		return pile_zone
	return slot_nodes.get(zone_id, null) as Node

func _move_fragment_to_zone(fragment_id: String, zone_id: String) -> bool:
	var fragment_node: Node = fragment_nodes.get(fragment_id, null) as Node
	if fragment_node == null:
		return false
	var zone_node: Node = _zone_by_id(zone_id)
	if zone_node == null:
		return false
	if not zone_node.has_method("add_item_control"):
		return false
	zone_node.call("add_item_control", fragment_node)
	return true

func _fragment_zone(fragment_id: String) -> String:
	var fragment_node: Node = fragment_nodes.get(fragment_id, null) as Node
	if fragment_node == null:
		return "PILE"
	if fragment_node.has_method("get_zone_id"):
		return str(fragment_node.call("get_zone_id"))
	return str(fragment_node.get_meta("zone_id", "PILE"))

func _fragment_in_slot(slot_id: String) -> String:
	var slot_node: Node = slot_nodes.get(slot_id, null) as Node
	if slot_node == null:
		return ""
	if slot_node.has_method("get_current_fragment_id"):
		return str(slot_node.call("get_current_fragment_id")).strip_edges()
	return ""

func _collect_sequence() -> Array[String]:
	var sequence: Array[String] = []
	for slot_id in slot_ids:
		sequence.append(_fragment_in_slot(slot_id))
	return sequence

func _build_snapshot_zones() -> Dictionary:
	var snapshot: Dictionary = {}
	for fragment_id_var in fragment_by_id.keys():
		var fragment_id: String = str(fragment_id_var)
		snapshot[fragment_id] = _fragment_zone(fragment_id)
	return snapshot

func _on_confirm_pressed() -> void:
	if confirm_locked:
		return

	var sequence: Array[String] = _collect_sequence()
	var snapshot_zones: Dictionary = _build_snapshot_zones()
	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	_log_event("CONFIRM_PRESSED", {
		"sequence": sequence.duplicate(),
		"filled_slots": _count_filled_slots(sequence)
	})

	var evaluation: Dictionary = FR8Scoring.evaluate(level_data, sequence, fragment_by_id)
	var score: Dictionary = FR8Scoring.resolve_score(level_data, evaluation)
	var checks: Dictionary = evaluation.get("checks", {
		"container_ok": false,
		"hierarchy_ok": false,
		"order_ok": false
	}) as Dictionary

	var points: int = int(score.get("points", 0))
	var max_points: int = int(score.get("max_points", 2))
	var is_fit: bool = bool(score.get("is_fit", false))
	var is_correct: bool = bool(score.get("is_correct", false))
	var stability_delta: int = int(score.get("stability_delta", 0))
	var verdict_code: String = str(score.get("verdict_code", "FAIL"))
	var error_code: String = str(evaluation.get("error_code", "FAIL"))
	var level_id: String = str(level_data.get("id", "FR8-A-00"))
	var match_key: String = "FR8_A|%s|%d" % [level_id, GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_08_FINAL_REPORT",
		"stage": "A",
		"level_id": level_id,
		"format": "TAG_ORDERING",
		"match_key": match_key,
		"sequence": sequence,
		"snapshot_zones": snapshot_zones,
		"error_code": error_code,
		"checks": {
			"container_ok": bool(checks.get("container_ok", false)),
			"hierarchy_ok": bool(checks.get("hierarchy_ok", false)),
			"order_ok": bool(checks.get("order_ok", false))
		},
		"elapsed_ms": elapsed_ms,
		"drag_count": drag_count,
		"swap_count": swap_count,
		"points": points,
		"max_points": max_points,
		"is_fit": is_fit,
		"is_correct": is_correct,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"trace": trace.duplicate(true)
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	var feedback_text: String = FR8Scoring.feedback_text(level_data, evaluation)
	if verdict_code == "PERFECT":
		level_solved = true
		confirm_locked = true
		btn_confirm.disabled = true
		btn_next.disabled = false
		btn_next.text = TEXT_FINISH if _is_last_level() else TEXT_NEXT
		_set_status("%s %s" % [feedback_text, STATUS_NEXT_HINT], COLOR_OK)
	elif verdict_code == "PARTIAL":
		level_solved = false
		confirm_locked = false
		btn_next.disabled = true
		_set_status(feedback_text, COLOR_WARN)
	else:
		level_solved = false
		confirm_locked = false
		btn_next.disabled = true
		if error_code == "INCOMPLETE":
			_set_status(STATUS_INCOMPLETE, COLOR_ERR)
		else:
			_set_status(feedback_text, COLOR_ERR)

	_play_confirm_audio(verdict_code)
	if verdict_code in ["FAIL", "EMPTY"]:
		_trigger_glitch()
		_shake_main_layout()

func _on_next_pressed() -> void:
	if not level_solved:
		_set_status(STATUS_SOLVE_FIRST, COLOR_WARN)
		return

	var from_level_id: String = str(level_data.get("id", "FR8-A-00"))
	var from_index: int = current_level_index
	if _is_last_level():
		_log_event("NEXT_PRESSED", {
			"from_level_id": from_level_id,
			"from_index": from_index,
			"to_index": -1
		})
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return

	var to_index: int = current_level_index + 1
	_log_event("NEXT_PRESSED", {
		"from_level_id": from_level_id,
		"from_index": from_index,
		"to_index": to_index
	})
	_start_level(to_index)

func _play_confirm_audio(verdict_code: String) -> void:
	if AudioManager == null:
		return
	match verdict_code:
		"PERFECT":
			AudioManager.play("relay")
		"FAIL", "EMPTY":
			AudioManager.play("error")
		_:
			AudioManager.play("click")

func _count_filled_slots(sequence: Array[String]) -> int:
	var filled: int = 0
	for fragment_id in sequence:
		if not str(fragment_id).is_empty():
			filled += 1
	return filled

func _update_code_preview() -> void:
	var lines: Array[String] = []
	for i in range(slot_ids.size()):
		var slot_id: String = slot_ids[i]
		var fragment_id: String = _fragment_in_slot(slot_id)
		var token: String = "____"
		if not fragment_id.is_empty() and fragment_by_id.has(fragment_id):
			var fragment_data: Dictionary = fragment_by_id.get(fragment_id, {}) as Dictionary
			token = str(fragment_data.get("token", fragment_data.get("label", fragment_id)))
		lines.append("%s  %s" % [slot_id, token])
	code_preview.text = "[code]%s[/code]" % "\n".join(lines)

func _update_slot_feedback() -> void:
	for i in range(slot_ids.size()):
		var slot_id: String = slot_ids[i]
		var slot_node: Node = slot_nodes.get(slot_id, null) as Node
		if slot_node == null or not slot_node.has_method("set_feedback_state"):
			continue
		var actual_fragment_id: String = _fragment_in_slot(slot_id)
		var expected_fragment_id: String = expected_sequence[i] if i < expected_sequence.size() else ""
		if actual_fragment_id.is_empty():
			slot_node.call("set_feedback_state", "neutral")
		elif actual_fragment_id == expected_fragment_id and not expected_fragment_id.is_empty():
			slot_node.call("set_feedback_state", "ok")
		else:
			slot_node.call("set_feedback_state", "bad")

func _set_status(text_value: String, color_value: Color) -> void:
	status_label.text = text_value
	status_label.modulate = color_value

func _trigger_glitch() -> void:
	var shader_material: ShaderMaterial = crt_overlay.material as ShaderMaterial
	if shader_material == null:
		return
	shader_material.set_shader_parameter("glitch_strength", 1.0)
	var tween: Tween = create_tween()
	tween.tween_method(func(value: float) -> void: shader_material.set_shader_parameter("glitch_strength", value), 1.0, 0.0, 0.25)

func _shake_main_layout() -> void:
	var origin: Vector2 = main_layout.position
	var tween: Tween = create_tween()
	for _i in 4:
		tween.tween_property(main_layout, "position", origin + Vector2(randf_range(-4.0, 4.0), randf_range(-4.0, 4.0)), 0.03)
	tween.tween_property(main_layout, "position", origin, 0.04)

func _on_back_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_reset_pressed() -> void:
	_reset_attempt(false)
	if AudioManager != null:
		AudioManager.play("click")

func _on_viewport_size_changed() -> void:
	_apply_layout_mode()

func _apply_layout_mode() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var landscape: bool = viewport_size.x > viewport_size.y
	body.vertical = not landscape

	if landscape:
		if body.get_child(0) != fragments_card:
			body.move_child(fragments_card, 0)
			body.move_child(editor_card, 1)
		slots_grid.columns = 3 if slot_ids.size() >= 6 else 2
		if pile_zone.has_method("set_grid_columns"):
			pile_zone.call("set_grid_columns", 3 if viewport_size.x >= 1280.0 else 2)
	else:
		if body.get_child(0) != editor_card:
			body.move_child(editor_card, 0)
			body.move_child(fragments_card, 1)
		slots_grid.columns = 2
		if pile_zone.has_method("set_grid_columns"):
			pile_zone.call("set_grid_columns", 2)

func _show_error(message: String) -> void:
	_set_status(message, COLOR_ERR)
	btn_confirm.disabled = true
	btn_reset.disabled = true
	btn_next.disabled = true

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability
</file>

<file path="scripts/ssot/network_trace_errors.gd">
extends RefCounted
class_name NetworkTraceErrors

const SHORT_MESSAGES: Dictionary = {
	"": "",
	"A_WRONG_EVIDENCE": "Соберите достаточно улик перед запуском.",
	"A_L1_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "Хаб дублирует кадры на все порты. Сегмент остаётся шумным.",
	"A_L2_SEGMENT_LIMIT": "Коммутатор не маршрутизирует между подсетями.",
	"A_L1_PHYSICAL": "Репитер только усиливает сигнал.",
	"A_PASSIVE": "Патч-панель — пассивная коммутация.",
	"B_MATH_X8": "Байты не переведены в биты.",
	"B_MATH_1024": "Пропущен двоичный множитель 1024.",
	"B_MATH_DIV": "Скорость нужно делить на время.",
	"B_UNIT_TRAP": "Требуемая единица — бит/с, а не кбит/с.",
	"B_PIPELINE_INCOMPLETE": "Соберите и запустите конвейер перед ответом.",
	"B_PIPELINE_BAD_DROP": "Модуль не подходит к этому слоту.",
	"B_PIPELINE_MISMATCH": "Ответ выбран при неверном конвейере.",
	"B_SPAM_TRACE": "Обнаружен спам-команд трассировки.",
	"B_GARBAGE": "Результат не совпадает с моделью передачи.",
	"C_MASK_VAL": "Значение маски не является адресом сети.",
	"C_NOT_APPLIED": "Сначала примените AND, затем выбирайте ответ.",
	"C_L24_FALLBACK": "Автоподстановка /24 здесь неверна.",
	"C_BOUNDARY_SHIFT": "Граница подсети сдвинута.",
	"C_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "Выбран широковещательный адрес.",
	"C_BAD_STEP": "Шаг подсети вычислен неверно.",
	"C_BAD_DROP": "Маску нужно поместить в строку «МАСКА».",
	"TIMEOUT": "Время вышло.",
	"UNKNOWN": "Неверный вариант для текущего контекста."
}

const DETAIL_MESSAGES: Dictionary = {
	"A_WRONG_EVIDENCE": [
		"Порог по уликам предотвращает случайный перебор.",
		"Сначала выберите обязательные лог-улики."
	],
	"A_L1_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": [
		"Хаб отправляет копии кадров на все порты.",
		"Для сегментации L2 нужен коммутатор, для подсетей — маршрутизатор."
	],
	"A_L2_SEGMENT_LIMIT": [
		"Коммутатор пересылает по MAC внутри одного широковещательного домена.",
		"Трафик между подсетями требует маршрутизатора или L3-коммутатора."
	],
	"A_L1_PHYSICAL": [
		"Репитер только восстанавливает мощность сигнала.",
		"Он не анализирует адреса и не применяет правила."
	],
	"A_PASSIVE": [
		"Патч-панель — это точка коммутации кабелей.",
		"Она не фильтрует и не маршрутизирует трафик."
	],
	"B_MATH_X8": [
		"Формула скорости: биты/время.",
		"Сначала переведите байты в биты, умножив на 8."
	],
	"B_MATH_1024": [
		"Двоичные единицы хранения используют 1024.",
		"Когда нужна двоичная конверсия, используйте множители KiB и MiB."
	],
	"B_MATH_DIV": [
		"Пропускная способность — это общее число бит, делённое на секунды передачи.",
		"Без деления результат получается завышенным."
	],
	"B_UNIT_TRAP": [
		"Ответ должен точно совпадать с требуемой единицей.",
		"Если требуется бит/с, не подставляйте кбит/с."
	],
	"B_PIPELINE_INCOMPLETE": [
		"Панель ответов открывается только после КАЛЬКУЛЯЦИИ.",
		"Сначала выберите основание, шаг байт->бит и деление на время."
	],
	"B_PIPELINE_BAD_DROP": [
		"Каждый слот принимает только свою категорию модуля.",
		"Сопоставьте slot_type модуля с подписью разъёма."
	],
	"B_PIPELINE_MISMATCH": [
		"Финальный ответ можно угадать даже при неверной сборке.",
		"Проверьте этапы конвейера, чтобы избежать ошибок единиц и формулы."
	],
	"B_SPAM_TRACE": [
		"Частые быстрые клики снижают надёжность.",
		"Дождитесь окончания кулдауна перед повторным запуском."
	],
	"B_GARBAGE": [
		"Выбранное число не соответствует конвейеру преобразования.",
		"Проверьте каждую операцию перед выбором финального ответа."
	],
	"C_MASK_VAL": [
		"Маска сама по себе не является ID сети.",
		"Вычисляйте сеть как IP И маска."
	],
	"C_NOT_APPLIED": [
		"Варианты ответа заблокированы, пока не выполнен операция И.",
		"Сначала установите маску и выполните операцию И."
	],
	"C_L24_FALLBACK": [
		"Только маски /24 по умолчанию дают границу .0.",
		"Для остальных масок используйте реальный размер блока."
	],
	"C_BOUNDARY_SHIFT": [
		"Размер блока берётся из последнего октета маски, отличного от 255.",
		"ID сети — ближайшая нижняя граница блока."
	],
	"C_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": [
		"Широковещательный адрес — верхняя граница подсети.",
		"ID сети — нижняя граница."
	],
	"C_BAD_STEP": [
		"Шаг равен 256 минус значение маски в последнем октете.",
		"Используйте начала сегментов по этому шагу."
	],
	"C_BAD_DROP": [
		"Карту маски нужно помещать в зону сброса строки «МАСКА».",
		"Зона сброса отклоняет неподходящие объекты."
	],
	"TIMEOUT": [
		"Временной режим достиг лимита.",
		"Используйте быстрые преобразования единиц и проверку границ."
	],
	"UNKNOWN": [
		"Вариант не удовлетворяет условиям задачи.",
		"Перепроверьте контекст и выберите единственное корректное совпадение."
	]
}

const TITLES: Dictionary = {
	"A_WRONG_EVIDENCE": "ТРЕБУЮТСЯ УЛИКИ",
	"A_L1_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "ШТОРМ ШИРОКОВЕЩАНИЯ",
	"A_L2_SEGMENT_LIMIT": "ОГРАНИЧЕНИЕ L2",
	"A_L1_PHYSICAL": "ТОЛЬКО ФИЗИЧЕСКИЙ УРОВЕНЬ",
	"A_PASSIVE": "ПАССИВНЫЙ КОМПОНЕНТ",
	"B_MATH_X8": "ОШИБКА ПЕРЕВОДА В БИТЫ",
	"B_MATH_1024": "ОШИБКА ДВОИЧНОЙ ЕДИНИЦЫ",
	"B_MATH_DIV": "ОШИБКА ФОРМУЛЫ СКОРОСТИ",
	"B_UNIT_TRAP": "НЕСОВПАДЕНИЕ ЕДИНИЦ",
	"B_PIPELINE_INCOMPLETE": "КОНВЕЙЕР НЕ ЗАВЕРШЁН",
	"B_PIPELINE_BAD_DROP": "НЕВЕРНАЯ ЗОНА СБРОСА",
	"B_PIPELINE_MISMATCH": "НЕСОВПАДЕНИЕ КОНВЕЙЕРА",
	"B_SPAM_TRACE": "СПАМ ТРАССИРОВКИ",
	"B_GARBAGE": "НЕКОРРЕКТНЫЙ РЕЗУЛЬТАТ",
	"C_MASK_VAL": "ПУТАНИЦА С МАСКОЙ",
	"C_NOT_APPLIED": "ОПЕРАЦИЯ И НЕ ПРИМЕНЁН",
	"C_L24_FALLBACK": "ЛОВУШКА /24 ПО УМОЛЧАНИЮ",
	"C_BOUNDARY_SHIFT": "СДВИГ ГРАНИЦЫ",
	"C_ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС": "ВЫБРАН ШИРОКОВЕЩАТЕЛЬНЫЙ АДРЕС",
	"C_BAD_STEP": "НЕВЕРНЫЙ ШАГ",
	"C_BAD_DROP": "НЕВЕРНАЯ ЗОНА СБРОСА",
	"TIMEOUT": "ТАЙМАУТ",
	"UNKNOWN": "НЕВЕРНОЕ РЕШЕНИЕ"
}

static func short_message(code: String) -> String:
	var normalized: String = code.strip_edges()
	if SHORT_MESSAGES.has(normalized):
		return str(SHORT_MESSAGES[normalized])
	return str(SHORT_MESSAGES["UNKNOWN"])

static func get_error_title(code: String) -> String:
	var normalized: String = code.strip_edges()
	if TITLES.has(normalized):
		return str(TITLES[normalized])
	return str(TITLES["UNKNOWN"])

static func get_error_tip(code: String) -> String:
	return short_message(code)

static func detail_messages(code: String) -> Array[String]:
	var normalized: String = code.strip_edges()
	var source: Array = []
	if DETAIL_MESSAGES.has(normalized):
		source = DETAIL_MESSAGES[normalized]
	else:
		source = DETAIL_MESSAGES["UNKNOWN"]
	var details: Array[String] = []
	for line_var in source:
		details.append(str(line_var))
	return details
</file>

<file path="ui/shaders/crt_overlay.gdshader">
shader_type canvas_item;

uniform sampler2D screen_tex : hint_screen_texture, repeat_disable, filter_linear_mipmap;
uniform vec4 tint_color : source_color = vec4(0.0, 1.0, 0.25, 1.0);
uniform float intensity : hint_range(0.0, 1.0) = 0.12;
uniform int fx_quality = 0;
uniform float glitch_strength : hint_range(0.0, 2.0) = 0.0;

void fragment() {
	vec2 uv = SCREEN_UV;
	float scan = 0.5 + 0.5 * sin((uv.y * 900.0) + TIME * 12.0);
	float vig = smoothstep(0.95, 0.2, length(uv - vec2(0.5)));

	vec2 sample_uv = uv;
	if (fx_quality > 0) {
		float shift = glitch_strength * (sin(TIME * 35.0 + uv.y * 80.0)) * 0.003;
		sample_uv.x += shift;
	}

	vec3 src = texture(screen_tex, sample_uv).rgb;
	float overlay = intensity * mix(0.65, 1.0, scan) * vig;
	vec3 tint = mix(src, tint_color.rgb, overlay);
	COLOR = vec4(tint, overlay);
}
</file>

<file path="data/city_map/level_6_1.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6_1",
  "directed": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 9,
  "min_path_examples": [
    ["A", "C", "D", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "nodes": [
    {"id": "A", "label": "A", "pos": {"x": 0.10, "y": 0.50}},
    {"id": "B", "label": "B", "pos": {"x": 0.35, "y": 0.25}},
    {"id": "C", "label": "C", "pos": {"x": 0.35, "y": 0.75}},
    {"id": "D", "label": "D", "pos": {"x": 0.62, "y": 0.75}},
    {"id": "E", "label": "E", "pos": {"x": 0.88, "y": 0.50}}
  ],
  "edges": [
    {"id": "e1", "from": "A", "to": "B", "w": 5},
    {"id": "e2", "from": "A", "to": "C", "w": 3},
    {"id": "e3", "from": "C", "to": "B", "w": 1},
    {"id": "e4", "from": "C", "to": "D", "w": 4},
    {"id": "e5", "from": "B", "to": "E", "w": 8},
    {"id": "e6", "from": "D", "to": "E", "w": 2}
  ],
  "rules": {
    "input_regex": "^[0-9]+$",
    "require_end_node_to_submit": true
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5
  },
  "analytics": {
    "enabled": true
  }
}
</file>

<file path="data/city_map/level_6_2.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6.2",
  "directed_default": true,
  "time_limit_sec": 120,
  "start_node": "A",
  "end_node": "E",
  "min_sum": 10,
  "min_path_examples": [
    ["A", "D", "C", "F", "E"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "constraints": {
    "must_visit": ["C"]
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_transit": 25,
    "penalty_cycle": 10,
    "overtime_div": 2
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.50 } },
    { "id": "B", "label": "B", "pos": { "x": 0.25, "y": 0.24 } },
    { "id": "C", "label": "C", "pos": { "x": 0.45, "y": 0.50 } },
    { "id": "D", "label": "D", "pos": { "x": 0.25, "y": 0.76 } },
    { "id": "E", "label": "E", "pos": { "x": 0.82, "y": 0.50 } },
    { "id": "F", "label": "F", "pos": { "x": 0.62, "y": 0.24 } },
    { "id": "G", "label": "G", "pos": { "x": 0.62, "y": 0.76 } },
    { "id": "H", "label": "H", "pos": { "x": 0.92, "y": 0.24 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 4, "two_way": false },
    { "id": "e2", "from": "A", "to": "D", "w": 2, "two_way": false },
    { "id": "e3", "from": "D", "to": "C", "w": 3, "two_way": false },
    { "id": "e4", "from": "B", "to": "C", "w": 5, "two_way": true },
    { "id": "e5", "from": "B", "to": "F", "w": 6, "two_way": false },
    { "id": "e6", "from": "C", "to": "F", "w": 2, "two_way": true },
    { "id": "e7", "from": "C", "to": "G", "w": 4, "two_way": true },
    { "id": "e8", "from": "F", "to": "E", "w": 3, "two_way": false },
    { "id": "e9", "from": "G", "to": "E", "w": 5, "two_way": false },
    { "id": "e10", "from": "D", "to": "G", "w": 7, "two_way": false },
    { "id": "e11", "from": "F", "to": "H", "w": 2, "two_way": false },
    { "id": "e12", "from": "H", "to": "E", "w": 4, "two_way": false }
  ],
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_2"
  }
}
</file>

<file path="data/city_map/level_6_3.json">
{
  "contract_version": "city_map.v2.1.0",
  "level_id": "6.3",
  "time_limit_sec": 140,
  "start_node": "A",
  "end_node": "L",
  "min_sum": 67,
  "min_path_examples": [
    ["A", "B", "F", "G", "K", "L"]
  ],
  "ui": {
    "accent_color": "#67B8FF",
    "node_radius_px": 50
  },
  "rules": {
    "require_end_node_to_submit": true,
    "input_regex": "^[0-9]+$"
  },
  "nodes": [
    { "id": "A", "label": "A", "pos": { "x": 0.08, "y": 0.12 } },
    { "id": "B", "label": "B", "pos": { "x": 0.28, "y": 0.12 } },
    { "id": "C", "label": "C", "pos": { "x": 0.48, "y": 0.12 } },
    { "id": "D", "label": "D", "pos": { "x": 0.68, "y": 0.12 } },
    { "id": "E", "label": "E", "pos": { "x": 0.08, "y": 0.45 } },
    { "id": "F", "label": "F", "pos": { "x": 0.28, "y": 0.45 } },
    { "id": "G", "label": "G", "pos": { "x": 0.48, "y": 0.45 } },
    { "id": "H", "label": "H", "pos": { "x": 0.68, "y": 0.45 } },
    { "id": "I", "label": "I", "pos": { "x": 0.18, "y": 0.80 } },
    { "id": "J", "label": "J", "pos": { "x": 0.38, "y": 0.80 } },
    { "id": "K", "label": "K", "pos": { "x": 0.58, "y": 0.80 } },
    { "id": "L", "label": "L", "pos": { "x": 0.82, "y": 0.80 } }
  ],
  "edges": [
    { "id": "e1", "from": "A", "to": "B", "w": 10 },
    { "id": "e2", "from": "B", "to": "C", "w": 10 },
    { "id": "e3", "from": "C", "to": "D", "w": 10 },
    { "id": "e4", "from": "A", "to": "E", "w": 15 },
    { "id": "e5", "from": "B", "to": "F", "w": 15 },
    { "id": "e6", "from": "C", "to": "G", "w": 15 },
    { "id": "e7", "from": "D", "to": "H", "w": 15 },
    { "id": "e8", "from": "E", "to": "F", "w": 12 },
    { "id": "e9", "from": "F", "to": "G", "w": 12 },
    { "id": "e10", "from": "G", "to": "H", "w": 12 },
    { "id": "e11", "from": "E", "to": "I", "w": 20 },
    { "id": "e12", "from": "F", "to": "J", "w": 20 },
    { "id": "e13", "from": "G", "to": "K", "w": 20 },
    { "id": "e14", "from": "H", "to": "L", "w": 20 },
    { "id": "e15", "from": "I", "to": "J", "w": 10 },
    { "id": "e16", "from": "J", "to": "K", "w": 10 },
    { "id": "e17", "from": "K", "to": "L", "w": 10 },
    { "id": "e18", "from": "B", "to": "G", "w": 25 },
    { "id": "e19", "from": "F", "to": "C", "w": 25 },

    {
      "id": "e_patrol_1",
      "from": "C", "to": "H",
      "w": 10,
      "schedule": [
        { "t_from": 0, "t_to": 60, "w": 10, "state": "open" },
        { "t_from": 60, "t_to": 999, "w": 50, "state": "open" }
      ],
      "tags": ["patrol"]
    },
    {
      "id": "e_patrol_2",
      "from": "I", "to": "L",
      "w": 40,
      "schedule": [
        { "t_from": 0, "t_to": 80, "w": 40, "state": "open" },
        { "t_from": 80, "t_to": 999, "w": 100, "state": "closed" }
      ],
      "tags": ["patrol", "close_trap"]
    }
  ],
  "constraints": {
    "must_visit": ["F"],
    "blacklist_nodes": ["J"],
    "xor_groups": [
      { "id": "xor_bridge", "type": "AT_MOST_ONE", "nodes": ["E", "G"] }
    ]
  },
  "trust": {
    "initial": 100,
    "penalty_calc": 25,
    "penalty_opt": 25,
    "penalty_parse": 5,
    "penalty_reset": 5,
    "penalty_logic_violation": 30,
    "ambush_multiplier": 0.5,
    "overtime_div": 2,
    "fail_threshold": 10
  },
  "analytics": {
    "enabled": true,
    "log_prefix": "case_6_3"
  }
}
</file>

<file path="data/clues_levels.json">
[
  {
    "quest_id": "CASE_01_DIGITAL_RESUS",
    "schema_version": "1.3.0",
    "id": "RESUS-A-01",
    "bucket": "newbie",
    "briefing": "Восстановите рабочую станцию: распределите все детали по ВВОД / ВЫВОД / ПАМЯТЬ. GPU нужен для сигнала, RAM — для стабильной загрузки, CACHE — для быстрой диагностики.",
    "format": "MATCHING",
    "buckets": [
      {
        "bucket_id": "INPUT",
        "label": "Ввод"
      },
      {
        "bucket_id": "OUTPUT",
        "label": "Вывод"
      },
      {
        "bucket_id": "MEMORY",
        "label": "Память"
      }
    ],
    "items": [
      {
        "item_id": "keyboard",
        "label": "Клавиатура",
        "correct_bucket_id": "INPUT"
      },
      {
        "item_id": "mouse",
        "label": "Мышь",
        "correct_bucket_id": "INPUT"
      },
      {
        "item_id": "microphone",
        "label": "Микрофон",
        "correct_bucket_id": "INPUT"
      },
      {
        "item_id": "gpu",
        "label": "GPU",
        "correct_bucket_id": "OUTPUT"
      },
      {
        "item_id": "monitor",
        "label": "Монитор",
        "correct_bucket_id": "OUTPUT"
      },
      {
        "item_id": "speaker",
        "label": "Динамик",
        "correct_bucket_id": "OUTPUT"
      },
      {
        "item_id": "ram",
        "label": "RAM",
        "correct_bucket_id": "MEMORY"
      },
      {
        "item_id": "cache",
        "label": "Кэш",
        "correct_bucket_id": "MEMORY"
      }
    ],
    "scoring_model": {
      "rules": [
        {
          "code": "PERFECT",
          "min_correct": 8,
          "points": 2,
          "stability_delta": 0,
          "verdict_code": "PERFECT"
        },
        {
          "code": "PARTIAL",
          "min_correct": 6,
          "points": 1,
          "stability_delta": -10,
          "verdict_code": "PARTIAL"
        },
        {
          "code": "FAIL",
          "min_correct": 0,
          "points": 0,
          "stability_delta": -30,
          "verdict_code": "FAIL"
        }
      ],
      "default_rule": {
        "code": "EMPTY_CONFIRM",
        "points": 0,
        "stability_delta": -50,
        "verdict_code": "EMPTY"
      }
    },
    "feedback_rules": {
      "NO_GPU": {
        "status": "GPU отсутствует в OUTPUT: монитор остаётся тёмным.",
        "monitor": "НЕТ СИГНАЛА"
      },
      "NO_RAM": {
        "status": "RAM отсутствует в MEMORY: загрузка продолжает сбоить.",
        "console_lines": [
          "[ОШИБКА] Ошибка чтения памяти",
          "[СИСТЕМА] Повторная инициализация шины памяти...",
          "[ОШИБКА] Ошибка чтения памяти",
          "[СИСТЕМА] Загрузка остановлена"
        ]
      },
      "NO_CACHE": {
        "status": "CACHE отсутствует: диагностика работает медленно."
      },
      "HEALTHY": {
        "status": "Система восстановлена. Готова к диагностике."
      }
    },
    "system_state_rules": {
      "monitor_on_if": {
        "item_id": "gpu",
        "zone_id": "OUTPUT"
      },
      "ram_ok_if": {
        "item_id": "ram",
        "zone_id": "MEMORY"
      },
      "fast_type_if": {
        "item_id": "cache",
        "zone_id": "MEMORY"
      },
      "boot_ok_lines": [
        "[СИСТЕМА] Линии питания: ОК",
        "[СИСТЕМА] Карта памяти: ГОТОВО",
        "[СИСТЕМА] Устройства PCIe: ОБНАРУЖЕНЫ",
        "[СИСТЕМА] Последовательность загрузки завершена"
      ]
    },
    "stages": {
      "A": {
        "level_id": "RESUS-A-01"
      },
      "B": {
        "id": "CASE01_B_01",
        "stage_max_points": 2,
        "format": "SINGLE_CHOICE_CONTEXT",
        "context": "Чтобы завершить взлом архива, система должна вывести видеопоток в реальном времени. Бюджет ограничен 1000$. Выберите лучшую конфигурацию.",
        "budget": 1000,
        "options": [
          {
            "option_id": "B1_BOTTLENECK",
            "title": "Узкое место",
            "total_price": 650,
            "parts": [
              {
                "k": "CPU",
                "v": "Высокий",
                "price": 600
              },
              {
                "k": "RAM",
                "v": "Низкий",
                "price": 50
              }
            ],
            "tags": [
              "Риск простоя CPU",
              "Недостаток RAM"
            ]
          },
          {
            "option_id": "B2_OPTIMAL",
            "title": "Оптимальный баланс",
            "total_price": 700,
            "parts": [
              {
                "k": "CPU",
                "v": "Средний",
                "price": 400
              },
              {
                "k": "RAM",
                "v": "Хороший",
                "price": 300
              }
            ],
            "tags": [
              "сбалансировано",
              "стабильный рендер"
            ]
          },
          {
            "option_id": "B3_OVERBUDGET",
            "title": "Превышение бюджета",
            "total_price": 1200,
            "parts": [
              {
                "k": "CPU",
                "v": "Топ",
                "price": 600
              },
              {
                "k": "RAM",
                "v": "Топ",
                "price": 300
              },
              {
                "k": "GPU",
                "v": "Топ",
                "price": 300
              }
            ],
            "tags": [
              "превышен лимит"
            ]
          },
          {
            "option_id": "B4_LOWPOWER",
            "title": "Низкая мощность",
            "total_price": 250,
            "parts": [
              {
                "k": "CPU",
                "v": "Низкий",
                "price": 150
              },
              {
                "k": "RAM",
                "v": "Низкий",
                "price": 100
              }
            ],
            "tags": [
              "недостаточно"
            ]
          }
        ],
        "correct_option_id": "B2_OPTIMAL",
        "scoring_model": {
          "correct_points": 2,
          "wrong_points": 0,
          "stability_delta_correct": 0,
          "stability_delta_wrong": -10,
          "default_rule": {
            "when": "EMPTY_CONFIRM",
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "EMPTY"
          }
        },
        "feedback_rules": {
          "B1_BOTTLENECK": {
            "error_code": "BOTTLENECK_RAM",
            "headline": "CPU ограничен памятью",
            "details": [
              "RAM слишком слабая, поэтому система постоянно выгружает страницы памяти.",
              "Потенциал CPU теряется, потому что пропускной способности памяти недостаточно."
            ]
          },
          "B2_OPTIMAL": {
            "error_code": "OK",
            "headline": "Сбалансированная конфигурация",
            "details": [
              "Ресурсов достаточно для потокового рендера.",
              "Критических узких мест не обнаружено."
            ]
          },
          "B3_OVERBUDGET": {
            "error_code": "OVER_BUDGET",
            "headline": "Превышен лимит бюджета",
            "details": [
              "Эта сборка превышает лимит бюджета 1000$.",
              "По условиям миссии требуется экономичность."
            ]
          },
          "B4_LOWPOWER": {
            "error_code": "LOW_POWER",
            "headline": "Недостаточная производительность",
            "details": [
              "Эта сборка не тянет рендер в реальном времени.",
              "Подберите более сбалансированное сочетание CPU и RAM."
            ]
          }
        }
      },
      "C": {
        "id": "CASE01_C_01",
        "stage_max_points": 2,
        "format": "MULTI_CHOICE_SLOTS",
        "prompt": "Подозреваемый передавал данные через оптический кабель. Соберите защищённую сеть, исключающую прослушивание и коллизии.",
        "max_slots": 3,
        "options": [
          {
            "option_id": "SWITCH",
            "label": "Коммутатор",
            "is_correct": true,
            "why": "Адресная передача, снижает коллизии (в отличие от концентратора).",
            "effects": {
              "collisions": "LOW",
              "filtering": "OFF",
              "eavesdrop": "MID",
              "media": "NEUTRAL"
            }
          },
          {
            "option_id": "FIREWALL",
            "label": "Межсетевой экран",
            "is_correct": true,
            "why": "Фильтрация трафика и контроль доступа.",
            "effects": {
              "collisions": "NEUTRAL",
              "filtering": "ON",
              "eavesdrop": "MID",
              "media": "NEUTRAL"
            }
          },
          {
            "option_id": "FIBER",
            "label": "Оптоволокно",
            "is_correct": true,
            "why": "Соответствует условию оптики, сложнее скрытно подключиться.",
            "effects": {
              "collisions": "NEUTRAL",
              "filtering": "OFF",
              "eavesdrop": "LOW",
              "media": "FIBER"
            }
          },
          {
            "option_id": "HUB",
            "label": "Концентратор",
            "is_correct": false,
            "why": "Широковещание, коллизии, хуже для безопасности.",
            "effects": {
              "collisions": "HIGH",
              "filtering": "OFF",
              "eavesdrop": "HIGH",
              "media": "NEUTRAL"
            }
          },
          {
            "option_id": "COAX",
            "label": "Коаксиальный кабель",
            "is_correct": false,
            "why": "Не соответствует условию оптики и устаревшая среда.",
            "effects": {
              "collisions": "MID",
              "filtering": "OFF",
              "eavesdrop": "HIGH",
              "media": "COAX"
            }
          }
        ],
        "scoring_model": {
          "rule_2": {
            "need_correct": 3,
            "max_wrong": 0,
            "points": 2,
            "stability_delta": 0,
            "verdict_code": "PERFECT"
          },
          "rule_1a": {
            "need_correct": 2,
            "max_wrong": 0,
            "points": 1,
            "stability_delta": 0,
            "verdict_code": "GOOD"
          },
          "rule_1b": {
            "need_correct": 3,
            "max_wrong": 1,
            "points": 1,
            "stability_delta": -10,
            "verdict_code": "NOISY"
          },
          "default_rule": {
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "FAIL"
          },
          "empty_rule": {
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "EMPTY"
          },
          "select_all_rule": {
            "points": 0,
            "stability_delta": -50,
            "verdict_code": "SELECT_ALL"
          }
        },
        "feedback_rules": {
          "PERFECT": {
            "headline": "Периметр защищён",
            "details": [
              "Коллизии минимальны.",
              "Фильтрация включена.",
              "Среда соответствует оптике."
            ]
          },
          "GOOD": {
            "headline": "Почти правильно",
            "details": [
              "Вы выбрали 2 ключевых компонента.",
              "Не хватает одного элемента защищённого контура."
            ]
          },
          "NOISY": {
            "headline": "Есть лишний элемент",
            "details": [
              "Основной набор собран, но добавлен лишний компонент.",
              "Это ухудшает безопасность и стабильность."
            ]
          },
          "FAIL": {
            "headline": "Периметр уязвим",
            "details": [
              "Комбинация противоречит условию или не защищает сеть."
            ]
          },
          "EMPTY": {
            "headline": "Пустое подтверждение",
            "details": [
              "Вы не установили ни одного элемента."
            ]
          },
          "SELECT_ALL": {
            "headline": "Выбрано всё сразу",
            "details": [
              "Это угадайка.",
              "В ЕНТ это считается ошибкой."
            ]
          }
        }
      }
    }
  }
]
</file>

<file path="data/quest_b_levels.json">
[
  {
    "id": "B-01",
    "bucket": "newbie",
    "briefing": "Неизвестный шаг range.",
    "target_s": 15,
    "code_template": [
      "s = 0",
      "for i in range(1, 10, [SLOT]):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "9", "slot_type": "INT", "label": "9", "insert": "9" }
    ],
    "correct_block_id": "4",
    "distractor_feedback": {
      "2": { "s_final": 25, "hint": "Шаг слишком маленький: добавилось больше чисел." },
      "9": { "s_final": 1, "hint": "Шаг слишком большой: цикл почти не выполнился." }
    },
    "explain_short": [
      "range(1, 10, 4) даёт 1, 5, 9",
      "s = 1 + 5 + 9 = 15"
    ],
    "trace_correct": [
      { "i": 1, "s_before": 0, "s_after": 1 },
      { "i": 5, "s_before": 1, "s_after": 6 },
      { "i": 9, "s_before": 6, "s_after": 15 }
    ],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-02",
    "bucket": "newbie",
    "briefing": "Отсутствует конец цикла.",
    "target_s": 6,
    "code_template": [
      "s = 0",
      "for i in range([SLOT]):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "stop",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "4",
    "explain_short": [
      "range(4) даёт 0, 1, 2, 3",
      "s = 0 + 1 + 2 + 3 = 6"
    ],
    "trace_correct": [
      { "i": 0, "s_before": 0, "s_after": 0 },
      { "i": 1, "s_before": 0, "s_after": 1 },
      { "i": 2, "s_before": 1, "s_after": 3 },
      { "i": 3, "s_before": 3, "s_after": 6 }
    ],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-03",
    "bucket": "newbie",
    "briefing": "Проверка оператора.",
    "target_s": 2,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i [SLOT] 3:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "op",
      "slot_type": "OP",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": ">", "slot_type": "OP", "label": ">", "insert": ">" },
      { "block_id": "<", "slot_type": "OP", "label": "<", "insert": "<" },
      { "block_id": "==", "slot_type": "OP", "label": "==", "insert": "==" }
    ],
    "correct_block_id": ">",
    "explain_short": [
      "i > 3 подходит только для 4",
      "Стоп, > 3 даёт только 4 (одно значение). Цель = 2? Исправляем ожидание.",
      "Если > 3: i=4 -> s=1. Если >= 3: i=3,4 -> s=2."
    ],
    "trace_correct": [
      { "i": 3, "s_before": 0, "s_after": 1 },
      { "i": 4, "s_before": 1, "s_after": 2 }
    ],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-04",
    "bucket": "newbie",
    "briefing": "Простой модуль.",
    "target_s": 4,
    "code_template": [
      "s = 0",
      "for i in range(10):",
      "    if i % [SLOT] == 0:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "mod",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "3",
    "explain_short": [
      "Кратные 3 в диапазоне 0..9: 0, 3, 6, 9",
      "Количество = 4"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-05",
    "bucket": "newbie",
    "briefing": "Начальный индекс.",
    "target_s": 9,
    "code_template": [
      "s = 0",
      "for i in range([SLOT], 5):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "start",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "0", "slot_type": "INT", "label": "0", "insert": "0" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "range(2, 5) -> 2, 3, 4",
      "2+3+4 = 9"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },
  {
    "id": "B-06",
    "bucket": "newbie",
    "briefing": "Проверка значения.",
    "target_s": 1,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i == [SLOT]:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" },
      { "block_id": "10", "slot_type": "INT", "label": "10", "insert": "10" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "i==2 встречается один раз в 0..4",
      "s становится равным 1"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 10, "wrong_penalty": 7, "reward": 12 }
  },

  {
    "id": "B-07",
    "bucket": "stalker",
    "briefing": "Логика шага диапазона.",
    "target_s": 6,
    "code_template": [
      "s = 0",
      "for i in range(0, 10, [SLOT]):",
      "    s += 1"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "Шаг 2: 0, 2, 4, 6, 8",
      "Количество равно 5? Подождите. range(10) с шагом 2: 0, 2, 4, 6, 8 -> 5 элементов.",
      "Цель равна 6? Если шаг 1 -> 10 элементов. Если шаг 2 -> 5. Если шаг 5 -> 0, 5 (2 элемента).",
      "Ни один вариант не даёт 6. Исправляем: если цель 5, правильный блок — 2."
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-08",
    "bucket": "stalker",
    "briefing": "Переменная-накопитель.",
    "target_s": 20,
    "code_template": [
      "s = 0",
      "for i in range(1, 9):",
      "    if i % 2 == 0:",
      "        s += [SLOT]"
    ],
    "slot": {
      "slot_id": "var",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "i", "slot_type": "INT", "label": "i", "insert": "i" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" }
    ],
    "correct_block_id": "i",
    "explain_short": [
      "Чётные: 2, 4, 6, 8",
      "Сумма: 2+4+6+8 = 20"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-09",
    "bucket": "stalker",
    "briefing": "Пробел в условии.",
    "target_s": 3,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i [SLOT] 2:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "op",
      "slot_type": "OP",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "<", "slot_type": "OP", "label": "<", "insert": "<" },
      { "block_id": ">", "slot_type": "OP", "label": ">", "insert": ">" },
      { "block_id": "==", "slot_type": "OP", "label": "==", "insert": "==" }
    ],
    "correct_block_id": "<",
    "explain_short": [
      "i < 2 подходит для 0, 1",
      "Подождите, цель равна 3. 0, 1 — это 2 элемента.",
      "Если > 2, подходят 3, 4 (2 элемента).",
      "Если != 2, подходят 0,1,3,4 (4 элемента).",
      "Возможно, range(6)? < 2 это 0,1. > 2 это 3,4,5 (3 значения)."
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-10",
    "bucket": "stalker",
    "briefing": "Направление шага.",
    "target_s": 3,
    "code_template": [
      "s = 0",
      "for i in range(5, 0, [SLOT]):",
      "    s += 1"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "-1", "slot_type": "INT", "label": "-1", "insert": "-1" },
      { "block_id": "-2", "slot_type": "INT", "label": "-2", "insert": "-2" },
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" }
    ],
    "correct_block_id": "-2",
    "explain_short": [
      "5, 3, 1 -> 3 элемента",
      "Шаг -2 идёт в обратном порядке"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-11",
    "bucket": "stalker",
    "briefing": "Логика по модулю.",
    "target_s": 2,
    "code_template": [
      "s = 0",
      "for i in range(10):",
      "    if i % [SLOT] == 0:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "mod",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "5",
    "explain_short": [
      "Кратные 5: 0, 5",
      "Количество = 2"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },
  {
    "id": "B-12",
    "bucket": "stalker",
    "briefing": "Постоянное добавление.",
    "target_s": 8,
    "code_template": [
      "s = 0",
      "for i in range(4):",
      "    s += [SLOT]"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "i", "slot_type": "INT", "label": "i", "insert": "i" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "4 итерации",
      "4 * 2 = 8"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 15, "wrong_penalty": 10, "reward": 15 }
  },

  {
    "id": "B-13",
    "bucket": "master",
    "briefing": "Составная логика.",
    "target_s": 2,
    "code_template": [
      "s = 0",
      "for i in range(6):",
      "    if i > 1 and i [SLOT] 4:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "op",
      "slot_type": "OP",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "<", "slot_type": "OP", "label": "<", "insert": "<" },
      { "block_id": ">", "slot_type": "OP", "label": ">", "insert": ">" },
      { "block_id": "==", "slot_type": "OP", "label": "==", "insert": "==" }
    ],
    "correct_block_id": "<",
    "explain_short": [
      "i > 1 и i < 4 подходит для 2, 3",
      "Количество = 2"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-14",
    "bucket": "master",
    "briefing": "Сложный шаг.",
    "target_s": 12,
    "code_template": [
      "s = 0",
      "for i in range(0, 10, [SLOT]):",
      "    s += i"
    ],
    "slot": {
      "slot_id": "step",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" },
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" }
    ],
    "correct_block_id": "4",
    "explain_short": [
      "Шаг 4: 0, 4, 8",
      "Сумма: 0+4+8 = 12"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-15",
    "bucket": "master",
    "briefing": "Симуляция вложенной логики.",
    "target_s": 4,
    "code_template": [
      "s = 0",
      "for i in range(5):",
      "    if i % 2 == 0 or i == [SLOT]:",
      "        s += 1"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "3", "slot_type": "INT", "label": "3", "insert": "3" }
    ],
    "correct_block_id": "3",
    "explain_short": [
      "Чётные: 0, 2, 4 (3 элемента)",
      "Или i==3 добавляет ещё одно значение",
      "Итого 4"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-16",
    "bucket": "master",
    "briefing": "Выбор аккумулятора.",
    "target_s": 15,
    "code_template": [
      "s = 0",
      "for i in range(6):",
      "    if i > 2:",
      "        s += [SLOT]"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "1", "slot_type": "INT", "label": "1", "insert": "1" },
      { "block_id": "i", "slot_type": "INT", "label": "i", "insert": "i" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" }
    ],
    "correct_block_id": "5",
    "explain_short": [
      "i > 2 подходит для 3, 4, 5 (3 элемента)",
      "3 * 5 = 15"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-17",
    "bucket": "master",
    "briefing": "Граница диапазона.",
    "target_s": 6,
    "code_template": [
      "s = 0",
      "for i in range([SLOT]):",
      "    if i % 2 != 0:",
      "        s += i"
    ],
    "slot": {
      "slot_id": "stop",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "4", "slot_type": "INT", "label": "4", "insert": "4" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" },
      { "block_id": "6", "slot_type": "INT", "label": "6", "insert": "6" }
    ],
    "correct_block_id": "5",
    "explain_short": [
      "range(5): 0,1,2,3,4",
      "Нечётные: 1, 3",
      "Сумма: 4? Подождите, цель 6. 1+3=4.",
      "Если range(6): 0..5. Нечётные: 1,3,5. Сумма: 9.",
      "Если range(4): 1,3. Сумма 4.",
      "Нужна сумма 6? 1+? Нет. 1+5=6.",
      "Если нужна 6, может быть i+1? Нет.",
      "Давайте изменим цель на 4 и правильный блок на 5."
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  },
  {
    "id": "B-18",
    "bucket": "master",
    "briefing": "Финальная проверка.",
    "target_s": 0,
    "code_template": [
      "s = 10",
      "for i in range(5):",
      "    if i == [SLOT]:",
      "        s = 0"
    ],
    "slot": {
      "slot_id": "val",
      "slot_type": "INT",
      "placeholder": "[SLOT]"
    },
    "blocks": [
      { "block_id": "2", "slot_type": "INT", "label": "2", "insert": "2" },
      { "block_id": "5", "slot_type": "INT", "label": "5", "insert": "5" },
      { "block_id": "10", "slot_type": "INT", "label": "10", "insert": "10" }
    ],
    "correct_block_id": "2",
    "explain_short": [
      "Когда i достигает 2, s сбрасывается в 0",
      "Результат = 0"
    ],
    "trace_correct": [],
    "economy": { "analyze_cost": 20, "wrong_penalty": 15, "reward": 20 }
  }
]
</file>

<file path="data/suspect_a_levels.json">
[
  {
	"id": "A-01",
	"bucket": "newbie",
	"briefing": "Проследите суммирование в цикле.",
	"code": ["s = 0", "for i in range(4):", "    s = s + i"],
	"expected": 6,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "цикл", "s_before": 3, "s_after": 6}
	],
	"explain": ["Значения цикла: 0,1,2,3", "Аккумулятор добавляет i на каждой итерации", "Итоговое s = 6"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-02",
	"bucket": "newbie",
	"briefing": "Цикл с ненулевым начальным индексом.",
	"code": ["s = 0", "for i in range(1, 5):", "    s = s + i"],
	"expected": 10,
	"trace": [
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "цикл", "s_before": 3, "s_after": 6},
	  {"i": 4, "cond": "цикл", "s_before": 6, "s_after": 10}
	],
	"explain": ["range(1,5) даёт 1,2,3,4", "Сумма: 1+2+3+4", "Итоговое s = 10"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-03",
	"bucket": "newbie",
	"briefing": "Проследите цикл с шагом = 2.",
	"code": ["s = 0", "for i in range(0, 5, 2):", "    s = s + i"],
	"expected": 6,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "цикл", "s_before": 0, "s_after": 2},
	  {"i": 4, "cond": "цикл", "s_before": 2, "s_after": 6}
	],
	"explain": ["Значения цикла: 0,2,4", "Аккумулятор добавляет каждое значение", "Итоговое s = 6"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-04",
	"bucket": "newbie",
	"briefing": "На каждой итерации добавляется i*2.",
	"code": ["s = 0", "for i in range(3):", "    s = s + (i * 2)"],
	"expected": 6,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 2},
	  {"i": 2, "cond": "цикл", "s_before": 2, "s_after": 6}
	],
	"explain": ["Последовательность добавления: 0,2,4", "0+2+4=6", "Итоговое s = 6"],
	"economy": {"analyze": 20, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-05",
	"bucket": "newbie",
	"briefing": "Посчитайте, сколько раз i > 2.",
	"code": ["s = 0", "for i in range(5):", "    if i > 2:", "        s = s + 1"],
	"expected": 2,
	"trace": [
	  {"i": 0, "cond": "i > 2 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i > 2 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i > 2 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 3, "cond": "i > 2 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 4, "cond": "i > 2 -> истина", "s_before": 1, "s_after": 2}
	],
	"explain": ["Условие истинно только для i=3 и i=4", "Счётчик увеличивается дважды", "Итоговое s = 2"],
	"economy": {"analyze": 25, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-06",
	"bucket": "newbie",
	"briefing": "Суммируйте только нечётные значения.",
	"code": ["s = 0", "for i in range(6):", "    if i % 2 != 0:", "        s = s + i"],
	"expected": 9,
	"trace": [
	  {"i": 0, "cond": "i % 2 != 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i % 2 != 0 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "i % 2 != 0 -> ложь", "s_before": 1, "s_after": 1},
	  {"i": 3, "cond": "i % 2 != 0 -> истина", "s_before": 1, "s_after": 4},
	  {"i": 4, "cond": "i % 2 != 0 -> ложь", "s_before": 4, "s_after": 4},
	  {"i": 5, "cond": "i % 2 != 0 -> истина", "s_before": 4, "s_after": 9}
	],
	"explain": ["Нечётные значения: 1,3,5", "Сумма 1+3+5", "Итоговое s = 9"],
	"economy": {"analyze": 25, "wrong": 10, "reward": 15}
  },
  {
	"id": "A-07",
	"bucket": "stalker",
	"briefing": "Суммируйте только чётные числа от 1 до 8.",
	"code": ["s = 0", "for i in range(1, 9):", "    if i % 2 == 0:", "        s = s + i"],
	"expected": 20,
	"trace": [
	  {"i": 1, "cond": "i % 2 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i % 2 == 0 -> истина", "s_before": 0, "s_after": 2},
	  {"i": 3, "cond": "i % 2 == 0 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 4, "cond": "i % 2 == 0 -> истина", "s_before": 2, "s_after": 6},
	  {"i": 5, "cond": "i % 2 == 0 -> ложь", "s_before": 6, "s_after": 6},
	  {"i": 6, "cond": "i % 2 == 0 -> истина", "s_before": 6, "s_after": 12},
	  {"i": 7, "cond": "i % 2 == 0 -> ложь", "s_before": 12, "s_after": 12},
	  {"i": 8, "cond": "i % 2 == 0 -> истина", "s_before": 12, "s_after": 20}
	],
	"explain": ["Чётные значения: 2,4,6,8", "Сумма 20"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-08",
	"bucket": "stalker",
	"briefing": "Посчитайте кратные 3 в range(10).",
	"code": ["s = 0", "for i in range(10):", "    if i % 3 == 0:", "        s = s + 1"],
	"expected": 4,
	"trace": [
	  {"i": 0, "cond": "i % 3 == 0 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 1, "cond": "i % 3 == 0 -> ложь", "s_before": 1, "s_after": 1},
	  {"i": 2, "cond": "i % 3 == 0 -> ложь", "s_before": 1, "s_after": 1},
	  {"i": 3, "cond": "i % 3 == 0 -> истина", "s_before": 1, "s_after": 2},
	  {"i": 4, "cond": "i % 3 == 0 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 5, "cond": "i % 3 == 0 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 6, "cond": "i % 3 == 0 -> истина", "s_before": 2, "s_after": 3},
	  {"i": 7, "cond": "i % 3 == 0 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 8, "cond": "i % 3 == 0 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 9, "cond": "i % 3 == 0 -> истина", "s_before": 3, "s_after": 4}
	],
	"explain": ["Кратные: 0,3,6,9", "Счётчик увеличивается 4 раза"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-09",
	"bucket": "stalker",
	"briefing": "Два обновления на итерацию.",
	"code": ["s = 0", "for i in range(4):", "    s = s + i", "    s = s + 1"],
	"expected": 10,
	"trace": [
	  {"i": 0, "cond": "после i", "s_before": 0, "s_after": 1},
	  {"i": 1, "cond": "после i", "s_before": 1, "s_after": 3},
	  {"i": 2, "cond": "после i", "s_before": 3, "s_after": 6},
	  {"i": 3, "cond": "после i", "s_before": 6, "s_after": 10}
	],
	"explain": ["На каждой итерации добавляется i, затем 1", "Эквивалентно добавлению (i+1)", "Итоговое s = 10"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-10",
	"bucket": "stalker",
	"briefing": "Убывающий range с шагом -2.",
	"code": ["s = 0", "for i in range(4, 0, -2):", "    s = s + 1"],
	"expected": 2,
	"trace": [
	  {"i": 4, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 2}
	],
	"explain": ["range(4,0,-2) даёт 4 и 2", "Цикл выполняется два раза"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-11",
	"bucket": "stalker",
	"briefing": "Суммируйте значения, делящиеся на 5.",
	"code": ["s = 0", "for i in range(10):", "    if i % 5 == 0:", "        s = s + i"],
	"expected": 5,
	"trace": [
	  {"i": 0, "cond": "i % 5 == 0 -> истина", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 3, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 4, "cond": "i % 5 == 0 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 5, "cond": "i % 5 == 0 -> истина", "s_before": 0, "s_after": 5},
	  {"i": 6, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5},
	  {"i": 7, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5},
	  {"i": 8, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5},
	  {"i": 9, "cond": "i % 5 == 0 -> ложь", "s_before": 5, "s_after": 5}
	],
	"explain": ["Делящиеся значения: 0 и 5", "Накопитель добавляет только эти значения", "Итоговое s = 5"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-12",
	"bucket": "stalker",
	"briefing": "Посчитайте значения, удовлетворяющие логике OR.",
	"code": ["s = 0", "for i in range(5):", "    if i < 2 or i > 3:", "        s = s + 1"],
	"expected": 3,
	"trace": [
	  {"i": 0, "cond": "i < 2 or i > 3 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 1, "cond": "i < 2 or i > 3 -> истина", "s_before": 1, "s_after": 2},
	  {"i": 2, "cond": "i < 2 or i > 3 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 3, "cond": "i < 2 or i > 3 -> ложь", "s_before": 2, "s_after": 2},
	  {"i": 4, "cond": "i < 2 or i > 3 -> истина", "s_before": 2, "s_after": 3}
	],
	"explain": ["Истинно для i=0,1,4", "Счётчик увеличивается три раза"],
	"economy": {"analyze": 30, "wrong": 15, "reward": 20}
  },
  {
	"id": "A-13",
	"bucket": "master",
	"briefing": "Посчитайте значения в открытом интервале (2,6).",
	"code": ["s = 0", "for i in range(10):", "    if i > 2 and i < 6:", "        s = s + 1"],
	"expected": 3,
	"trace": [
	  {"i": 0, "cond": "i > 2 and i < 6 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i > 2 and i < 6 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 2, "cond": "i > 2 and i < 6 -> ложь", "s_before": 0, "s_after": 0},
	  {"i": 3, "cond": "i > 2 and i < 6 -> истина", "s_before": 0, "s_after": 1},
	  {"i": 4, "cond": "i > 2 and i < 6 -> истина", "s_before": 1, "s_after": 2},
	  {"i": 5, "cond": "i > 2 and i < 6 -> истина", "s_before": 2, "s_after": 3},
	  {"i": 6, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 7, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 8, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3},
	  {"i": 9, "cond": "i > 2 and i < 6 -> ложь", "s_before": 3, "s_after": 3}
	],
	"explain": ["Только i=3,4,5 удовлетворяют обоим условиям", "Итоговое s = 3"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-14",
	"bucket": "master",
	"briefing": "Ветка зависит от текущего значения аккумулятора.",
	"code": ["s = 0", "for i in range(3):", "    if s == 0:", "        s = 2", "    else:", "        s = s * 2"],
	"expected": 8,
	"trace": [
	  {"i": 0, "cond": "s == 0 -> истина", "s_before": 0, "s_after": 2},
	  {"i": 1, "cond": "s == 0 -> ложь", "s_before": 2, "s_after": 4},
	  {"i": 2, "cond": "s == 0 -> ложь", "s_before": 4, "s_after": 8}
	],
	"explain": ["Первая итерация задаёт s=2", "Затем значение удваивается в каждой итерации", "Итоговое s = 8"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-15",
	"bucket": "master",
	"briefing": "Следите за принудительным сбросом при i=3.",
	"code": ["s = 10", "for i in range(5):", "    if i == 3:", "        s = 0"],
	"expected": 0,
	"trace": [
	  {"i": 0, "cond": "i == 3 -> ложь", "s_before": 10, "s_after": 10},
	  {"i": 1, "cond": "i == 3 -> ложь", "s_before": 10, "s_after": 10},
	  {"i": 2, "cond": "i == 3 -> ложь", "s_before": 10, "s_after": 10},
	  {"i": 3, "cond": "i == 3 -> истина", "s_before": 10, "s_after": 0},
	  {"i": 4, "cond": "i == 3 -> ложь", "s_before": 0, "s_after": 0}
	],
	"explain": ["Накопитель начинается с 10", "При i=3 он явно сбрасывается в 0", "Итоговое s = 0"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-16",
	"bucket": "master",
	"briefing": "В чётной ветке добавляется i, в нечётной — 1.",
	"code": ["s = 0", "for i in range(5):", "    if i % 2 == 0:", "        s = s + i", "    else:", "        s = s + 1"],
	"expected": 8,
	"trace": [
	  {"i": 0, "cond": "i % 2 == 0 -> истина", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "i % 2 == 0 -> ложь", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "i % 2 == 0 -> истина", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "i % 2 == 0 -> ложь", "s_before": 3, "s_after": 4},
	  {"i": 4, "cond": "i % 2 == 0 -> истина", "s_before": 4, "s_after": 8}
	],
	"explain": ["Для чётного i добавляется само i", "Для нечётного i добавляется 1", "Итоговое s = 8"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-17",
	"bucket": "master",
	"briefing": "Накопите квадраты для нечётной последовательности.",
	"code": ["s = 0", "for i in range(1, 6, 2):", "    s = s + i * i"],
	"expected": 35,
	"trace": [
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 3, "cond": "цикл", "s_before": 1, "s_after": 10},
	  {"i": 5, "cond": "цикл", "s_before": 10, "s_after": 35}
	],
	"explain": ["Слагаемые: 1^2, 3^2, 5^2", "1 + 9 + 25 = 35"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  },
  {
	"id": "A-18",
	"bucket": "master",
	"briefing": "Финальная контрольная сумма от 0 до 10.",
	"code": ["s = 0", "for i in range(11):", "    s = s + i"],
	"expected": 55,
	"trace": [
	  {"i": 0, "cond": "цикл", "s_before": 0, "s_after": 0},
	  {"i": 1, "cond": "цикл", "s_before": 0, "s_after": 1},
	  {"i": 2, "cond": "цикл", "s_before": 1, "s_after": 3},
	  {"i": 3, "cond": "цикл", "s_before": 3, "s_after": 6},
	  {"i": 4, "cond": "цикл", "s_before": 6, "s_after": 10},
	  {"i": 5, "cond": "цикл", "s_before": 10, "s_after": 15},
	  {"i": 6, "cond": "цикл", "s_before": 15, "s_after": 21},
	  {"i": 7, "cond": "цикл", "s_before": 21, "s_after": 28},
	  {"i": 8, "cond": "цикл", "s_before": 28, "s_after": 36},
	  {"i": 9, "cond": "цикл", "s_before": 36, "s_after": 45},
	  {"i": 10, "cond": "цикл", "s_before": 45, "s_after": 55}
	],
	"explain": ["Классическая арифметическая серия 0..10", "Результат: 55"],
	"economy": {"analyze": 40, "wrong": 20, "reward": 25}
  }
]
</file>

<file path="scenes/case_01/DigitalResusQuestA.gd">
extends Control

const LEVELS_PATH := "res://data/clues_levels.json"
const ITEM_SCENE := preload("res://scenes/ui/ResusPartItem.tscn")
const ResusData := preload("res://scripts/case_01/ResusData.gd")
const ResusScoring := preload("res://scripts/case_01/ResusScoring.gd")

const COLOR_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_WARN := Color(0.86, 0.73, 0.56, 1.0)
const COLOR_ERR := Color(0.93, 0.34, 0.38, 1.0)

var levels: Array = []
var current_level_index: int = 0
var level_data: Dictionary = {}

var start_time_ms: int = 0
var drag_count: int = 0
var trace: Array = []
var item_nodes: Dictionary = {}

var console_target_text: String = ""
var console_visible_chars: int = 0
var console_cps: float = 14.0
var console_accum: float = 0.0
var _landscape_active: bool = false
var _portrait_content: VBoxContainer
var _landscape_content: HBoxContainer
var _landscape_left: VBoxContainer
var _landscape_right: VBoxContainer

@onready var main_vbox: VBoxContainer = $SafeArea/MainVBox
@onready var briefing_card: PanelContainer = $SafeArea/MainVBox/BriefingCard
@onready var title_label: Label = $SafeArea/MainVBox/Header/TitleLabel
@onready var stage_label: Label = $SafeArea/MainVBox/Header/StageLabel
@onready var stability_bar: ProgressBar = $SafeArea/MainVBox/Header/StabilityBar
@onready var briefing_label: Label = $SafeArea/MainVBox/BriefingCard/BriefingLabel

@onready var system_card: PanelContainer = $SafeArea/MainVBox/SystemCard
@onready var monitor_frame: PanelContainer = $SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame
@onready var monitor_screen: ColorRect = $SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame/MonitorScreen
@onready var monitor_label: Label = $SafeArea/MainVBox/SystemCard/SystemVBox/MonitorFrame/MonitorLabel
@onready var boot_console: RichTextLabel = $SafeArea/MainVBox/SystemCard/SystemVBox/BootConsole

@onready var zones_card: PanelContainer = $SafeArea/MainVBox/ZonesCard
@onready var pile_zone: Node = $SafeArea/MainVBox/PartsPileCard
@onready var zone_input: Node = $SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneInput
@onready var zone_output: Node = $SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneOutput
@onready var zone_memory: Node = $SafeArea/MainVBox/ZonesCard/ZonesVBox/ZoneMemory
@onready var parts_pile_card: PanelContainer = $SafeArea/MainVBox/PartsPileCard
@onready var parts_grid: GridContainer = $SafeArea/MainVBox/PartsPileCard/VBox/Scroll/PartsGrid

@onready var bottom_bar: HBoxContainer = $SafeArea/MainVBox/BottomBar
@onready var status_label: Label = $SafeArea/MainVBox/BottomBar/StatusLabel
@onready var btn_reset: Button = $SafeArea/MainVBox/BottomBar/BtnReset
@onready var btn_confirm: Button = $SafeArea/MainVBox/BottomBar/BtnConfirm
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack

@onready var dimmer: ColorRect = $Dimmer
@onready var result_popup: PanelContainer = $ResultPopup
@onready var result_verdict_label: Label = $ResultPopup/VBox/VerdictLabel
@onready var result_score_label: Label = $ResultPopup/VBox/ScoreLabel
@onready var result_stability_label: Label = $ResultPopup/VBox/StabilityLabel
@onready var result_retry_button: Button = $ResultPopup/VBox/Buttons/BtnRetry
@onready var result_back_button: Button = $ResultPopup/VBox/Buttons/BtnBack

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	_connect_ui_signals()
	_connect_zone_signals()
	_build_responsive_layout()
	_load_levels()
	if levels.is_empty():
		_show_error("Не удалось загрузить данные уровня «Цифровая реанимация».")
		return
	_start_level(current_level_index)
	_on_viewport_size_changed()

func _process(delta: float) -> void:
	_update_console(delta)

func _connect_ui_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	result_retry_button.pressed.connect(_on_retry_pressed)
	result_back_button.pressed.connect(_on_back_pressed)

func _connect_zone_signals() -> void:
	var callback: Callable = Callable(self, "_on_item_placed")
	for zone in _all_zones():
		if zone.has_signal("item_placed") and not zone.is_connected("item_placed", callback):
			zone.connect("item_placed", callback)

func _build_responsive_layout() -> void:
	if is_instance_valid(_portrait_content) and is_instance_valid(_landscape_content):
		return

	_portrait_content = VBoxContainer.new()
	_portrait_content.name = "PortraitContent"
	_portrait_content.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_portrait_content.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_portrait_content.add_theme_constant_override("separation", 10)

	_landscape_content = HBoxContainer.new()
	_landscape_content.name = "LandscapeContent"
	_landscape_content.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_landscape_content.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_landscape_content.add_theme_constant_override("separation", 10)
	_landscape_content.visible = false

	_landscape_left = VBoxContainer.new()
	_landscape_left.name = "LandscapeLeft"
	_landscape_left.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_landscape_left.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_landscape_left.size_flags_stretch_ratio = 1.1
	_landscape_left.add_theme_constant_override("separation", 8)

	_landscape_right = VBoxContainer.new()
	_landscape_right.name = "LandscapeRight"
	_landscape_right.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_landscape_right.size_flags_vertical = Control.SIZE_EXPAND_FILL
	_landscape_right.size_flags_stretch_ratio = 1.0
	_landscape_right.add_theme_constant_override("separation", 8)

	_landscape_content.add_child(_landscape_left)
	_landscape_content.add_child(_landscape_right)

	main_vbox.add_child(_portrait_content)
	main_vbox.add_child(_landscape_content)

	var insert_index: int = max(0, main_vbox.get_children().find(briefing_card) + 1)
	main_vbox.move_child(_portrait_content, insert_index)
	main_vbox.move_child(_landscape_content, insert_index + 1)

	var portrait_nodes: Array[Control] = [system_card, zones_card, parts_pile_card, bottom_bar]
	for node in portrait_nodes:
		node.reparent(_portrait_content)

func _load_levels() -> void:
	levels = ResusData.load_levels(LEVELS_PATH)

func _start_level(index: int) -> void:
	current_level_index = clamp(index, 0, max(0, levels.size() - 1))
	level_data = (levels[current_level_index] as Dictionary).duplicate(true)
	title_label.text = "ДЕЛО №1: ЦИФРОВАЯ РЕАНИМАЦИЯ"
	stage_label.text = "ЭТАП A"
	briefing_label.text = str(level_data.get("briefing", ""))
	btn_reset.text = "СБРОС"
	btn_confirm.text = "ПОДТВЕРДИТЬ"
	result_retry_button.text = "ПОВТОРИТЬ"
	result_back_button.text = "ВЫХОД"

	var bucket_labels: Dictionary = _bucket_label_map(level_data.get("buckets", []) as Array)

	_zone_setup(pile_zone, "PILE", "Куча деталей")
	_zone_setup(zone_input, "INPUT", str(bucket_labels.get("INPUT", "INPUT")))
	_zone_setup(zone_output, "OUTPUT", str(bucket_labels.get("OUTPUT", "OUTPUT")))
	_zone_setup(zone_memory, "MEMORY", str(bucket_labels.get("MEMORY", "MEMORY")))

	_reset_attempt()

func _zone_setup(zone: Node, zone_id: String, zone_label: String) -> void:
	if zone.has_method("setup"):
		zone.call("setup", zone_id, zone_label)

func _bucket_label_map(buckets: Array) -> Dictionary:
	var out: Dictionary = {}
	for bucket_v in buckets:
		if typeof(bucket_v) != TYPE_DICTIONARY:
			continue
		var bucket: Dictionary = bucket_v as Dictionary
		var bucket_id: String = str(bucket.get("bucket_id", "")).to_upper()
		if bucket_id == "":
			continue
		out[bucket_id] = str(bucket.get("label", bucket_id))
	return out

func _reset_attempt() -> void:
	start_time_ms = Time.get_ticks_msec()
	drag_count = 0
	trace.clear()
	item_nodes.clear()
	btn_confirm.disabled = false
	result_popup.visible = false
	dimmer.visible = false

	for zone in _all_zones():
		if zone.has_method("clear_items"):
			zone.call("clear_items")

	_spawn_items()
	_refresh_system_state(_build_snapshot())
	_update_stability_ui()

func _spawn_items() -> void:
	var items: Array = level_data.get("items", []) as Array
	for item_v in items:
		if typeof(item_v) != TYPE_DICTIONARY:
			continue
		var item_data: Dictionary = (item_v as Dictionary).duplicate(true)
		var item_node: Node = ITEM_SCENE.instantiate()
		if not (item_node is Control):
			continue
		if item_node.has_method("setup"):
			item_node.call("setup", item_data)
		if item_node.has_signal("drag_started"):
			item_node.connect("drag_started", Callable(self, "_on_drag_started"))

		if pile_zone.has_method("add_item_control"):
			pile_zone.call("add_item_control", item_node)

		var item_id: String = str(item_data.get("item_id", ""))
		if item_id != "":
			item_nodes[item_id] = item_node

func _on_drag_started(item_id: String, from_zone: String) -> void:
	drag_count += 1
	_log_event("DRAG_START", {
		"item_id": item_id,
		"from_zone": from_zone
	})

func _on_item_placed(item_id: String, to_bucket: String, from_bucket: String) -> void:
	_log_event("ITEM_PLACED", {
		"item_id": item_id,
		"from_zone": from_bucket,
		"to_zone": to_bucket
	})
	_refresh_system_state(_build_snapshot())

func _build_snapshot() -> Dictionary:
	var snapshot: Dictionary = {}
	for item_id_v in item_nodes.keys():
		var item_id: String = str(item_id_v)
		var item_node_v: Variant = item_nodes[item_id]
		if not (item_node_v is Node):
			snapshot[item_id] = "PILE"
			continue
		var item_node: Node = item_node_v as Node
		snapshot[item_id] = str(item_node.get_meta("zone_id", "PILE")).to_upper()
	return snapshot

func _count_placed(snapshot: Dictionary) -> int:
	var count: int = 0
	for zone_v in snapshot.values():
		if str(zone_v).to_upper() != "PILE":
			count += 1
	return count

func _evaluate_system_state(snapshot: Dictionary) -> Dictionary:
	var rules: Dictionary = level_data.get("system_state_rules", {}) as Dictionary
	var monitor_on: bool = _rule_holds(snapshot, rules.get("monitor_on_if", {}))
	var ram_ok: bool = _rule_holds(snapshot, rules.get("ram_ok_if", {}))
	var fast_type: bool = _rule_holds(snapshot, rules.get("fast_type_if", {}))
	return {
		"monitor_on": monitor_on,
		"ram_ok": ram_ok,
		"fast_type": fast_type
	}

func _rule_holds(snapshot: Dictionary, rule_v: Variant) -> bool:
	if typeof(rule_v) != TYPE_DICTIONARY:
		return false
	var rule: Dictionary = rule_v as Dictionary
	var item_id: String = str(rule.get("item_id", ""))
	var zone_id: String = str(rule.get("zone_id", "")).to_upper()
	if item_id == "" or zone_id == "":
		return false
	return str(snapshot.get(item_id, "PILE")).to_upper() == zone_id

func _refresh_system_state(snapshot: Dictionary) -> void:
	var state: Dictionary = _evaluate_system_state(snapshot)
	var monitor_on: bool = bool(state.get("monitor_on", false))
	var ram_ok: bool = bool(state.get("ram_ok", false))
	var fast_type: bool = bool(state.get("fast_type", false))

	if monitor_on:
		monitor_screen.color = Color(0.09, 0.2, 0.12, 1.0)
		monitor_label.text = "СИГНАЛ ЕСТЬ"
		monitor_label.modulate = COLOR_OK
	else:
		monitor_screen.color = Color(0.03, 0.03, 0.03, 1.0)
		monitor_label.text = "NO SIGNAL"
		monitor_label.modulate = COLOR_ERR

	console_cps = 40.0 if fast_type else 14.0

	var feedback_rules: Dictionary = level_data.get("feedback_rules", {}) as Dictionary
	var system_rules: Dictionary = level_data.get("system_state_rules", {}) as Dictionary
	var console_lines: Array = []
	var problem_lines: Array[String] = []
	var status_color: Color = COLOR_OK

	if not ram_ok:
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"NO_RAM",
			"Сбой загрузки: установите RAM в ПАМЯТЬ"
		))
		status_color = COLOR_ERR
		console_lines = ((feedback_rules.get("NO_RAM", {}) as Dictionary).get("console_lines", []) as Array).duplicate()
	else:
		console_lines = (system_rules.get("boot_ok_lines", []) as Array).duplicate()

	if not monitor_on:
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"NO_GPU",
			"Нет видеосигнала: установите GPU в ВЫВОД"
		))
		status_color = COLOR_ERR

	if ram_ok and not fast_type:
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"NO_CACHE",
			"Диагностика медленная: установите CACHE в ПАМЯТЬ"
		))
		if status_color != COLOR_ERR:
			status_color = COLOR_WARN

	if problem_lines.is_empty():
		problem_lines.append(_feedback_status_line(
			feedback_rules,
			"HEALTHY",
			"Система стабилизирована. Можно подтверждать."
		))
		status_color = COLOR_OK

	if console_lines.is_empty():
		console_lines.append("...")
	_set_console_target(_array_to_lines(console_lines))

	status_label.text = "\n".join(problem_lines)
	status_label.modulate = status_color

func _feedback_status_line(feedback_rules: Dictionary, rule_key: String, fallback: String) -> String:
	return str((feedback_rules.get(rule_key, {}) as Dictionary).get("status", fallback))
func _set_console_target(text: String) -> void:
	if console_target_text == text:
		return
	console_target_text = text
	console_visible_chars = 0
	console_accum = 0.0
	boot_console.text = ""

func _update_console(delta: float) -> void:
	if console_target_text.is_empty():
		return
	if console_visible_chars >= console_target_text.length():
		return
	console_accum += delta * console_cps
	var advance: int = int(floor(console_accum))
	if advance <= 0:
		return
	console_accum -= float(advance)
	console_visible_chars = min(console_target_text.length(), console_visible_chars + advance)
	boot_console.text = console_target_text.substr(0, console_visible_chars)

func _array_to_lines(lines: Array) -> String:
	var out: Array[String] = []
	for line_v in lines:
		out.append(str(line_v))
	return "\n".join(out)

func _on_confirm_pressed() -> void:
	var snapshot: Dictionary = _build_snapshot()
	var placed_count: int = _count_placed(snapshot)
	_log_event("CONFIRM_PRESSED", {"placed_count": placed_count})

	var result: Dictionary = ResusScoring.score(level_data, snapshot, placed_count)
	var system_state: Dictionary = _evaluate_system_state(snapshot)
	var elapsed_ms: int = Time.get_ticks_msec() - start_time_ms
	var match_key: String = "RESUS_A|%s|%d" % [str(level_data.get("id", "RESUS-A")), GlobalMetrics.session_history.size()]

	var payload: Dictionary = {
		"quest_id": "CASE_01_DIGITAL_RESUS",
		"stage": "A",
		"level_id": str(level_data.get("id", "RESUS-A-00")),
		"format": "MATCHING",
		"match_key": match_key,
		"snapshot": snapshot,
		"trace": trace.duplicate(true),
		"elapsed_ms": elapsed_ms,
		"drag_count": drag_count,
		"placed_count": placed_count,
		"correct_count": int(result.get("correct_count", 0)),
		"total_items": int(result.get("total_items", 0)),
		"points": int(result.get("points", 0)),
		"max_points": int(result.get("max_points", 2)),
		"is_fit": bool(result.get("is_fit", false)),
		"is_correct": bool(result.get("is_correct", false)),
		"stability_delta": int(result.get("stability_delta", 0)),
		"verdict_code": str(result.get("verdict_code", "FAIL")),
		"rule_code": str(result.get("rule_code", "SCORING_RULE")),
		"system_state": system_state
	}
	GlobalMetrics.register_trial(payload)
	_update_stability_ui()

	btn_confirm.disabled = true
	_show_result(result)

	if bool(result.get("is_correct", false)):
		AudioManager.play("relay")
	elif bool(result.get("is_fit", false)):
		AudioManager.play("click")
	else:
		AudioManager.play("error")

func _show_result(result: Dictionary) -> void:
	var verdict_code: String = str(result.get("verdict_code", "FAIL"))
	result_verdict_label.text = verdict_code
	result_score_label.text = "%d/%d  |  %d/%d" % [
		int(result.get("correct_count", 0)),
		int(result.get("total_items", 8)),
		int(result.get("points", 0)),
		int(result.get("max_points", 2))
	]
	result_stability_label.text = "Δ Стабильность: %d" % int(result.get("stability_delta", 0))

	if verdict_code == "PERFECT":
		result_verdict_label.modulate = COLOR_OK
	elif verdict_code == "PARTIAL":
		result_verdict_label.modulate = COLOR_WARN
	else:
		result_verdict_label.modulate = COLOR_ERR

	dimmer.visible = true
	result_popup.visible = true

func _on_reset_pressed() -> void:
	var snapshot: Dictionary = _build_snapshot()
	_log_event("RESET_PRESSED", {
		"placed_count": _count_placed(snapshot)
	})
	_reset_attempt()
	AudioManager.play("click")
func _on_retry_pressed() -> void:
	_reset_attempt()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _log_event(event_name: String, data: Dictionary = {}) -> void:
	trace.append({
		"t_ms": Time.get_ticks_msec() - start_time_ms,
		"event": event_name,
		"data": data.duplicate(true)
	})

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_bar.value = GlobalMetrics.stability

func _on_viewport_size_changed() -> void:
	var width: float = get_viewport_rect().size.x
	var height: float = get_viewport_rect().size.y
	var should_landscape: bool = width > height and width >= 900.0
	_apply_layout_mode(should_landscape)

func _apply_layout_mode(landscape: bool) -> void:
	if _landscape_active != landscape:
		_landscape_active = landscape
		if landscape:
			system_card.reparent(_landscape_left)
			zones_card.reparent(_landscape_left)
			parts_pile_card.reparent(_landscape_right)
			bottom_bar.reparent(_landscape_right)
		else:
			var portrait_nodes: Array[Control] = [system_card, zones_card, parts_pile_card, bottom_bar]
			for node in portrait_nodes:
				node.reparent(_portrait_content)
		_portrait_content.visible = not landscape
		_landscape_content.visible = landscape

	_apply_responsive_sizes(landscape, get_viewport_rect().size.x)

func _apply_responsive_sizes(landscape: bool, width: float) -> void:
	if landscape:
		briefing_label.custom_minimum_size = Vector2(0, 48)
		monitor_frame.custom_minimum_size = Vector2(0, 108)
		boot_console.custom_minimum_size = Vector2(0, 118)
		_set_zone_height(90)
		parts_pile_card.custom_minimum_size = Vector2(0, 0)
		status_label.custom_minimum_size = Vector2(0, 58)
		btn_reset.custom_minimum_size = Vector2(140, 58)
		btn_confirm.custom_minimum_size = Vector2(170, 58)
		parts_grid.columns = 3 if width >= 1250.0 else 2
	else:
		briefing_label.custom_minimum_size = Vector2(0, 72)
		monitor_frame.custom_minimum_size = Vector2(0, 150)
		boot_console.custom_minimum_size = Vector2(0, 180)
		_set_zone_height(120)
		parts_pile_card.custom_minimum_size = Vector2(0, 220)
		status_label.custom_minimum_size = Vector2(0, 72)
		btn_reset.custom_minimum_size = Vector2(160, 72)
		btn_confirm.custom_minimum_size = Vector2(180, 72)
		parts_grid.columns = 1 if width < 700.0 else 2

func _set_zone_height(height_px: int) -> void:
	var target_size: Vector2 = Vector2(0, height_px)
	if zone_input is Control:
		(zone_input as Control).custom_minimum_size = target_size
	if zone_output is Control:
		(zone_output as Control).custom_minimum_size = target_size
	if zone_memory is Control:
		(zone_memory as Control).custom_minimum_size = target_size

func _all_zones() -> Array:
	return [pile_zone, zone_input, zone_output, zone_memory]

func _show_error(message: String) -> void:
	status_label.text = message
	status_label.modulate = COLOR_ERR
	btn_confirm.disabled = true
</file>

<file path="scenes/case_07/da7_data_archive_c.tscn">
[gd_scene load_steps=7 format=3]

[ext_resource type="Script" path="res://scripts/case_07/da7_data_archive_c.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="AudioStream" path="res://audio/click.wav" id="3_click"]
[ext_resource type="AudioStream" path="res://audio/error.wav" id="4_error"]
[ext_resource type="AudioStream" path="res://audio/relay.wav" id="5_relay"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="6_noir_overlay"]

[node name="DA7_DataArchiveQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("6_noir_overlay")]

[node name="SafeArea" type="Control" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Margin" type="MarginContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2

[node name="Root" type="VBoxContainer" parent="SafeArea/Margin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="BackRow" type="HBoxContainer" parent="SafeArea/Margin/Root"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/Margin/Root/BackRow"]
custom_minimum_size = Vector2(120, 48)
layout_mode = 2
text = "НАЗАД"

[node name="Header" type="PanelContainer" parent="SafeArea/Margin/Root"]
layout_mode = 2
size_flags_horizontal = 3

[node name="HeaderVBox" type="VBoxContainer" parent="SafeArea/Margin/Root/Header"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="Title" type="Label" parent="SafeArea/Margin/Root/Header/HeaderVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО #7: МАСТЕР SQL"

[node name="TimerRow" type="HBoxContainer" parent="SafeArea/Margin/Root/Header/HeaderVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="StabilityLabel" type="Label" parent="SafeArea/Margin/Root/Header/HeaderVBox/TimerRow"]
custom_minimum_size = Vector2(160, 0)
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="TimerBar" type="ProgressBar" parent="SafeArea/Margin/Root/Header/HeaderVBox/TimerRow"]
layout_mode = 2
size_flags_horizontal = 3
max_value = 120.0
value = 120.0
show_percentage = false

[node name="TimerLabel" type="Label" parent="SafeArea/Margin/Root/Header/HeaderVBox/TimerRow"]
custom_minimum_size = Vector2(78, 0)
layout_mode = 2
text = "02:00"
horizontal_alignment = 2

[node name="Prompt" type="RichTextLabel" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 84)
layout_mode = 2
bbcode_enabled = true
text = "Загрузка дела..."
fit_content = false
autowrap_mode = 2

[node name="CodePanel" type="PanelContainer" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 140)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CodeArea" type="HFlowContainer" parent="SafeArea/Margin/Root/CodePanel"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8

[node name="ControlsRow" type="HBoxContainer" parent="SafeArea/Margin/Root"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnUndo" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ОТМЕНА"

[node name="BtnClear" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ОЧИСТИТЬ"

[node name="BtnSubmit" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ОТПРАВИТЬ"

[node name="BtnNext" type="Button" parent="SafeArea/Margin/Root/ControlsRow"]
visible = false
custom_minimum_size = Vector2(160, 56)
layout_mode = 2
text = "ДАЛЕЕ"

[node name="StatusLabel" type="Label" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 34)
layout_mode = 2
text = "Соберите токены запроса и отправьте."
autowrap_mode = 2

[node name="RepoPanel" type="PanelContainer" parent="SafeArea/Margin/Root"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RepoScroll" type="ScrollContainer" parent="SafeArea/Margin/Root/RepoPanel"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
horizontal_scroll_mode = 0

[node name="BlockRepository" type="GridContainer" parent="SafeArea/Margin/Root/RepoPanel/RepoScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 4

[node name="SFX" type="Node" parent="."]

[node name="SfxClick" type="AudioStreamPlayer" parent="SFX"]
stream = ExtResource("3_click")

[node name="SfxError" type="AudioStreamPlayer" parent="SFX"]
stream = ExtResource("4_error")

[node name="SfxRelay" type="AudioStreamPlayer" parent="SFX"]
stream = ExtResource("5_relay")
</file>

<file path="scenes/MainMenu.gd">
extends Control

@onready var menu_root: VBoxContainer = $Center/Menu
@onready var start_btn: Button = $Center/Menu/NotebookArea
@onready var learn_btn: Button = $Center/Menu/PapersArea

func _ready() -> void:
	start_btn.pressed.connect(_on_start_pressed)
	learn_btn.pressed.connect(_on_learn_pressed)
	_animate_intro()

func _on_start_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_learn_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/LearnSelect.tscn")

func _animate_intro() -> void:
	menu_root.modulate.a = 0.0
	menu_root.position.y += 32.0
	var tween: Tween = create_tween()
	tween.tween_property(menu_root, "modulate:a", 1.0, 0.35).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	tween.parallel().tween_property(menu_root, "position:y", menu_root.position.y - 32.0, 0.42).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)
</file>

<file path="scenes/MatrixDecryptor.tscn">
[gd_scene load_steps=3 format=3 uid="uid://rr4uj50uqt2r"]

[ext_resource type="Script" path="res://scenes/MatrixDecryptor.gd" id="1_script"]
[ext_resource type="PackedScene" path="res://scenes/decryptor/MatrixDecryptorUI.tscn" id="2_ui"]

[node name="MatrixDecryptor" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="UI" parent="." instance=ExtResource("2_ui")]
layout_mode = 1
</file>

<file path="scenes/NetworkTraceQuestC.tscn">
[gd_scene load_steps=10 format=3]

[ext_resource type="Script" path="res://scripts/quests/network_trace/NetworkTraceQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_terminal_green.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="PackedScene" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="4_diag_panel"]
[ext_resource type="PackedScene" path="res://scenes/ui/subnet/LockIndicator.tscn" id="5_lock_indicator"]
[ext_resource type="PackedScene" path="res://scenes/ui/subnet/MaskOverlay.tscn" id="6_mask_overlay"]
[ext_resource type="PackedScene" path="res://scenes/ui/subnet/SubnetRuler.tscn" id="7_subnet_ruler"]
[ext_resource type="Script" path="res://scripts/ui/subnet/MaskDropTarget.gd" id="8_drop_target"]

[sub_resource type="ShaderMaterial" id="1_overlay_material"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(0, 1, 0.25, 1)
shader_parameter/intensity = 0.12
shader_parameter/fx_quality = 0
shader_parameter/glitch_strength = 0.0

[node name="NetworkTraceQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.04, 0.06, 0.05, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="CRT_Overlay" type="ColorRect" parent="CanvasLayer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("1_overlay_material")
color = Color(1, 1, 1, 0)

[node name="CanvasModulate" type="CanvasModulate" parent="."]
color = Color(0.9, 1, 0.94, 1)

[node name="Main" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="V" type="VBoxContainer" parent="Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Header" type="HBoxContainer" parent="Main/V"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnBack" type="Button" parent="Main/V/Header"]
custom_minimum_size = Vector2(118, 58)
layout_mode = 2
text = "НАЗАД"

[node name="LblTitle" type="Label" parent="Main/V/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 24
text = "СЕТЕВОЙ СЛЕД | C"

[node name="LblMeta" type="Label" parent="Main/V/Header"]
custom_minimum_size = Vector2(330, 52)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ДЕЛО -- | ОШ 0/3 | T-02:00"
horizontal_alignment = 2
vertical_alignment = 1

[node name="PaletteSelect" type="OptionButton" parent="Main/V/Header"]
custom_minimum_size = Vector2(132, 52)
layout_mode = 2

[node name="Body" type="BoxContainer" parent="Main/V"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="TerminalPane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.4

[node name="TerminalMargin" type="MarginContainer" parent="Main/V/Body/TerminalPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="TerminalV" type="VBoxContainer" parent="Main/V/Body/TerminalPane/TerminalMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LblBriefing" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="LblPrompt" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
custom_minimum_size = Vector2(0, 72)
layout_mode = 2
size_flags_horizontal = 3
bbcode_enabled = true
fit_content = false
scroll_active = false

[node name="TargetBox" type="VBoxContainer" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="LblTargetIp" type="Label" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox"]
layout_mode = 2
text = "IP: --"

[node name="LblTargetCidr" type="Label" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox"]
layout_mode = 2
text = "CIDR: --"

[node name="LblTargetAsk" type="Label" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/TargetBox"]
layout_mode = 2
text = "ЗАПРОС: --"

[node name="LogScroll" type="ScrollContainer" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LogText" type="RichTextLabel" parent="Main/V/Body/TerminalPane/TerminalMargin/TerminalV/LogScroll"]
custom_minimum_size = Vector2(0, 180)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
fit_content = false
selection_enabled = true
autowrap_mode = 2

[node name="BoardPane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.25

[node name="BoardMargin" type="MarginContainer" parent="Main/V/Body/BoardPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BoardV" type="VBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="LockIndicator" parent="Main/V/Body/BoardPane/BoardMargin/BoardV" instance=ExtResource("5_lock_indicator")]
layout_mode = 2

[node name="BitBoard" type="VBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="RowIpLine" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblRowIp" type="Label" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowIpLine"]
custom_minimum_size = Vector2(62, 44)
layout_mode = 2
text = "IP"
vertical_alignment = 1

[node name="RowIp" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowIpLine"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="RowMaskLine" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblRowMask" type="Label" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine"]
custom_minimum_size = Vector2(62, 44)
layout_mode = 2
text = "МАСКА"
vertical_alignment = 1

[node name="MaskDropTarget" type="PanelContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
script = ExtResource("8_drop_target")

[node name="RowMask" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowMaskLine/MaskDropTarget"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
offset_left = 6.0
offset_top = 4.0
offset_right = -6.0
offset_bottom = -4.0
theme_override_constants/separation = 4

[node name="RowResLine" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard"]
visible = false
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblRowRes" type="Label" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine"]
custom_minimum_size = Vector2(62, 44)
layout_mode = 2
text = "РЕЗУЛЬТАТ"
vertical_alignment = 1

[node name="RowRes" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BitBoard/RowResLine"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="MaskTray" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="LblMaskTray" type="Label" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/MaskTray"]
custom_minimum_size = Vector2(94, 52)
layout_mode = 2
text = "МАСКА"
vertical_alignment = 1

[node name="MaskOverlay" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/MaskTray" instance=ExtResource("6_mask_overlay")]
layout_mode = 2

[node name="Ruler" parent="Main/V/Body/BoardPane/BoardMargin/BoardV" instance=ExtResource("7_subnet_ruler")]
layout_mode = 2

[node name="BoardActions" type="HBoxContainer" parent="Main/V/Body/BoardPane/BoardMargin/BoardV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnAnalyze" type="Button" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "АНАЛИЗ"

[node name="BtnApplyAnd" type="Button" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРИМЕНИТЬ И"

[node name="BtnReset" type="Button" parent="Main/V/Body/BoardPane/BoardMargin/BoardV/BoardActions"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="AnswersPane" type="PanelContainer" parent="Main/V/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="AnswersMargin" type="MarginContainer" parent="Main/V/Body/AnswersPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="AnswersV" type="VBoxContainer" parent="Main/V/Body/AnswersPane/AnswersMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="OptionsGrid" type="GridContainer" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 2

[node name="ActionBtn1" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn2" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn3" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn4" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn5" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="ActionBtn6" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/OptionsGrid"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
size_flags_horizontal = 3
text = ""

[node name="LblStatus" type="Label" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 78)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Статус"

[node name="BottomRow" type="HBoxContainer" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnNext" type="Button" parent="Main/V/Body/AnswersPane/AnswersMargin/AnswersV/BottomRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
visible = false
text = "ДАЛЕЕ"

[node name="DiagnosticsPanel" parent="." instance=ExtResource("4_diag_panel")]
layout_mode = 1
anchor_left = 0.1
anchor_top = 0.12
anchor_right = 0.9
anchor_bottom = 0.9
</file>

<file path="scripts/case_01/ResusScoring.gd">
extends RefCounted

static func score(level: Dictionary, snapshot: Dictionary, placed_count: int) -> Dictionary:
	var items: Array = level.get("items", []) as Array
	var total_items: int = items.size()
	var scoring_model: Dictionary = level.get("scoring_model", {}) as Dictionary
	var rules: Array = (scoring_model.get("rules", []) as Array).duplicate()
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary

	var correct_count: int = 0
	for item_v in items:
		if typeof(item_v) != TYPE_DICTIONARY:
			continue
		var item: Dictionary = item_v as Dictionary
		var item_id: String = str(item.get("item_id", ""))
		var expected_bucket: String = str(item.get("correct_bucket_id", "")).to_upper()
		var actual_bucket: String = str(snapshot.get(item_id, "PILE")).to_upper()
		if expected_bucket == actual_bucket:
			correct_count += 1

	var max_points: int = 0
	for rule_v in rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			continue
		var rule_data: Dictionary = rule_v as Dictionary
		max_points = max(max_points, int(rule_data.get("points", 0)))

	if placed_count <= 0:
		return {
			"correct_count": correct_count,
			"total_items": total_items,
			"points": int(default_rule.get("points", 0)),
			"max_points": max_points,
			"is_fit": false,
			"is_correct": false,
			"stability_delta": int(default_rule.get("stability_delta", -50)),
			"verdict_code": str(default_rule.get("verdict_code", "EMPTY")),
			"rule_code": str(default_rule.get("code", "EMPTY_CONFIRM"))
		}

	var selected_rule: Dictionary = {}
	var selected_min_correct: int = -9999
	for rule_v in rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_v as Dictionary
		var min_correct: int = int(rule.get("min_correct", 0))
		if correct_count >= min_correct and min_correct > selected_min_correct:
			selected_min_correct = min_correct
			selected_rule = rule

	if selected_rule.is_empty():
		selected_rule = {
			"points": 0,
			"stability_delta": -30,
			"verdict_code": "FAIL",
			"code": "FALLBACK"
		}

	var points: int = int(selected_rule.get("points", 0))
	var is_correct: bool = correct_count == total_items and points == max_points
	var is_fit: bool = points > 0

	return {
		"correct_count": correct_count,
		"total_items": total_items,
		"points": points,
		"max_points": max_points,
		"is_fit": is_fit,
		"is_correct": is_correct,
		"stability_delta": int(selected_rule.get("stability_delta", -30)),
		"verdict_code": str(selected_rule.get("verdict_code", "FAIL")),
		"rule_code": str(selected_rule.get("code", "SCORING_RULE"))
	}

static func calculate_stage_b_result(stage_b_data: Dictionary, snapshot: Dictionary) -> Dictionary:
	var selected_option_id: String = str(snapshot.get("selected_option_id", "")).strip_edges()
	var scoring_model: Dictionary = stage_b_data.get("scoring_model", {}) as Dictionary
	var feedback_rules: Dictionary = stage_b_data.get("feedback_rules", {}) as Dictionary
	var correct_option_id: String = str(stage_b_data.get("correct_option_id", ""))
	var max_points: int = int(stage_b_data.get("stage_max_points", int(scoring_model.get("correct_points", 2))))

	if selected_option_id == "":
		var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
		return {
			"points": int(default_rule.get("points", 0)),
			"max_points": max_points,
			"is_correct": false,
			"is_fit": false,
			"stability_delta": int(default_rule.get("stability_delta", -50)),
			"verdict_code": str(default_rule.get("verdict_code", "EMPTY")),
			"error_code": "EMPTY",
			"diagnostic_headline": "Вариант не выбран",
			"diagnostic_details": ["Выберите один из 4 вариантов и подтвердите решение."]
		}

	var is_correct: bool = selected_option_id == correct_option_id
	var points: int = int(scoring_model.get("correct_points", 2)) if is_correct else int(scoring_model.get("wrong_points", 0))
	var stability_delta: int = int(scoring_model.get("stability_delta_correct", 0)) if is_correct else int(scoring_model.get("stability_delta_wrong", -10))
	var verdict_code: String = "SUCCESS" if is_correct else "WRONG"

	var feedback: Dictionary = feedback_rules.get(selected_option_id, {}) as Dictionary
	if feedback.is_empty() and feedback_rules.has(correct_option_id):
		feedback = feedback_rules.get(correct_option_id, {}) as Dictionary

	var error_code: String = str(feedback.get("error_code", "OK" if is_correct else "WRONG"))
	var headline: String = str(feedback.get("headline", "Конфигурация проверена"))
	var details: Array = (feedback.get("details", []) as Array).duplicate()

	return {
		"points": points,
		"max_points": max_points,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"error_code": error_code,
		"diagnostic_headline": headline,
		"diagnostic_details": details
	}

static func calculate_stage_c_result(stage_c_data: Dictionary, snapshot: Dictionary) -> Dictionary:
	var options: Array = stage_c_data.get("options", []) as Array
	var scoring_model: Dictionary = stage_c_data.get("scoring_model", {}) as Dictionary
	var feedback_rules: Dictionary = stage_c_data.get("feedback_rules", {}) as Dictionary

	var option_by_id: Dictionary = {}
	var correct_set: Dictionary = {}
	for option_v in options:
		if typeof(option_v) != TYPE_DICTIONARY:
			continue
		var option_data: Dictionary = option_v as Dictionary
		var option_id: String = str(option_data.get("option_id", "")).strip_edges()
		if option_id == "":
			continue
		option_by_id[option_id] = option_data
		if bool(option_data.get("is_correct", false)):
			correct_set[option_id] = true

	var slots_raw: Array = snapshot.get("slots", []) as Array
	var slots: Array[String] = []
	for slot_v in slots_raw:
		slots.append(str(slot_v).strip_edges())

	var selected_raw: Array = snapshot.get("selected", []) as Array
	if selected_raw.is_empty() and not slots.is_empty():
		selected_raw = slots_raw
	var selected_set: Dictionary = {}
	var selected_ids: Array[String] = []
	for selected_v in selected_raw:
		var selected_id: String = str(selected_v).strip_edges()
		if selected_id == "" or selected_set.has(selected_id):
			continue
		selected_set[selected_id] = true
		selected_ids.append(selected_id)
	selected_ids.sort()

	var correct_selected: int = 0
	var wrong_selected: int = 0
	var explain_selected: Array = []
	for selected_id in selected_ids:
		var is_option_correct: bool = correct_set.has(selected_id)
		if is_option_correct:
			correct_selected += 1
		else:
			wrong_selected += 1

		var option_data_v: Variant = option_by_id.get(selected_id, {})
		var option_data: Dictionary = option_data_v as Dictionary
		explain_selected.append({
			"option_id": selected_id,
			"label": str(option_data.get("label", selected_id)),
			"is_correct": is_option_correct,
			"why": str(option_data.get("why", "Пояснение отсутствует."))
		})

	var selected_count: int = selected_ids.size()
	var unique_used_count: int = int(snapshot.get("unique_used_count", selected_count))
	var strategy_flags: Array[String] = []
	if options.size() > 0 and unique_used_count >= options.size():
		strategy_flags.append("TOUCHED_ALL_OPTIONS")
	var max_points: int = int(stage_c_data.get("stage_max_points", 2))
	var verdict_code: String = "FAIL"
	var points: int = 0
	var stability_delta: int = -50

	var rule_2: Dictionary = scoring_model.get("rule_2", {}) as Dictionary
	var rule_1a: Dictionary = scoring_model.get("rule_1a", {}) as Dictionary
	var rule_1b: Dictionary = scoring_model.get("rule_1b", {}) as Dictionary
	var default_rule: Dictionary = scoring_model.get("default_rule", {}) as Dictionary
	var empty_rule: Dictionary = scoring_model.get("empty_rule", {}) as Dictionary
	var select_all_rule: Dictionary = scoring_model.get("select_all_rule", default_rule) as Dictionary
	var is_select_all_behavior: bool = options.size() > 0 and selected_count == options.size()

	if selected_count == 0:
		verdict_code = str(empty_rule.get("verdict_code", "EMPTY"))
		points = int(empty_rule.get("points", 0))
		stability_delta = int(empty_rule.get("stability_delta", -50))
	elif is_select_all_behavior:
		verdict_code = str(select_all_rule.get("verdict_code", "SELECT_ALL"))
		points = int(select_all_rule.get("points", 0))
		stability_delta = int(select_all_rule.get("stability_delta", -50))
	elif correct_selected == int(rule_2.get("need_correct", 3)) and wrong_selected <= int(rule_2.get("max_wrong", 0)):
		verdict_code = str(rule_2.get("verdict_code", "PERFECT"))
		points = int(rule_2.get("points", 2))
		stability_delta = int(rule_2.get("stability_delta", 0))
	elif correct_selected == int(rule_1a.get("need_correct", 2)) and wrong_selected <= int(rule_1a.get("max_wrong", 0)):
		verdict_code = str(rule_1a.get("verdict_code", "GOOD"))
		points = int(rule_1a.get("points", 1))
		stability_delta = int(rule_1a.get("stability_delta", 0))
	elif correct_selected == int(rule_1b.get("need_correct", 3)) and wrong_selected <= int(rule_1b.get("max_wrong", 1)):
		verdict_code = str(rule_1b.get("verdict_code", "NOISY"))
		points = int(rule_1b.get("points", 1))
		stability_delta = int(rule_1b.get("stability_delta", -10))
	else:
		verdict_code = str(default_rule.get("verdict_code", "FAIL"))
		points = int(default_rule.get("points", 0))
		stability_delta = int(default_rule.get("stability_delta", -50))

	var required_ids: Array[String] = []
	for option_id_v in correct_set.keys():
		required_ids.append(str(option_id_v))
	required_ids.sort()

	var missing_required: Array[String] = []
	for required_id in required_ids:
		if not selected_set.has(required_id):
			missing_required.append(required_id)

	var feedback: Dictionary = feedback_rules.get(verdict_code, {}) as Dictionary
	var feedback_headline: String = str(feedback.get("headline", verdict_code))
	var feedback_details: Array = (feedback.get("details", []) as Array).duplicate()

	return {
		"points": points,
		"max_points": max_points,
		"is_correct": verdict_code == "PERFECT",
		"is_fit": points > 0,
		"stability_delta": stability_delta,
		"verdict_code": verdict_code,
		"slots": slots.duplicate(),
		"selected_ids": selected_ids.duplicate(),
		"correct_selected": correct_selected,
		"wrong_selected": wrong_selected,
		"selected_count": selected_count,
		"unique_used_count": unique_used_count,
		"strategy_flags": strategy_flags.duplicate(),
		"missing_required": missing_required.duplicate(),
		"feedback_headline": feedback_headline,
		"feedback_details": feedback_details,
		"explain_selected": explain_selected
	}
</file>

<file path="scripts/case_07/da7_cases.gd">
extends Node

const CasesA = preload("res://scripts/case_07/da7_cases_a.gd")
const CasesB = preload("res://scripts/case_07/da7_cases_b.gd")
const CasesC = preload("res://scripts/case_07/da7_cases_c.gd")

static func get_cases(level: String) -> Array:
	match level.to_upper():
		"A":
			return CasesA.CASES_A.duplicate(true)
		"B":
			return CasesB.CASES_B.duplicate(true)
		"C":
			return CasesC.CASES_C.duplicate(true)
	return []
</file>

<file path="scripts/case_07/da7_data_archive_c.gd">
extends Control

const CasesHub = preload("res://scripts/case_07/da7_cases.gd")
const CasesModuleC = preload("res://scripts/case_07/da7_cases_c.gd")

const BREAKPOINT_PX := 900
const SESSION_CASE_COUNT := 6
const TYPEWRITER_INTERVAL_SEC := 0.05
const LAYOUT_MOBILE := "mobile"
const LAYOUT_DESKTOP := "desktop"

var session_cases: Array = []
var current_case_index: int = -1
var current_case: Dictionary = {}
var current_layout: String = LAYOUT_DESKTOP
var session_finished: bool = false

var case_started_ts: int = 0
var time_to_first_action_ms: int = -1
var is_trial_active: bool = false
var trial_locked: bool = false
var timed_out: bool = false

var limit_sec: int = 120
var time_left_sec: float = 120.0
var typewriter_active: bool = false
var typewriter_accum: float = 0.0

var selected_sequence_ids: Array[String] = []
var block_by_id: Dictionary = {}
var repo_button_by_id: Dictionary = {}
var allow_repeat_roles: Array = []

var reorder_count: int = 0
var undo_count: int = 0
var block_pick_count: int = 0
var clear_used: bool = false
var unique_blocks_used: Dictionary = {}

@onready var title_label: Label = $SafeArea/Margin/Root/Header/HeaderVBox/Title
@onready var btn_back: Button = $SafeArea/Margin/Root/BackRow/BtnBack
@onready var stability_label: Label = $SafeArea/Margin/Root/Header/HeaderVBox/TimerRow/StabilityLabel
@onready var timer_bar: ProgressBar = $SafeArea/Margin/Root/Header/HeaderVBox/TimerRow/TimerBar
@onready var timer_label: Label = $SafeArea/Margin/Root/Header/HeaderVBox/TimerRow/TimerLabel
@onready var prompt_label: RichTextLabel = $SafeArea/Margin/Root/Prompt
@onready var code_area: HFlowContainer = $SafeArea/Margin/Root/CodePanel/CodeArea
@onready var btn_undo: Button = $SafeArea/Margin/Root/ControlsRow/BtnUndo
@onready var btn_clear: Button = $SafeArea/Margin/Root/ControlsRow/BtnClear
@onready var btn_submit: Button = $SafeArea/Margin/Root/ControlsRow/BtnSubmit
@onready var btn_next: Button = $SafeArea/Margin/Root/ControlsRow/BtnNext
@onready var status_label: Label = $SafeArea/Margin/Root/StatusLabel
@onready var block_repository: GridContainer = $SafeArea/Margin/Root/RepoPanel/RepoScroll/BlockRepository
@onready var sfx_click: AudioStreamPlayer = $SFX/SfxClick
@onready var sfx_error: AudioStreamPlayer = $SFX/SfxError
@onready var sfx_relay: AudioStreamPlayer = $SFX/SfxRelay

func _ready() -> void:
	randomize()
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	btn_back.pressed.connect(_on_back_pressed)
	btn_undo.pressed.connect(_on_undo_pressed)
	btn_clear.pressed.connect(_on_clear_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_next.pressed.connect(_on_next_pressed)

	_init_session()
	call_deferred("_on_viewport_size_changed")
	_load_next_case()

func _process(delta: float) -> void:
	if typewriter_active:
		typewriter_accum += delta
		while typewriter_accum >= TYPEWRITER_INTERVAL_SEC and typewriter_active:
			typewriter_accum -= TYPEWRITER_INTERVAL_SEC
			if prompt_label.visible_characters < prompt_label.get_total_character_count():
				prompt_label.visible_characters += 1
			else:
				typewriter_active = false
				prompt_label.visible_characters = -1

	if not is_trial_active:
		return

	time_left_sec = max(0.0, time_left_sec - delta)
	_update_timer_ui()
	if time_left_sec <= 0.0 and not timed_out:
		timed_out = true
		var timeout_eval: Dictionary = _evaluate_sequence(selected_sequence_ids, true)
		_finish_trial(false, "TIMEOUT", timeout_eval, "TIMEOUT")

func _init_session() -> void:
	var all_cases: Array = CasesHub.get_cases("C")
	var valid_cases: Array = []
	for case_v in all_cases:
		if typeof(case_v) != TYPE_DICTIONARY:
			continue
		var case_data: Dictionary = case_v as Dictionary
		if CasesModuleC.validate_case_c(case_data):
			valid_cases.append(case_data)
	valid_cases.shuffle()
	session_cases = valid_cases.slice(0, min(SESSION_CASE_COUNT, valid_cases.size()))
	current_case_index = -1
	GlobalMetrics.stability = 100.0
	_update_stability_ui()

func _load_next_case() -> void:
	current_case_index += 1
	if current_case_index >= session_cases.size():
		_finish_session()
		return
	current_case = (session_cases[current_case_index] as Dictionary).duplicate(true)
	session_finished = false
	case_started_ts = Time.get_ticks_msec()
	time_to_first_action_ms = -1
	is_trial_active = true
	trial_locked = false
	timed_out = false
	reorder_count = 0
	undo_count = 0
	block_pick_count = 0
	clear_used = false
	unique_blocks_used.clear()
	selected_sequence_ids.clear()
	repo_button_by_id.clear()
	block_by_id.clear()
	_render_case()

func _render_case() -> void:
	var case_id: String = str(current_case.get("id", "DA7-C-00"))
	title_label.text = "ДЕЛО #7: МАСТЕР SQL [%s]" % case_id
	var timing_policy: Dictionary = current_case.get("timing_policy", {}) as Dictionary
	limit_sec = int(timing_policy.get("limit_sec", 120))
	time_left_sec = float(limit_sec)
	timer_bar.max_value = max(1.0, float(limit_sec))
	timer_bar.value = timer_bar.max_value
	prompt_label.bbcode_enabled = true
	prompt_label.text = "[b]%s[/b]" % str(current_case.get("prompt", "Соберите SQL-последовательность."))
	prompt_label.visible_characters = 0
	typewriter_active = true
	typewriter_accum = 0.0
	var rules: Dictionary = _active_rules()
	allow_repeat_roles = (rules.get("allow_repeat_roles", []) as Array).duplicate()
	_build_block_repository()
	_rebuild_code_area()
	_set_input_locked(false)
	btn_next.text = "ДАЛЕЕ"
	btn_next.visible = false
	status_label.text = "Соберите токены запроса и отправьте."
	_update_timer_ui()
	_update_stability_ui()

func _active_rules() -> Dictionary:
	var rules: Dictionary = current_case.get("rules", {}) as Dictionary
	if rules.is_empty():
		rules = current_case.get("constraints", {}) as Dictionary
	return rules

func _build_block_repository() -> void:
	for child in block_repository.get_children():
		child.queue_free()
	var blocks: Array = (current_case.get("available_blocks", []) as Array).duplicate()
	var anti_cheat: Dictionary = current_case.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_blocks", false)):
		blocks.shuffle()
	for block_v in blocks:
		if typeof(block_v) != TYPE_DICTIONARY:
			continue
		var block_data: Dictionary = block_v as Dictionary
		var block_id: String = str(block_data.get("id", ""))
		if block_id == "":
			continue
		block_by_id[block_id] = block_data
		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 56)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.text = str(block_data.get("text", block_id))
		btn.pressed.connect(_on_block_pressed.bind(block_id))
		block_repository.add_child(btn)
		repo_button_by_id[block_id] = btn

func _on_block_pressed(block_id: String) -> void:
	if trial_locked or not is_trial_active:
		return
	if not block_by_id.has(block_id):
		return
	_register_interaction()
	var role: String = str((block_by_id.get(block_id, {}) as Dictionary).get("role", ""))
	if _role_is_single_use(role) and _sequence_has_role(role):
		status_label.text = "Роль %s уже использована." % role
		return
	selected_sequence_ids.append(block_id)
	block_pick_count += 1
	unique_blocks_used[block_id] = true
	var btn: Button = repo_button_by_id.get(block_id, null) as Button
	if is_instance_valid(btn):
		btn.disabled = true
	if is_instance_valid(sfx_click):
		sfx_click.play()
	_rebuild_code_area()

func _rebuild_code_area() -> void:
	for child in code_area.get_children():
		child.queue_free()
	for idx in range(selected_sequence_ids.size()):
		var block_id: String = selected_sequence_ids[idx]
		var block_data: Dictionary = block_by_id.get(block_id, {}) as Dictionary
		var chip: PanelContainer = PanelContainer.new()
		chip.custom_minimum_size = Vector2(0, 54)
		var row: HBoxContainer = HBoxContainer.new()
		row.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		row.add_theme_constant_override("separation", 6)
		chip.add_child(row)

		var btn_left: Button = Button.new()
		btn_left.text = "<"
		btn_left.custom_minimum_size = Vector2(36, 42)
		btn_left.disabled = idx == 0
		btn_left.pressed.connect(_on_move_token.bind(idx, -1))
		row.add_child(btn_left)

		var lbl: Label = Label.new()
		lbl.text = str(block_data.get("text", block_id))
		lbl.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		row.add_child(lbl)

		var btn_right: Button = Button.new()
		btn_right.text = ">"
		btn_right.custom_minimum_size = Vector2(36, 42)
		btn_right.disabled = idx >= selected_sequence_ids.size() - 1
		btn_right.pressed.connect(_on_move_token.bind(idx, 1))
		row.add_child(btn_right)

		var btn_remove: Button = Button.new()
		btn_remove.text = "X"
		btn_remove.custom_minimum_size = Vector2(36, 42)
		btn_remove.pressed.connect(_on_remove_token.bind(idx))
		row.add_child(btn_remove)

		code_area.add_child(chip)
	_update_submit_state()

func _on_move_token(index: int, direction: int) -> void:
	if trial_locked or not is_trial_active:
		return
	var new_index: int = index + direction
	if new_index < 0 or new_index >= selected_sequence_ids.size():
		return
	_register_interaction()
	var token: String = selected_sequence_ids[index]
	selected_sequence_ids[index] = selected_sequence_ids[new_index]
	selected_sequence_ids[new_index] = token
	reorder_count += 1
	if is_instance_valid(sfx_click):
		sfx_click.play()
	_rebuild_code_area()

func _on_remove_token(index: int) -> void:
	if trial_locked or not is_trial_active:
		return
	if index < 0 or index >= selected_sequence_ids.size():
		return
	_register_interaction()
	var block_id: String = selected_sequence_ids[index]
	selected_sequence_ids.remove_at(index)
	var btn: Button = repo_button_by_id.get(block_id, null) as Button
	if is_instance_valid(btn):
		btn.disabled = false
	if is_instance_valid(sfx_click):
		sfx_click.play()
	_rebuild_code_area()

func _on_undo_pressed() -> void:
	if trial_locked or not is_trial_active:
		return
	if selected_sequence_ids.is_empty():
		return
	undo_count += 1
	_on_remove_token(selected_sequence_ids.size() - 1)

func _on_clear_pressed() -> void:
	if trial_locked or not is_trial_active:
		return
	if selected_sequence_ids.is_empty():
		return
	clear_used = true
	selected_sequence_ids.clear()
	for block_id in repo_button_by_id.keys():
		var btn: Button = repo_button_by_id.get(block_id, null) as Button
		if is_instance_valid(btn):
			btn.disabled = false
	_rebuild_code_area()
	status_label.text = "Последовательность очищена."

func _on_submit_pressed() -> void:
	if trial_locked or not is_trial_active:
		return
	_register_interaction()
	var eval_result: Dictionary = _evaluate_sequence(selected_sequence_ids)
	var is_correct: bool = bool(eval_result.get("is_correct", false))
	var f_reason: Variant = eval_result.get("f_reason", null)
	var end_state: String = "SUCCESS" if is_correct else "FAIL"
	_finish_trial(is_correct, f_reason, eval_result, end_state)

func _finish_trial(is_correct: bool, f_reason: Variant, eval_result: Dictionary, end_state: String) -> void:
	trial_locked = true
	is_trial_active = false
	typewriter_active = false
	prompt_label.visible_characters = -1
	_set_input_locked(true)
	if is_correct:
		status_label.text = "ДОСТУП РАЗРЕШЁН. Запрос корректен."
		if is_instance_valid(sfx_relay):
			sfx_relay.play()
	else:
		status_label.text = "ОШИБКА: %s" % str(f_reason)
		if is_instance_valid(sfx_error):
			sfx_error.play()
	_log_trial(is_correct, f_reason, eval_result, end_state)
	_update_stability_ui()
	btn_next.visible = true

func _evaluate_sequence(selected_ids: Array[String], force_timeout: bool = false) -> Dictionary:
	var rules: Dictionary = _active_rules()
	var required_roles: Array = rules.get("required_roles", []) as Array
	var forbidden_roles: Array = rules.get("forbidden_roles", []) as Array
	var forbidden_block_ids: Array = rules.get("forbidden_block_ids", []) as Array
	var skeleton_roles: Array = rules.get("skeleton_roles", []) as Array
	var order_rules: Array = rules.get("order_rules", []) as Array
	var min_tokens: int = int(rules.get("min_tokens", 1))
	var correct_ids: Array[String] = _to_string_array(current_case.get("correct_sequence_ids", []) as Array)

	var selected_roles: Array[String] = _roles_for_ids(selected_ids)
	var missing_roles: Array[String] = _missing_required_roles(selected_roles, required_roles)
	var diff: Dictionary = _build_diff(selected_ids, correct_ids)

	if force_timeout:
		return _build_eval("TIMEOUT", selected_roles, missing_roles, diff)
	if selected_ids == correct_ids:
		return _build_eval("SUCCESS", selected_roles, [], diff)
	if _has_forbidden_tokens(selected_ids, selected_roles, forbidden_block_ids, forbidden_roles):
		return _build_eval("SQL_SYNTAX_ERROR", selected_roles, missing_roles, diff)
	if selected_ids.size() < min_tokens or not missing_roles.is_empty():
		return _build_eval("INCOMPLETE_QUERY", selected_roles, missing_roles, diff)
	if _violates_order_rules(selected_roles, order_rules) or _violates_skeleton_order(selected_roles, skeleton_roles):
		return _build_eval("KEYWORD_ORDER", selected_roles, missing_roles, diff)
	if _same_multiset(selected_ids, correct_ids) and selected_ids != correct_ids:
		return _build_eval("KEYWORD_ORDER", selected_roles, missing_roles, diff)
	if (diff.get("extra_ids", []) as Array).size() > 0:
		return _build_eval("EXTRA_TOKENS", selected_roles, missing_roles, diff)
	return _build_eval("LOGIC_MISMATCH", selected_roles, missing_roles, diff)

func _build_eval(reason: String, selected_roles: Array[String], missing_roles: Array[String], diff: Dictionary) -> Dictionary:
	var is_correct: bool = reason == "SUCCESS"
	var final_reason: Variant = null if is_correct else reason
	return {
		"is_correct": is_correct,
		"f_reason": final_reason,
		"selected_roles": selected_roles,
		"missing_roles": missing_roles,
		"diff": diff
	}

func _to_string_array(values: Array) -> Array[String]:
	var out: Array[String] = []
	for value_v in values:
		out.append(str(value_v))
	return out

func _roles_for_ids(ids: Array[String]) -> Array[String]:
	var roles: Array[String] = []
	for id in ids:
		var block_data: Dictionary = block_by_id.get(id, {}) as Dictionary
		roles.append(str(block_data.get("role", "")))
	return roles

func _missing_required_roles(selected_roles: Array[String], required_roles: Array) -> Array[String]:
	var lookup: Dictionary = {}
	for role_v in selected_roles:
		lookup[str(role_v)] = true
	var missing: Array[String] = []
	for role_v in required_roles:
		var role: String = str(role_v)
		if not lookup.has(role):
			missing.append(role)
	return missing

func _has_forbidden_tokens(selected_ids: Array[String], selected_roles: Array[String], forbidden_block_ids: Array, forbidden_roles: Array) -> bool:
	var forbidden_block_lookup: Dictionary = {}
	for block_id_v in forbidden_block_ids:
		forbidden_block_lookup[str(block_id_v)] = true
	for selected_id in selected_ids:
		if forbidden_block_lookup.has(selected_id):
			return true

	var forbidden_role_lookup: Dictionary = {}
	for role_v in forbidden_roles:
		forbidden_role_lookup[str(role_v)] = true
	for selected_role in selected_roles:
		if forbidden_role_lookup.has(selected_role):
			return true
	return false

func _violates_order_rules(selected_roles: Array[String], order_rules: Array) -> bool:
	for rule_v in order_rules:
		if typeof(rule_v) != TYPE_DICTIONARY:
			continue
		var rule: Dictionary = rule_v as Dictionary
		var before_role: String = str(rule.get("before", ""))
		var after_role: String = str(rule.get("after", ""))
		if before_role == "" or after_role == "":
			continue
		var before_idx: int = _first_role_index(selected_roles, before_role)
		var after_idx: int = _first_role_index(selected_roles, after_role)
		if before_idx < 0 or after_idx < 0:
			continue
		if before_idx <= after_idx:
			return true
	return false

func _violates_skeleton_order(selected_roles: Array[String], skeleton_roles: Array) -> bool:
	var cursor: int = -1
	for role_v in skeleton_roles:
		var role: String = str(role_v)
		var idx: int = _first_role_index(selected_roles, role)
		if idx < 0:
			continue
		if idx < cursor:
			return true
		cursor = idx
	return false

func _first_role_index(selected_roles: Array[String], role: String) -> int:
	for idx in range(selected_roles.size()):
		if selected_roles[idx] == role:
			return idx
	return -1

func _build_diff(selected_ids: Array[String], correct_ids: Array[String]) -> Dictionary:
	var selected_counts: Dictionary = _counts(selected_ids)
	var correct_counts: Dictionary = _counts(correct_ids)

	var missing_ids: Array[String] = []
	for key_v in correct_counts.keys():
		var key: String = str(key_v)
		var need: int = int(correct_counts[key]) - int(selected_counts.get(key, 0))
		for _i in range(max(0, need)):
			missing_ids.append(key)

	var extra_ids: Array[String] = []
	for key_v in selected_counts.keys():
		var key: String = str(key_v)
		var extra: int = int(selected_counts[key]) - int(correct_counts.get(key, 0))
		for _j in range(max(0, extra)):
			extra_ids.append(key)

	var first_mismatch_index: int = -1
	var max_len: int = max(selected_ids.size(), correct_ids.size())
	for idx in range(max_len):
		var selected_id: String = selected_ids[idx] if idx < selected_ids.size() else "<none>"
		var correct_id: String = correct_ids[idx] if idx < correct_ids.size() else "<none>"
		if selected_id != correct_id:
			first_mismatch_index = idx
			break

	return {
		"missing_ids": missing_ids,
		"extra_ids": extra_ids,
		"first_mismatch_index": first_mismatch_index
	}

func _counts(ids: Array[String]) -> Dictionary:
	var out: Dictionary = {}
	for id in ids:
		out[id] = int(out.get(id, 0)) + 1
	return out

func _same_multiset(a: Array[String], b: Array[String]) -> bool:
	if a.size() != b.size():
		return false
	return _counts(a) == _counts(b)

func _role_is_single_use(role: String) -> bool:
	return not allow_repeat_roles.has(role)

func _sequence_has_role(role: String) -> bool:
	for block_id in selected_sequence_ids:
		var block_data: Dictionary = block_by_id.get(block_id, {}) as Dictionary
		if str(block_data.get("role", "")) == role:
			return true
	return false

func _register_interaction() -> void:
	if time_to_first_action_ms < 0:
		time_to_first_action_ms = Time.get_ticks_msec() - case_started_ts

func _log_trial(is_correct: bool, f_reason: Variant, eval_result: Dictionary, end_state: String) -> void:
	var now_ms: int = Time.get_ticks_msec()
	var elapsed_ms: int = now_ms - case_started_ts
	var effective_first_action_ms: int = max(0, time_to_first_action_ms)
	if time_to_first_action_ms < 0:
		effective_first_action_ms = elapsed_ms

	var timing_policy: Dictionary = current_case.get("timing_policy", {}) as Dictionary
	var rules: Dictionary = _active_rules()
	var diff: Dictionary = eval_result.get("diff", {}) as Dictionary
	var payload: Dictionary = {
		"quest_id": "DA7",
		"level": "C",
		"stage": "C",
		"case_id": str(current_case.get("id", "DA7-C-00")),
		"question_id": str(current_case.get("id", "DA7-C-00")),
		"interaction_type": str(current_case.get("interaction_type", "ASSEMBLE_BLOCKS")),
		"topic": str(current_case.get("topic", "DB_SQL")),
		"schema_version": str(current_case.get("schema_version", "DA7.C.v1")),
		"match_key": "DA7_C|%s" % str(current_case.get("id", "DA7-C-00")),
		"is_correct": is_correct,
		"f_reason": f_reason,
		"end_state": end_state,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"timing": {
			"policy_mode": str(timing_policy.get("mode", "EXAM")),
			"limit_sec": int(timing_policy.get("limit_sec", limit_sec)),
			"effective_elapsed_ms": elapsed_ms,
			"time_to_first_action_ms": effective_first_action_ms
		},
		"answer": {
			"user_sequence_ids": selected_sequence_ids.duplicate(),
			"selected_roles": eval_result.get("selected_roles", [])
		},
		"expected": {
			"correct_sequence_ids": _to_string_array(current_case.get("correct_sequence_ids", []) as Array),
			"required_roles": rules.get("required_roles", []),
			"skeleton_roles": rules.get("skeleton_roles", []),
			"order_rules": rules.get("order_rules", [])
		},
		"diff": {
			"missing_ids": diff.get("missing_ids", []),
			"extra_ids": diff.get("extra_ids", []),
			"first_mismatch_index": int(diff.get("first_mismatch_index", -1))
		},
		"telemetry": {
			"time_to_first_action_ms": effective_first_action_ms,
			"pick_count": block_pick_count,
			"block_pick_count": block_pick_count,
			"unique_blocks_used": unique_blocks_used.size(),
			"unique_blocks_used_ids": unique_blocks_used.keys(),
			"reorder_count": reorder_count,
			"undo_count": undo_count,
			"clear_used": clear_used
		},
		"flags": {
			"timed_out": timed_out
		},
		"ui": {
			"layout": current_layout,
			"vw": int(get_viewport_rect().size.x),
			"vh": int(get_viewport_rect().size.y)
		},
		"anti_cheat": current_case.get("anti_cheat", {}) as Dictionary
	}
	GlobalMetrics.register_trial(payload)

func _set_input_locked(locked: bool) -> void:
	btn_undo.disabled = locked
	btn_clear.disabled = locked
	btn_submit.disabled = locked or selected_sequence_ids.is_empty()
	for block_id_v in repo_button_by_id.keys():
		var block_id: String = str(block_id_v)
		var btn_v: Variant = repo_button_by_id[block_id]
		if not (btn_v is Button):
			continue
		var btn: Button = btn_v as Button
		if locked:
			btn.disabled = true
		else:
			btn.disabled = selected_sequence_ids.has(block_id)

func _update_submit_state() -> void:
	btn_submit.disabled = trial_locked or not is_trial_active or selected_sequence_ids.is_empty()

func _update_timer_ui() -> void:
	timer_bar.value = time_left_sec
	var minutes: int = int(time_left_sec) / 60
	var seconds: int = int(time_left_sec) % 60
	timer_label.text = "%02d:%02d" % [minutes, seconds]
	if time_left_sec <= 20.0:
		timer_label.modulate = Color(1.0, 0.4, 0.3, 1.0)
	else:
		timer_label.modulate = Color(1.0, 1.0, 1.0, 1.0)

func _on_next_pressed() -> void:
	if session_finished:
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
		return
	_load_next_case()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _finish_session() -> void:
	is_trial_active = false
	trial_locked = true
	session_finished = true
	typewriter_active = false
	title_label.text = "ДЕЛО #7: МАСТЕР SQL [ЗАВЕРШЕНО]"
	status_label.text = "Сессия завершена."
	btn_next.text = "ВЫХОД"
	btn_next.disabled = false
	btn_next.visible = true
	_set_input_locked(true)

func _on_stability_changed(_new_value: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	stability_label.text = "Стабильность: %d%%" % int(GlobalMetrics.stability)

func _on_viewport_size_changed() -> void:
	var size: Vector2 = get_viewport_rect().size
	if size.x < BREAKPOINT_PX:
		current_layout = LAYOUT_MOBILE
		block_repository.columns = 3
	else:
		current_layout = LAYOUT_DESKTOP
		block_repository.columns = 4
</file>

<file path="scripts/radio_intercept/RadioQuestA.gd">
extends Control

const N_VALUES = [32, 64, 100, 128, 200, 256]
const POINT_COUNT = 96
const MAX_NOISE = 24.0
const PHONE_LANDSCAPE_MAX_HEIGHT := 520.0

@onready var safe_area: MarginContainer = $SafeArea
@onready var root_vbox: VBoxContainer = $SafeArea/RootPanel/VBox
@onready var oscillo_box: PanelContainer = $SafeArea/RootPanel/VBox/OscilloBox
@onready var tuner_row: HBoxContainer = $SafeArea/RootPanel/VBox/TunerRow
@onready var buttons_row: HBoxContainer = $SafeArea/RootPanel/VBox/ButtonsRow
@onready var task_label: Label = $SafeArea/RootPanel/VBox/HeaderBar/TaskLabel
@onready var oscillo_area: Control = $SafeArea/RootPanel/VBox/OscilloBox/OscilloArea
@onready var osc_line: Line2D = $SafeArea/RootPanel/VBox/OscilloBox/OscilloArea/OscilloNode/OscLine
@onready var bits_label: Label = $SafeArea/RootPanel/VBox/TunerRow/BitsLabel
@onready var bits_slider: HSlider = $SafeArea/RootPanel/VBox/TunerRow/BitsSlider
@onready var hint_button: Button = $SafeArea/RootPanel/VBox/ButtonsRow/HintButton
@onready var confirm_button: Button = $SafeArea/RootPanel/VBox/ButtonsRow/ConfirmButton
@onready var hint_label: Label = $SafeArea/RootPanel/VBox/HintLabel

var current_n: int = 0
var i_min: int = 0
var used_hint: bool = false
var forced_sampling: bool = false
var started_at: int = 0
var first_action_at: int = 0
var _phase: float = 0.0
var _animate: bool = true

func _ready():
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)
	_on_viewport_size_changed()
	_start_new_task()
	call_deferred("_draw_signal")

func _process(delta: float) -> void:
	if _animate:
		_phase += delta * 2.0
		_draw_signal()

	if not forced_sampling and first_action_at == 0:
		var elapsed = Time.get_ticks_msec() - started_at
		if elapsed >= 8000:
			forced_sampling = true
			hint_label.text = "Режим принудительного замера активирован."

func _start_new_task():
	current_n = N_VALUES[randi() % N_VALUES.size()]
	i_min = int(ceil(log(float(current_n)) / log(2.0)))
	used_hint = false
	forced_sampling = false
	started_at = Time.get_ticks_msec()
	first_action_at = 0

	task_label.text = "Перехват... Мощность алфавита: %d символов. Настройте глубину кодирования." % current_n
	bits_slider.value = 1
	bits_label.text = "Биты: %d" % int(bits_slider.value)
	hint_label.text = ""

func _on_bits_slider_value_changed(value: float) -> void:
	if first_action_at == 0:
		first_action_at = Time.get_ticks_msec()
	bits_label.text = "Биты: %d" % int(value)
	_draw_signal()

func _on_hint_button_pressed() -> void:
	used_hint = true
	var hint = "Формула Хартли: N = 2^i\nМинимум i для %d: %d" % [current_n, i_min]
	hint_label.text = hint

func _on_confirm_button_pressed() -> void:
	var chosen_i = int(bits_slider.value)
	var capacity = int(pow(2.0, chosen_i))
	var correct = capacity >= current_n
	var overkill = correct and chosen_i > i_min
	var elapsed_ms = Time.get_ticks_msec() - started_at

	var payload = {
		"quest": "radio_intercept",
		"stage": "A",
		"N": current_n,
		"i_min": i_min,
		"chosen_i": chosen_i,
		"capacity": capacity,
		"is_correct": correct,
		"is_overkill": overkill,
		"used_hint": used_hint,
		"forced_sampling": forced_sampling,
		"elapsed_ms": elapsed_ms
	}
	GlobalMetrics.register_trial(payload)

	_start_new_task()
	_draw_signal()

func _on_slider_value_changed(value: float) -> void:
	_on_bits_slider_value_changed(value)

func _on_hint_pressed() -> void:
	_on_hint_button_pressed()

func _on_confirm_pressed() -> void:
	_on_confirm_button_pressed()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/LearnSelect.tscn")

func _on_viewport_size_changed() -> void:
	var size: Vector2 = get_viewport_rect().size
	var is_phone_landscape: bool = _is_phone_landscape(size)
	if is_phone_landscape:
		safe_area.add_theme_constant_override("margin_left", 10)
		safe_area.add_theme_constant_override("margin_right", 10)
		safe_area.add_theme_constant_override("margin_top", 8)
		safe_area.add_theme_constant_override("margin_bottom", 8)
		root_vbox.add_theme_constant_override("separation", 12)
		task_label.add_theme_font_size_override("font_size", 20)
		bits_label.add_theme_font_size_override("font_size", 24)
		oscillo_box.custom_minimum_size.y = clampf(size.y * 0.35, 150.0, 220.0)
		tuner_row.custom_minimum_size.y = 62.0
		bits_slider.custom_minimum_size.x = clampf(size.x * 0.30, 220.0, 340.0)
		buttons_row.add_theme_constant_override("separation", 16)
		hint_button.custom_minimum_size = Vector2(150, 52)
		confirm_button.custom_minimum_size = Vector2(170, 52)
		hint_label.custom_minimum_size.y = 40.0
	else:
		safe_area.add_theme_constant_override("margin_left", 16)
		safe_area.add_theme_constant_override("margin_right", 16)
		safe_area.add_theme_constant_override("margin_top", 12)
		safe_area.add_theme_constant_override("margin_bottom", 12)
		root_vbox.add_theme_constant_override("separation", 20)
		task_label.add_theme_font_size_override("font_size", 24)
		bits_label.add_theme_font_size_override("font_size", 32)
		oscillo_box.custom_minimum_size.y = 280.0
		tuner_row.custom_minimum_size.y = 80.0
		bits_slider.custom_minimum_size.x = 400.0
		buttons_row.add_theme_constant_override("separation", 40)
		hint_button.custom_minimum_size = Vector2(200, 60)
		confirm_button.custom_minimum_size = Vector2(200, 60)
		hint_label.custom_minimum_size.y = 50.0
	call_deferred("_draw_signal")

func _is_phone_landscape(size: Vector2) -> bool:
	return size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

func _draw_signal():
	if not is_instance_valid(oscillo_area):
		return
	var size = oscillo_area.size
	if size.x <= 1 or size.y <= 1:
		return

	var chosen_i = int(bits_slider.value)
	var capacity = int(pow(2.0, chosen_i))
	var correct = capacity >= current_n
	var overkill = correct and chosen_i > i_min

	var noise_strength = 0.0
	if not correct:
		noise_strength = MAX_NOISE
	elif overkill:
		noise_strength = MAX_NOISE * 0.12
	else:
		noise_strength = 0.0

	var points := PackedVector2Array()
	points.resize(POINT_COUNT)
	var mid_y = size.y * 0.5
	var amp = size.y * 0.35
	for i in range(POINT_COUNT):
		var t = float(i) / float(POINT_COUNT - 1)
		var x = t * size.x
		var y = mid_y + sin(t * TAU * 2.0 + _phase) * amp
		if noise_strength > 0.0:
			y += randf_range(-noise_strength, noise_strength)
		points[i] = Vector2(x, y)

	osc_line.points = points
</file>

<file path="scripts/ui/ConfigCard.gd">
extends PanelContainer

signal selected(option_id: String)

const COLOR_BASE := Color(1.0, 1.0, 1.0, 1.0)
const COLOR_SELECTED := Color(1.08, 1.08, 1.08, 1.0)
const COLOR_BUDGET_OK := Color(0.92, 0.92, 0.92, 1.0)
const COLOR_BUDGET_BAD := Color(0.93, 0.34, 0.38, 1.0)

var option_id: String = ""
var total_price: int = 0
var budget_limit: int = 0
var _locked: bool = false

@onready var title_label: Label = _resolve_label("VBox/Title")
@onready var price_label: Label = _resolve_label("VBox/Price")
@onready var parts_label: Label = _resolve_label("VBox/Parts", "VBox/Детали")
@onready var tags_label: Label = _resolve_label("VBox/Tags", "VBox/Теги")

func _resolve_label(primary_path: String, fallback_path: String = "") -> Label:
	var node: Node = get_node_or_null(primary_path)
	if node == null and fallback_path != "":
		node = get_node_or_null(fallback_path)
	return node as Label

func setup(option_data: Dictionary, budget: int) -> void:
	option_id = str(option_data.get("option_id", ""))
	total_price = int(option_data.get("total_price", 0))
	budget_limit = budget

	if is_instance_valid(title_label):
		title_label.text = str(option_data.get("title", option_id))
	if is_instance_valid(price_label):
		price_label.text = "Бюджет: %d$" % total_price
		price_label.modulate = COLOR_BUDGET_BAD if total_price > budget_limit else COLOR_BUDGET_OK
	
	var parts_lines: Array[String] = []
	var parts: Array = option_data.get("parts", []) as Array
	for part_v in parts:
		if typeof(part_v) != TYPE_DICTIONARY:
			continue
		var part: Dictionary = part_v as Dictionary
		parts_lines.append("%s: %s (%s$)" % [str(part.get("k", "?")), str(part.get("v", "?")), str(part.get("price", 0))])
	if is_instance_valid(parts_label):
		parts_label.text = "\n".join(parts_lines)

	var tags: Array = option_data.get("tags", []) as Array
	var tags_text: String = ""
	for tag_v in tags:
		if tags_text != "":
			tags_text += "  |  "
		tags_text += str(tag_v)
	if is_instance_valid(tags_label):
		tags_label.text = tags_text

func set_selected_state(is_selected: bool) -> void:
	modulate = COLOR_SELECTED if is_selected else COLOR_BASE

func set_locked(locked: bool) -> void:
	_locked = locked

func _gui_input(event: InputEvent) -> void:
	if _locked:
		return
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event as InputEventMouseButton
		if mouse_event.pressed and mouse_event.button_index == MOUSE_BUTTON_LEFT:
			accept_event()
			selected.emit(option_id)
	elif event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event as InputEventScreenTouch
		if touch_event.pressed:
			accept_event()
			selected.emit(option_id)
</file>

<file path="scripts/ui/FixMenuC.gd">
extends PopupPanel

signal option_selected(option_id: String)
signal apply_requested(option_id: String)
signal canceled

@onready var lbl_title: Label = $Root/LblTitle
@onready var lbl_original: Label = $Root/LblOriginal
@onready var btn_opt_a: Button = $Root/Options/BtnOptA
@onready var btn_opt_b: Button = $Root/Options/BtnOptB
@onready var btn_opt_c: Button = $Root/Options/BtnOptC
@onready var btn_apply: Button = $Root/Actions/BtnApply
@onready var btn_close: Button = $Root/Actions/BtnClose

var selected_option_id := ""
var options_by_id: Dictionary = {}

func _normalize_option_id(value: Variant) -> String:
	return str(value).strip_edges().to_upper()

func _short_line(line_text: String, max_chars: int = 48) -> String:
	var clean := line_text.strip_edges()
	if clean.length() <= max_chars:
		return clean
	return clean.substr(0, max_chars - 3) + "..."

func _ready() -> void:
	btn_opt_a.pressed.connect(_on_option_pressed.bind("A"))
	btn_opt_b.pressed.connect(_on_option_pressed.bind("B"))
	btn_opt_c.pressed.connect(_on_option_pressed.bind("C"))
	btn_apply.pressed.connect(_on_apply_pressed)
	btn_close.pressed.connect(_on_close_pressed)
	btn_apply.disabled = true

func setup(line_number_1_based: int, original_line: String, fix_options: Array, preselected_option_id: String = "") -> void:
	lbl_title.text = "ИСПРАВИТЬ СТРОКУ %02d" % line_number_1_based
	lbl_original.text = "оригинал: %s" % _short_line(original_line, 64)

	options_by_id.clear()
	var option_buttons := {
		"A": btn_opt_a,
		"B": btn_opt_b,
		"C": btn_opt_c
	}
	var ordered_ids := ["A", "B", "C"]

	for option_id in ordered_ids:
		var btn: Button = option_buttons[option_id]
		btn.text = "%s) --" % option_id
		btn.disabled = true

	for opt_var in fix_options:
		if typeof(opt_var) != TYPE_DICTIONARY:
			continue
		var opt: Dictionary = opt_var
		var option_id := _normalize_option_id(opt.get("option_id", ""))
		if not option_buttons.has(option_id):
			continue
		options_by_id[option_id] = opt
		var btn: Button = option_buttons[option_id]
		btn.disabled = false
		btn.text = "%s) %s  ->  s=%s" % [
			option_id,
			_short_line(str(opt.get("replace_line", ""))),
			str(opt.get("result_s", "?"))
		]

	var normalized_preselected := _normalize_option_id(preselected_option_id)
	selected_option_id = normalized_preselected if options_by_id.has(normalized_preselected) else ""
	_refresh_selection_visuals()

func _on_option_pressed(option_id: String) -> void:
	var normalized_option_id := _normalize_option_id(option_id)
	if not options_by_id.has(normalized_option_id):
		return
	selected_option_id = normalized_option_id
	_refresh_selection_visuals()
	option_selected.emit(normalized_option_id)

func _refresh_selection_visuals() -> void:
	var map := {
		"A": btn_opt_a,
		"B": btn_opt_b,
		"C": btn_opt_c
	}
	for option_id in map.keys():
		var btn: Button = map[option_id]
		if option_id == selected_option_id:
			btn.modulate = Color(0.95, 0.95, 0.93, 1.0)
		else:
			btn.modulate = Color(0.78, 0.78, 0.76, 1.0)
	btn_apply.disabled = selected_option_id == ""

func _on_apply_pressed() -> void:
	if selected_option_id == "":
		return
	apply_requested.emit(selected_option_id)
	hide()

func _on_close_pressed() -> void:
	canceled.emit()
	hide()
</file>

<file path="scenes/CityMapQuestA.tscn">
[gd_scene load_steps=4 format=3 uid="uid://citymapquest001"]

[ext_resource type="Script" path="res://scenes/CityMapQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_untformatic.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="CityMapQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.04, 0.05, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]
tint_color = Color(0.33, 0.55, 0.95, 1)
intensity = 0.1

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(56, 56)
layout_mode = 2
text = "<"

[node name="LabelCase" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО 6: КАРТА ГОРОДА"

[node name="LabelMode" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ: A"

[node name="Spacer" type="Control" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LabelState" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="LabelTimer" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ВРЕМЯ: 02:00"

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingMargin" type="MarginContainer" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BriefingVBox" type="VBoxContainer" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="BriefingTitle" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "АУДИТ МАРШРУТА"

[node name="BriefingText" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
autowrap_mode = 2
text = "Доберитесь до узла E по направленным дорогам. Введите итоговую сумму пути и отправьте. Проходит только минимальный маршрут."

[node name="ConstraintLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
visible = false
layout_mode = 2
autowrap_mode = 2
text = ""

[node name="ContentSplit" type="BoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="GraphPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 2.0

[node name="GraphMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/GraphPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="GraphContainer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin"]
custom_minimum_size = Vector2(420, 320)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EdgesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="NodesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="InfoPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
custom_minimum_size = Vector2(300, 0)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="InfoMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="InfoVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="PathDisplay" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
autowrap_mode = 2
text = "ПУТЬ: A"

[node name="SumLiveLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СУММА: 0"

[node name="InputLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ВВЕДИТЕ ИТОГОВУЮ СУММУ"

[node name="SumInput" type="LineEdit" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
placeholder_text = "0"
max_length = 6

[node name="ButtonsRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnSubmit" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ОТПРАВИТЬ"

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_vertical = 3
autowrap_mode = 2
text = ""

[node name="Footer" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
theme_override_constants/separation = 8

[node name="FooterLabel" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Ориентированный граф: нажимать можно только исходящие дороги из текущего узла."

[node name="FooterMeta" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
text = "КАРТА ГОРОДА / A"
</file>

<file path="scenes/CityMapQuestB.tscn">
[gd_scene load_steps=4 format=3 uid="uid://citymapquest002"]

[ext_resource type="Script" path="res://scenes/CityMapQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_untformatic.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="CityMapQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.04, 0.05, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]
tint_color = Color(0.33, 0.55, 0.95, 1)
intensity = 0.1

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(56, 56)
layout_mode = 2
text = "<"

[node name="LabelCase" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО 6: КАРТА ГОРОДА"

[node name="LabelMode" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ: B"

[node name="Spacer" type="Control" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LabelState" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="LabelTimer" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ВРЕМЯ: 02:00"

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingMargin" type="MarginContainer" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BriefingVBox" type="VBoxContainer" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="BriefingTitle" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ПРОВЕРКА ТРАНЗИТА"

[node name="BriefingText" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
autowrap_mode = 2
text = "Доберитесь до узла E, укажите точную сумму маршрута и докажите его оптимальность в ориентированном графе."

[node name="ConstraintLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
autowrap_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО ПОСЕТИТЬ C"

[node name="ContentSplit" type="BoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="GraphPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 2.0

[node name="GraphMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/GraphPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="GraphContainer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin"]
custom_minimum_size = Vector2(420, 320)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EdgesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="NodesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="InfoPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
custom_minimum_size = Vector2(320, 0)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="InfoMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="InfoVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ConstraintInfoLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО ПОСЕТИТЬ C"

[node name="PathDisplay" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
autowrap_mode = 2
text = "ПУТЬ: A"

[node name="SumLiveLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СУММА: 0"

[node name="BacktrackLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ОТКАТЫ: 0"

[node name="WarningLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
autowrap_mode = 2
text = "ПРЕДУПРЕЖДЕНИЯ: -"

[node name="InputLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ВВЕДИТЕ ИТОГОВУЮ СУММУ"

[node name="SumInput" type="LineEdit" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
placeholder_text = "0"
max_length = 6

[node name="ButtonsRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnSubmit" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ОТПРАВИТЬ"

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_vertical = 3
autowrap_mode = 2
text = ""

[node name="Footer" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
theme_override_constants/separation = 8

[node name="FooterLabel" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Двусторонние дороги активны только там, где в данных есть обратное ребро."

[node name="FooterMeta" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
text = "КАРТА ГОРОДА / B"
</file>

<file path="scenes/CityMapQuestC.tscn">
[gd_scene load_steps=4 format=3 uid="uid://citymapquest003"]

[ext_resource type="Script" path="res://scenes/CityMapQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_untformatic.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="CityMapQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.04, 0.05, 0.08, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]
tint_color = Color(0.33, 0.55, 0.95, 1)
intensity = 0.1

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 24.0
offset_top = 24.0
offset_right = -24.0
offset_bottom = -24.0
grow_horizontal = 2
grow_vertical = 2

[node name="MainVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="Header" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/MainVBox/Header"]
custom_minimum_size = Vector2(56, 56)
layout_mode = 2
text = "<"

[node name="LabelCase" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ДЕЛО 6: КАРТА ГОРОДА"

[node name="LabelMode" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ: C"

[node name="Spacer" type="Control" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LabelState" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="LabelTimer" type="Label" parent="SafeArea/MainVBox/Header"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ВРЕМЯ: 02:20"

[node name="BriefingCard" type="PanelContainer" parent="SafeArea/MainVBox"]
layout_mode = 2

[node name="BriefingMargin" type="MarginContainer" parent="SafeArea/MainVBox/BriefingCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="BriefingVBox" type="VBoxContainer" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="BriefingTitle" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ОКНО КОМЕНДАНТСКОГО ЧАСА"

[node name="BriefingText" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
autowrap_mode = 2
text = "Доберитесь до узла L в условиях динамических окон патруля. Рёбра ЗАКРЫТО заблокированы, рёбра ОПАСНО имеют повышенную стоимость."

[node name="ConstraintLabel" type="Label" parent="SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox"]
layout_mode = 2
autowrap_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО F | НЕ БОЛЕЕ ОДНОГО ИЗ (E,G) | ИЗБЕГАТЬ J"

[node name="ContentSplit" type="BoxContainer" parent="SafeArea/MainVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="GraphPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 2.0

[node name="GraphMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/GraphPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="GraphContainer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin"]
custom_minimum_size = Vector2(420, 320)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="EdgesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="NodesLayer" type="Control" parent="SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="InfoPanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit"]
custom_minimum_size = Vector2(340, 0)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.0

[node name="InfoMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="InfoVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="ConstraintInfoLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО F"

[node name="PathDisplay" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
autowrap_mode = 2
text = "ПУТЬ: A"

[node name="SimTimeLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СИМ: 0"

[node name="SumLiveLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "СУММА: 0"

[node name="WarningLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
autowrap_mode = 2
text = "ПРЕДУПРЕЖДЕНИЯ: -"

[node name="InputLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
text = "ВВЕДИТЕ ИТОГОВУЮ СУММУ"

[node name="SumInput" type="LineEdit" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
placeholder_text = "0"
max_length = 6

[node name="ButtonsRow" type="HBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnReset" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
text = "СБРОС"

[node name="BtnSubmit" type="Button" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow"]
custom_minimum_size = Vector2(0, 44)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ОТПРАВИТЬ"

[node name="SchedulePanel" type="PanelContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScheduleMargin" type="MarginContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="ScheduleVBox" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="ScheduleTitle" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox"]
layout_mode = 2
text = "РАСПИСАНИЕ"

[node name="ScheduleScroll" type="ScrollContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScheduleList" type="VBoxContainer" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox/ScheduleScroll"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="StatusLabel" type="Label" parent="SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
autowrap_mode = 2
text = ""

[node name="Footer" type="HBoxContainer" parent="SafeArea/MainVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
theme_override_constants/separation = 8

[node name="FooterLabel" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3
text = "РЕАЛЬНЫЙ таймер в заголовке. СИМ-время меняется только при успешном перемещении."

[node name="FooterMeta" type="Label" parent="SafeArea/MainVBox/Footer"]
layout_mode = 2
text = "КАРТА ГОРОДА / C"
</file>

<file path="scenes/DisarmQuestC.tscn">
[gd_scene load_steps=8 format=3 uid="uid://disarm_quest_c_new"]

[ext_resource type="Script" path="res://scripts/DisarmQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]
[ext_resource type="PackedScene" uid="uid://fix_menu_c_new" path="res://scenes/ui/FixMenuC.tscn" id="3_fix_menu"]
[ext_resource type="PackedScene" uid="uid://diagnostics_panel_c_new" path="res://scenes/ui/DiagnosticsPanelC.tscn" id="4_diag_panel"]
[ext_resource type="Shader" path="res://ui/shaders/noir_pencil_overlay.gdshader" id="5_shader"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_noir"]
shader = ExtResource("5_shader")
shader_parameter/intensity = 0.34
shader_parameter/grain_strength = 0.34
shader_parameter/hatch_strength = 0.28
shader_parameter/vignette_strength = 0.44
shader_parameter/fx_quality = 1
shader_parameter/pulse = 0.0
shader_parameter/jitter_strength = 0.0

[node name="DisarmQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.0509804, 0.0509804, 0.0509804, 1)

[node name="NoirOverlay" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
material = SubResource("ShaderMaterial_noir")
color = Color(1, 1, 1, 0)

[node name="MainLayout" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 12.0
offset_top = 12.0
offset_right = -12.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 10

[node name="HeaderRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="MainLayout/HeaderRow"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="MainLayout/HeaderRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 28
text = "Дело C: Разминирование"

[node name="LblSession" type="Label" parent="MainLayout/HeaderRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 22
text = "СЕССИЯ: C-01"
horizontal_alignment = 2

[node name="StatusMonitor" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
custom_minimum_size = Vector2(0, 140)

[node name="MonitorsRow" type="HBoxContainer" parent="MainLayout/StatusMonitor"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="ExpectedPanel" type="PanelContainer" parent="MainLayout/StatusMonitor/MonitorsRow"]
layout_mode = 2
size_flags_horizontal = 3
self_modulate = Color(0.92, 0.92, 0.9, 1)

[node name="ExpectedVBox" type="VBoxContainer" parent="MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblExpectedTitle" type="Label" parent="MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel/ExpectedVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ОЖИДАЕМОЕ"
horizontal_alignment = 1

[node name="LblExpectedValue" type="Label" parent="MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel/ExpectedVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 34
text = "s = 20"
horizontal_alignment = 1

[node name="ActualPanel" type="PanelContainer" parent="MainLayout/StatusMonitor/MonitorsRow"]
layout_mode = 2
size_flags_horizontal = 3
self_modulate = Color(1, 1, 1, 1)

[node name="ActualVBox" type="VBoxContainer" parent="MainLayout/StatusMonitor/MonitorsRow/ActualPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="LblActualTitle" type="Label" parent="MainLayout/StatusMonitor/MonitorsRow/ActualPanel/ActualVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ФАКТ"
horizontal_alignment = 1

[node name="LblActualValue" type="Label" parent="MainLayout/StatusMonitor/MonitorsRow/ActualPanel/ActualVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 34
text = "s = 15"
horizontal_alignment = 1

[node name="BodyRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="CodeFrame" type="PanelContainer" parent="MainLayout/BodyRow"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CodeRoot" type="Control" parent="MainLayout/BodyRow/CodeFrame"]
layout_mode = 2
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="CodeView" type="CodeEdit" parent="MainLayout/BodyRow/CodeFrame/CodeRoot"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 8.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = -8.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 24

[node name="LineHighlight" type="ColorRect" parent="MainLayout/BodyRow/CodeFrame/CodeRoot"]
visible = false
layout_mode = 1
position = Vector2(8, 8)
size = Vector2(100, 32)
mouse_filter = 2
color = Color(0.93, 0.93, 0.91, 0.14)

[node name="SideInfo" type="VBoxContainer" parent="MainLayout/BodyRow"]
custom_minimum_size = Vector2(300, 0)
layout_mode = 2
theme_override_constants/separation = 12

[node name="LblHint" type="Label" parent="MainLayout/BodyRow/SideInfo"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/font_size = 22
text = "Найдите строку с ошибкой и выберите исправление."
autowrap_mode = 2

[node name="MisclickCounter" type="Label" parent="MainLayout/BodyRow/SideInfo"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ПРОМАХИ: 0"

[node name="ActionsRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="BtnAnalyze" type="Button" parent="MainLayout/ActionsRow"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="BtnVerify" type="Button" parent="MainLayout/ActionsRow"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРОВЕРИТЬ"

[node name="BtnNext" type="Button" parent="MainLayout/ActionsRow"]
visible = false
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="DiagnosticsBlocker" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 0
color = Color(0, 0, 0, 0.4)

[node name="FixMenuC" parent="." instance=ExtResource("3_fix_menu")]
visible = false

[node name="DiagnosticsPanelC" parent="." instance=ExtResource("4_diag_panel")]
visible = false
</file>

<file path="scenes/LearnSelect.tscn">
[gd_scene load_steps=4 format=3 uid="uid://d2r81qjl2u0td"]

[ext_resource type="Script" path="res://scenes/LearnSelect.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="3_noir"]

[node name="LearnSelect" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.04, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("3_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 24
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 24
theme_override_constants/margin_bottom = 16

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 20
alignment = 1

[node name="Title" type="Label" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_font_sizes/font_size = 58
text = "ОБУЧЕНИЕ"
horizontal_alignment = 1

[node name="QuestGrid" type="GridContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/h_separation = 14
theme_override_constants/v_separation = 14
columns = 3

[node name="CluesButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Цифровая реанимация"

[node name="RadioButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Радиоперехват A"

[node name="DecryptorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Дешифрование A"

[node name="LieDetectorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Детектор лжи A"

[node name="SuspectScriptButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Скрипт подозреваемого"

[node name="CityMapButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Карта города"

[node name="DataArchiveButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Архив данных"

[node name="FinalReportButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Финальный отчет"

[node name="NetworkTraceButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Сетевой след"

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Выберите учебный модуль"
horizontal_alignment = 1
vertical_alignment = 1
</file>

<file path="scenes/LogicQuestA.tscn">
[gd_scene load_steps=6 format=3 uid="uid://bj856hihjj58i"]

[ext_resource type="Script" path="res://scenes/LogicQuestA.gd" id="1_script"]

[sub_resource type="SystemFont" id="SystemFont_1"]
font_names = PackedStringArray("Courier New", "Consolas", "Liberation Mono")

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_header"]
bg_color = Color(0.1, 0.1, 0.1, 1)
border_width_bottom = 2
border_color = Color(0.3, 0.3, 0.3, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_controls"]
bg_color = Color(0.1, 0.1, 0.1, 1)
border_width_top = 2
border_color = Color(0.3, 0.3, 0.3, 1)

[sub_resource type="Environment" id="Environment_glow"]
background_mode = 3
glow_enabled = true
glow_intensity = 0.8
glow_strength = 1.0
glow_blend_mode = 1

[node name="LogicQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="MainLayout" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2

[node name="HeaderPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_header")

[node name="HeaderMargin" type="MarginContainer" parent="MainLayout/HeaderPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 5

[node name="HeaderHBox" type="HBoxContainer" parent="MainLayout/HeaderPanel/HeaderMargin"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
text = "<"

[node name="StabilityLabel" type="Label" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0.2, 1, 0.2, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 20
text = "СТАБИЛЬНОСТЬ: 100%"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StatsLabel" type="Label" parent="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.6, 0.6, 0.6, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 16
text = "ДЕЛО: 01"

[node name="StoryPanel" type="PanelContainer" parent="MainLayout"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_controls")

[node name="StoryMargin" type="MarginContainer" parent="MainLayout/StoryPanel"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 10

[node name="StoryText" type="RichTextLabel" parent="MainLayout/StoryPanel/StoryMargin"]
layout_mode = 2
theme_override_fonts/normal_font = SubResource("SystemFont_1")
theme_override_font_sizes/normal_font_size = 18
bbcode_enabled = true
text = "Показания свидетеля..."
fit_content = true

[node name="BoardContainer" type="Control" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="WiresLayer" type="Node2D" parent="MainLayout/BoardContainer"]

[node name="InputA_Wire" type="Line2D" parent="MainLayout/BoardContainer/WiresLayer"]
points = PackedVector2Array(60, 80, 200, 80, 200, 130, 280, 130)
width = 4.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="InputB_Wire" type="Line2D" parent="MainLayout/BoardContainer/WiresLayer"]
points = PackedVector2Array(60, 240, 200, 240, 200, 190, 280, 190)
width = 4.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="Output_Wire" type="Line2D" parent="MainLayout/BoardContainer/WiresLayer"]
points = PackedVector2Array(500, 160, 680, 160)
width = 4.0
default_color = Color(0.2, 0.2, 0.2, 1)

[node name="InputA_Btn" type="Button" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 20.0
offset_top = 50.0
offset_right = 120.0
offset_bottom = 110.0
theme_override_fonts/font = SubResource("SystemFont_1")
toggle_mode = true
text = "A: 0"

[node name="InputB_Btn" type="Button" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 20.0
offset_top = 210.0
offset_right = 120.0
offset_bottom = 270.0
theme_override_fonts/font = SubResource("SystemFont_1")
toggle_mode = true
text = "B: 0"

[node name="GateSelector" type="OptionButton" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 280.0
offset_top = 130.0
offset_right = 500.0
offset_bottom = 190.0
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 24
alignment = 1

[node name="Lamp" type="ColorRect" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 680.0
offset_top = 120.0
offset_right = 760.0
offset_bottom = 200.0
color = Color(0.1, 0.1, 0.1, 1)

[node name="LampLabel" type="Label" parent="MainLayout/BoardContainer/Lamp"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 24
text = "F"
horizontal_alignment = 1
vertical_alignment = 1

[node name="OutputLabel" type="Label" parent="MainLayout/BoardContainer"]
layout_mode = 0
offset_left = 660.0
offset_top = 210.0
offset_right = 780.0
offset_bottom = 240.0
theme_override_colors/font_color = Color(0.6, 0.6, 0.6, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
text = "ВЫХОД"
horizontal_alignment = 1

[node name="JournalLabel" type="Label" parent="MainLayout/BoardContainer"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.05
anchor_top = 0.8
anchor_right = 0.95
anchor_bottom = 0.98
theme_override_colors/font_color = Color(0.5, 0.5, 0.5, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 12
text = "ЛОГ: ..."
autowrap_mode = 2

[node name="ControlsPanel" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_controls")

[node name="ControlsMargin" type="MarginContainer" parent="MainLayout/ControlsPanel"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="HBox" type="HBoxContainer" parent="MainLayout/ControlsPanel/ControlsMargin"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 1

[node name="BtnHint" type="Button" parent="MainLayout/ControlsPanel/ControlsMargin/HBox"]
custom_minimum_size = Vector2(100, 60)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
text = "ПОДСКАЗКА"

[node name="BtnVerdict" type="Button" parent="MainLayout/ControlsPanel/ControlsMargin/HBox"]
custom_minimum_size = Vector2(160, 60)
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 20
text = "ВЕРДИКТ"

[node name="BtnNext" type="Button" parent="MainLayout/ControlsPanel/ControlsMargin/HBox"]
visible = false
custom_minimum_size = Vector2(160, 60)
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0, 1, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 20
text = "ДАЛЕЕ >"

[node name="FeedbackLabel" type="Label" parent="MainLayout/ControlsPanel/ControlsMargin/HBox"]
visible = false
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.3, 0.3, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
text = "Доступ запрещён"

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_glow")

[node name="ClickPlayer" type="AudioStreamPlayer" parent="."]

[node name="GameOverPanel" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Overlay" type="ColorRect" parent="GameOverPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.1, 0, 0, 0.9)

[node name="CenterContainer" type="CenterContainer" parent="GameOverPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBox" type="VBoxContainer" parent="GameOverPanel/CenterContainer"]
custom_minimum_size = Vector2(600, 0)
layout_mode = 2
theme_override_constants/separation = 20

[node name="Title" type="Label" parent="GameOverPanel/CenterContainer/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0, 0, 1)
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 32
text = "КРИТИЧЕСКИЙ СБОЙ"
horizontal_alignment = 1

[node name="RestartButton" type="Button" parent="GameOverPanel/CenterContainer/VBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_fonts/font = SubResource("SystemFont_1")
theme_override_font_sizes/font_size = 24
text = "ПЕРЕЗАПУСК СИСТЕМЫ"

[connection signal="pressed" from="MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/BtnBack" to="." method="_on_back_button_pressed"]
[connection signal="toggled" from="MainLayout/BoardContainer/InputA_Btn" to="." method="_on_input_a_toggled"]
[connection signal="toggled" from="MainLayout/BoardContainer/InputB_Btn" to="." method="_on_input_b_toggled"]
[connection signal="item_selected" from="MainLayout/BoardContainer/GateSelector" to="." method="_on_gate_selected"]
[connection signal="pressed" from="MainLayout/ControlsPanel/ControlsMargin/HBox/BtnHint" to="." method="_on_hint_pressed"]
[connection signal="pressed" from="MainLayout/ControlsPanel/ControlsMargin/HBox/BtnVerdict" to="." method="_on_verdict_pressed"]
[connection signal="pressed" from="MainLayout/ControlsPanel/ControlsMargin/HBox/BtnNext" to="." method="_on_next_button_pressed"]
[connection signal="pressed" from="GameOverPanel/CenterContainer/VBox/RestartButton" to="." method="_on_restart_pressed"]
</file>

<file path="scenes/LogicQuestB.gd">
extends Control

# --- CONSTANTS ---
const LAYOUT_CASCADE_TOP = "CASCADE_TOP" # (A op B) op C
const LAYOUT_CASCADE_BOTTOM = "CASCADE_BOTTOM" # A op (B op C)

const GATE_NONE = "NONE"
const GATE_AND = "AND"
const GATE_OR = "OR"
const GATE_NOT = "NOT"
const GATE_XOR = "XOR"
const GATE_NAND = "NAND"
const GATE_NOR = "NOR"

# Cases Data (Level B)
const CASES = [
	{
		"id": "B_01",
		"layout": LAYOUT_CASCADE_TOP,
		"story": "Система (1) активна, если [b]ДАТЧИК_1[/b] ИЛИ [b]ДАТЧИК_2[/b] сработали, и при этом [b]КЛЮЧ[/b] повернут.",
		"labels": ["ДАТЧИК 1", "ДАТЧИК 2", "КЛЮЧ"],
		"correct_gates": [GATE_OR, GATE_AND], # Slot 1 (A/B), Slot 2 (Res/C)
		"hint": "Сначала объедини датчики (ИЛИ), потом проверь ключ (И)."
	},
	{
		"id": "B_02",
		"layout": LAYOUT_CASCADE_BOTTOM,
		"story": "Авария (1) происходит, если [b]ДАВЛЕНИЕ[/b] высоко, И ([b]ТЕМПЕРАТУРА[/b] критична ИЛИ [b]НАСОС[/b] отказал).",
		"labels": ["ДАВЛЕНИЕ", "ТЕМПЕРАТУРА", "НАСОС"],
		"correct_gates": [GATE_OR, GATE_AND], # Slot 1 (B/C), Slot 2 (A/Res) -> Note: S1 is usually the 'inner' one in bottom cascade visually?
		# Let's define: In Cascade Bottom, Slot 1 is B-C, Slot 2 is A-(S1).
		"hint": "Скобки важны. Сначала реши проблему температуры и насоса."
	},
	{
		"id": "B_03",
		"layout": LAYOUT_CASCADE_TOP,
		"story": "Доступ (1): Достаточно одного из ключей ([b]КЛЮЧ_А[/b] или [b]КЛЮЧ_B[/b]), но [b]РУБИЛЬНИК[/b] должен быть включен.",
		"labels": ["КЛЮЧ А", "КЛЮЧ B", "РУБИЛЬНИК"],
		"correct_gates": [GATE_OR, GATE_AND],
		"hint": "Ключи через ИЛИ, результат с рубильником через И."
	},
	{
		"id": "B_04",
		"layout": LAYOUT_CASCADE_BOTTOM,
		"story": "Тревога (1): [b]ДАТЧИК_1[/b] активен, либо ([b]ДАТЧИК_2[/b] и [b]ДАТЧИК_3[/b] активны одновременно).",
		"labels": ["ДАТЧИК 1", "ДАТЧИК 2", "ДАТЧИК 3"],
		"correct_gates": [GATE_AND, GATE_OR], # S1(B,C)=AND, S2(A, S1)=OR
		"hint": "Внутреннее условие: 2 и 3. Внешнее: 1 или результат."
	},
	{
		"id": "B_05",
		"layout": LAYOUT_CASCADE_TOP,
		"story": "Секрет (1): [b]РЫЧАГ_1[/b] не равен [b]РЫЧАГУ_2[/b], и [b]РЫЧАГ_3[/b] тоже должен быть включен.",
		"labels": ["РЫЧАГ 1", "РЫЧАГ 2", "РЫЧАГ 3"],
		"correct_gates": [GATE_XOR, GATE_AND],
		"hint": "Не равны = XOR."
	}
]

# --- UI NODES ---
@onready var story_text = $MainLayout/StoryPanel/StoryMargin/StoryText
@onready var stats_label = $MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/StatsLabel
@onready var stability_label = $MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/StabilityLabel

@onready var input_a_btn = $MainLayout/BoardContainer/Switches/InputA_Btn
@onready var input_b_btn = $MainLayout/BoardContainer/Switches/InputB_Btn
@onready var input_c_btn = $MainLayout/BoardContainer/Switches/InputC_Btn

@onready var layout_top = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Top
@onready var layout_bottom = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom

@onready var slot1_btn = $MainLayout/BoardContainer/Slots/Slot1
@onready var slot1_lbl = $MainLayout/BoardContainer/Slots/Slot1/Symbol
@onready var slot2_btn = $MainLayout/BoardContainer/Slots/Slot2
@onready var slot2_lbl = $MainLayout/BoardContainer/Slots/Slot2/Symbol

@onready var inter_lamp = $MainLayout/BoardContainer/InterLamp
@onready var out_lamp = $MainLayout/BoardContainer/OutputLamp
@onready var out_lamp_lbl = $MainLayout/BoardContainer/OutputLamp/Label

@onready var feedback_lbl = $MainLayout/ControlsPanel/Margin/HBox/FeedbackLabel
@onready var btn_verdict = $MainLayout/ControlsPanel/Margin/HBox/BtnVerdict
@onready var btn_next = $MainLayout/ControlsPanel/Margin/HBox/BtnNext
@onready var btn_hint = $MainLayout/ControlsPanel/Margin/HBox/BtnHint

@onready var game_over_panel = $GameOverPanel
@onready var click_player = $ClickPlayer

# Wires Top
@onready var t_wire_a = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Top/Wire_A_S1
@onready var t_wire_b = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Top/Wire_B_S1
@onready var t_wire_s1 = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Top/Wire_S1_S2
@onready var t_wire_c = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Top/Wire_C_S2
@onready var t_wire_out = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Top/Wire_S2_Out

# Wires Bottom
@onready var b_wire_a = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom/Wire_A_S2
@onready var b_wire_b = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom/Wire_B_S1
@onready var b_wire_c = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom/Wire_C_S1
@onready var b_wire_s1 = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom/Wire_S1_S2
@onready var b_wire_out = $MainLayout/BoardContainer/Layouts/Layout_Cascade_Bottom/Wire_S2_Out

# Gate Buttons
@onready var gates_grid = $MainLayout/SelectorPanel/Margin/GateGrid

# --- STATE ---
var current_case_idx = 0
var current_case = {}
var inputs = [false, false, false] # A, B, C
var placed_gates = [GATE_NONE, GATE_NONE] # Slot 1, Slot 2
var selected_slot_idx = -1
var hints_used = 0
var case_attempts = 0
var case_started_ms: int = 0
var first_action_ms: int = -1
var verdict_count: int = 0

const COLOR_ON = Color(1.2, 1.2, 1.2, 1)
const COLOR_OFF = Color(0.15, 0.15, 0.15, 1)
const COLOR_LAMP_ON = Color(1.5, 1.5, 1.2, 1)
const COLOR_LAMP_OFF = Color(0.1, 0.1, 0.1, 1)

func _ready():
	GlobalMetrics.stability_changed.connect(_update_stability)
	_update_stability(GlobalMetrics.stability, 0)
	load_case(0)

func load_case(idx):
	if idx >= CASES.size():
		idx = 0
	current_case_idx = idx
	current_case = CASES[idx]

	inputs = [false, false, false]
	placed_gates = [GATE_NONE, GATE_NONE]
	selected_slot_idx = -1
	hints_used = 0
	case_attempts = 0
	case_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	verdict_count = 0

	# Update UI
	story_text.text = current_case.story
	stats_label.text = "ДЕЛО: %02d" % (idx + 1)

	var labels = current_case.labels
	input_a_btn.text = "%s: 0" % labels[0]
	input_b_btn.text = "%s: 0" % labels[1]
	input_c_btn.text = "%s: 0" % labels[2]
	input_a_btn.button_pressed = false
	input_b_btn.button_pressed = false
	input_c_btn.button_pressed = false

	# Reset Slots
	_update_slot_visuals(0)
	_update_slot_visuals(1)

	# Select Layout
	layout_top.visible = (current_case.layout == LAYOUT_CASCADE_TOP)
	layout_bottom.visible = (current_case.layout == LAYOUT_CASCADE_BOTTOM)

	# Reset State
	btn_verdict.visible = true
	btn_next.visible = false
	feedback_lbl.text = ""

	# Reset Controls
	_set_selector_enabled(false)

	_update_circuit()

func _update_slot_visuals(idx):
	var gate = placed_gates[idx]
	var btn = slot1_btn if idx == 0 else slot2_btn
	var lbl = slot1_lbl if idx == 0 else slot2_lbl

	if gate == GATE_NONE:
		lbl.text = "?"
		lbl.modulate = Color(0.5, 0.5, 0.5)
	else:
		lbl.text = _get_gate_symbol(gate)
		lbl.modulate = Color(1, 1, 1)

func _get_gate_symbol(type):
	match type:
		GATE_AND: return "&"
		GATE_OR: return "1"
		GATE_NOT: return "¬"
		GATE_XOR: return "⊕"
		GATE_NAND: return "|"
		GATE_NOR: return "↓"
	return "?"

func _on_input_a_toggled(pressed):
	_mark_first_action()
	inputs[0] = pressed
	input_a_btn.text = "%s: %s" % [current_case.labels[0], "1" if pressed else "0"]
	_update_circuit()

func _on_input_b_toggled(pressed):
	_mark_first_action()
	inputs[1] = pressed
	input_b_btn.text = "%s: %s" % [current_case.labels[1], "1" if pressed else "0"]
	_update_circuit()

func _on_input_c_toggled(pressed):
	_mark_first_action()
	inputs[2] = pressed
	input_c_btn.text = "%s: %s" % [current_case.labels[2], "1" if pressed else "0"]
	_update_circuit()

func _on_slot1_pressed():
	_select_slot(0)

func _on_slot2_pressed():
	_select_slot(1)

func _select_slot(idx):
	_mark_first_action()
	selected_slot_idx = idx
	_play_click()

	# Highlight UI
	var style_normal = load("res://scenes/LogicQuestB.tscn::StyleBoxFlat_slot_normal") # Fallback/Hack if not local
	# Actually we rely on theme override in scene, simpler to just set focus or border
	# For now, just enable selector
	_set_selector_enabled(true)
	feedback_lbl.text = "ВЫБЕРИТЕ КОМПОНЕНТ ДЛЯ СЛОТА %d" % (idx + 1)
	feedback_lbl.add_theme_color_override("font_color", Color(0.5, 0.8, 1))
	feedback_lbl.visible = true

func _set_selector_enabled(enabled):
	for child in gates_grid.get_children():
		child.disabled = !enabled

func _on_gate_btn_pressed(type):
	if selected_slot_idx == -1: return
	_mark_first_action()

	placed_gates[selected_slot_idx] = type
	_update_slot_visuals(selected_slot_idx)
	_play_click()

	selected_slot_idx = -1
	_set_selector_enabled(false)
	feedback_lbl.text = ""
	_update_circuit()

func _update_circuit():
	var res = _calculate_circuit()
	var inter_val = res.inter
	var final_val = res.final

	# Visuals
	if current_case.layout == LAYOUT_CASCADE_TOP:
		t_wire_a.default_color = COLOR_ON if inputs[0] else COLOR_OFF
		t_wire_b.default_color = COLOR_ON if inputs[1] else COLOR_OFF
		t_wire_c.default_color = COLOR_ON if inputs[2] else COLOR_OFF

		# S1 is first stage
		t_wire_s1.default_color = COLOR_ON if inter_val else COLOR_OFF
		t_wire_out.default_color = COLOR_ON if final_val else COLOR_OFF

	elif current_case.layout == LAYOUT_CASCADE_BOTTOM:
		b_wire_a.default_color = COLOR_ON if inputs[0] else COLOR_OFF
		b_wire_b.default_color = COLOR_ON if inputs[1] else COLOR_OFF
		b_wire_c.default_color = COLOR_ON if inputs[2] else COLOR_OFF

		# S1 is inner stage (B, C) usually
		b_wire_s1.default_color = COLOR_ON if inter_val else COLOR_OFF
		b_wire_out.default_color = COLOR_ON if final_val else COLOR_OFF

	# Lamps
	inter_lamp.color = COLOR_LAMP_ON if inter_val else COLOR_LAMP_OFF

	if final_val:
		out_lamp.color = COLOR_LAMP_ON
		out_lamp_lbl.modulate = Color(0, 0, 0)
	else:
		out_lamp.color = COLOR_LAMP_OFF
		out_lamp_lbl.modulate = Color(0.3, 0.3, 0.3)

func _calculate_circuit():
	var g1 = placed_gates[0]
	var g2 = placed_gates[1]

	var inter = false
	var final = false

	if current_case.layout == LAYOUT_CASCADE_TOP:
		# Slot 1: A, B -> Inter
		# Slot 2: Inter, C -> Final
		if g1 != GATE_NONE:
			inter = _gate_op(inputs[0], inputs[1], g1)

		if g2 != GATE_NONE:
			final = _gate_op(inter, inputs[2], g2)

	elif current_case.layout == LAYOUT_CASCADE_BOTTOM:
		# Slot 1: B, C -> Inter
		# Slot 2: A, Inter -> Final
		if g1 != GATE_NONE:
			inter = _gate_op(inputs[1], inputs[2], g1)

		if g2 != GATE_NONE:
			final = _gate_op(inputs[0], inter, g2)

	return {"inter": inter, "final": final}

func _gate_op(a, b, type):
	match type:
		GATE_AND: return a and b
		GATE_OR: return a or b
		GATE_NOT: return not a # Usually single input, assume 'a' is primary
		GATE_XOR: return a != b
		GATE_NAND: return not (a and b)
		GATE_NOR: return not (a or b)
	return false

func _on_verdict_pressed():
	_mark_first_action()
	verdict_count += 1
	# Check completeness
	if placed_gates[0] == GATE_NONE or placed_gates[1] == GATE_NONE:
		_show_feedback("СХЕМА НЕ СОБРАНА", Color(1, 0.5, 0))
		_register_trial("INCOMPLETE", false)
		return

	var correct = current_case.correct_gates
	if placed_gates[0] == correct[0] and placed_gates[1] == correct[1]:
		_show_feedback("СИСТЕМА СТАБИЛЬНА. ДОСТУП РАЗРЕШЁН.", Color(0, 1, 0))
		btn_verdict.visible = false
		btn_next.visible = true
		_set_selector_enabled(false)
		_register_trial("SUCCESS", true)
	else:
		case_attempts += 1
		var pen = 15.0 + (case_attempts * 5.0)
		_apply_penalty(pen)
		_show_feedback("ЛОГИЧЕСКАЯ ОШИБКА. СТАБИЛЬНОСТЬ -%d" % int(pen), Color(1, 0, 0))
		_register_trial("WRONG_GATE", false)

func _show_feedback(msg, col):
	feedback_lbl.text = msg
	feedback_lbl.add_theme_color_override("font_color", col)
	feedback_lbl.visible = true

func _apply_penalty(amt):
	GlobalMetrics.stability = max(0.0, GlobalMetrics.stability - amt)
	GlobalMetrics.stability_changed.emit(GlobalMetrics.stability, -amt)
	if GlobalMetrics.stability <= 0:
		_game_over()

func _game_over():
	game_over_panel.visible = true

func _update_stability(val, _change):
	stability_label.text = "СТАБИЛЬНОСТЬ: %d%%" % int(val)
	if val < 30: stability_label.add_theme_color_override("font_color", Color(1, 0, 0))
	elif val < 70: stability_label.add_theme_color_override("font_color", Color(1, 1, 0))
	else: stability_label.add_theme_color_override("font_color", Color(0, 1, 0))

func _on_next_button_pressed():
	load_case(current_case_idx + 1)

func _on_back_button_pressed():
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - case_started_ms

func _register_trial(verdict_code: String, is_correct: bool) -> void:
	var case_id := str(current_case.get("id", "B_00"))
	var variant_source := "%s|%s" % [str(current_case.get("layout", "")), ",".join(placed_gates)]
	var payload := TrialV2.build("LOGIC_QUEST", "B", case_id, "DRAG_DROP", str(hash(variant_source)))
	var elapsed_ms: int = maxi(0, Time.get_ticks_msec() - case_started_ms)
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_correct
	payload["is_fit"] = is_correct
	payload["stability_delta"] = 0
	payload["verdict_code"] = verdict_code
	payload["attempts"] = case_attempts
	payload["hints_used"] = hints_used
	payload["verdict_count"] = verdict_count
	payload["placed_gates"] = placed_gates.duplicate()
	payload["correct_gates"] = current_case.get("correct_gates", []).duplicate()
	GlobalMetrics.register_trial(payload)

func _play_click():
	if click_player.stream:
		click_player.play()

func _on_hint_pressed():
	_mark_first_action()
	hints_used += 1
	_show_feedback("ПОДСКАЗКА: " + current_case.hint, Color(0.5, 0.8, 1))
	_apply_penalty(5.0)

func _on_restart_pressed():
	GlobalMetrics.stability = 100.0
	GlobalMetrics.stability_changed.emit(100.0, 0)
	game_over_panel.visible = false
	load_case(current_case_idx)
</file>

<file path="scenes/MatrixDecryptor.gd">
extends Control

const STATE_UNSET := -1
const STATE_ZERO := 0
const STATE_ONE := 1

const COLOR_NORMAL = Color("33ff66")
const COLOR_WARN = Color("ffcc00")
const COLOR_ERROR = Color("ff5555")
const COLOR_DIM = Color(0.65, 0.65, 0.65)
const MIN_CELL_SIZE := 64

@onready var btn_back: Button = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnBack
@onready var btn_details: Button = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnDetails
@onready var btn_close_details: Button = $UI/DetailsSheet/DetailsContent/DetailsHeader/BtnCloseDetails
@onready var level_label: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/LevelLabel
@onready var stability_text: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityText
@onready var progress_stability: ProgressBar = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityBar
@onready var shield_freq: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldFreq
@onready var shield_lazy: Label = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldLazy

@onready var row_labels: VBoxContainer = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/RowLabels
@onready var col_labels: HBoxContainer = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack/ColumnLabels
@onready var grid: GridContainer = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/MatrixBoard/MatrixStack/Grid
@onready var inlet_tag: Label = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow/InletTag
@onready var outlet_tag: Label = $UI/SafeArea/Main/ContentSplit/LeftPanel/MatrixPanel/MatrixContent/InOutRow/OutletTag

@onready var btn_hint: Button = $UI/SafeArea/Main/BottomBar/Actions/BtnHint
@onready var btn_check: Button = $UI/SafeArea/Main/BottomBar/Actions/BtnCheck
@onready var btn_reset: Button = $UI/SafeArea/Main/BottomBar/Actions/BtnReset

@onready var progress_label: Label = $UI/SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent/ProgressLabel
@onready var mode_state_label: Label = $UI/SafeArea/Main/ContentSplit/RightPanel/StatusPanel/StatusContent/ModeLabel
@onready var hint_text: Label = $UI/SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent/HintText
@onready var live_log_text: RichTextLabel = $UI/SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent/LiveLogText

@onready var toast_panel: PanelContainer = $UI/ToastLayer/Toast
@onready var toast_label: Label = $UI/ToastLayer/Toast/ToastLabel
@onready var details_sheet: PanelContainer = $UI/DetailsSheet
@onready var details_text: RichTextLabel = $UI/DetailsSheet/DetailsContent/DetailsScroll/DetailsText
@onready var noir_overlay = $UI/NoirOverlay

var _cell_buttons: Array = []
var _row_label_nodes: Array = []
var _col_label_nodes: Array = []
var _mono_font: Font

var _input_locked: bool = false
var _safe_mode_active: bool = false
var _details_open: bool = false

var _last_row_ok: Array = []
var _last_col_ok: Array = []
var _unlock_depth: int = 1

var _task_started_ms: int = 0
var _first_action_ms: int = -1
var _check_count: int = 0

var _log_lines: Array[String] = []

func _ready() -> void:
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not GlobalMetrics.shield_triggered.is_connected(_on_shield_triggered):
		GlobalMetrics.shield_triggered.connect(_on_shield_triggered)

	btn_back.pressed.connect(_on_menu_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_check.pressed.connect(_on_check_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)

	_setup_fonts()
	_build_row_labels()
	_build_col_labels()
	_build_grid()
	_reset_shield_state()
	_hide_overlays()

	await get_tree().process_frame
	_set_details_open(false, true)

	_start_new_matrix()

func _matrix_size() -> int:
	return GlobalMetrics.MATRIX_SIZE

func _setup_fonts() -> void:
	var font = load("res://fonts/IBMPlexMono-Medium.ttf")
	if font:
		_mono_font = font
	else:
		var fallback := SystemFont.new()
		fallback.font_names = PackedStringArray(["Courier New", "Consolas", "Liberation Mono"])
		_mono_font = fallback

func _build_row_labels() -> void:
	_row_label_nodes.clear()
	for child in row_labels.get_children():
		child.queue_free()

	for _i in range(_matrix_size()):
		var lbl := Label.new()
		lbl.custom_minimum_size = Vector2(92, MIN_CELL_SIZE)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		lbl.add_theme_color_override("font_color", COLOR_DIM)
		lbl.add_theme_font_override("font", _mono_font)
		lbl.add_theme_font_size_override("font_size", 20)
		row_labels.add_child(lbl)
		_row_label_nodes.append(lbl)

func _build_col_labels() -> void:
	_col_label_nodes.clear()
	for child in col_labels.get_children():
		child.queue_free()

	for _i in range(_matrix_size()):
		var lbl := Label.new()
		lbl.custom_minimum_size = Vector2(MIN_CELL_SIZE, 48)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		lbl.add_theme_color_override("font_color", COLOR_DIM)
		lbl.add_theme_font_override("font", _mono_font)
		lbl.add_theme_font_size_override("font_size", 18)
		col_labels.add_child(lbl)
		_col_label_nodes.append(lbl)

func _build_grid() -> void:
	_cell_buttons.clear()
	for child in grid.get_children():
		child.queue_free()

	grid.columns = _matrix_size()
	for r in range(_matrix_size()):
		var row_buttons: Array = []
		for c in range(_matrix_size()):
			var btn := Button.new()
			btn.custom_minimum_size = Vector2(MIN_CELL_SIZE, MIN_CELL_SIZE)
			btn.text = "."
			btn.focus_mode = Control.FOCUS_NONE
			btn.add_theme_font_override("font", _mono_font)
			btn.add_theme_font_size_override("font_size", 24)
			btn.pressed.connect(_on_cell_pressed.bind(r, c))
			grid.add_child(btn)
			row_buttons.append(btn)
		_cell_buttons.append(row_buttons)

func _start_new_matrix() -> void:
	GlobalMetrics.start_matrix_quest()
	_reset_trial_telemetry()
	_safe_mode_active = false
	_unlock_depth = 1
	_last_row_ok.clear()
	_last_col_ok.clear()
	_set_input_enabled(true)
	_refresh_header_labels()
	_apply_constraints_to_labels()
	_refresh_grid_from_state()
	_update_status_highlights()
	hint_text.text = "Диагностики пока нет."
	_log_message("Матрица инициализирована. Ограничения потока загружены.", COLOR_NORMAL)

func _refresh_header_labels() -> void:
	var edge = _matrix_size() - 1
	level_label.text = "ПРОТОКОЛ C | %dx%d" % [_matrix_size(), _matrix_size()]
	inlet_tag.text = "ВХОД [0,0]"
	outlet_tag.text = "ВЫХОД [%d,%d]" % [edge, edge]
	inlet_tag.add_theme_color_override("font_color", Color(0.6, 1.0, 0.7, 1.0))
	outlet_tag.add_theme_color_override("font_color", Color(0.6, 0.95, 1.0, 1.0))

func _apply_constraints_to_labels() -> void:
	for r in range(_matrix_size()):
		var constraint: Dictionary = GlobalMetrics.matrix_row_constraints[r]
		if bool(constraint.get("is_hex_visible", false)):
			_row_label_nodes[r].text = "%02X" % int(constraint.get("hex_value", 0))
		else:
			_row_label_nodes[r].text = "?"

	for c in range(_matrix_size()):
		var constraint: Dictionary = GlobalMetrics.matrix_col_constraints[c]
		var parity := "E" if int(constraint.get("parity", 0)) == 0 else "O"
		_col_label_nodes[c].text = "%d%s" % [int(constraint.get("ones_count", 0)), parity]

func _refresh_grid_from_state() -> void:
	for r in range(_matrix_size()):
		for c in range(_matrix_size()):
			_update_cell_visual(r, c)

func _is_cell_unlocked(row: int, col: int) -> bool:
	return row <= _unlock_depth and col <= _unlock_depth

func _update_cell_visual(row: int, col: int) -> void:
	var state = int(GlobalMetrics.matrix_current[row][col])
	var btn: Button = _cell_buttons[row][col]
	var unlocked = _is_cell_unlocked(row, col)
	btn.disabled = _input_locked or not unlocked

	if not unlocked:
		btn.text = "·" if state == STATE_UNSET else str(state)
		btn.add_theme_color_override("font_color", Color(0.45, 0.45, 0.45, 1.0))
		btn.self_modulate = Color(0.65, 0.65, 0.65, 1.0)
		return

	match state:
		STATE_UNSET:
			btn.text = "."
			btn.add_theme_color_override("font_color", Color(0.5, 0.5, 0.5, 1.0))
		STATE_ZERO:
			btn.text = "0"
			btn.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8, 1.0))
		STATE_ONE:
			btn.text = "1"
			btn.add_theme_color_override("font_color", Color(1, 1, 1, 1.0))

	var edge = _matrix_size() - 1
	if row == 0 and col == 0:
		btn.self_modulate = Color(0.78, 1.0, 0.82, 1.0)
	elif row == edge and col == edge:
		btn.self_modulate = Color(0.78, 0.94, 1.0, 1.0)
	else:
		btn.self_modulate = Color(1, 1, 1, 1)

func _on_cell_pressed(row: int, col: int) -> void:
	if _input_locked or not _is_cell_unlocked(row, col):
		return
	if _first_action_ms < 0:
		_first_action_ms = Time.get_ticks_msec() - _task_started_ms
	AudioManager.play("click")
	var current = int(GlobalMetrics.matrix_current[row][col])
	var next_state = STATE_ZERO if current == STATE_UNSET else (STATE_ONE if current == STATE_ZERO else STATE_UNSET)
	GlobalMetrics.matrix_current[row][col] = next_state
	GlobalMetrics.record_matrix_change(row, col)
	_update_cell_visual(row, col)
	_update_status_highlights()

func _update_status_highlights() -> void:
	var result: Dictionary = GlobalMetrics.validate_matrix_logic()
	var row_ok: Array = result.get("row_ok", [])
	var col_ok: Array = result.get("col_ok", [])
	var play_ok_sound := false

	var visible_rows := 0
	var solved_visible_rows := 0
	for r in range(_matrix_size()):
		var constraint: Dictionary = GlobalMetrics.matrix_row_constraints[r]
		var visible = bool(constraint.get("is_hex_visible", false))
		if visible:
			visible_rows += 1
		if visible and bool(row_ok[r]):
			solved_visible_rows += 1
			_row_label_nodes[r].add_theme_color_override("font_color", COLOR_NORMAL)
			if _last_row_ok.size() == _matrix_size() and not bool(_last_row_ok[r]):
				play_ok_sound = true
		else:
			_row_label_nodes[r].add_theme_color_override("font_color", COLOR_DIM)

	var solved_cols := 0
	for c in range(_matrix_size()):
		if bool(col_ok[c]):
			solved_cols += 1
			_col_label_nodes[c].add_theme_color_override("font_color", COLOR_NORMAL)
			if _last_col_ok.size() == _matrix_size() and not bool(_last_col_ok[c]):
				play_ok_sound = true
		else:
			_col_label_nodes[c].add_theme_color_override("font_color", COLOR_DIM)

	_last_row_ok = row_ok.duplicate()
	_last_col_ok = col_ok.duplicate()
	if play_ok_sound:
		AudioManager.play("click")

	var frontier_side = _unlock_depth + 1
	var frontier_total = frontier_side * frontier_side
	var frontier_filled = 0
	for r in range(frontier_side):
		for c in range(frontier_side):
			if int(GlobalMetrics.matrix_current[r][c]) != STATE_UNSET:
				frontier_filled += 1

	if frontier_filled >= frontier_total and _unlock_depth < _matrix_size() - 1:
		_unlock_depth += 1
		_refresh_grid_from_state()
		_log_message("Поток открыт до зоны %dx%d." % [_unlock_depth + 1, _unlock_depth + 1], COLOR_NORMAL)
		frontier_side = _unlock_depth + 1
		frontier_total = frontier_side * frontier_side
		frontier_filled = 0
		for r in range(frontier_side):
			for c in range(frontier_side):
				if int(GlobalMetrics.matrix_current[r][c]) != STATE_UNSET:
					frontier_filled += 1

	progress_label.text = "Открытая зона: %dx%d | Фронт: %d/%d | Строки: %d/%d | Столбцы: %d/%d" % [
		_unlock_depth + 1,
		_unlock_depth + 1,
		frontier_filled,
		frontier_total,
		solved_visible_rows,
		maxi(1, visible_rows),
		solved_cols,
		_matrix_size()
	]
	mode_state_label.text = "Безопасный режим: %s" % ("ВКЛ" if _safe_mode_active else "ВЫКЛ")

func _on_hint_pressed() -> void:
	if _input_locked:
		hint_text.text = "Ввод заблокирован щитом или безопасным режимом."
		_show_toast("ВВОД ЗАБЛОКИРОВАН", COLOR_WARN)
		return
	var logic: Dictionary = GlobalMetrics.validate_matrix_logic()
	var hd_val = int(logic.get("hd", 0))
	hint_text.text = "HD: %d | Сосредоточьтесь на видимых HEX-строках и совпадении чётности столбцов." % hd_val
	_log_message("Запрошена подсказка. HD=%d" % hd_val, COLOR_WARN)
	_show_toast("ПОДСКАЗКА ПОКАЗАНА", COLOR_WARN)

func _on_check_pressed() -> void:
	if _input_locked:
		return
	_check_count += 1
	var changed_cells_count: int = GlobalMetrics.matrix_changed_cells.size()
	var result: Dictionary = GlobalMetrics.check_matrix_solution()
	_register_trial(result, changed_cells_count)

	if bool(result.get("success", false)):
		AudioManager.play("relay")
		_overlay_glitch(0.15, 0.12)
		_show_toast("ДОСТУП РАЗРЕШЁН", COLOR_NORMAL)
		_log_message("ДОСТУП РАЗРЕШЁН. Матрица решена.", COLOR_NORMAL)
		await get_tree().create_timer(1.0).timeout
		_start_new_matrix()
		return

	AudioManager.play("error")
	_overlay_glitch(0.6, 0.2)
	var message := str(result.get("message", "Неверно"))
	hint_text.text = message
	if str(result.get("error", "")) in ["SHIELD_FREQ", "SHIELD_ACTIVE", "SHIELD_LAZY"]:
		_log_message(message, COLOR_WARN)
	else:
		_log_message(message, COLOR_ERROR)
	_show_toast("НЕВЕРНО", COLOR_ERROR)

func _on_reset_pressed() -> void:
	for r in range(_matrix_size()):
		for c in range(_matrix_size()):
			GlobalMetrics.matrix_current[r][c] = STATE_UNSET
	GlobalMetrics.matrix_changed_cells.clear()
	_unlock_depth = 1
	_reset_trial_telemetry()
	_refresh_grid_from_state()
	_update_status_highlights()
	hint_text.text = "Ввод матрицы сброшен."
	_log_message("Матрица сброшена в неопределённое состояние.", COLOR_WARN)
	_show_toast("СБРОС", COLOR_WARN)

func _on_shield_triggered(name: String, duration: float) -> void:
	AudioManager.play("error")
	_overlay_glitch(0.6, 0.2)
	if name == "FREQUENCY":
		_flash_shield(shield_freq)
	elif name == "LAZY":
		_flash_shield(shield_lazy)
	_log_message("ЩИТ %s активен %.1f c." % [name, duration], COLOR_WARN)
	_set_input_enabled(false)
	await get_tree().create_timer(duration).timeout
	if not _safe_mode_active:
		_set_input_enabled(true)
		_log_message("Кулдаун щита завершён.", COLOR_NORMAL)

func _on_stability_changed(new_val: float, _change: float) -> void:
	progress_stability.value = new_val
	stability_text.text = "СТАБИЛЬНОСТЬ: %d%%" % int(new_val)
	if new_val <= 0.0 and not _safe_mode_active:
		_safe_mode_active = true
		mode_state_label.text = "Безопасный режим: ВКЛ"
		_set_input_enabled(false)
		await _start_safe_mode_analysis()

func _start_safe_mode_analysis() -> void:
	_log_message("БЕЗОПАСНЫЙ РЕЖИМ: анализ запущен.", COLOR_WARN)
	var conflict = _find_conflict_cell()
	if conflict.size() == 2:
		var row = int(conflict[0])
		var col = int(conflict[1])
		_highlight_conflict(row, col)
		hint_text.text = "Конфликт около [%d, %d]. Проверьте HEX строки и количество/чётность столбцов." % [row + 1, col + 1]
		_log_message("Конфликт обнаружен в [%d, %d]." % [row + 1, col + 1], COLOR_ERROR)
	else:
		hint_text.text = "Конфликт не локализован. Сначала проверьте нерешённые строки/столбцы."
		_log_message("Конфликт не локализован.", COLOR_WARN)

	await get_tree().create_timer(8.0).timeout
	_clear_conflict_highlight()
	_safe_mode_active = false
	mode_state_label.text = "Безопасный режим: ВЫКЛ"
	_set_input_enabled(true)
	_log_message("БЕЗОПАСНЫЙ РЕЖИМ: ввод восстановлен.", COLOR_NORMAL)

func _find_conflict_cell() -> Array:
	var row_values: Array = []
	var row_has_unset: Array = []
	for r in range(_matrix_size()):
		var value = 0
		var has_unset = false
		for c in range(_matrix_size()):
			var cell = int(GlobalMetrics.matrix_current[r][c])
			if cell == STATE_UNSET:
				has_unset = true
			elif cell == STATE_ONE:
				value += GlobalMetrics.MATRIX_WEIGHTS[c]
		row_values.append(value)
		row_has_unset.append(has_unset)

	var col_counts: Array = []
	var col_has_unset: Array = []
	for c in range(_matrix_size()):
		var ones = 0
		var has_unset = false
		for r in range(_matrix_size()):
			var cell = int(GlobalMetrics.matrix_current[r][c])
			if cell == STATE_UNSET:
				has_unset = true
			elif cell == STATE_ONE:
				ones += 1
		col_counts.append(ones)
		col_has_unset.append(has_unset)

	for r in range(_matrix_size()):
		for c in range(_matrix_size()):
			if int(GlobalMetrics.matrix_current[r][c]) != STATE_ONE:
				continue
			var row_constraint: Dictionary = GlobalMetrics.matrix_row_constraints[r]
			var col_constraint: Dictionary = GlobalMetrics.matrix_col_constraints[c]
			var row_over = row_values[r] > int(row_constraint.get("hex_value", 0))
			var col_over = col_counts[c] > int(col_constraint.get("ones_count", 0))
			if row_over and col_over:
				return [r, c]

	for r in range(_matrix_size()):
		for c in range(_matrix_size()):
			if int(GlobalMetrics.matrix_current[r][c]) != STATE_ONE:
				continue
			var row_constraint: Dictionary = GlobalMetrics.matrix_row_constraints[r]
			var col_constraint: Dictionary = GlobalMetrics.matrix_col_constraints[c]
			var row_bad = bool(row_has_unset[r]) or row_values[r] != int(row_constraint.get("hex_value", 0))
			var col_bad = bool(col_has_unset[c]) or col_counts[c] != int(col_constraint.get("ones_count", 0))
			if row_bad and col_bad:
				return [r, c]

	for r in range(_matrix_size()):
		for c in range(_matrix_size()):
			if int(GlobalMetrics.matrix_current[r][c]) == STATE_ONE:
				var col_constraint: Dictionary = GlobalMetrics.matrix_col_constraints[c]
				if col_counts[c] > int(col_constraint.get("ones_count", 0)):
					return [r, c]

	return []

func _highlight_conflict(row: int, col: int) -> void:
	for r in range(_matrix_size()):
		for c in range(_matrix_size()):
			var btn: Button = _cell_buttons[r][c]
			if r == row or c == col:
				btn.self_modulate = Color(1.0, 0.4, 0.4, 1.0)
			else:
				btn.self_modulate = Color(0.85, 0.85, 0.85, 1.0)
	_row_label_nodes[row].add_theme_color_override("font_color", COLOR_ERROR)
	_col_label_nodes[col].add_theme_color_override("font_color", COLOR_ERROR)

func _clear_conflict_highlight() -> void:
	_refresh_grid_from_state()
	_update_status_highlights()

func _set_input_enabled(enabled: bool) -> void:
	_input_locked = not enabled
	btn_check.disabled = not enabled
	btn_hint.disabled = not enabled
	btn_reset.disabled = not enabled
	_refresh_grid_from_state()

func _reset_trial_telemetry() -> void:
	_task_started_ms = Time.get_ticks_msec()
	_first_action_ms = -1
	_check_count = 0

func _register_trial(result: Dictionary, changed_cells_count: int) -> void:
	var variant_hash := str(hash(JSON.stringify(GlobalMetrics.matrix_quest)))
	var payload := TrialV2.build("MATRIX_DECRYPTOR", "C", "MATRIX_01", "GRID_CHECK", variant_hash)
	var elapsed_ms: int = maxi(0, Time.get_ticks_msec() - _task_started_ms)
	var is_success := bool(result.get("success", false))
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = _first_action_ms if _first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_success
	payload["is_fit"] = is_success
	payload["stability_delta"] = 0
	payload["error_type"] = str(result.get("error", "NONE"))
	payload["penalty_reported"] = float(result.get("penalty", 0.0))
	payload["hamming"] = int(result.get("hamming", -1))
	payload["changed_cells_count"] = changed_cells_count
	payload["check_count"] = _check_count
	GlobalMetrics.register_trial(payload)

func _log_message(msg: String, color: Color) -> void:
	var time_str = Time.get_time_string_from_system()
	var line = "[%s] %s" % [time_str, msg]
	_log_lines.append(line)
	if _log_lines.size() > 220:
		_log_lines.remove_at(0)
	var all_text = "\n".join(_log_lines)
	details_text.text = all_text
	var tail = _log_lines.slice(maxi(0, _log_lines.size() - 18), _log_lines.size())
	live_log_text.text = "\n".join(tail)
	live_log_text.add_theme_color_override("default_color", color)

func _show_toast(msg: String, color: Color) -> void:
	toast_label.text = msg
	toast_label.add_theme_color_override("font_color", color)
	toast_panel.visible = true
	toast_panel.modulate = Color(1, 1, 1, 0)
	var tween := create_tween()
	tween.tween_property(toast_panel, "modulate", Color(1, 1, 1, 1), 0.15)
	tween.tween_interval(0.9)
	tween.tween_property(toast_panel, "modulate", Color(1, 1, 1, 0), 0.25)
	tween.tween_callback(func() -> void: toast_panel.visible = false)

func _flash_shield(label: Label) -> void:
	label.modulate = Color(1, 1, 1, 1)
	var tween := create_tween()
	tween.tween_property(label, "modulate", Color(1, 1, 1, 0.25), 0.6)

func _reset_shield_state() -> void:
	shield_freq.modulate = Color(1, 1, 1, 0.25)
	shield_lazy.modulate = Color(1, 1, 1, 0.25)

func _hide_overlays() -> void:
	toast_panel.visible = false
	details_sheet.visible = false

func _on_details_pressed() -> void:
	_set_details_open(not _details_open, false)

func _set_details_open(open: bool, immediate: bool) -> void:
	_details_open = open
	if open:
		details_sheet.visible = true

	var target_offset = -details_sheet.size.y if open else 0.0
	if immediate:
		details_sheet.offset_top = target_offset
		if not open:
			details_sheet.visible = false
		return

	var tween := create_tween()
	tween.tween_property(details_sheet, "offset_top", target_offset, 0.22).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	if not open:
		tween.tween_callback(func() -> void: details_sheet.visible = false)

func _overlay_glitch(strength: float, duration: float) -> void:
	if noir_overlay != null and noir_overlay.has_method("glitch_burst"):
		noir_overlay.call("glitch_burst", strength, duration)

func _on_menu_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
</file>

<file path="scenes/RadioQuestC.tscn">
[gd_scene load_steps=6 format=3 uid="uid://dmd28rj5m2f34"]

[ext_resource type="Script" path="res://scenes/RadioQuestC.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_terminal_green.tres" id="2_theme"]
[ext_resource type="Script" path="res://scenes/TimeKnob.gd" id="3_knob_script"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="4_shader"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_crt"]
shader = ExtResource("4_shader")
shader_parameter/tint_color = Color(0, 1, 0.25, 1)
shader_parameter/intensity = 0.12
shader_parameter/fx_quality = 1
shader_parameter/glitch_strength = 0.0

[node name="RadioQuestC" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.08, 0.05, 1)

[node name="CRTLayer" type="CanvasLayer" parent="."]

[node name="CRTOverlay" type="ColorRect" parent="CRTLayer"]
material = SubResource("ShaderMaterial_crt")
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 16.0
offset_top = 12.0
offset_right = -16.0
offset_bottom = -12.0
grow_horizontal = 2
grow_vertical = 2

[node name="RootVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="TopBar" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2

[node name="TopBarHBox" type="HBoxContainer" parent="SafeArea/RootVBox/TopBar"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="BtnBack" type="Button" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "<-"

[node name="TitleLabel" type="Label" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 30
text = "ЗАГОЛОВОК"

[node name="ModeChip" type="Label" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "РЕЖИМ"

[node name="StabilityLabel" type="Label" parent="SafeArea/RootVBox/TopBar/TopBarHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "СТАБИЛЬНОСТЬ"

[node name="BodyHSplit" type="HSplitContainer" parent="SafeArea/RootVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 760

[node name="LeftCol" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="MissionCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol"]
custom_minimum_size = Vector2(0, 160)
layout_mode = 2

[node name="MissionMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="MissionVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="MissionTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "МИССИЯ"

[node name="TaskLine1" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "СТРОКА1"

[node name="TaskLine2" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "СТРОКА2"

[node name="TaskLine3" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.8, 0.3, 1)
theme_override_font_sizes/font_size = 24
text = "СТРОКА3"

[node name="MicroHint" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.75, 0.75, 0.75, 1)
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "ПОДСКАЗКА"

[node name="KnobCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol"]
layout_mode = 2
size_flags_vertical = 3

[node name="KnobMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="KnobVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Step1Label" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ШАГ1"

[node name="KnobCenter" type="CenterContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="TimeKnob" type="Control" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/KnobCenter"]
custom_minimum_size = Vector2(320, 320)
layout_mode = 2
script = ExtResource("3_knob_script")

[node name="EstimateValue" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 38
horizontal_alignment = 1
text = "t = 0.0"

[node name="FineButtonsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="BtnMinus1" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "-1"

[node name="BtnMinus01" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "-0.1"

[node name="BtnPlus01" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "+0.1"

[node name="BtnPlus1" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
text = "+1"

[node name="BtnAnalyze" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
text = "АНАЛИЗ"

[node name="StatusCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol"]
custom_minimum_size = Vector2(0, 96)
layout_mode = 2

[node name="StatusMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/StatusCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 8

[node name="StatusLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftCol/StatusCard/StatusMargin"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
autowrap_mode = 2
text = "СТАТУС"

[node name="RightCol" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="RiskCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol"]
layout_mode = 2
size_flags_vertical = 3

[node name="RiskMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="RiskVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="Step2Label" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ШАГ2"

[node name="DetectionTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "ОБНАРУЖЕНИЕ"

[node name="DetectionBar" type="ProgressBar" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
show_percentage = false

[node name="DetectCountdown" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "--"

[node name="TransferTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "ПЕРЕДАЧА"

[node name="TransferBar" type="ProgressBar" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
custom_minimum_size = Vector2(0, 36)
layout_mode = 2
show_percentage = false

[node name="TransferCountdown" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "--"

[node name="RiskLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "РИСК"

[node name="ActionsCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2

[node name="ActionsMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="ActionsVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Step3Label" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "ШАГ3"

[node name="PrimaryActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnRisk" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "РИСК"

[node name="BtnAbort" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРЕРВАТЬ"

[node name="SecondaryActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnUnits" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ЕДИНИЦЫ"

[node name="BtnDetails" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДЕТАЛИ"

[node name="BtnNext" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
visible = false
text = "ДАЛЕЕ"

[node name="SampleStrip" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="Sample1" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample1"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample1"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -7.0
offset_top = -9.0
offset_right = 7.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample2" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample2"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample2"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -7.0
offset_top = -9.0
offset_right = 7.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample3" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample3"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample3"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -7.0
offset_top = -9.0
offset_right = 7.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample4" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample4"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample4"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -7.0
offset_top = -9.0
offset_right = 7.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample5" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample5"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample5"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -7.0
offset_top = -9.0
offset_right = 7.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample6" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample6"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample6"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -7.0
offset_top = -9.0
offset_right = 7.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="Sample7" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip"]
custom_minimum_size = Vector2(42, 32)
layout_mode = 2
size_flags_horizontal = 3

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample7"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.18, 0.18, 0.18, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip/Sample7"]
visible = false
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -7.0
offset_top = -9.0
offset_right = 7.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 16
text = "A"
horizontal_alignment = 1

[node name="DetailsOverlay" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1

[node name="Dim" type="ColorRect" parent="DetailsOverlay"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
color = Color(0, 0, 0, 0.6)

[node name="BottomSheet" type="PanelContainer" parent="DetailsOverlay"]
layout_mode = 1
anchors_preset = 0
anchor_left = 0.12
anchor_top = 0.30
anchor_right = 0.88
anchor_bottom = 0.94
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1

[node name="SheetMargin" type="MarginContainer" parent="DetailsOverlay/BottomSheet"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="SheetVBox" type="VBoxContainer" parent="DetailsOverlay/BottomSheet/SheetMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="SheetTitle" type="Label" parent="DetailsOverlay/BottomSheet/SheetMargin/SheetVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 28
text = "ДЕТАЛИ"

[node name="SheetText" type="RichTextLabel" parent="DetailsOverlay/BottomSheet/SheetMargin/SheetVBox"]
custom_minimum_size = Vector2(0, 220)
layout_mode = 2
size_flags_vertical = 3
fit_content = false
scroll_active = true
bbcode_enabled = false

[node name="BtnCloseDetails" type="Button" parent="DetailsOverlay/BottomSheet/SheetMargin/SheetVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "ЗАКРЫТЬ"

[node name="AlarmFlash" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
color = Color(1, 0.05, 0.05, 0)
</file>

<file path="scenes/RestoreQuestB.tscn">
[gd_scene load_steps=7 format=3 uid="uid://restorequest_b"]

[ext_resource type="Script" path="res://scripts/RestoreQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]
[ext_resource type="PackedScene" uid="uid://diagnostics_panel_b" path="res://scenes/ui/DiagnosticsPanelB.tscn" id="3_panel"]
[ext_resource type="Script" path="res://scripts/ui/DropZone.gd" id="4_dropzone"]
[ext_resource type="Shader" path="res://ui/shaders/noir_pencil_overlay.gdshader" id="5_shader"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_noir"]
shader = ExtResource("5_shader")
shader_parameter/intensity = 0.34
shader_parameter/grain_strength = 0.33
shader_parameter/hatch_strength = 0.26
shader_parameter/vignette_strength = 0.42
shader_parameter/fx_quality = 1
shader_parameter/pulse = 0.0
shader_parameter/jitter_strength = 0.0

[node name="RestoreQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="NoirOverlay" type="ColorRect" parent="CanvasLayer"]
material = SubResource("ShaderMaterial_noir")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
color = Color(1, 1, 1, 0)

[node name="MainLayout" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Header" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
alignment = 1

[node name="BtnBack" type="Button" parent="MainLayout/Header"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "ВОССТАНОВЛЕНИЕ B-01"

[node name="LblSessionId" type="Label" parent="MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 3
text = "СЕССИЯ ИНИЦ."
horizontal_alignment = 2

[node name="BarsRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
alignment = 1

[node name="DecryptBar" type="ProgressBar" parent="MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
show_percentage = false

[node name="EnergyBar" type="ProgressBar" parent="MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 100.0
show_percentage = false

[node name="TargetDisplay" type="PanelContainer" parent="MainLayout"]
layout_mode = 2

[node name="LblTarget" type="Label" parent="MainLayout/TargetDisplay"]
layout_mode = 2
text = "ЦЕЛЬ: s = ?"
horizontal_alignment = 1

[node name="TerminalFrame" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="CodeScroll" type="ScrollContainer" parent="MainLayout/TerminalFrame"]
layout_mode = 2

[node name="CodeDisplay" type="RichTextLabel" parent="MainLayout/TerminalFrame/CodeScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "Загрузка кода..."
fit_content = true

[node name="SlotRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
alignment = 1

[node name="DropZone" type="PanelContainer" parent="MainLayout/SlotRow"]
custom_minimum_size = Vector2(240, 96)
layout_mode = 2
script = ExtResource("4_dropzone")

[node name="Label" type="Label" parent="MainLayout/SlotRow/DropZone"]
layout_mode = 2
text = "[СЛОТ]"
horizontal_alignment = 1
vertical_alignment = 1

[node name="LblSlotHint" type="Label" parent="MainLayout/SlotRow"]
layout_mode = 2
text = "<-- Перетащите блок сюда"

[node name="InventoryFrame" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.5

[node name="InventoryMargin" type="MarginContainer" parent="MainLayout/InventoryFrame"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="InventoryScroll" type="ScrollContainer" parent="MainLayout/InventoryFrame/InventoryMargin"]
layout_mode = 2

[node name="BlocksContainer" type="HBoxContainer" parent="MainLayout/InventoryFrame/InventoryMargin/InventoryScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 14
alignment = 1

[node name="Actions" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnAnalyze" type="Button" parent="MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="BtnSubmit" type="Button" parent="MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "ПРОВЕРИТЬ"

[node name="BtnNext" type="Button" parent="MainLayout/Actions"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "ДАЛЕЕ"

[node name="DiagnosticsBlocker" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 0
color = Color(0, 0, 0, 0.45)

[node name="DiagnosticsPanelB" parent="." instance=ExtResource("3_panel")]
layout_mode = 1
visible = false
mouse_filter = 0
</file>

<file path="scripts/ui/DropZone.gd">
extends PanelContainer

signal block_dropped(block_data)

var required_type: String = "INT"
var current_block_data = null
var last_prev_block_id = null
var breathing_tween: Tween

@onready var lbl_hint = $Label

func _ready():
	_start_breathing()

func setup(type: String):
	required_type = type
	_reset_state()

func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	# Ensure the data is a dictionary and has the right type
	if typeof(data) == TYPE_DICTIONARY and data.get("kind") == "CODE_BLOCK":
		return data.get("slot_type") == required_type
	return false

func _drop_data(at_position: Vector2, data: Variant) -> void:
	# Stop breathing
	if breathing_tween:
		breathing_tween.kill()

	last_prev_block_id = get_block_id()
	current_block_data = data
	lbl_hint.text = str(data.get("label", "ОШИБКА"))

	# Snapping Effect
	modulate = Color(1, 1, 1, 1) # Full opaque
	var tween = create_tween()
	tween.tween_property(self, "scale", Vector2(1.1, 1.1), 0.1)
	tween.tween_property(self, "scale", Vector2(1.0, 1.0), 0.1)

	block_dropped.emit(data)

func _start_breathing():
	if breathing_tween:
		breathing_tween.kill()

	modulate = Color(1, 1, 1, 0.7)
	breathing_tween = create_tween().set_loops()
	breathing_tween.tween_property(self, "modulate:a", 1.0, 1.0)
	breathing_tween.tween_property(self, "modulate:a", 0.6, 1.0)

func _reset_state():
	current_block_data = null
	last_prev_block_id = null
	lbl_hint.text = "[СЛОТ]"
	_start_breathing()

func reset() -> void:
	_reset_state()

func get_block_id():
	if current_block_data:
		return current_block_data.get("block_id")
	return null

func get_block_data():
	if current_block_data == null:
		return null
	return current_block_data.duplicate(true)

func get_last_prev_block_id():
	return last_prev_block_id
</file>

<file path="scenes/CityMapQuestB.gd">
extends Control

const LEVEL_PATH := "res://data/city_map/level_6_2.json"
const LOG_PREFIX := "case_6_2"
const DEFAULT_ACCENT := Color(0.40, 0.72, 1.0, 1.0)
const ARROW_ANGLE_RAD := 0.52
const ARROW_LEN := 16.0

@onready var content_split: BoxContainer = $SafeArea/MainVBox/ContentSplit
@onready var graph_container: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer
@onready var edges_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/EdgesLayer
@onready var nodes_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/NodesLayer
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack
@onready var btn_reset: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnReset
@onready var btn_submit: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnSubmit
@onready var sum_input: LineEdit = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumInput
@onready var path_display: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/PathDisplay
@onready var sum_live_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumLiveLabel
@onready var constraint_info_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ConstraintInfoLabel
@onready var backtrack_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/BacktrackLabel
@onready var warning_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/WarningLabel
@onready var status_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/StatusLabel
@onready var label_state: Label = $SafeArea/MainVBox/Header/LabelState
@onready var label_timer: Label = $SafeArea/MainVBox/Header/LabelTimer
@onready var footer_label: Label = $SafeArea/MainVBox/Footer/FooterLabel
@onready var briefing_title: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingTitle
@onready var briefing_text: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingText
@onready var briefing_constraint: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/ConstraintLabel

var level_data: Dictionary = {}
var node_defs: Dictionary = {}
var adjacency: Dictionary = {}
var edge_visuals: Dictionary = {}
var edge_key_to_visuals: Dictionary = {}
var node_buttons: Dictionary = {}
var config_hash: String = ""
var input_regex := RegEx.new()

var min_sum: int = 0
var accent_color: Color = DEFAULT_ACCENT
var node_radius_px: float = 25.0
var must_visit_nodes: Array[String] = []

var current_node: String = ""
var path: Array[String] = []
var path_sum: int = 0
var stability: float = 100.0
var t_elapsed_seconds: int = 0
var is_game_over: bool = false
var first_attempt_edge: String = ""
var level_started_ms: int = 0
var first_action_ms: int = -1

var backtrack_count: int = 0
var cycle_events: int = 0
var cycle_detected: bool = false
var constraint_violations: int = 0

var n_calc: int = 0
var n_opt: int = 0
var n_parse: int = 0
var n_reset: int = 0
var n_transit: int = 0
var n_cycle: int = 0

func _ready() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	sum_input.text_changed.connect(_on_sum_input_changed)
	graph_container.resized.connect(_on_graph_resized)

	_load_level_data(LEVEL_PATH)
	_apply_content_layout_mode()
	_setup_timer()
	call_deferred("_post_ready")

func _post_ready() -> void:
	_set_briefing()
	_rebuild_graph_ui()
	_reset_round_state(true)
	_update_timer_display()
	_recalculate_stability()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_content_layout_mode()
		_rebuild_graph_ui()
		_update_visuals()
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_OUT:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = true
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_IN:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = false

func _apply_content_layout_mode() -> void:
	content_split.vertical = get_viewport_rect().size.x < get_viewport_rect().size.y

func _setup_timer() -> void:
	var timer := Timer.new()
	timer.name = "ResearchTimer"
	timer.wait_time = 1.0
	timer.autostart = true
	timer.timeout.connect(_on_timer_tick)
	add_child(timer)

func _on_timer_tick() -> void:
	if is_game_over:
		return
	t_elapsed_seconds += 1
	_update_timer_display()
	if t_elapsed_seconds > int(level_data.get("time_limit_sec", 120)):
		_recalculate_stability()

func _load_level_data(path_to_file: String) -> void:
	var file := FileAccess.open(path_to_file, FileAccess.READ)
	if file == null:
		push_error("Failed to open level data: %s" % path_to_file)
		return

	var raw_json := file.get_as_text()
	config_hash = raw_json.sha256_text()
	var parsed: Variant = JSON.parse_string(raw_json)
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid level JSON in %s" % path_to_file)
		return

	level_data = parsed
	node_defs.clear()
	adjacency.clear()
	must_visit_nodes.clear()

	for node_var in level_data.get("nodes", []):
		var node: Dictionary = node_var
		node_defs[str(node.get("id", ""))] = node

	for transit_var in level_data.get("constraints", {}).get("must_visit", []):
		must_visit_nodes.append(str(transit_var))

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		var w := int(edge.get("w", 0))
		if from_id.is_empty() or to_id.is_empty():
			continue
		_add_adjacency(from_id, to_id, w)
		if edge.get("two_way", false):
			_add_adjacency(to_id, from_id, w)

	input_regex = RegEx.new()
	var regex_pattern := "^[0-9]+$"
	if level_data.has("rules") and level_data.rules.has("input_regex"):
		regex_pattern = str(level_data.rules.input_regex)
	input_regex.compile(regex_pattern)

	min_sum = int(level_data.get("min_sum", -1))
	if min_sum < 0:
		min_sum = _calculate_min_sum_with_constraints()

	if level_data.has("ui"):
		if level_data.ui.has("accent_color"):
			accent_color = Color(level_data.ui.accent_color)
		if level_data.ui.has("node_radius_px"):
			var raw_radius := float(level_data.ui.node_radius_px)
			node_radius_px = raw_radius * 0.5 if raw_radius > 32.0 else raw_radius
			node_radius_px = maxf(16.0, node_radius_px)

func _add_adjacency(from_id: String, to_id: String, weight: int) -> void:
	if not adjacency.has(from_id):
		adjacency[from_id] = {}
	adjacency[from_id][to_id] = weight

func _set_briefing() -> void:
	briefing_title.text = "ПРОВЕРКА ТРАНЗИТА"
	briefing_text.text = "Доберитесь до узла E, укажите точную сумму маршрута и докажите его оптимальность в ориентированном графе."
	var constraint_text := "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО ПОСЕТИТЬ %s" % ",".join(must_visit_nodes)
	briefing_constraint.text = constraint_text
	constraint_info_label.text = constraint_text
	footer_label.text = "Двусторонние дороги активны только там, где в данных есть обратное ребро."

func _calculate_min_sum_with_constraints() -> int:
	var start_node := str(level_data.get("start_node", ""))
	var end_node := str(level_data.get("end_node", ""))
	if start_node.is_empty() or end_node.is_empty():
		return 0

	var frontier: Array[Dictionary] = [{
		"node": start_node,
		"cost": 0,
		"path": [start_node]
	}]
	var best := 1_000_000_000

	while not frontier.is_empty():
		var best_index := 0
		for i in range(1, frontier.size()):
			if int(frontier[i].cost) < int(frontier[best_index].cost):
				best_index = i
		var state: Dictionary = frontier.pop_at(best_index)

		var node_id := str(state.node)
		var cost := int(state.cost)
		var path_local: Array = state.path
		if cost >= best:
			continue

		if node_id == end_node and _path_has_all_transit(path_local):
			best = min(best, cost)
			continue

		for next_id in adjacency.get(node_id, {}).keys():
			var local_visits := 0
			for p in path_local:
				if str(p) == str(next_id):
					local_visits += 1
			if local_visits >= 2:
				continue
			frontier.append({
				"node": str(next_id),
				"cost": cost + int(adjacency[node_id][next_id]),
				"path": path_local + [str(next_id)]
			})

	return 0 if best >= 1_000_000_000 else best

func _path_has_all_transit(path_local: Array) -> bool:
	for must_node in must_visit_nodes:
		if not path_local.has(must_node):
			return false
	return true

func _on_graph_resized() -> void:
	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return
	_rebuild_graph_ui()
	_update_visuals()

func _rebuild_graph_ui() -> void:
	for child in edges_layer.get_children():
		child.queue_free()
	for child in nodes_layer.get_children():
		child.queue_free()
	edge_visuals.clear()
	edge_key_to_visuals.clear()
	node_buttons.clear()

	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty() or not node_defs.has(from_id) or not node_defs.has(to_id):
			continue

		var visual_id := str(edge.get("id", _edge_key(from_id, to_id)))
		var start_pos := _node_screen_pos(node_defs[from_id])
		var end_pos := _node_screen_pos(node_defs[to_id])

		var line := Line2D.new()
		line.width = 4.0
		line.points = PackedVector2Array([start_pos, end_pos])
		line.gradient = _build_gradient(Color(0.18, 0.22, 0.30, 0.28), Color(0.30, 0.38, 0.52, 0.48))
		edges_layer.add_child(line)

		var arrows: Array[Polygon2D] = []
		var forward_arrow := _create_arrow_polygon(start_pos, end_pos)
		edges_layer.add_child(forward_arrow)
		arrows.append(forward_arrow)

		var keys: Array[String] = [_edge_key(from_id, to_id)]
		if edge.get("two_way", false):
			var reverse_arrow := _create_arrow_polygon(end_pos, start_pos)
			edges_layer.add_child(reverse_arrow)
			arrows.append(reverse_arrow)
			keys.append(_edge_key(to_id, from_id))

		var label := Label.new()
		label.text = str(edge.get("w", 0))
		label.add_theme_font_size_override("font_size", 15)
		label.position = _edge_label_pos(start_pos, end_pos)
		label.add_theme_color_override("font_color", Color(0.62, 0.74, 0.90))
		edges_layer.add_child(label)

		edge_visuals[visual_id] = {
			"line": line,
			"arrows": arrows,
			"label": label,
			"keys": keys
		}

		for key in keys:
			if not edge_key_to_visuals.has(key):
				edge_key_to_visuals[key] = []
			edge_key_to_visuals[key].append(visual_id)

	for node_id in node_defs.keys():
		var node: Dictionary = node_defs[node_id]
		var btn := Button.new()
		btn.text = str(node.get("label", node_id))
		var diameter := node_radius_px * 2.0
		btn.size = Vector2(diameter, diameter)
		btn.position = _node_screen_pos(node) - Vector2(node_radius_px, node_radius_px)
		btn.pressed.connect(_on_node_pressed.bind(node_id))
		nodes_layer.add_child(btn)
		node_buttons[node_id] = btn

func _edge_label_pos(start_pos: Vector2, end_pos: Vector2) -> Vector2:
	var dir := (end_pos - start_pos).normalized()
	var normal := Vector2(-dir.y, dir.x)
	return ((start_pos + end_pos) * 0.5) + (normal * 12.0) - Vector2(10.0, 10.0)

func _create_arrow_polygon(start_pos: Vector2, end_pos: Vector2) -> Polygon2D:
	var dir := (end_pos - start_pos).normalized()
	var tip := end_pos - dir * (node_radius_px + 4.0)
	var base := tip - dir * ARROW_LEN
	var side_len := ARROW_LEN * 0.65

	var polygon := Polygon2D.new()
	polygon.polygon = PackedVector2Array([
		tip,
		base + dir.rotated(ARROW_ANGLE_RAD) * side_len,
		base + dir.rotated(-ARROW_ANGLE_RAD) * side_len
	])
	polygon.color = Color(0.45, 0.66, 0.96, 0.95)
	return polygon

func _build_gradient(start_color: Color, end_color: Color) -> Gradient:
	var gradient := Gradient.new()
	gradient.set_color(0, start_color)
	gradient.set_color(1, end_color)
	return gradient

func _node_screen_pos(node_data: Dictionary) -> Vector2:
	var pos: Dictionary = node_data.get("pos", {})
	var x := float(pos.get("x", 0.0))
	var y := float(pos.get("y", 0.0))

	if x >= 0.0 and x <= 1.0 and y >= 0.0 and y <= 1.0:
		var padding := node_radius_px + 4.0
		var usable := graph_container.size - Vector2(padding * 2.0, padding * 2.0)
		usable.x = maxf(1.0, usable.x)
		usable.y = maxf(1.0, usable.y)
		return Vector2(padding + x * usable.x, padding + y * usable.y)

	return Vector2(x, y)

func _reset_round_state(full_reset: bool) -> void:
	current_node = str(level_data.get("start_node", "A"))
	path = [current_node]
	path_sum = 0
	backtrack_count = 0
	cycle_events = 0
	cycle_detected = false
	first_attempt_edge = ""
	first_action_ms = -1
	sum_input.clear()
	status_label.text = ""

	if full_reset:
		level_started_ms = Time.get_ticks_msec()

	_update_visuals()

func _update_visuals() -> void:
	path_display.text = "ПУТЬ: %s" % " -> ".join(path)
	sum_live_label.text = "СУММА: %d" % path_sum
	backtrack_label.text = "ОТКАТЫ: %d" % backtrack_count
	if cycle_detected:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ОБНАРУЖЕН ЦИКЛ"
	elif backtrack_count > 0:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ИСПОЛЬЗОВАН ОТКАТ"
	else:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: -"

	for node_id in node_buttons.keys():
		var btn: Button = node_buttons[node_id]
		var is_current: bool = node_id == current_node
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(node_id)
		btn.disabled = is_current or not is_available or is_game_over
		if is_current:
			btn.modulate = Color(0.95, 0.86, 0.45)
		elif is_available:
			btn.modulate = Color(1, 1, 1)
		else:
			btn.modulate = Color(0.42, 0.46, 0.56)

	for visual_id in edge_visuals.keys():
		_apply_style_to_visual(visual_id, "dim")

	if adjacency.has(current_node):
		for next_id in adjacency[current_node].keys():
			_set_edge_style_by_key(_edge_key(current_node, str(next_id)), "available")

	for i in range(path.size() - 1):
		_set_edge_style_by_key(_edge_key(path[i], path[i + 1]), "traversed")

func _set_edge_style_by_key(key: String, state: String) -> void:
	if not edge_key_to_visuals.has(key):
		return
	for visual_id in edge_key_to_visuals[key]:
		_apply_style_to_visual(str(visual_id), state)

func _apply_style_to_visual(visual_id: String, state: String) -> void:
	if not edge_visuals.has(visual_id):
		return
	var visual: Dictionary = edge_visuals[visual_id]
	var line: Line2D = visual["line"]
	var arrows: Array = visual["arrows"]
	var label: Label = visual["label"]

	var start_color := Color(0.18, 0.22, 0.30, 0.28)
	var end_color := Color(0.30, 0.38, 0.52, 0.48)
	if state == "available":
		start_color = Color(0.24, 0.40, 0.62, 0.48)
		end_color = accent_color
		end_color.a = 0.95
	elif state == "traversed":
		start_color = accent_color.lightened(0.10)
		start_color.a = 0.80
		end_color = Color(0.92, 0.97, 1.0, 1.0)

	line.gradient = _build_gradient(start_color, end_color)
	for arrow in arrows:
		(arrow as Polygon2D).color = end_color
	label.add_theme_color_override("font_color", end_color.lightened(0.10))

func _edge_key(from_id: String, to_id: String) -> String:
	return "%s->%s" % [from_id, to_id]

func _on_node_pressed(node_id: String) -> void:
	if is_game_over:
		return
	if not adjacency.has(current_node) or not adjacency[current_node].has(node_id):
		return

	if first_attempt_edge.is_empty():
		first_attempt_edge = _edge_key(current_node, node_id)
		first_action_ms = Time.get_ticks_msec() - level_started_ms

	if path.size() >= 2 and path[path.size() - 2] == node_id:
		backtrack_count += 1

	if path.has(node_id):
		cycle_events += 1
		cycle_detected = true

	path_sum += int(adjacency[current_node][node_id])
	path.append(node_id)
	current_node = node_id
	_update_visuals()

func _on_reset_pressed() -> void:
	if is_game_over:
		return
	n_reset += 1
	_reset_round_state(false)
	_recalculate_stability()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_sum_input_changed(new_text: String) -> void:
	var digits := ""
	for ch in new_text:
		if ch >= "0" and ch <= "9":
			digits += ch
	if digits != new_text:
		sum_input.text = digits
		sum_input.caret_column = digits.length()

func _on_submit_pressed() -> void:
	if is_game_over:
		return

	var verdict := _judge_solution(sum_input.text.strip_edges())
	_log_attempt(verdict)

	if verdict.result_code == "OK":
		status_label.text = "Маршрут принят. Ограничение и оптимальность подтверждены."
		status_label.add_theme_color_override("font_color", Color(0.38, 1.0, 0.62))
		is_game_over = true
		btn_submit.disabled = true
		btn_reset.disabled = true
		_update_visuals()
		return

	status_label.text = _result_message(str(verdict.result_code))
	status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.28))
	_recalculate_stability()

func _result_message(result_code: String) -> String:
	match result_code:
		"ERR_INCOMPLETE":
			return "Дойдите до узла E перед отправкой."
		"ERR_MISSING_TRANSIT":
			return "Ограничение не выполнено: посетите обязательные транзитные узлы."
		"ERR_CYCLE":
			return "В маршруте обнаружен цикл."
		"ERR_PARSE":
			return "Вводите только цифры."
		"ERR_CALC":
			return "Введённая сумма не совпадает с выбранным маршрутом."
		"ERR_NOT_OPT":
			return "Маршрут корректный, но не оптимальный."
		"ERR_PATH_INVALID":
			return "Маршрут недопустим для ориентированных рёбер."
		_:
			return "Необработанный результат: %s" % result_code

func _judge_solution(input_text: String) -> Dictionary:
	var sum_actual := _compute_path_sum()
	var sum_input_value: Variant = null
	var result_code := "OK"

	if sum_actual < 0:
		result_code = "ERR_PATH_INVALID"
	elif current_node != str(level_data.get("end_node", "E")):
		result_code = "ERR_INCOMPLETE"
	elif not _path_has_all_transit(path):
		n_transit += 1
		constraint_violations += 1
		result_code = "ERR_MISSING_TRANSIT"
	elif cycle_events > 0:
		n_cycle += 1
		constraint_violations += 1
		result_code = "ERR_CYCLE"
	elif input_regex.search(input_text) == null:
		n_parse += 1
		result_code = "ERR_PARSE"
	else:
		sum_input_value = int(input_text)
		if int(sum_input_value) != sum_actual:
			n_calc += 1
			result_code = "ERR_CALC"
		elif sum_actual != min_sum:
			n_opt += 1
			result_code = "ERR_NOT_OPT"

	return {
		"result_code": result_code,
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"must_visit_ok": _path_has_all_transit(path)
	}

func _compute_path_sum() -> int:
	var total := 0
	for i in range(path.size() - 1):
		var from_id := path[i]
		var to_id := path[i + 1]
		if not adjacency.has(from_id) or not adjacency[from_id].has(to_id):
			return -1
		total += int(adjacency[from_id][to_id])
	return total

func _recalculate_stability() -> void:
	var trust_cfg: Dictionary = level_data.get("trust", {})
	var overtime_div := int(trust_cfg.get("overtime_div", 2))
	overtime_div = maxi(1, overtime_div)
	var overtime: int = maxi(0, t_elapsed_seconds - int(level_data.get("time_limit_sec", 120)))
	var overtime_penalty := int(floor(float(overtime) / float(overtime_div)))

	var penalties := (
		n_calc * int(trust_cfg.get("penalty_calc", 25))
		+ n_opt * int(trust_cfg.get("penalty_opt", 25))
		+ n_parse * int(trust_cfg.get("penalty_parse", 5))
		+ n_reset * int(trust_cfg.get("penalty_reset", 5))
		+ n_transit * int(trust_cfg.get("penalty_transit", 25))
		+ n_cycle * int(trust_cfg.get("penalty_cycle", 10))
		+ overtime_penalty
	)

	stability = clampf(float(trust_cfg.get("initial", 100)) - float(penalties), 0.0, 100.0)
	label_state.text = "СТАБИЛЬНОСТЬ: %d%%" % int(stability)

	if stability <= 10.0 and not is_game_over:
		is_game_over = true
		status_label.text = "МИССИЯ ПРОВАЛЕНА: КРИТИЧЕСКАЯ СТАБИЛЬНОСТЬ."
		status_label.add_theme_color_override("font_color", Color(1.0, 0.30, 0.30))
		btn_submit.disabled = true
		btn_reset.disabled = true
		_update_visuals()

func _update_timer_display() -> void:
	var time_limit := int(level_data.get("time_limit_sec", 120))
	var remaining: int = maxi(0, time_limit - t_elapsed_seconds)
	var mm: int = remaining / 60
	var ss: int = remaining % 60
	label_timer.text = "ВРЕМЯ: %02d:%02d" % [mm, ss]
	if t_elapsed_seconds > time_limit:
		label_timer.add_theme_color_override("font_color", Color(1.0, 0.36, 0.36))
	else:
		label_timer.add_theme_color_override("font_color", Color(1, 1, 1))

func _log_attempt(verdict: Dictionary) -> void:
	var sum_actual := int(verdict.get("sum_actual", -1))
	var sum_input_value: Variant = verdict.get("sum_input", null)
	var result_code := str(verdict.get("result_code", "ERR_UNKNOWN"))
	var must_visit_ok := bool(verdict.get("must_visit_ok", false))

	var attempt_no := GlobalMetrics.session_history.size() + 1
	var log_data := {
		"schema_version": "city_map.v2.1.0",
		"quest_id": "CITY_MAP",
		"stage": "B",
		"task_id": str(level_data.get("level_id", "6.2")),
		"match_key": "CITY_MAP|B|%s|v%s" % [str(level_data.get("level_id", "6.2")), config_hash.substr(0, 8)],
		"variant_hash": config_hash,
		"contract_version": str(level_data.get("contract_version", "city_map.v2.1.0")),
		"attempt_no": attempt_no,
		"result_code": result_code,
		"calc_ok": sum_input_value != null and int(sum_input_value) == sum_actual,
		"optimal_ok": sum_actual == min_sum and result_code == "OK" and must_visit_ok,
		"must_visit_ok": must_visit_ok,
		"first_attempt_edge": null if first_attempt_edge.is_empty() else first_attempt_edge,
		"t_elapsed_seconds": t_elapsed_seconds,
		"path": path.duplicate(),
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"min_sum": min_sum,
		"backtrack_count": backtrack_count,
		"cycle_events": cycle_events,
		"constraint_violations": constraint_violations,
		"stability_final": int(stability),
		"n_calc": n_calc,
		"n_opt": n_opt,
		"n_parse": n_parse,
		"n_reset": n_reset,
		"n_transit": n_transit,
		"n_cycle": n_cycle,
		"is_correct": result_code == "OK",
		"is_fit": result_code == "OK",
		"stability_delta": 0,
		"elapsed_ms": t_elapsed_seconds * 1000,
		"duration": float(t_elapsed_seconds),
		"time_to_first_action_ms": first_action_ms if first_action_ms >= 0 else t_elapsed_seconds * 1000,
		"error_type": "NONE" if result_code == "OK" else result_code
	}

	GlobalMetrics.register_trial(log_data)
	_save_json_log(log_data)

func _save_json_log(data: Dictionary) -> void:
	var dir := DirAccess.open("user://")
	if dir == null:
		return
	if not dir.dir_exists("research_logs"):
		dir.make_dir("research_logs")

	var filename := "user://research_logs/%s_%d.json" % [LOG_PREFIX, Time.get_unix_time_from_system()]
	var file := FileAccess.open(filename, FileAccess.WRITE)
	if file != null:
		file.store_string(JSON.stringify(data, "\t"))
		file.close()
</file>

<file path="scenes/CityMapQuestC.gd">
extends Control

const LEVEL_PATH := "res://data/city_map/level_6_3.json"
const LOG_PREFIX := "case_6_3"
const DEFAULT_ACCENT := Color(0.40, 0.72, 1.0, 1.0)
const ARROW_ANGLE_RAD := 0.52
const ARROW_LEN := 16.0

@onready var content_split: BoxContainer = $SafeArea/MainVBox/ContentSplit
@onready var graph_container: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer
@onready var edges_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/EdgesLayer
@onready var nodes_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/NodesLayer
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack
@onready var btn_reset: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnReset
@onready var btn_submit: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnSubmit
@onready var sum_input: LineEdit = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumInput
@onready var path_display: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/PathDisplay
@onready var sim_time_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SimTimeLabel
@onready var sum_live_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumLiveLabel
@onready var constraint_info_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ConstraintInfoLabel
@onready var warning_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/WarningLabel
@onready var status_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/StatusLabel
@onready var schedule_list: VBoxContainer = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SchedulePanel/ScheduleMargin/ScheduleVBox/ScheduleScroll/ScheduleList
@onready var label_state: Label = $SafeArea/MainVBox/Header/LabelState
@onready var label_timer: Label = $SafeArea/MainVBox/Header/LabelTimer
@onready var footer_label: Label = $SafeArea/MainVBox/Footer/FooterLabel
@onready var briefing_title: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingTitle
@onready var briefing_text: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingText
@onready var briefing_constraint: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/ConstraintLabel

var level_data: Dictionary = {}
var node_defs: Dictionary = {}
var adjacency: Dictionary = {}
var edge_visuals: Dictionary = {}
var node_buttons: Dictionary = {}
var config_hash: String = ""
var input_regex := RegEx.new()

var min_sum: int = 0
var accent_color: Color = DEFAULT_ACCENT
var node_radius_px: float = 25.0
var must_visit_nodes: Array[String] = []
var blacklist_nodes: Array[String] = []
var xor_groups: Array = []

var current_node: String = ""
var path: Array[String] = []
var path_sum: int = 0
var step_weights: Array[int] = []
var stability: float = 100.0
var real_time_sec: int = 0
var sim_time_sec: int = 0
var is_game_over: bool = false
var first_attempt_edge: String = ""
var level_started_ms: int = 0
var first_action_ms: int = -1
var planning_time_ms: int = 0

var backtrack_count: int = 0
var cycle_events: int = 0
var cycle_detected: bool = false
var constraint_violations: int = 0
var closed_edge_attempts: int = 0
var ambush_hits: int = 0
var xor_violation: bool = false
var dynamic_weight_awareness: bool = true

var n_calc: int = 0
var n_opt: int = 0
var n_parse: int = 0
var n_reset: int = 0
var n_transit: int = 0
var n_logic: int = 0
var n_closed: int = 0

func _ready() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	sum_input.text_changed.connect(_on_sum_input_changed)
	graph_container.resized.connect(_on_graph_resized)

	_load_level_data(LEVEL_PATH)
	_apply_content_layout_mode()
	_setup_timer()
	call_deferred("_post_ready")

func _post_ready() -> void:
	_set_briefing()
	_rebuild_graph_ui()
	_build_schedule_ui()
	_reset_round_state(true)
	_update_timer_display()
	_recalculate_stability()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_content_layout_mode()
		_rebuild_graph_ui()
		_update_visuals()
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_OUT:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = true
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_IN:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = false

func _apply_content_layout_mode() -> void:
	content_split.vertical = get_viewport_rect().size.x < get_viewport_rect().size.y

func _setup_timer() -> void:
	var timer := Timer.new()
	timer.name = "ResearchTimer"
	timer.wait_time = 1.0
	timer.autostart = true
	timer.timeout.connect(_on_timer_tick)
	add_child(timer)

func _on_timer_tick() -> void:
	if is_game_over:
		return
	real_time_sec += 1
	_update_timer_display()
	if real_time_sec > int(level_data.get("time_limit_sec", 140)):
		_recalculate_stability()

func _load_level_data(path_to_file: String) -> void:
	var file := FileAccess.open(path_to_file, FileAccess.READ)
	if file == null:
		push_error("Failed to open level data: %s" % path_to_file)
		return

	var raw_json := file.get_as_text()
	config_hash = raw_json.sha256_text()
	var parsed: Variant = JSON.parse_string(raw_json)
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid level JSON in %s" % path_to_file)
		return

	level_data = parsed
	node_defs.clear()
	adjacency.clear()
	must_visit_nodes.clear()
	blacklist_nodes.clear()
	xor_groups.clear()

	for node_var in level_data.get("nodes", []):
		var node: Dictionary = node_var
		node_defs[str(node.get("id", ""))] = node

	for must_var in level_data.get("constraints", {}).get("must_visit", []):
		must_visit_nodes.append(str(must_var))
	for blacklist_var in level_data.get("constraints", {}).get("blacklist_nodes", []):
		blacklist_nodes.append(str(blacklist_var))
	for xor_var in level_data.get("constraints", {}).get("xor_groups", []):
		xor_groups.append(xor_var)

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty():
			continue
		if not adjacency.has(from_id):
			adjacency[from_id] = {}
		adjacency[from_id][to_id] = edge

	input_regex = RegEx.new()
	var regex_pattern := "^[0-9]+$"
	if level_data.has("rules") and level_data.rules.has("input_regex"):
		regex_pattern = str(level_data.rules.input_regex)
	input_regex.compile(regex_pattern)

	min_sum = int(level_data.get("min_sum", -1))
	if min_sum < 0:
		min_sum = _calculate_min_sum_dynamic()

	if level_data.has("ui"):
		if level_data.ui.has("accent_color"):
			accent_color = Color(level_data.ui.accent_color)
		if level_data.ui.has("node_radius_px"):
			var raw_radius := float(level_data.ui.node_radius_px)
			node_radius_px = raw_radius * 0.5 if raw_radius > 32.0 else raw_radius
			node_radius_px = maxf(16.0, node_radius_px)

func _set_briefing() -> void:
	briefing_title.text = "ОКНО КОМЕНДАНТСКОГО ЧАСА"
	briefing_text.text = "Доберитесь до узла L в условиях динамических окон патруля. Рёбра ЗАКРЫТО заблокированы, рёбра ОПАСНО имеют повышенную стоимость."
	var constraint_text := "ОГРАНИЧЕНИЕ: ОБЯЗАТЕЛЬНО %s | НЕ БОЛЕЕ ОДНОГО ИЗ (E,G) | ИЗБЕГАТЬ %s" % [
		"-" if must_visit_nodes.is_empty() else ",".join(must_visit_nodes),
		"-" if blacklist_nodes.is_empty() else ",".join(blacklist_nodes)
	]
	briefing_constraint.text = constraint_text
	constraint_info_label.text = constraint_text
	footer_label.text = "РЕАЛЬНЫЙ таймер в заголовке. СИМ-время меняется только при успешном перемещении."

func _build_schedule_ui() -> void:
	for child in schedule_list.get_children():
		child.queue_free()

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		if not edge.has("schedule"):
			continue
		var parts: Array[String] = []
		for slot_var in edge.schedule:
			var slot: Dictionary = slot_var
			var state := str(slot.get("state", "open"))
			var w_text := "ЗАКРЫТО" if state == "closed" else str(slot.get("w", edge.get("w", 0)))
			parts.append("[%d-%d: %s]" % [int(slot.get("t_from", 0)), int(slot.get("t_to", 0)), w_text])

		var row := Label.new()
		row.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
		row.text = "%s->%s: %s" % [str(edge.get("from", "")), str(edge.get("to", "")), " ".join(parts)]
		schedule_list.add_child(row)

func _calculate_min_sum_dynamic() -> int:
	var start_node := str(level_data.get("start_node", ""))
	var end_node := str(level_data.get("end_node", ""))
	if start_node.is_empty() or end_node.is_empty():
		return 0

	var frontier: Array[Dictionary] = [{
		"node": start_node,
		"sim": 0,
		"cost": 0,
		"path": [start_node]
	}]
	var best := 1_000_000_000

	while not frontier.is_empty():
		var best_index := 0
		for i in range(1, frontier.size()):
			if int(frontier[i].cost) < int(frontier[best_index].cost):
				best_index = i
		var state: Dictionary = frontier.pop_at(best_index)

		var node_id := str(state.node)
		var sim := int(state.sim)
		var cost := int(state.cost)
		var path_local: Array = state.path
		if cost >= best:
			continue

		if node_id == end_node and _must_visit_ok(path_local) and not _is_xor_violation(path_local) and not _path_has_blacklist(path_local):
			best = min(best, cost)
			continue

		for next_id in adjacency.get(node_id, {}).keys():
			var edge: Dictionary = adjacency[node_id][next_id]
			var runtime := _edge_runtime_state(edge, sim)
			if runtime.state == "closed":
				continue

			var visits := 0
			for p in path_local:
				if str(p) == str(next_id):
					visits += 1
			if visits >= 2:
				continue

			var next_path := path_local + [str(next_id)]
			if _is_xor_violation(next_path):
				continue
			if _path_has_blacklist(next_path):
				continue

			frontier.append({
				"node": str(next_id),
				"sim": sim + int(runtime.weight),
				"cost": cost + int(runtime.weight),
				"path": next_path
			})

	return 0 if best >= 1_000_000_000 else best

func _on_graph_resized() -> void:
	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return
	_rebuild_graph_ui()
	_update_visuals()

func _rebuild_graph_ui() -> void:
	for child in edges_layer.get_children():
		child.queue_free()
	for child in nodes_layer.get_children():
		child.queue_free()
	edge_visuals.clear()
	node_buttons.clear()

	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty() or not node_defs.has(from_id) or not node_defs.has(to_id):
			continue

		var start_pos := _node_screen_pos(node_defs[from_id])
		var end_pos := _node_screen_pos(node_defs[to_id])
		var line := Line2D.new()
		line.width = 4.0
		line.points = PackedVector2Array([start_pos, end_pos])
		line.gradient = _build_gradient(Color(0.18, 0.22, 0.30, 0.28), Color(0.30, 0.38, 0.52, 0.48))
		edges_layer.add_child(line)

		var arrow := _create_arrow_polygon(start_pos, end_pos)
		edges_layer.add_child(arrow)

		var label := Label.new()
		label.text = str(edge.get("w", 0))
		label.add_theme_font_size_override("font_size", 15)
		label.position = _edge_label_pos(start_pos, end_pos)
		label.add_theme_color_override("font_color", Color(0.62, 0.74, 0.90))
		edges_layer.add_child(label)

		edge_visuals[_edge_key(from_id, to_id)] = {
			"line": line,
			"arrow": arrow,
			"label": label,
			"edge": edge
		}

	for node_id in node_defs.keys():
		var node: Dictionary = node_defs[node_id]
		var btn := Button.new()
		btn.text = str(node.get("label", node_id))
		var diameter := node_radius_px * 2.0
		btn.size = Vector2(diameter, diameter)
		btn.position = _node_screen_pos(node) - Vector2(node_radius_px, node_radius_px)
		btn.pressed.connect(_on_node_pressed.bind(node_id))
		nodes_layer.add_child(btn)
		node_buttons[node_id] = btn

func _edge_label_pos(start_pos: Vector2, end_pos: Vector2) -> Vector2:
	var dir := (end_pos - start_pos).normalized()
	var normal := Vector2(-dir.y, dir.x)
	return ((start_pos + end_pos) * 0.5) + (normal * 12.0) - Vector2(10.0, 10.0)

func _create_arrow_polygon(start_pos: Vector2, end_pos: Vector2) -> Polygon2D:
	var dir := (end_pos - start_pos).normalized()
	var tip := end_pos - dir * (node_radius_px + 4.0)
	var base := tip - dir * ARROW_LEN
	var side_len := ARROW_LEN * 0.65

	var polygon := Polygon2D.new()
	polygon.polygon = PackedVector2Array([
		tip,
		base + dir.rotated(ARROW_ANGLE_RAD) * side_len,
		base + dir.rotated(-ARROW_ANGLE_RAD) * side_len
	])
	polygon.color = Color(0.45, 0.66, 0.96, 0.95)
	return polygon

func _build_gradient(start_color: Color, end_color: Color) -> Gradient:
	var gradient := Gradient.new()
	gradient.set_color(0, start_color)
	gradient.set_color(1, end_color)
	return gradient

func _node_screen_pos(node_data: Dictionary) -> Vector2:
	var pos: Dictionary = node_data.get("pos", {})
	var x := float(pos.get("x", 0.0))
	var y := float(pos.get("y", 0.0))

	if x >= 0.0 and x <= 1.0 and y >= 0.0 and y <= 1.0:
		var padding := node_radius_px + 4.0
		var usable := graph_container.size - Vector2(padding * 2.0, padding * 2.0)
		usable.x = maxf(1.0, usable.x)
		usable.y = maxf(1.0, usable.y)
		return Vector2(padding + x * usable.x, padding + y * usable.y)

	return Vector2(x, y)

func _reset_round_state(full_reset: bool) -> void:
	current_node = str(level_data.get("start_node", "A"))
	path = [current_node]
	path_sum = 0
	step_weights.clear()
	sim_time_sec = 0
	backtrack_count = 0
	cycle_events = 0
	cycle_detected = false
	constraint_violations = 0
	closed_edge_attempts = 0
	ambush_hits = 0
	xor_violation = false
	dynamic_weight_awareness = true
	first_attempt_edge = ""
	first_action_ms = -1
	planning_time_ms = 0
	sum_input.clear()
	status_label.text = ""

	if full_reset:
		level_started_ms = Time.get_ticks_msec()
		real_time_sec = 0

	_update_visuals()

func _update_visuals() -> void:
	path_display.text = "ПУТЬ: %s" % " -> ".join(path)
	sim_time_label.text = "СИМ: %d" % sim_time_sec
	sum_live_label.text = "СУММА: %d" % path_sum

	if xor_violation:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: НАРУШЕНИЕ XOR"
	elif _path_has_blacklist(path):
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ВХОД В ЧЁРНЫЙ СПИСОК"
	elif closed_edge_attempts > 0:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ЗАКРЫТОЕ РЕБРО ЗАБЛОКИРОВАНО"
	elif cycle_detected:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: ОБНАРУЖЕН ЦИКЛ"
	else:
		warning_label.text = "ПРЕДУПРЕЖДЕНИЯ: -"

	for node_id in node_buttons.keys():
		var btn: Button = node_buttons[node_id]
		var is_current: bool = node_id == current_node
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(node_id)
		btn.disabled = is_current or not is_available or is_game_over
		if is_current:
			btn.modulate = Color(0.95, 0.86, 0.45)
		elif is_available:
			btn.modulate = Color(1, 1, 1)
		else:
			btn.modulate = Color(0.42, 0.46, 0.56)

	for key in edge_visuals.keys():
		var visual: Dictionary = edge_visuals[key]
		var edge: Dictionary = visual.edge
		var runtime := _edge_runtime_state(edge, sim_time_sec)
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(str(edge.get("to", ""))) and str(edge.get("from", "")) == current_node
		var is_traversed: bool = _path_contains_edge(str(edge.get("from", "")), str(edge.get("to", "")))

		var state := "dim"
		if is_traversed:
			state = "traversed"
		elif runtime.state == "closed":
			state = "closed"
		elif runtime.danger:
			state = "danger"
		elif is_available:
			state = "available"

		_apply_edge_style(key, state, runtime)

func _apply_edge_style(key: String, state: String, runtime: Dictionary) -> void:
	if not edge_visuals.has(key):
		return
	var visual: Dictionary = edge_visuals[key]
	var line: Line2D = visual.line
	var arrow: Polygon2D = visual.arrow
	var label: Label = visual.label

	var start_color := Color(0.18, 0.22, 0.30, 0.28)
	var end_color := Color(0.30, 0.38, 0.52, 0.48)
	var label_text := str(runtime.weight)

	match state:
		"available":
			start_color = Color(0.24, 0.40, 0.62, 0.48)
			end_color = accent_color
			end_color.a = 0.95
		"traversed":
			start_color = accent_color.lightened(0.10)
			start_color.a = 0.80
			end_color = Color(0.92, 0.97, 1.0, 1.0)
		"closed":
			start_color = Color(0.58, 0.14, 0.14, 0.55)
			end_color = Color(1.0, 0.25, 0.25, 1.0)
			label_text = "ЗАКРЫТО"
		"danger":
			start_color = Color(0.62, 0.35, 0.12, 0.60)
			end_color = Color(1.0, 0.62, 0.18, 1.0)
			label_text = "%d ОПАСНО" % int(runtime.weight)

	line.gradient = _build_gradient(start_color, end_color)
	arrow.color = end_color
	label.text = label_text
	label.add_theme_color_override("font_color", end_color.lightened(0.10))

func _path_contains_edge(from_id: String, to_id: String) -> bool:
	for i in range(path.size() - 1):
		if path[i] == from_id and path[i + 1] == to_id:
			return true
	return false

func _edge_key(from_id: String, to_id: String) -> String:
	return "%s->%s" % [from_id, to_id]

func _edge_runtime_state(edge: Dictionary, time_sec: int) -> Dictionary:
	var base_weight := int(edge.get("w", 0))
	var active_weight := base_weight
	var active_state := "open"

	if edge.has("schedule"):
		for slot_var in edge.schedule:
			var slot: Dictionary = slot_var
			var from_t := int(slot.get("t_from", 0))
			var to_t := int(slot.get("t_to", 0))
			if time_sec >= from_t and time_sec < to_t:
				active_state = str(slot.get("state", "open"))
				active_weight = int(slot.get("w", base_weight))
				break

	return {
		"weight": active_weight,
		"state": active_state,
		"danger": active_state != "closed" and active_weight > base_weight
	}

func _on_node_pressed(node_id: String) -> void:
	if is_game_over:
		return
	if not adjacency.has(current_node) or not adjacency[current_node].has(node_id):
		return

	if first_attempt_edge.is_empty():
		first_attempt_edge = _edge_key(current_node, node_id)
		first_action_ms = Time.get_ticks_msec() - level_started_ms
		planning_time_ms = first_action_ms

	if path.size() >= 2 and path[path.size() - 2] == node_id:
		backtrack_count += 1
	if path.has(node_id):
		cycle_events += 1
		cycle_detected = true

	var edge: Dictionary = adjacency[current_node][node_id]
	var runtime := _edge_runtime_state(edge, sim_time_sec)
	if runtime.state == "closed":
		closed_edge_attempts += 1
		n_closed += 1
		dynamic_weight_awareness = false
		status_label.text = "ЗАКРЫТОЕ РЕБРО: перемещение заблокировано"
		status_label.add_theme_color_override("font_color", Color(1.0, 0.35, 0.35))
		_recalculate_stability()
		_update_visuals()
		return

	if runtime.danger:
		dynamic_weight_awareness = false

	path_sum += int(runtime.weight)
	step_weights.append(int(runtime.weight))
	sim_time_sec += int(runtime.weight)
	path.append(node_id)
	current_node = node_id

	if blacklist_nodes.has(node_id):
		ambush_hits += 1
		constraint_violations += 1
		status_label.text = "ЗАСАДА: вход в узел чёрного списка"
		status_label.add_theme_color_override("font_color", Color(1.0, 0.42, 0.30))

	if _is_xor_violation(path) and not xor_violation:
		xor_violation = true
		n_logic += 1
		constraint_violations += 1
		status_label.text = "НАРУШЕНИЕ XOR: в группе допускается не более одного узла"
		status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.18))

	_recalculate_stability()
	_update_visuals()

func _on_reset_pressed() -> void:
	if is_game_over:
		return
	n_reset += 1
	_reset_round_state(false)
	_recalculate_stability()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_sum_input_changed(new_text: String) -> void:
	var digits := ""
	for ch in new_text:
		if ch >= "0" and ch <= "9":
			digits += ch
	if digits != new_text:
		sum_input.text = digits
		sum_input.caret_column = digits.length()

func _on_submit_pressed() -> void:
	if is_game_over:
		return

	var verdict := _judge_solution(sum_input.text.strip_edges())
	_log_attempt(verdict)

	if verdict.result_code == "OK":
		status_label.text = "Маршрут принят. Динамические ограничения соблюдены."
		status_label.add_theme_color_override("font_color", Color(0.38, 1.0, 0.62))
		is_game_over = true
		btn_submit.disabled = true
		btn_reset.disabled = true
		_update_visuals()
		return

	status_label.text = _result_message(str(verdict.result_code))
	status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.28))
	_recalculate_stability()

func _result_message(result_code: String) -> String:
	match result_code:
		"ERR_INCOMPLETE":
			return "Дойдите до узла L перед отправкой."
		"ERR_MISSING_TRANSIT":
			return "Ограничение не выполнено: посетите обязательные транзитные узлы."
		"ERR_LOGIC_VIOLATION":
			return "Нарушено ограничение XOR."
		"ERR_AMBUSH":
			return "Посещён узел из чёрного списка."
		"ERR_PARSE":
			return "Вводите только цифры."
		"ERR_CALC":
			return "Введённая сумма не совпадает со смоделированной стоимостью пути."
		"ERR_NOT_OPT":
			return "Маршрут корректный, но не оптимальный."
		"ERR_PATH_INVALID":
			return "Маршрут недопустим для ориентированных рёбер."
		_:
			return "Необработанный результат: %s" % result_code

func _judge_solution(input_text: String) -> Dictionary:
	var sum_actual := _compute_path_sum()
	var sum_input_value: Variant = null
	var result_code := "OK"

	if sum_actual < 0:
		result_code = "ERR_PATH_INVALID"
	elif current_node != str(level_data.get("end_node", "L")):
		result_code = "ERR_INCOMPLETE"
	elif not _must_visit_ok(path):
		n_transit += 1
		constraint_violations += 1
		result_code = "ERR_MISSING_TRANSIT"
	elif _is_xor_violation(path):
		if not xor_violation:
			xor_violation = true
			n_logic += 1
		constraint_violations += 1
		result_code = "ERR_LOGIC_VIOLATION"
	elif _path_has_blacklist(path):
		result_code = "ERR_AMBUSH"
	elif input_regex.search(input_text) == null:
		n_parse += 1
		result_code = "ERR_PARSE"
	else:
		sum_input_value = int(input_text)
		if int(sum_input_value) != sum_actual:
			n_calc += 1
			result_code = "ERR_CALC"
		elif sum_actual != min_sum:
			n_opt += 1
			result_code = "ERR_NOT_OPT"

	return {
		"result_code": result_code,
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"must_visit_ok": _must_visit_ok(path)
	}

func _compute_path_sum() -> int:
	var total := 0
	for i in range(path.size() - 1):
		var from_id := path[i]
		var to_id := path[i + 1]
		if not adjacency.has(from_id) or not adjacency[from_id].has(to_id):
			return -1
		total += int(step_weights[i]) if i < step_weights.size() else 0
	return total

func _must_visit_ok(path_local: Array) -> bool:
	for node_id in must_visit_nodes:
		if not path_local.has(node_id):
			return false
	return true

func _path_has_blacklist(path_local: Array) -> bool:
	for node_id in blacklist_nodes:
		if path_local.has(node_id):
			return true
	return false

func _is_xor_violation(path_local: Array) -> bool:
	for group_var in xor_groups:
		var group: Dictionary = group_var
		if str(group.get("type", "")) != "AT_MOST_ONE":
			continue
		var count := 0
		for node_id_var in group.get("nodes", []):
			if path_local.has(str(node_id_var)):
				count += 1
		if count > 1:
			return true
	return false

func _recalculate_stability() -> void:
	var trust_cfg: Dictionary = level_data.get("trust", {})
	var overtime_div := int(trust_cfg.get("overtime_div", 2))
	overtime_div = maxi(1, overtime_div)
	var overtime: int = maxi(0, real_time_sec - int(level_data.get("time_limit_sec", 140)))
	var overtime_penalty := int(floor(float(overtime) / float(overtime_div)))

	var penalties := (
		n_calc * int(trust_cfg.get("penalty_calc", 25))
		+ n_opt * int(trust_cfg.get("penalty_opt", 25))
		+ n_parse * int(trust_cfg.get("penalty_parse", 5))
		+ n_reset * int(trust_cfg.get("penalty_reset", 5))
		+ n_transit * int(trust_cfg.get("penalty_transit", 25))
		+ n_logic * int(trust_cfg.get("penalty_logic_violation", 30))
		+ n_closed * int(trust_cfg.get("penalty_closed_edge", 8))
		+ overtime_penalty
	)

	var effective := float(trust_cfg.get("initial", 100)) - float(penalties)
	var ambush_multiplier := float(trust_cfg.get("ambush_multiplier", 0.5))
	for _i in range(ambush_hits):
		effective *= ambush_multiplier

	stability = clampf(effective, 0.0, 100.0)
	label_state.text = "СТАБИЛЬНОСТЬ: %d%%" % int(stability)

	var fail_threshold := float(trust_cfg.get("fail_threshold", 10))
	if stability <= fail_threshold and not is_game_over:
		is_game_over = true
		status_label.text = "МИССИЯ ПРОВАЛЕНА: КРИТИЧЕСКАЯ СТАБИЛЬНОСТЬ."
		status_label.add_theme_color_override("font_color", Color(1.0, 0.30, 0.30))
		btn_submit.disabled = true
		btn_reset.disabled = true
		_update_visuals()

func _update_timer_display() -> void:
	var time_limit := int(level_data.get("time_limit_sec", 140))
	var remaining: int = maxi(0, time_limit - real_time_sec)
	var mm: int = remaining / 60
	var ss: int = remaining % 60
	label_timer.text = "ВРЕМЯ: %02d:%02d" % [mm, ss]
	if real_time_sec > time_limit:
		label_timer.add_theme_color_override("font_color", Color(1.0, 0.36, 0.36))
	else:
		label_timer.add_theme_color_override("font_color", Color(1, 1, 1))

func _log_attempt(verdict: Dictionary) -> void:
	var sum_actual := int(verdict.get("sum_actual", -1))
	var sum_input_value: Variant = verdict.get("sum_input", null)
	var result_code := str(verdict.get("result_code", "ERR_UNKNOWN"))
	var must_visit_ok := bool(verdict.get("must_visit_ok", false))

	var attempt_no := GlobalMetrics.session_history.size() + 1
	var log_data := {
		"schema_version": "city_map.v2.1.0",
		"quest_id": "CITY_MAP",
		"stage": "C",
		"task_id": str(level_data.get("level_id", "6.3")),
		"match_key": "CITY_MAP|C|%s|v%s" % [str(level_data.get("level_id", "6.3")), config_hash.substr(0, 8)],
		"variant_hash": config_hash,
		"contract_version": str(level_data.get("contract_version", "city_map.v2.1.0")),
		"attempt_no": attempt_no,
		"result_code": result_code,
		"calc_ok": sum_input_value != null and int(sum_input_value) == sum_actual,
		"optimal_ok": sum_actual == min_sum and result_code == "OK" and must_visit_ok and not xor_violation and not _path_has_blacklist(path),
		"must_visit_ok": must_visit_ok,
		"first_attempt_edge": null if first_attempt_edge.is_empty() else first_attempt_edge,
		"t_elapsed_seconds": real_time_sec,
		"path": path.duplicate(),
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"min_sum": min_sum,
		"backtrack_count": backtrack_count,
		"cycle_events": cycle_events,
		"constraint_violations": constraint_violations,
		"planning_time_ms": planning_time_ms,
		"dynamic_weight_awareness": dynamic_weight_awareness,
		"closed_edge_attempts": closed_edge_attempts,
		"ambush_hits": ambush_hits,
		"xor_violation": xor_violation,
		"sim_time_sec": sim_time_sec,
		"stability_final": int(stability),
		"n_calc": n_calc,
		"n_opt": n_opt,
		"n_parse": n_parse,
		"n_reset": n_reset,
		"n_transit": n_transit,
		"n_logic": n_logic,
		"n_closed": n_closed,
		"is_correct": result_code == "OK",
		"is_fit": result_code == "OK",
		"stability_delta": 0,
		"elapsed_ms": real_time_sec * 1000,
		"duration": float(real_time_sec),
		"time_to_first_action_ms": first_action_ms if first_action_ms >= 0 else real_time_sec * 1000,
		"error_type": "NONE" if result_code == "OK" else result_code
	}

	GlobalMetrics.register_trial(log_data)
	_save_json_log(log_data)

func _save_json_log(data: Dictionary) -> void:
	var dir := DirAccess.open("user://")
	if dir == null:
		return
	if not dir.dir_exists("research_logs"):
		dir.make_dir("research_logs")

	var filename := "user://research_logs/%s_%d.json" % [LOG_PREFIX, Time.get_unix_time_from_system()]
	var file := FileAccess.open(filename, FileAccess.WRITE)
	if file != null:
		file.store_string(JSON.stringify(data, "\t"))
		file.close()
</file>

<file path="scenes/decryptor/DecryptorUI.tscn">
[gd_scene load_steps=3 format=3 uid="uid://c4p1o1h01r4g6"]

[ext_resource type="Theme" uid="uid://cfgksggpp15wa" path="res://ui/theme_terminal_green.tres" id="1_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="2_overlay"]

[node name="DecryptorUI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("1_theme")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.05, 0.03, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("2_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="Main" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="HeaderBar" type="PanelContainer" parent="SafeArea/Main"]
custom_minimum_size = Vector2(0, 70)
layout_mode = 2
theme_type_variation = &"HeaderPanel"

[node name="HeaderContent" type="HBoxContainer" parent="SafeArea/Main/HeaderBar"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="BtnBack" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(64, 52)
layout_mode = 2
text = "<"

[node name="ModeChip" type="PanelContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(80, 40)
layout_mode = 2

[node name="ModeLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/ModeChip"]
layout_mode = 2
text = "ДЕК"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Spacer1" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LevelLabel" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
text = "ПРОТОКОЛ A-1"

[node name="Spacer2" type="Control" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
size_flags_horizontal = 3

[node name="StabilityGroup" type="VBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2

[node name="StabilityText" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup"]
custom_minimum_size = Vector2(170, 18)
layout_mode = 2
value = 100.0

[node name="Shields" type="HBoxContainer" parent="SafeArea/Main/HeaderBar/HeaderContent"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="ShieldFreq" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "F"

[node name="ShieldLazy" type="Label" parent="SafeArea/Main/HeaderBar/HeaderContent/Shields"]
custom_minimum_size = Vector2(24, 24)
layout_mode = 2
text = "L"

[node name="BtnDetails" type="Button" parent="SafeArea/Main/HeaderBar/HeaderContent"]
custom_minimum_size = Vector2(72, 48)
layout_mode = 2
text = "ЛОГ"

[node name="ContentSplit" type="HBoxContainer" parent="SafeArea/Main"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 12

[node name="LeftPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
size_flags_stretch_ratio = 1.45
theme_override_constants/separation = 10

[node name="TargetPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2

[node name="TargetContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="TargetTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent"]
layout_mode = 2
text = "ЦЕЛЬ"

[node name="TargetValueBig" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent"]
layout_mode = 2
theme_override_font_sizes/font_size = 36
text = "00"
horizontal_alignment = 1

[node name="TargetSub" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent"]
layout_mode = 2
horizontal_alignment = 1

[node name="InputPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2

[node name="InputContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="InputBin" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent"]
layout_mode = 2
text = "BIN: 0000 0000"

[node name="InputBasesRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="InputDec" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow"]
layout_mode = 2
text = "DEC: 0"

[node name="InputOct" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow"]
layout_mode = 2
text = "OCT: 0"

[node name="InputHex" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow"]
layout_mode = 2
text = "HEX: 0"

[node name="SwitchesPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/LeftPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="SwitchesContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 8

[node name="NibblesCenter" type="CenterContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="NibblesRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter"]
layout_mode = 2
theme_override_constants/separation = 12
alignment = 1

[node name="UpperNibble" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="UpperTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/UpperNibble"]
layout_mode = 2
text = "ВЫСОКИЙ"
horizontal_alignment = 1

[node name="UpperBits" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/UpperNibble"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="LowerNibble" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 4

[node name="LowerTitle" type="Label" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/LowerNibble"]
layout_mode = 2
text = "НИЗКИЙ"
horizontal_alignment = 1

[node name="LowerBits" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/LowerNibble"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 6

[node name="WeightsRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="RightPanel" type="VBoxContainer" parent="SafeArea/Main/ContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="RankPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="RankContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="RankTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent"]
layout_mode = 2
text = "РАНГ"

[node name="RankLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "НОВИЧОК"

[node name="ProgressLabel" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent"]
layout_mode = 2
text = "УРОВЕНЬ 1 / 30"

[node name="ProtocolPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="ProtocolContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="ProtocolTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent"]
layout_mode = 2
text = "ДИАГНОСТИКА ПРОТОКОЛА"

[node name="RegsRow" type="HBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="RegAValue" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow"]
layout_mode = 2
text = "A: --"

[node name="RegBValue" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow"]
layout_mode = 2
text = "B: --"

[node name="OpValue" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow"]
layout_mode = 2
text = "OP: --"

[node name="ShiftStatus" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent"]
layout_mode = 2
text = "СДВИГ: ожидание"

[node name="LiveLogPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="LiveLogContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 6

[node name="LiveLogTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
text = "ЖИВОЙ ТЕРМИНАЛ"

[node name="LiveLogText" type="RichTextLabel" parent="SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent"]
layout_mode = 2
size_flags_vertical = 3
scroll_following = true

[node name="HintPanel" type="PanelContainer" parent="SafeArea/Main/ContentSplit/RightPanel"]
layout_mode = 2

[node name="HintContent" type="VBoxContainer" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="HintTitle" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "ПОСЛЕДНЯЯ ДИАГНОСТИКА"

[node name="HintText" type="Label" parent="SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent"]
layout_mode = 2
text = "Диагностики пока нет."
autowrap_mode = 3

[node name="BottomBar" type="PanelContainer" parent="SafeArea/Main"]
layout_mode = 2
theme_type_variation = &"HeaderPanel"

[node name="Actions" type="HBoxContainer" parent="SafeArea/Main/BottomBar"]
layout_mode = 2
theme_override_constants/separation = 10
alignment = 1

[node name="BtnHint" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ПОДСКАЗКА"

[node name="BtnCheck" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ПРОВЕРИТЬ"

[node name="BtnReset" type="Button" parent="SafeArea/Main/BottomBar/Actions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "СБРОС"

[node name="ToastLayer" type="CanvasLayer" parent="."]

[node name="Toast" type="PanelContainer" parent="ToastLayer"]
visible = false
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -180.0
offset_top = -120.0
offset_right = 180.0
offset_bottom = -60.0
grow_horizontal = 2

[node name="ToastLabel" type="Label" parent="ToastLayer/Toast"]
layout_mode = 2
horizontal_alignment = 1
vertical_alignment = 1

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -380.0
grow_horizontal = 2
grow_vertical = 2

[node name="DetailsContent" type="VBoxContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="DetailsHeader" type="HBoxContainer" parent="DetailsSheet/DetailsContent"]
layout_mode = 2

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsContent/DetailsHeader"]
layout_mode = 2
text = "ДЕТАЛИ"

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsContent/DetailsHeader"]
custom_minimum_size = Vector2(84, 42)
layout_mode = 2
text = "ЗАКРЫТЬ"

[node name="DetailsScroll" type="ScrollContainer" parent="DetailsSheet/DetailsContent"]
custom_minimum_size = Vector2(0, 260)
layout_mode = 2

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsContent/DetailsScroll"]
layout_mode = 2
bbcode_enabled = true

[node name="SafeModeOverlay" type="CanvasLayer" parent="."]
visible = false

[node name="Dim" type="ColorRect" parent="SafeModeOverlay"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.6)

[node name="CenterContainer" type="CenterContainer" parent="SafeModeOverlay"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="SafePanel" type="PanelContainer" parent="SafeModeOverlay/CenterContainer"]
custom_minimum_size = Vector2(0, 360)
layout_mode = 2

[node name="SafeContent" type="VBoxContainer" parent="SafeModeOverlay/CenterContainer/SafePanel"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="SafeTitle" type="Label" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
layout_mode = 2
text = "БЕЗОПАСНЫЙ РЕЖИМ: АНАЛИЗ ОШИБОК"

[node name="SafeSummary" type="RichTextLabel" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
bbcode_enabled = true

[node name="SafeBitsRow" type="HBoxContainer" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
layout_mode = 2
theme_override_constants/separation = 6

[node name="SafeActions" type="HBoxContainer" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnRetry" type="Button" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ПОВТОРИТЬ"

[node name="BtnContinue" type="Button" parent="SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "ПРОДОЛЖИТЬ"
</file>

<file path="scenes/QuestSelect.tscn">
[gd_scene load_steps=6 format=3 uid="uid://c6l2jvi53qwcf"]

[ext_resource type="Script" path="res://scenes/QuestSelect.gd" id="1_script"]
[ext_resource type="Shader" path="res://scenes/Blur.gdshader" id="2_shader"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="3_theme"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="4_noir"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_1"]
shader = ExtResource("2_shader")
shader_parameter/lod = 2.5
shader_parameter/modulate = Color(0, 0, 0, 0.82)

[node name="QuestSelect" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("3_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.03, 0.03, 0.04, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("4_noir")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 24
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 24
theme_override_constants/margin_bottom = 16

[node name="MainLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 20
alignment = 1

[node name="Title" type="Label" parent="SafeArea/MainLayout"]
layout_mode = 2
theme_override_font_sizes/font_size = 58
text = "ВЫБОР КВЕСТА"
horizontal_alignment = 1

[node name="QuestGrid" type="GridContainer" parent="SafeArea/MainLayout"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/h_separation = 14
theme_override_constants/v_separation = 14
columns = 3

[node name="CluesButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Цифровая реанимация"

[node name="RadioButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Радиоперехват"

[node name="DecryptorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Дешифрование"

[node name="LieDetectorButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Детектор лжи"

[node name="SuspectScriptButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Скрипт подозреваемого"

[node name="CityMapButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Карта города"

[node name="DataArchiveButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Архив данных"

[node name="FinalReportButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Финальный отчет"

[node name="NetworkTraceButton" type="Button" parent="SafeArea/MainLayout/QuestGrid"]
custom_minimum_size = Vector2(280, 118)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Сетевой след"

[node name="StatusLabel" type="Label" parent="SafeArea/MainLayout"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Выберите квест"
horizontal_alignment = 1
vertical_alignment = 1

[node name="ModalLayer" type="CanvasLayer" parent="."]

[node name="ModeSelectionModal" type="Panel" parent="ModalLayer"]
visible = false
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundDim" type="ColorRect" parent="ModalLayer/ModeSelectionModal"]
material = SubResource("ShaderMaterial_1")
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="CenterContainer" type="CenterContainer" parent="ModalLayer/ModeSelectionModal"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="ModalLayer/ModeSelectionModal/CenterContainer"]
custom_minimum_size = Vector2(620, 420)
layout_mode = 2
theme_override_constants/separation = 20

[node name="ModalTitle" type="Label" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 44
text = "ВЫБОР СЛОЖНОСТИ"
horizontal_alignment = 1

[node name="BtnComplexityA" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 74)
layout_mode = 2
theme_override_font_sizes/font_size = 30
text = "СЛОЖНОСТЬ A"

[node name="BtnComplexityB" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 74)
layout_mode = 2
theme_override_font_sizes/font_size = 30
disabled = true
text = "СЛОЖНОСТЬ B"

[node name="BtnComplexityC" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 74)
layout_mode = 2
theme_override_font_sizes/font_size = 30
disabled = true
text = "СЛОЖНОСТЬ C"

[node name="BtnClose" type="Button" parent="ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "НАЗАД"
</file>

<file path="scenes/RadioQuestB.gd">
extends Control

enum Phase {
	CALC,
	SELECT,
	DONE
}

const POOL_NORMAL: Array[int] = [64, 80, 100, 128, 256, 512, 1024]
const POOL_ANCHOR: Array[int] = [75, 110, 125, 300, 750, 1000]
const SAMPLE_SLOTS: int = 7
const PHONE_LANDSCAPE_MAX_HEIGHT: float = 520.0

const COLOR_IDLE: Color = Color(0.18, 0.18, 0.18, 1.0)
const COLOR_GOOD: Color = Color(0.20, 0.90, 0.30, 1.0)
const COLOR_WARN: Color = Color(0.95, 0.75, 0.20, 1.0)
const COLOR_BAD: Color = Color(0.95, 0.25, 0.25, 1.0)

const TXT_TITLE: String = "\u0420\u0410\u0414\u0418\u041e\u041f\u0415\u0420\u0415\u0425\u0412\u0410\u0422 | B"
const TXT_BACK: String = "\u041d\u0410\u0417\u0410\u0414"
const TXT_STORAGE_TITLE: String = "\u0421\u041a\u041b\u0410\u0414 \u041d\u041e\u0421\u0418\u0422\u0415\u041b\u0415\u0419"
const TXT_CONTEXT_TITLE: String = "\u0422\u0415\u0420\u041c\u0418\u041d\u0410\u041b"
const TXT_TASK: String = "\u0412\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435 I = K*i \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_CALC_TITLE: String = "\u0420\u0410\u0421\u0427\u0401\u0422 I"
const TXT_BTN_CHECK: String = "\u041f\u0420\u041e\u0412\u0415\u0420\u0418\u0422\u042c"
const TXT_PREVIEW_TITLE: String = "\u0414\u0418\u0410\u0413\u041d\u041e\u0421\u0422\u0418\u041a\u0410"
const TXT_BTN_CONVERTER: String = "\u041a\u041e\u041d\u0412\u0415\u0420\u0422\u0415\u0420"
const TXT_BTN_CONFIRM: String = "\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u042c"
const TXT_BTN_NEXT: String = "\u0414\u0410\u041b\u0415\u0415"
const TXT_BTN_DETAILS_CLOSED: String = "\u041f\u041e\u0414\u0420\u041e\u0411\u041d\u0415\u0415 \u25be"
const TXT_BTN_DETAILS_OPEN: String = "\u0421\u041a\u0420\u042b\u0422\u042c \u25b4"
const TXT_DETAILS_TITLE: String = "\u041f\u041e\u042f\u0421\u041d\u0415\u041d\u0418\u0415"
const TXT_DETAILS_CLOSE: String = "\u0417\u0410\u041a\u0420\u042b\u0422\u042c"

const TXT_STATUS_PLAN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u0439\u0442\u0435 I, \u0437\u0430\u0442\u0435\u043c \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_STATUS_CALC_OK: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0420\u0430\u0441\u0447\u0451\u0442 I \u0432\u0435\u0440\u043d\u044b\u0439. \u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_STATUS_CALC_WARN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0420\u0430\u0441\u0447\u0451\u0442 I \u043d\u0435\u0442\u043e\u0447\u043d\u044b\u0439. \u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c \u043e\u0441\u043e\u0437\u043d\u0430\u043d\u043d\u043e."
const TXT_STATUS_CONVERTER: String = "\u0421\u0422\u0410\u0422\u0423\u0421: I = %d \u0431\u0438\u0442 (%d \u0431\u0430\u0439\u0442)."
const TXT_RESULT_BEST: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041e\u0442\u043b\u0438\u0447\u043d\u043e. \u041e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c."
const TXT_RESULT_UNDER: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e. \u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c \u043d\u0435 \u0432\u043c\u0435\u0449\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435."
const TXT_RESULT_CALC: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0412\u044b\u0431\u043e\u0440 \u0441\u0434\u0435\u043b\u0430\u043d, \u043d\u043e \u0440\u0430\u0441\u0447\u0451\u0442 I \u0431\u044b\u043b \u043d\u0435\u0442\u043e\u0447\u043d\u044b\u043c."
const TXT_RESULT_UNIT: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u043e\u0445\u043e\u0436\u0435 \u043d\u0430 \u043f\u0443\u0442\u0430\u043d\u0438\u0446\u0443 \u0435\u0434\u0438\u043d\u0438\u0446 (\u0431\u0438\u0442/\u0431\u0430\u0439\u0442)."
const TXT_RESULT_OVER: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0412\u0435\u0440\u043d\u043e, \u043d\u043e \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c \u0438\u0437\u0431\u044b\u0442\u043e\u0447\u0435\u043d."

@onready var safe_area: MarginContainer = $SafeArea
@onready var root_vbox: VBoxContainer = $SafeArea/RootVBox
@onready var body_split: HSplitContainer = $SafeArea/RootVBox/BodyHSplit
@onready var left_pane: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane
@onready var right_vbox: VBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox
@onready var storage_grid: GridContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid

@onready var btn_back: Button = $SafeArea/RootVBox/Header/HeaderHBox/BtnBack
@onready var title_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/TitleLabel
@onready var meta_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/MetaLabel

@onready var storage_title: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageTitle
@onready var storage_btns: Array[Button] = [
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn1,
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn2,
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn3,
	$SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid/StorageBtn4
]

@onready var context_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/ContextTitle
@onready var i_info_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/IInfoLabel
@onready var k_info_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/KInfoLabel
@onready var task_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox/TaskLabel

@onready var calc_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/CalcTitle
@onready var btn_minus: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow/BtnMinus
@onready var i_bits_value_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow/IBitsValue
@onready var btn_plus: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow/BtnPlus
@onready var btn_check_calc: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/BtnCheckCalc

@onready var preview_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewTitle
@onready var preview_calc_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewCalcLabel
@onready var preview_fit_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewFitLabel
@onready var preview_class_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox/PreviewClassLabel

@onready var btn_converter: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnConverter
@onready var btn_capture: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnCapture
@onready var btn_next: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnNext
@onready var sample_strip: HBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip
@onready var status_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/StatusLabel
@onready var btn_details: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/BtnDetails
@onready var footer_label: Label = $SafeArea/RootVBox/Footer/FooterMargin/FooterLabel

@onready var dimmer: ColorRect = $Dimmer
@onready var details_sheet: PanelContainer = $DetailsSheet
@onready var details_title: Label = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsTitle
@onready var details_text: RichTextLabel = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsText
@onready var btn_close_details: Button = $DetailsSheet/DetailsMargin/DetailsVBox/BtnCloseDetails

var phase: Phase = Phase.CALC
var i_bits: int = 7
var k_symbols: int = 0
var i_bits_true: int = 0
var i_bits_user: int = 0
var calc_checked: bool = false
var selected_storage_idx: int = -1
var storage_options: Array[Dictionary] = []
var used_converter: bool = false
var forced_sampling: bool = false
var is_timed: bool = false

var start_ms: int = 0
var first_action_ms: int = -1
var current_trial_idx: int = 0
var anchor_countdown: int = 0
var pool_type: String = "NORMAL"
var sample_refs: Array[Dictionary] = []

var _current_stability: float = 100.0
var _ui_ready: bool = false

func _ready() -> void:
	randomize()
	_apply_static_texts()
	_connect_signals()
	_collect_sample_refs()
	_reset_sample_strip()
	_set_details_visible(false)
	_apply_safe_area_padding()
	_configure_layout()

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	_on_stability_changed(GlobalMetrics.stability, 0.0)

	anchor_countdown = randi_range(7, 10)
	_start_trial()
	_ui_ready = true

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and _ui_ready:
		_apply_safe_area_padding()
		_configure_layout()

func _apply_static_texts() -> void:
	title_label.text = TXT_TITLE
	btn_back.text = TXT_BACK
	storage_title.text = TXT_STORAGE_TITLE
	context_title.text = TXT_CONTEXT_TITLE
	task_label.text = TXT_TASK
	calc_title.text = TXT_CALC_TITLE
	btn_minus.text = "-8"
	btn_plus.text = "+8"
	btn_check_calc.text = TXT_BTN_CHECK
	preview_title.text = TXT_PREVIEW_TITLE
	btn_converter.text = TXT_BTN_CONVERTER
	btn_capture.text = TXT_BTN_CONFIRM
	btn_next.text = TXT_BTN_NEXT
	btn_details.text = TXT_BTN_DETAILS_CLOSED
	details_title.text = TXT_DETAILS_TITLE
	btn_close_details.text = TXT_DETAILS_CLOSE

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_minus.pressed.connect(_on_minus_pressed)
	btn_plus.pressed.connect(_on_plus_pressed)
	btn_check_calc.pressed.connect(_on_check_calc_pressed)
	btn_converter.pressed.connect(_on_converter_pressed)
	btn_capture.pressed.connect(_on_capture_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_close_pressed)
	dimmer.gui_input.connect(_on_dimmer_gui_input)

	for idx in range(storage_btns.size()):
		storage_btns[idx].pressed.connect(_on_storage_selected.bind(idx))

func _collect_sample_refs() -> void:
	sample_refs.clear()
	for child_var in sample_strip.get_children():
		var child_node: Node = child_var as Node
		var bg_node: ColorRect = child_node.get_node_or_null("BG") as ColorRect
		var mark_node: Label = child_node.get_node_or_null("AnchorMark") as Label
		if bg_node != null and mark_node != null:
			sample_refs.append({"bg": bg_node, "mark": mark_node})

func _reset_sample_strip() -> void:
	for slot_var in sample_refs:
		var slot: Dictionary = slot_var as Dictionary
		var bg: ColorRect = slot["bg"] as ColorRect
		var mark: Label = slot["mark"] as Label
		bg.color = COLOR_IDLE
		mark.visible = false
	current_trial_idx = 0

func _start_trial() -> void:
	phase = Phase.CALC
	calc_checked = false
	selected_storage_idx = -1
	used_converter = false
	i_bits_user = 0
	start_ms = Time.get_ticks_msec()
	first_action_ms = -1

	if anchor_countdown <= 0:
		k_symbols = POOL_ANCHOR.pick_random()
		pool_type = "ANCHOR"
		anchor_countdown = randi_range(7, 10)
	else:
		k_symbols = POOL_NORMAL.pick_random()
		pool_type = "NORMAL"
		anchor_countdown -= 1

	i_bits_true = k_symbols * i_bits
	_generate_storage_options()

	i_info_label.text = "i = %d \u0431\u0438\u0442" % i_bits
	k_info_label.text = "K = %d \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432" % k_symbols
	i_bits_value_label.text = str(i_bits_user)
	i_bits_value_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))

	btn_minus.disabled = false
	btn_plus.disabled = false
	btn_check_calc.disabled = false
	btn_capture.disabled = true
	btn_capture.visible = true
	btn_next.visible = false

	for idx in range(storage_btns.size()):
		var btn: Button = storage_btns[idx]
		btn.disabled = true
		btn.button_pressed = false
		btn.text = _format_storage_option(storage_options[idx])
		btn.modulate = Color(1, 1, 1, 1)

	status_label.text = TXT_STATUS_PLAN
	status_label.add_theme_color_override("font_color", Color(0.85, 0.85, 0.85, 1.0))
	footer_label.text = ""
	_update_preview()
	_update_header_meta()
	_update_details_text()

func _generate_storage_options() -> void:
	storage_options.clear()

	var best_cap: int = 1
	while best_cap <= i_bits_true:
		best_cap *= 2
	if best_cap == i_bits_true:
		best_cap *= 2
	storage_options.append(_make_auto_option(best_cap, "BEST"))

	var under_cap: int = maxi(1, int(floor(float(i_bits_true) * 0.75)))
	storage_options.append(_make_auto_option(under_cap, "UNDER"))

	if i_bits_true % 8 == 0:
		storage_options.append({
			"capacity_bits": i_bits_true * 8,
			"display_size": i_bits_true,
			"display_unit": "\u0431\u0430\u0439\u0442",
			"tag": "UNIT_TRAP"
		})
	else:
		storage_options.append({
			"capacity_bits": i_bits_true * 8192,
			"display_size": i_bits_true,
			"display_unit": "\u041a\u0411",
			"tag": "UNIT_TRAP"
		})

	var over_cap: int = int(ceil((float(i_bits_true) * 4.0) / 100.0) * 100.0)
	storage_options.append(_make_auto_option(over_cap, "OVER"))

	storage_options.shuffle()

func _make_auto_option(capacity_bits: int, tag: String) -> Dictionary:
	var display_size: int = capacity_bits
	var display_unit: String = "\u0431\u0438\u0442"
	if capacity_bits >= 8192 and capacity_bits % 8192 == 0:
		display_size = capacity_bits / 8192
		display_unit = "\u041a\u0411"
	elif capacity_bits >= 8 and capacity_bits % 8 == 0:
		display_size = capacity_bits / 8
		display_unit = "\u0431\u0430\u0439\u0442"
	return {
		"capacity_bits": capacity_bits,
		"display_size": display_size,
		"display_unit": display_unit,
		"tag": tag
	}

func _format_storage_option(opt: Dictionary) -> String:
	return "%d %s" % [int(opt["display_size"]), str(opt["display_unit"])]

func _register_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec()

func _on_minus_pressed() -> void:
	if phase != Phase.CALC:
		return
	_register_action()
	i_bits_user = maxi(0, i_bits_user - 8)
	i_bits_value_label.text = str(i_bits_user)
	_update_preview()
	_update_details_text()

func _on_plus_pressed() -> void:
	if phase != Phase.CALC:
		return
	_register_action()
	i_bits_user += 8
	i_bits_value_label.text = str(i_bits_user)
	_update_preview()
	_update_details_text()

func _on_check_calc_pressed() -> void:
	if phase != Phase.CALC:
		return
	_register_action()

	calc_checked = true
	phase = Phase.SELECT

	for btn in storage_btns:
		btn.disabled = false

	btn_minus.disabled = true
	btn_plus.disabled = true
	btn_check_calc.disabled = true

	if i_bits_user == i_bits_true:
		status_label.text = TXT_STATUS_CALC_OK
		status_label.add_theme_color_override("font_color", COLOR_GOOD)
		i_bits_value_label.add_theme_color_override("font_color", COLOR_GOOD)
	else:
		status_label.text = TXT_STATUS_CALC_WARN
		status_label.add_theme_color_override("font_color", COLOR_WARN)
		i_bits_value_label.add_theme_color_override("font_color", COLOR_WARN)

	_update_preview()
	_update_details_text()

func _on_storage_selected(idx: int) -> void:
	if phase != Phase.SELECT:
		return
	_register_action()

	selected_storage_idx = idx
	for i in range(storage_btns.size()):
		storage_btns[i].button_pressed = (i == idx)
		storage_btns[i].modulate = Color(1, 1, 0.75, 1) if i == idx else Color(1, 1, 1, 1)

	btn_capture.disabled = false
	_update_preview()
	_update_details_text()

func _on_converter_pressed() -> void:
	if phase == Phase.DONE:
		return
	_register_action()
	used_converter = true
	status_label.text = TXT_STATUS_CONVERTER % [i_bits_true, i_bits_true / 8]
	status_label.add_theme_color_override("font_color", Color(0.55, 0.85, 1.0, 1.0))
	_update_preview()
	_update_details_text()

func _on_capture_pressed() -> void:
	if phase != Phase.SELECT or selected_storage_idx < 0:
		return
	_register_action()
	_finish_trial()

func _finish_trial() -> void:
	phase = Phase.DONE
	btn_capture.visible = false
	btn_next.visible = true

	var choice: Dictionary = storage_options[selected_storage_idx]
	var choice_cap: int = int(choice["capacity_bits"])
	var calc_correct: bool = (i_bits_user == i_bits_true)
	var is_fit: bool = choice_cap >= i_bits_true
	var is_best_fit: bool = false
	var is_overkill: bool = false
	var waste_ratio: float = 0.0
	if i_bits_true > 0:
		waste_ratio = float(choice_cap) / float(i_bits_true)

	var error_type: String = "unknown"
	if choice_cap < i_bits_true:
		error_type = "underfit"
	elif not calc_correct:
		error_type = "calc_wrong"
	elif str(choice["tag"]) == "UNIT_TRAP":
		error_type = "unit_confusion_bits_bytes"
	elif str(choice["tag"]) == "BEST":
		error_type = "best_fit"
		is_best_fit = true
	elif waste_ratio > 4.0:
		error_type = "overkill_hard"
		is_overkill = true
	else:
		error_type = "overkill_soft"
		is_overkill = true

	var valid_mastery: bool = (not used_converter) and calc_correct and is_best_fit

	if error_type == "best_fit":
		status_label.text = TXT_RESULT_BEST
		status_label.add_theme_color_override("font_color", COLOR_GOOD)
		_update_sample_slot(COLOR_GOOD)
	elif error_type == "underfit":
		status_label.text = TXT_RESULT_UNDER
		status_label.add_theme_color_override("font_color", COLOR_BAD)
		_update_sample_slot(COLOR_BAD)
	elif error_type == "calc_wrong":
		status_label.text = TXT_RESULT_CALC
		status_label.add_theme_color_override("font_color", COLOR_BAD)
		_update_sample_slot(COLOR_BAD)
	elif error_type == "unit_confusion_bits_bytes":
		status_label.text = TXT_RESULT_UNIT
		status_label.add_theme_color_override("font_color", COLOR_WARN)
		_update_sample_slot(COLOR_WARN)
	else:
		status_label.text = TXT_RESULT_OVER
		status_label.add_theme_color_override("font_color", COLOR_WARN)
		_update_sample_slot(COLOR_WARN)

	var payload: Dictionary = {
		"quest_id": "radio_intercept",
		"stage_id": "B",
		"match_key": "RI_B_%s" % ("TIMED" if is_timed else "UNTIMED"),
		"pool_type": pool_type,
		"dependency_mode": "default_i",
		"i_bits": i_bits,
		"K_symbols": k_symbols,
		"I_bits_true": i_bits_true,
		"I_bits_user": i_bits_user,
		"calc_correct": calc_correct,
		"used_converter": used_converter,
		"choice_capacity_bits": choice_cap,
		"choice_display_size": int(choice["display_size"]),
		"choice_display_unit": str(choice["display_unit"]),
		"is_fit": is_fit,
		"is_best_fit": is_best_fit,
		"is_overkill": is_overkill,
		"waste_ratio": waste_ratio,
		"error_type": error_type,
		"valid_for_mastery": valid_mastery,
		"valid_for_diagnostics": true,
		"elapsed_ms": Time.get_ticks_msec() - start_ms,
		"time_to_first_action_ms": (first_action_ms - start_ms) if first_action_ms > 0 else 0,
		"is_timed": is_timed,
		"forced_sampling": forced_sampling
	}
	GlobalMetrics.register_trial(payload)

	_update_preview()
	_update_details_text()

func _update_sample_slot(color: Color) -> void:
	if sample_refs.is_empty():
		return
	var slot: Dictionary = sample_refs[current_trial_idx] as Dictionary
	var bg: ColorRect = slot["bg"] as ColorRect
	var mark: Label = slot["mark"] as Label
	bg.color = color
	mark.visible = pool_type == "ANCHOR"
	current_trial_idx = (current_trial_idx + 1) % min(SAMPLE_SLOTS, sample_refs.size())

func _update_preview() -> void:
	if i_bits_user <= 0:
		preview_calc_label.text = "\u0420\u0430\u0441\u0447\u0451\u0442 I: \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d"
		preview_calc_label.add_theme_color_override("font_color", Color(0.75, 0.75, 0.75, 1.0))
	elif i_bits_user == i_bits_true:
		preview_calc_label.text = "\u0420\u0430\u0441\u0447\u0451\u0442 I: \u0432\u0435\u0440\u043d\u043e (%d \u0431\u0438\u0442)" % i_bits_true
		preview_calc_label.add_theme_color_override("font_color", COLOR_GOOD)
	else:
		preview_calc_label.text = "\u0420\u0430\u0441\u0447\u0451\u0442 I: \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 (%d vs %d)" % [i_bits_user, i_bits_true]
		preview_calc_label.add_theme_color_override("font_color", COLOR_WARN)

	if selected_storage_idx < 0:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043d\u0435 \u0432\u044b\u0431\u0440\u0430\u043d"
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: \u2014"
		preview_fit_label.add_theme_color_override("font_color", Color(0.75, 0.75, 0.75, 1.0))
		preview_class_label.add_theme_color_override("font_color", Color(0.75, 0.75, 0.75, 1.0))
		return

	var opt: Dictionary = storage_options[selected_storage_idx]
	var cap: int = int(opt["capacity_bits"])
	var tag: String = str(opt["tag"])

	if cap < i_bits_true:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043d\u0435 \u043f\u043e\u043c\u0435\u0449\u0430\u0435\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_BAD)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: UNDERFIT"
		preview_class_label.add_theme_color_override("font_color", COLOR_BAD)
	elif tag == "BEST":
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_GOOD)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: BEST FIT"
		preview_class_label.add_theme_color_override("font_color", COLOR_GOOD)
	elif tag == "UNIT_TRAP":
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u0435\u0434\u0438\u043d\u0438\u0446\u044b"
		preview_fit_label.add_theme_color_override("font_color", COLOR_WARN)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: UNIT CONFUSION"
		preview_class_label.add_theme_color_override("font_color", COLOR_WARN)
	elif cap >= i_bits_true * 4:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_WARN)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: OVERKILL"
		preview_class_label.add_theme_color_override("font_color", COLOR_WARN)
	else:
		preview_fit_label.text = "\u041d\u043e\u0441\u0438\u0442\u0435\u043b\u044c: \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442"
		preview_fit_label.add_theme_color_override("font_color", COLOR_WARN)
		preview_class_label.text = "\u041a\u043b\u0430\u0441\u0441: SOFT OVERKILL"
		preview_class_label.add_theme_color_override("font_color", COLOR_WARN)

func _update_details_text() -> void:
	var lines: Array[String] = []
	lines.append("i: %d" % i_bits)
	lines.append("K: %d" % k_symbols)
	lines.append("I_true: %d" % i_bits_true)
	lines.append("I_user: %d" % i_bits_user)
	lines.append("pool: %s" % pool_type)
	if selected_storage_idx >= 0:
		var opt: Dictionary = storage_options[selected_storage_idx]
		lines.append("choice: %d %s" % [int(opt["display_size"]), str(opt["display_unit"])])
		lines.append("choice_bits: %d" % int(opt["capacity_bits"]))
	if used_converter:
		lines.append("converter: used")
	details_text.text = "\n".join(lines)

func _on_next_pressed() -> void:
	_start_trial()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_details_pressed() -> void:
	_set_details_visible(true)

func _on_details_close_pressed() -> void:
	_set_details_visible(false)

func _on_dimmer_gui_input(event: InputEvent) -> void:
	if (event is InputEventMouseButton and event.pressed) or (event is InputEventScreenTouch and event.pressed):
		_set_details_visible(false)

func _set_details_visible(visible: bool) -> void:
	details_sheet.visible = visible
	dimmer.visible = visible
	btn_details.text = TXT_BTN_DETAILS_OPEN if visible else TXT_BTN_DETAILS_CLOSED

func _update_header_meta() -> void:
	var mode_text: String = "\u0411\u0415\u0417 \u0422\u0410\u0419\u041c\u0415\u0420\u0410"
	meta_label.text = "\u0420\u0415\u0416\u0418\u041c: %s | \u0421\u0422\u0410\u0411: %d%%" % [mode_text, int(_current_stability)]

func _on_stability_changed(new_value: float, _delta: float) -> void:
	_current_stability = new_value
	_update_header_meta()

func _apply_safe_area_padding() -> void:
	var left: float = 16.0
	var top: float = 12.0
	var right: float = 16.0
	var bottom: float = 12.0

	var safe_rect: Rect2i = DisplayServer.get_display_safe_area()
	if safe_rect.size.x > 0 and safe_rect.size.y > 0:
		var viewport_size: Vector2 = get_viewport_rect().size
		left = maxf(left, float(safe_rect.position.x))
		top = maxf(top, float(safe_rect.position.y))
		right = maxf(right, viewport_size.x - float(safe_rect.position.x + safe_rect.size.x))
		bottom = maxf(bottom, viewport_size.y - float(safe_rect.position.y + safe_rect.size.y))

	safe_area.add_theme_constant_override("margin_left", int(round(left)))
	safe_area.add_theme_constant_override("margin_top", int(round(top)))
	safe_area.add_theme_constant_override("margin_right", int(round(right)))
	safe_area.add_theme_constant_override("margin_bottom", int(round(bottom)))

func _configure_layout() -> void:
	var size: Vector2 = get_viewport_rect().size
	var phone_landscape: bool = size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

	if phone_landscape:
		body_split.split_offset = int(size.x * 0.52)
		root_vbox.add_theme_constant_override("separation", 8)
		storage_grid.columns = 2
		for btn in storage_btns:
			btn.custom_minimum_size.y = 80
		for btn in [btn_back, btn_minus, btn_plus, btn_check_calc, btn_converter, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 56
		meta_label.add_theme_font_size_override("font_size", 16)
		status_label.add_theme_font_size_override("font_size", 16)
	elif size.x < 1280.0:
		body_split.split_offset = int(size.x * 0.54)
		root_vbox.add_theme_constant_override("separation", 10)
		storage_grid.columns = 2
		for btn in storage_btns:
			btn.custom_minimum_size.y = 88
		for btn in [btn_back, btn_minus, btn_plus, btn_check_calc, btn_converter, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58
		meta_label.add_theme_font_size_override("font_size", 17)
		status_label.add_theme_font_size_override("font_size", 18)
	else:
		body_split.split_offset = int(size.x * 0.55)
		root_vbox.add_theme_constant_override("separation", 10)
		storage_grid.columns = 2
		for btn in storage_btns:
			btn.custom_minimum_size.y = 92
		for btn in [btn_back, btn_minus, btn_plus, btn_check_calc, btn_converter, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58
		meta_label.add_theme_font_size_override("font_size", 18)
		status_label.add_theme_font_size_override("font_size", 18)
</file>

<file path="scenes/RadioQuestB.tscn">
[gd_scene load_steps=4 format=3]

[ext_resource type="Script" path="res://scenes/RadioQuestB.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_terminal_green.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_crt"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(0, 1, 0.25, 1)
shader_parameter/intensity = 0.12
shader_parameter/fx_quality = 1
shader_parameter/glitch_strength = 0.0

[node name="RadioQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.01, 0.03, 0.015, 1)

[node name="CRTLayer" type="CanvasLayer" parent="."]

[node name="CRTOverlay" type="ColorRect" parent="CRTLayer"]
material = SubResource("ShaderMaterial_crt")
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Header" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2

[node name="HeaderHBox" type="HBoxContainer" parent="SafeArea/RootVBox/Header"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "BACK"

[node name="TitleLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 28
text = "RADIO INTERCEPT | B"

[node name="MetaLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(360, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 18
horizontal_alignment = 2
text = "MODE | STABILITY"

[node name="BodyHSplit" type="HSplitContainer" parent="SafeArea/RootVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 720

[node name="LeftPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LeftMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="LeftVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="StorageTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "STORAGE BAY"

[node name="StorageGrid" type="GridContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 10
columns = 2

[node name="StorageBtn1" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 1"

[node name="StorageBtn2" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 2"

[node name="StorageBtn3" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 3"

[node name="StorageBtn4" type="Button" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/StorageGrid"]
custom_minimum_size = Vector2(0, 92)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
toggle_mode = true
text = "Option 4"

[node name="RightPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RightMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="RightVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="ContextCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 124)
layout_mode = 2

[node name="ContextMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="ContextVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="ContextTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "TERMINAL"

[node name="IInfoLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "i = 7 bits"

[node name="KInfoLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "K = 128 symbols"

[node name="TaskLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ContextCard/ContextMargin/ContextVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Compute I = K*i and choose best storage option"

[node name="CalcCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2

[node name="CalcMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="CalcVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="CalcTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "CALC I"

[node name="IBitsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnMinus" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow"]
custom_minimum_size = Vector2(72, 56)
layout_mode = 2
text = "-8"

[node name="IBitsValue" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow"]
custom_minimum_size = Vector2(140, 0)
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 34
horizontal_alignment = 1
text = "0"

[node name="BtnPlus" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox/IBitsRow"]
custom_minimum_size = Vector2(72, 56)
layout_mode = 2
text = "+8"

[node name="BtnCheckCalc" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/CalcCard/CalcMargin/CalcVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "CHECK"

[node name="PreviewCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2

[node name="PreviewMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="PreviewVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="PreviewTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "DIAGNOSTICS"

[node name="PreviewCalcLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Calc:"

[node name="PreviewFitLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Fit:"

[node name="PreviewClassLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/PreviewCard/PreviewMargin/PreviewVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Class:"

[node name="ActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnConverter" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "CONVERTER"

[node name="BtnCapture" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
disabled = true
text = "CONFIRM"

[node name="BtnNext" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "NEXT"

[node name="SampleStrip" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 32)
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Sample1" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample2" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample3" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample4" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample5" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample6" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample7" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StatusLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 88)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Status"

[node name="BtnDetails" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "DETAILS"

[node name="Footer" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2

[node name="FooterMargin" type="MarginContainer" parent="SafeArea/RootVBox/Footer"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="FooterLabel" type="Label" parent="SafeArea/RootVBox/Footer/FooterMargin"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = ""

[node name="Dimmer" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
color = Color(0, 0, 0, 0.6)

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -320.0
grow_horizontal = 2
grow_vertical = 0

[node name="DetailsMargin" type="MarginContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="DetailsVBox" type="VBoxContainer" parent="DetailsSheet/DetailsMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "DETAILS"

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_vertical = 3
fit_content = false
scroll_active = true
bbcode_enabled = false

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "CLOSE"
</file>

<file path="scenes/RadioQuestC.gd">
extends Control

enum State {
	TUNE,
	ANALYZED,
	EXEC,
	DONE
}

enum Decision {
	NONE,
	RISK,
	ABORT
}

enum Outcome {
	NONE,
	SUCCESS_SEND,
	INTERCEPTED,
	SAFE_ABORT,
	MISSED_WINDOW
}

const EPS: float = 0.05
const MIN_ESTIMATE: float = 0.0
const MAX_ESTIMATE: float = 30.0
const SAMPLE_SLOTS: int = 7
const PHONE_LANDSCAPE_MAX_HEIGHT: float = 520.0

const UNIT_MB := "\u041c\u0411"
const UNIT_GB := "\u0413\u0411"
const UNIT_MBIT_SEC := "\u041c\u0431\u0438\u0442/\u0441"
const SYMBOL_SEC := "\u0441"

const TXT_MODE := "\u0420\u0415\u0416\u0418\u041c: \u0411\u0415\u0417 \u0412\u0420\u0415\u041c\u0415\u041d\u0418"
const TXT_TITLE := "\u0420\u0410\u0414\u0418\u041e\u041f\u0415\u0420\u0415\u0425\u0412\u0410\u0422 \u2022 C"
const TXT_MISSION := "\u042d\u041a\u0421\u0422\u0420\u0415\u041d\u041d\u0410\u042f \u041f\u0415\u0420\u0415\u0414\u0410\u0427\u0410"
const TXT_HINT := "\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043e\u0446\u0435\u043d\u0438 t. \u041f\u043e\u0442\u043e\u043c \u0410\u041d\u0410\u041b\u0418\u0417. \u041f\u043e\u0442\u043e\u043c \u0440\u0435\u0448\u0435\u043d\u0438\u0435."
const TXT_STEP_1 := "\u0428\u0410\u0413 1: \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438"
const TXT_STEP_2 := "\u0428\u0410\u0413 2: \u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c \u0440\u0438\u0441\u043a\u0430"
const TXT_STEP_3 := "\u0428\u0410\u0413 3: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0440\u0435\u0448\u0435\u043d\u0438\u0435"
const TXT_DETECT_TITLE := "\u041f\u0415\u041b\u0415\u041d\u0413\u0410\u0426\u0418\u042f"
const TXT_TRANSFER_TITLE := "\u041f\u0415\u0420\u0415\u0414\u0410\u0427\u0410"

const TXT_BTN_UNITS := "\u041f\u041e\u0414\u0421\u041a\u0410\u0417\u041a\u0410 (\u0435\u0434\u0438\u043d\u0438\u0446\u044b)"
const TXT_BTN_ANALYZE := "\u0410\u041d\u0410\u041b\u0418\u0417"
const TXT_BTN_RISK := "\u0420\u0418\u0421\u041a\u041d\u0423\u0422\u042c"
const TXT_BTN_ABORT := "\u0421\u0411\u0420\u041e\u0421"
const TXT_BTN_NEXT := "\u0414\u0410\u041b\u0415\u0415"
const TXT_BTN_DETAILS := "\u041f\u041e\u0414\u0420\u041e\u0411\u041d\u0415\u0415 \u25be"
const TXT_DETAILS_TITLE := "\u041f\u041e\u042f\u0421\u041d\u0415\u041d\u0418\u0415"
const TXT_DETAILS_CLOSE := "\u0417\u0410\u041a\u0420\u042b\u0422\u042c"

const TXT_RISK_UNKNOWN := "\u0420\u0438\u0441\u043a: \u041d\u0415\u0418\u0417\u0412\u0415\u0421\u0422\u0415\u041d"
const TXT_RISK_LOW := "\u041d\u0418\u0417\u041a\u0418\u0419"
const TXT_RISK_MID := "\u0421\u0420\u0415\u0414\u041d\u0418\u0419"
const TXT_RISK_HIGH := "\u0412\u042b\u0421\u041e\u041a\u0418\u0419"

const TXT_PLAN_STATUS := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u043f\u0440\u043e\u0433\u043d\u043e\u0437 \u0438 \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0410\u041d\u0410\u041b\u0418\u0417\u00bb."
const TXT_ANALYZED_OK := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0442\u043e\u0447\u043d\u044b\u0439. \u0420\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u043e \u0440\u0435\u0448\u0435\u043d\u0438\u0435."
const TXT_ANALYZED_MID := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0431\u043b\u0438\u0437\u043a\u0438\u0439. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0440\u0438\u0441\u043a\u043e\u0432\u0430\u043d\u043d\u043e."
const TXT_ANALYZED_BAD := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u043d\u0435\u0442\u043e\u0447\u043d\u044b\u0439. \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0440\u0438\u0441\u043a\u043e\u0432\u0430\u043d\u043d\u043e."
const TXT_EXEC_STARTED := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u0437\u0430\u043f\u0443\u0449\u0435\u043d\u0430."
const TXT_UNITS_HINT := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041c\u0411 -> \u041c\u0431\u0438\u0442: x8, \u0413\u0411 -> \u041c\u0411: x1024, t = I / v."

const TXT_OUT_SUCCESS := "\u0421\u0422\u0410\u0422\u0423\u0421: \u0423\u0421\u041f\u0415\u0425. \u041f\u0430\u043a\u0435\u0442 \u0443\u0448\u0451\u043b \u0434\u043e \u043f\u0435\u043b\u0435\u043d\u0433\u0430\u0446\u0438\u0438."
const TXT_OUT_INTERCEPT := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0420\u041e\u0412\u0410\u041b. \u0412\u0430\u0441 \u0437\u0430\u0441\u0435\u043a\u043b\u0438."
const TXT_OUT_SAFE_ABORT := "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u0420\u0410\u0412\u0418\u041b\u042c\u041d\u041e. \u041e\u0442\u043a\u0430\u0437 \u0441\u043f\u0430\u0441 \u043c\u0438\u0441\u0441\u0438\u044e."
const TXT_OUT_MISSED := "\u0421\u0422\u0410\u0422\u0423\u0421: \u0423\u041f\u0423\u0429\u0415\u041d\u041e. \u0412\u044b \u043c\u043e\u0433\u043b\u0438 \u0443\u0441\u043f\u0435\u0442\u044c."

const POOL_MB_NORMAL: Array[float] = [1.0, 2.0, 4.0, 5.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 40.0]
const POOL_GB_NORMAL: Array[float] = [0.5, 1.0, 1.5, 2.0]
const POOL_SPEED_INT: Array[float] = [1.0, 2.0, 4.0, 5.0, 8.0, 10.0, 16.0, 20.0, 25.0]
const POOL_SPEED_FRAC: Array[float] = [1.5, 2.5, 7.5, 12.5]

const COLOR_SAMPLE_IDLE: Color = Color(0.18, 0.18, 0.18, 1.0)
const COLOR_SAMPLE_SUCCESS: Color = Color(0.20, 0.90, 0.30, 1.0)
const COLOR_SAMPLE_FAIL: Color = Color(0.95, 0.25, 0.25, 1.0)
const COLOR_SAMPLE_WARN: Color = Color(0.95, 0.75, 0.20, 1.0)

@onready var safe_area: MarginContainer = $SafeArea
@onready var body_split: HSplitContainer = $SafeArea/RootVBox/BodyHSplit
@onready var top_bar: PanelContainer = $SafeArea/RootVBox/TopBar
@onready var mission_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard
@onready var actions_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard

@onready var title_label: Label = $SafeArea/RootVBox/TopBar/TopBarHBox/TitleLabel
@onready var mode_chip: Label = $SafeArea/RootVBox/TopBar/TopBarHBox/ModeChip
@onready var stability_label: Label = $SafeArea/RootVBox/TopBar/TopBarHBox/StabilityLabel
@onready var btn_back: Button = $SafeArea/RootVBox/TopBar/TopBarHBox/BtnBack

@onready var mission_title: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/MissionTitle
@onready var task_line_1: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/TaskLine1
@onready var task_line_2: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/TaskLine2
@onready var task_line_3: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/TaskLine3
@onready var micro_hint: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/MissionCard/MissionMargin/MissionVBox/MicroHint

@onready var step_1_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/Step1Label
@onready var estimate_value_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/EstimateValue
@onready var time_knob: Control = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/KnobCenter/TimeKnob
@onready var btn_minus_1: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnMinus1
@onready var btn_minus_01: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnMinus01
@onready var btn_plus_01: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnPlus01
@onready var btn_plus_1: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/FineButtonsRow/BtnPlus1
@onready var btn_analyze: Button = $SafeArea/RootVBox/BodyHSplit/LeftCol/KnobCard/KnobMargin/KnobVBox/BtnAnalyze

@onready var status_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftCol/StatusCard/StatusMargin/StatusLabel

@onready var step_2_label: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/Step2Label
@onready var detection_title: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/DetectionTitle
@onready var detection_bar: ProgressBar = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/DetectionBar
@onready var detect_countdown: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/DetectCountdown
@onready var transfer_title: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/TransferTitle
@onready var transfer_bar: ProgressBar = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/TransferBar
@onready var transfer_countdown: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/TransferCountdown
@onready var risk_label: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/RiskCard/RiskMargin/RiskVBox/RiskLabel

@onready var step_3_label: Label = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/Step3Label
@onready var btn_units: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow/BtnUnits
@onready var btn_details: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow/BtnDetails
@onready var btn_risk: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow/BtnRisk
@onready var btn_abort: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/PrimaryActionsRow/BtnAbort
@onready var btn_next: Button = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SecondaryActionsRow/BtnNext
@onready var sample_strip: HBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightCol/ActionsCard/ActionsMargin/ActionsVBox/SampleStrip

@onready var details_overlay: Control = $DetailsOverlay
@onready var details_sheet_title: Label = $DetailsOverlay/BottomSheet/SheetMargin/SheetVBox/SheetTitle
@onready var details_sheet_text: RichTextLabel = $DetailsOverlay/BottomSheet/SheetMargin/SheetVBox/SheetText
@onready var btn_close_details: Button = $DetailsOverlay/BottomSheet/SheetMargin/SheetVBox/BtnCloseDetails

@onready var alarm_flash: ColorRect = $AlarmFlash

var state: State = State.TUNE
var decision: Decision = Decision.NONE
var outcome: Outcome = Outcome.NONE

var file_size_value: float = 0.0
var file_size_unit: String = UNIT_MB
var speed_mbit: float = 0.0
var t_detect: float = 0.0
var t_true: float = 0.0
var t_est: float = 0.0

var pool_type: String = "NORMAL"
var anchor_type: String = "none"
var anchor_countdown: int = 0

var detection_elapsed: float = 0.0
var transfer_elapsed: float = 0.0
var transfer_started: bool = false
var used_units: bool = false

var start_ms: int = 0
var first_action_ms: int = -1
var check_ms: int = -1
var decision_ms: int = -1

var analyze_count: int = 0
var knob_moves_count: int = 0
var direction_changes: int = 0
var _last_move_sign: int = 0

var sample_cursor: int = 0
var sample_refs: Array = []
var _ui_ready: bool = false

func _ready() -> void:
	randomize()
	_apply_static_texts()
	_connect_signals()
	_collect_sample_refs()
	_reset_sample_strip()
	_apply_safe_area_padding()
	_configure_layout()
	_set_details_visible(false)

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	_on_stability_changed(GlobalMetrics.stability, 0.0)

	anchor_countdown = randi_range(7, 10)
	_start_trial()
	_ui_ready = true

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and _ui_ready:
		_apply_safe_area_padding()
		_configure_layout()

func _process(delta: float) -> void:
	if state != State.ANALYZED and state != State.EXEC:
		return

	detection_elapsed += delta
	if decision == Decision.RISK and transfer_started:
		transfer_elapsed += delta

	_update_runtime_ui()

	if decision == Decision.RISK:
		if transfer_elapsed >= t_true and detection_elapsed <= t_detect + EPS:
			_finalize_trial(Outcome.SUCCESS_SEND, "RISK")
			return
		if detection_elapsed >= t_detect and transfer_elapsed < t_true - EPS:
			_play_alarm_flash()
			_finalize_trial(Outcome.INTERCEPTED, "RISK")
			return
	else:
		if detection_elapsed >= t_detect:
			if decision_ms < 0:
				decision_ms = Time.get_ticks_msec()
			_play_alarm_flash()
			_finalize_trial(Outcome.INTERCEPTED, "NONE")

func _apply_static_texts() -> void:
	title_label.text = TXT_TITLE
	mode_chip.text = TXT_MODE
	mission_title.text = TXT_MISSION
	micro_hint.text = TXT_HINT
	step_1_label.text = TXT_STEP_1
	step_2_label.text = TXT_STEP_2
	step_3_label.text = TXT_STEP_3
	detection_title.text = TXT_DETECT_TITLE
	transfer_title.text = TXT_TRANSFER_TITLE

	btn_units.text = TXT_BTN_UNITS
	btn_details.text = TXT_BTN_DETAILS
	btn_analyze.text = TXT_BTN_ANALYZE
	btn_risk.text = TXT_BTN_RISK
	btn_abort.text = TXT_BTN_ABORT
	btn_next.text = TXT_BTN_NEXT
	details_sheet_title.text = TXT_DETAILS_TITLE
	btn_close_details.text = TXT_DETAILS_CLOSE

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_minus_1.pressed.connect(_on_minus_1_pressed)
	btn_minus_01.pressed.connect(_on_minus_01_pressed)
	btn_plus_01.pressed.connect(_on_plus_01_pressed)
	btn_plus_1.pressed.connect(_on_plus_1_pressed)
	btn_units.pressed.connect(_on_units_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_close_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_risk.pressed.connect(_on_risk_pressed)
	btn_abort.pressed.connect(_on_abort_pressed)
	btn_next.pressed.connect(_on_next_pressed)

	var knob_callback: Callable = Callable(self, "_on_knob_value_changed")
	if not time_knob.is_connected("value_changed", knob_callback):
		time_knob.connect("value_changed", knob_callback)

func _apply_safe_area_padding() -> void:
	if safe_area == null:
		return

	var base_left: float = 16.0
	var base_top: float = 12.0
	var base_right: float = 16.0
	var base_bottom: float = 12.0

	var safe_rect: Rect2i = DisplayServer.get_display_safe_area()
	if safe_rect.size.x > 0 and safe_rect.size.y > 0:
		var viewport_size: Vector2 = get_viewport_rect().size
		base_left = maxf(base_left, float(safe_rect.position.x))
		base_top = maxf(base_top, float(safe_rect.position.y))
		base_right = maxf(base_right, viewport_size.x - float(safe_rect.position.x + safe_rect.size.x))
		base_bottom = maxf(base_bottom, viewport_size.y - float(safe_rect.position.y + safe_rect.size.y))

	safe_area.add_theme_constant_override("margin_left", int(round(base_left)))
	safe_area.add_theme_constant_override("margin_top", int(round(base_top)))
	safe_area.add_theme_constant_override("margin_right", int(round(base_right)))
	safe_area.add_theme_constant_override("margin_bottom", int(round(base_bottom)))

func _configure_layout() -> void:
	if body_split == null or time_knob == null:
		return

	var size: Vector2 = get_viewport_rect().size
	var is_phone_landscape: bool = size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT
	if is_phone_landscape:
		body_split.split_offset = int(size.x * 0.54)
		top_bar.custom_minimum_size.y = 58.0
		mission_card.custom_minimum_size.y = 140.0
		actions_card.custom_minimum_size.y = 200.0
		time_knob.custom_minimum_size = Vector2(220, 220)
		title_label.add_theme_font_size_override("font_size", 24)
		mode_chip.add_theme_font_size_override("font_size", 15)
		stability_label.add_theme_font_size_override("font_size", 15)
		estimate_value_label.add_theme_font_size_override("font_size", 30)
		for btn in [btn_back, btn_minus_1, btn_minus_01, btn_plus_01, btn_plus_1, btn_analyze, btn_risk, btn_abort, btn_units, btn_details, btn_next, btn_close_details]:
			btn.custom_minimum_size.y = 56.0
	elif size.x < 1500.0:
		body_split.split_offset = int(size.x * 0.55)
		top_bar.custom_minimum_size.y = 62.0
		mission_card.custom_minimum_size.y = 150.0
		actions_card.custom_minimum_size.y = 210.0
		time_knob.custom_minimum_size = Vector2(270, 270)
		title_label.add_theme_font_size_override("font_size", 28)
		mode_chip.add_theme_font_size_override("font_size", 17)
		stability_label.add_theme_font_size_override("font_size", 17)
		estimate_value_label.add_theme_font_size_override("font_size", 34)
		for btn in [btn_back, btn_minus_1, btn_minus_01, btn_plus_01, btn_plus_1, btn_analyze, btn_risk, btn_abort, btn_units, btn_details, btn_next, btn_close_details]:
			btn.custom_minimum_size.y = 58.0
	else:
		body_split.split_offset = int(size.x * 0.56)
		top_bar.custom_minimum_size.y = 62.0
		mission_card.custom_minimum_size.y = 160.0
		actions_card.custom_minimum_size.y = 220.0
		time_knob.custom_minimum_size = Vector2(320, 320)
		title_label.add_theme_font_size_override("font_size", 30)
		mode_chip.add_theme_font_size_override("font_size", 18)
		stability_label.add_theme_font_size_override("font_size", 18)
		estimate_value_label.add_theme_font_size_override("font_size", 38)
		for btn in [btn_back, btn_minus_1, btn_minus_01, btn_plus_01, btn_plus_1, btn_analyze, btn_risk, btn_abort, btn_units, btn_details, btn_next, btn_close_details]:
			btn.custom_minimum_size.y = 58.0

func _collect_sample_refs() -> void:
	sample_refs.clear()
	for child_var in sample_strip.get_children():
		var child_node: Node = child_var as Node
		var bg_node: ColorRect = child_node.get_node_or_null("BG") as ColorRect
		var mark_node: Label = child_node.get_node_or_null("AnchorMark") as Label
		if bg_node != null and mark_node != null:
			mark_node.text = "\u042f"
			sample_refs.append({"bg": bg_node, "mark": mark_node})

func _reset_sample_strip() -> void:
	for slot_var in sample_refs:
		var slot: Dictionary = slot_var as Dictionary
		var bg: ColorRect = slot["bg"] as ColorRect
		var mark: Label = slot["mark"] as Label
		bg.color = COLOR_SAMPLE_IDLE
		mark.visible = false

func _start_trial() -> void:
	state = State.TUNE
	decision = Decision.NONE
	outcome = Outcome.NONE
	transfer_started = false
	used_units = false

	detection_elapsed = 0.0
	transfer_elapsed = 0.0

	analyze_count = 0
	knob_moves_count = 0
	direction_changes = 0
	_last_move_sign = 0

	start_ms = Time.get_ticks_msec()
	first_action_ms = -1
	check_ms = -1
	decision_ms = -1

	_generate_trial()
	_refresh_task_labels()
	_reset_runtime_ui()
	_set_tune_state_ui()

	time_knob.call("set_knob_value", 0.0, false)
	_set_estimate(0.0)
	_update_details_text()

func _generate_trial() -> void:
	var generated: Dictionary = {}
	if anchor_countdown <= 0:
		pool_type = "ANCHOR"
		var anchor_pick: int = randi() % 3
		if anchor_pick == 0:
			generated = _generate_anchor_forgot_x8()
		elif anchor_pick == 1:
			generated = _generate_anchor_boundary()
		else:
			generated = _generate_anchor_gb()
		if generated.is_empty():
			generated = _generate_normal_trial()
			pool_type = "NORMAL"
		anchor_countdown = randi_range(7, 10)
	else:
		pool_type = "NORMAL"
		generated = _generate_normal_trial()
		anchor_countdown -= 1

	file_size_value = float(generated["size_value"])
	file_size_unit = str(generated["size_unit"])
	speed_mbit = float(generated["speed_mbit"])
	t_detect = float(generated["t_detect"])
	t_true = float(generated["t_true"])
	anchor_type = str(generated["anchor_type"])

func _generate_normal_trial() -> Dictionary:
	for _i in range(500):
		var use_gb: bool = randf() < 0.10
		var size_value: float = 0.0
		var size_unit: String = UNIT_MB
		if use_gb:
			size_value = POOL_GB_NORMAL[randi() % POOL_GB_NORMAL.size()]
			size_unit = UNIT_GB
		else:
			size_value = POOL_MB_NORMAL[randi() % POOL_MB_NORMAL.size()]
			size_unit = UNIT_MB

		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, size_unit, speed)
		if true_time < 2.0 or true_time > 20.0:
			continue

		var detect_time: float = clampf(true_time + randf_range(-3.0, 3.0), 0.8, 24.0)
		if absf(true_time - detect_time) < 0.2:
			detect_time = clampf(detect_time + 0.4, 0.8, 24.0)

		return {
			"size_value": size_value,
			"size_unit": size_unit,
			"speed_mbit": speed,
			"t_detect": detect_time,
			"t_true": true_time,
			"anchor_type": "none"
		}

	return {
		"size_value": 10.0,
		"size_unit": UNIT_MB,
		"speed_mbit": 16.0,
		"t_detect": 6.0,
		"t_true": 5.0,
		"anchor_type": "none"
	}

func _generate_anchor_forgot_x8() -> Dictionary:
	for _i in range(500):
		var size_value: float = POOL_MB_NORMAL[randi() % POOL_MB_NORMAL.size()]
		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, UNIT_MB, speed)
		if true_time < 4.0 or true_time > 20.0:
			continue

		var fake_time: float = size_value / speed
		var detect_low: float = maxf(fake_time + 0.2, 0.6)
		var detect_high: float = true_time - 0.2
		if detect_high <= detect_low:
			continue

		return {
			"size_value": size_value,
			"size_unit": UNIT_MB,
			"speed_mbit": speed,
			"t_detect": randf_range(detect_low, detect_high),
			"t_true": true_time,
			"anchor_type": "forgot_x8"
		}
	return {}

func _generate_anchor_boundary() -> Dictionary:
	for _i in range(500):
		var use_gb: bool = randf() < 0.30
		var size_value: float = 0.0
		var size_unit: String = UNIT_MB
		if use_gb:
			size_value = POOL_GB_NORMAL[randi() % POOL_GB_NORMAL.size()]
			size_unit = UNIT_GB
		else:
			size_value = POOL_MB_NORMAL[randi() % POOL_MB_NORMAL.size()]
			size_unit = UNIT_MB

		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, size_unit, speed)
		if true_time < 2.0 or true_time > 20.0:
			continue

		var detect_time: float = clampf(true_time + randf_range(-0.18, 0.18), 0.8, 24.0)
		if absf(true_time - detect_time) <= 0.2:
			return {
				"size_value": size_value,
				"size_unit": size_unit,
				"speed_mbit": speed,
				"t_detect": detect_time,
				"t_true": true_time,
				"anchor_type": "boundary"
			}
	return {}

func _generate_anchor_gb() -> Dictionary:
	for _i in range(500):
		var size_value: float = POOL_GB_NORMAL[randi() % POOL_GB_NORMAL.size()]
		var speed: float = _pick_speed()
		var true_time: float = _compute_true_time(size_value, UNIT_GB, speed)
		if true_time < 6.0 or true_time > 20.0:
			continue

		var fake_time: float = (size_value * 8.0) / speed
		var detect_low: float = fake_time + 0.1
		var detect_high: float = true_time - 0.3
		if detect_high <= detect_low:
			continue

		return {
			"size_value": size_value,
			"size_unit": UNIT_GB,
			"speed_mbit": speed,
			"t_detect": randf_range(detect_low, detect_high),
			"t_true": true_time,
			"anchor_type": "forgot_x1024"
		}
	return {}

func _pick_speed() -> float:
	if randf() < 0.30:
		return POOL_SPEED_FRAC[randi() % POOL_SPEED_FRAC.size()]
	return POOL_SPEED_INT[randi() % POOL_SPEED_INT.size()]

func _compute_true_time(size_value: float, size_unit: String, speed: float) -> float:
	var i_mbit: float = size_value * 8.0
	if size_unit == UNIT_GB:
		i_mbit = size_value * 1024.0 * 8.0
	return i_mbit / speed

func _refresh_task_labels() -> void:
	task_line_1.text = "\u041e\u0431\u044a\u0451\u043c \u043f\u0430\u043a\u0435\u0442\u0430: %s %s" % [_format_num(file_size_value), file_size_unit]
	task_line_2.text = "\u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043a\u0430\u043d\u0430\u043b\u0430: %s %s" % [_format_num(speed_mbit), UNIT_MBIT_SEC]
	task_line_3.text = "\u0414\u043e \u043f\u0435\u043b\u0435\u043d\u0433\u0430\u0446\u0438\u0438: %s %s" % [_format_num(t_detect), SYMBOL_SEC]

func _reset_runtime_ui() -> void:
	detection_bar.value = 0.0
	transfer_bar.value = 0.0
	detect_countdown.text = "%s %s" % [_format_num(t_detect), SYMBOL_SEC]
	transfer_countdown.text = "\u2014"
	risk_label.text = TXT_RISK_UNKNOWN
	alarm_flash.color = Color(1.0, 0.05, 0.05, 0.0)

func _set_tune_state_ui() -> void:
	state = State.TUNE
	_set_knob_interactive(true)
	btn_analyze.disabled = false
	btn_risk.disabled = true
	btn_abort.disabled = true
	btn_units.disabled = false
	btn_next.visible = false
	status_label.text = TXT_PLAN_STATUS

func _set_analyzed_state_ui() -> void:
	state = State.ANALYZED
	_set_knob_interactive(false)
	btn_analyze.disabled = true
	btn_risk.disabled = false
	btn_abort.disabled = false
	btn_units.disabled = false
	btn_next.visible = false

	var abs_error: float = absf(t_est - t_true)
	if abs_error <= 0.3:
		status_label.text = TXT_ANALYZED_OK
	elif abs_error <= 1.0:
		status_label.text = TXT_ANALYZED_MID
	else:
		status_label.text = TXT_ANALYZED_BAD

	risk_label.text = "\u0420\u0438\u0441\u043a: %s" % _estimate_risk_text()

func _set_exec_state_ui() -> void:
	state = State.EXEC
	_set_knob_interactive(false)
	btn_analyze.disabled = true
	btn_risk.disabled = true
	btn_abort.disabled = true
	btn_units.disabled = true
	btn_next.visible = false

func _set_done_state_ui() -> void:
	state = State.DONE
	_set_knob_interactive(false)
	btn_analyze.disabled = true
	btn_risk.disabled = true
	btn_abort.disabled = true
	btn_units.disabled = true
	btn_next.visible = true

func _set_knob_interactive(is_enabled: bool) -> void:
	time_knob.mouse_filter = Control.MOUSE_FILTER_STOP if is_enabled else Control.MOUSE_FILTER_IGNORE
	btn_minus_1.disabled = not is_enabled
	btn_minus_01.disabled = not is_enabled
	btn_plus_01.disabled = not is_enabled
	btn_plus_1.disabled = not is_enabled

func _on_knob_value_changed(new_value: float, delta: float) -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_set_estimate(new_value)
	_register_knob_move(delta)

func _on_minus_01_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(-0.1)

func _on_plus_01_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(0.1)

func _on_minus_1_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(-1.0)

func _on_plus_1_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	_apply_estimate_delta(1.0)

func _apply_estimate_delta(delta: float) -> void:
	var next_value: float = clampf(t_est + delta, MIN_ESTIMATE, MAX_ESTIMATE)
	if is_equal_approx(next_value, t_est):
		return
	time_knob.call("set_knob_value", next_value, false)
	_set_estimate(next_value)
	_register_knob_move(delta)

func _set_estimate(value_sec: float) -> void:
	t_est = clampf(value_sec, MIN_ESTIMATE, MAX_ESTIMATE)
	estimate_value_label.text = "t = %s %s" % [_format_num(t_est), SYMBOL_SEC]
	_update_details_text()

func _register_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec()

func _register_knob_move(delta: float) -> void:
	if is_zero_approx(delta):
		return
	knob_moves_count += 1
	var sign: int = 1 if delta > 0.0 else -1
	if _last_move_sign != 0 and sign != _last_move_sign:
		direction_changes += 1
	_last_move_sign = sign

func _on_analyze_pressed() -> void:
	if state != State.TUNE:
		return
	_register_first_action()
	analyze_count += 1
	if check_ms < 0:
		check_ms = Time.get_ticks_msec()
	detection_elapsed = 0.0
	transfer_elapsed = 0.0
	_set_analyzed_state_ui()
	_update_details_text()

func _on_risk_pressed() -> void:
	if state != State.ANALYZED and state != State.EXEC:
		return
	_register_first_action()
	if decision == Decision.RISK:
		return

	if decision_ms < 0:
		decision_ms = Time.get_ticks_msec()
	decision = Decision.RISK
	transfer_started = true
	transfer_elapsed = 0.0
	_set_exec_state_ui()
	status_label.text = TXT_EXEC_STARTED
	_update_details_text()

func _on_abort_pressed() -> void:
	if state != State.ANALYZED and state != State.EXEC:
		return
	_register_first_action()
	if decision_ms < 0:
		decision_ms = Time.get_ticks_msec()
	decision = Decision.ABORT

	if t_true > t_detect + EPS:
		_finalize_trial(Outcome.SAFE_ABORT, "ABORT")
	else:
		_finalize_trial(Outcome.MISSED_WINDOW, "ABORT")

func _on_units_pressed() -> void:
	if state == State.DONE:
		return
	_register_first_action()
	used_units = true
	status_label.text = TXT_UNITS_HINT
	_update_details_text()

func _on_details_pressed() -> void:
	_set_details_visible(true)

func _on_details_close_pressed() -> void:
	_set_details_visible(false)

func _set_details_visible(is_visible: bool) -> void:
	details_overlay.visible = is_visible

func _on_next_pressed() -> void:
	_start_trial()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _update_runtime_ui() -> void:
	var detect_ratio: float = 0.0
	if t_detect > 0.0:
		detect_ratio = clampf(detection_elapsed / t_detect, 0.0, 1.0)
	detection_bar.value = detect_ratio * 100.0
	detect_countdown.text = "%s %s" % [_format_num(maxf(0.0, t_detect - detection_elapsed)), SYMBOL_SEC]

	if decision == Decision.RISK and transfer_started and t_true > 0.0:
		var transfer_ratio: float = clampf(transfer_elapsed / t_true, 0.0, 1.0)
		transfer_bar.value = transfer_ratio * 100.0
		transfer_countdown.text = "%s %s" % [_format_num(maxf(0.0, t_true - transfer_elapsed)), SYMBOL_SEC]
	else:
		transfer_bar.value = 0.0
		transfer_countdown.text = "\u043e\u0436\u0438\u0434\u0430\u043d\u0438\u0435"

func _estimate_risk_text() -> String:
	if t_est <= t_detect - 0.5:
		return TXT_RISK_LOW
	if t_est <= t_detect + 0.5:
		return TXT_RISK_MID
	return TXT_RISK_HIGH

func _finalize_trial(result: Outcome, decision_label: String) -> void:
	if state == State.DONE:
		return

	outcome = result
	_set_done_state_ui()

	var is_success: bool = (outcome == Outcome.SUCCESS_SEND or outcome == Outcome.SAFE_ABORT)
	var sample_color: Color = COLOR_SAMPLE_FAIL
	match outcome:
		Outcome.SUCCESS_SEND:
			status_label.text = TXT_OUT_SUCCESS
			sample_color = COLOR_SAMPLE_SUCCESS
		Outcome.INTERCEPTED:
			status_label.text = TXT_OUT_INTERCEPT
			sample_color = COLOR_SAMPLE_FAIL
		Outcome.SAFE_ABORT:
			status_label.text = TXT_OUT_SAFE_ABORT
			sample_color = COLOR_SAMPLE_SUCCESS
		Outcome.MISSED_WINDOW:
			status_label.text = TXT_OUT_MISSED
			sample_color = COLOR_SAMPLE_WARN
		_:
			status_label.text = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u043e"
			sample_color = COLOR_SAMPLE_FAIL

	_update_sample_slot(sample_color)
	_send_trial_payload(is_success, decision_label)
	_update_details_text()

func _update_sample_slot(color: Color) -> void:
	if sample_refs.is_empty():
		return
	var slot: Dictionary = sample_refs[sample_cursor] as Dictionary
	var bg: ColorRect = slot["bg"] as ColorRect
	var mark: Label = slot["mark"] as Label
	bg.color = color
	mark.visible = (pool_type == "ANCHOR")
	sample_cursor = (sample_cursor + 1) % min(SAMPLE_SLOTS, sample_refs.size())

func _send_trial_payload(is_success: bool, decision_label: String) -> void:
	var now_ms: int = Time.get_ticks_msec()
	var elapsed_ms: int = now_ms - start_ms
	var time_to_first_action_ms: int = 0
	if first_action_ms >= 0:
		time_to_first_action_ms = first_action_ms - start_ms

	var time_to_check_ms: int = 0
	if check_ms >= 0:
		time_to_check_ms = check_ms - start_ms

	var time_to_decision_ms: int = elapsed_ms
	if decision_ms >= 0:
		time_to_decision_ms = decision_ms - start_ms

	var error_abs: float = absf(t_est - t_true)
	var error_rel: float = 0.0
	if t_true > 0.0:
		error_rel = error_abs / t_true

	var low_certainty: bool = (knob_moves_count >= 6 or direction_changes >= 2)
	var error_type: String = _classify_error_type(time_to_decision_ms)

	var payload: Dictionary = {
		"quest_id": "radio_intercept",
		"stage_id": "C",
		"match_key": _build_match_key(),
		"pool_type": pool_type,
		"anchor_type": anchor_type,
		"anchor": (pool_type == "ANCHOR"),
		"file_size_value": file_size_value,
		"file_size_unit": file_size_unit,
		"speed_mbit": speed_mbit,
		"t_detect": t_detect,
		"t_true": t_true,
		"t_est": t_est,
		"estimate_sec": t_est,
		"true_sec": t_true,
		"error_sec_abs": error_abs,
		"error_sec_rel": error_rel,
		"decision": decision_label,
		"outcome": _outcome_to_text(outcome),
		"used_units": used_units,
		"error_type": error_type,
		"knob_moves_count": knob_moves_count,
		"direction_changes": direction_changes,
		"analyze_count": analyze_count,
		"low_certainty": low_certainty,
		"valid_for_diagnostics": true,
		"valid_for_mastery": (not used_units) and (outcome == Outcome.SUCCESS_SEND or outcome == Outcome.SAFE_ABORT),
		"is_correct": is_success,
		"is_fit": is_success,
		"elapsed_ms": elapsed_ms,
		"time_to_first_action_ms": time_to_first_action_ms,
		"time_to_check_ms": time_to_check_ms,
		"time_to_decision_ms": time_to_decision_ms
	}
	GlobalMetrics.register_trial(payload)

func _classify_error_type(time_to_decision_ms: int) -> String:
	if used_units:
		return "assisted"
	if t_true <= 0.0:
		return "arithmetic_error"

	var rel_x8: float = absf((t_est * 8.0) - t_true) / t_true
	if rel_x8 < 0.15:
		return "forgot_x8"

	if file_size_unit == UNIT_GB:
		var rel_x1024: float = absf((t_est * 1024.0) - t_true) / t_true
		if rel_x1024 < 0.15:
			return "forgot_x1024"

	var rel_error: float = absf(t_est - t_true) / t_true
	if rel_error > 0.25:
		return "arithmetic_error"
	if time_to_decision_ms > 15000:
		return "hesitation"
	return "none"

func _build_match_key() -> String:
	var unit_token: String = "MB"
	if file_size_unit == UNIT_GB:
		unit_token = "GB"
	return "RI_C_%s%s_v%s_T%s_%s" % [
		unit_token,
		_format_key_num(file_size_value),
		_format_key_num(speed_mbit),
		_format_key_num(t_detect),
		pool_type
	]

func _outcome_to_text(current_outcome: Outcome) -> String:
	match current_outcome:
		Outcome.SUCCESS_SEND:
			return "SUCCESS_SEND"
		Outcome.INTERCEPTED:
			return "INTERCEPTED"
		Outcome.SAFE_ABORT:
			return "SAFE_ABORT"
		Outcome.MISSED_WINDOW:
			return "MISSED_WINDOW"
		_:
			return "NONE"

func _update_details_text() -> void:
	var lines: Array[String] = []
	lines.append("\u0424\u043e\u0440\u043c\u0443\u043b\u0430: t = I / v")
	lines.append("I (%s): %s" % [file_size_unit, _format_num(file_size_value)])
	lines.append("v (%s): %s" % [UNIT_MBIT_SEC, _format_num(speed_mbit)])
	lines.append("T_detect: %s %s" % [_format_num(t_detect), SYMBOL_SEC])
	lines.append("t_est: %s %s" % [_format_num(t_est), SYMBOL_SEC])
	if used_units:
		lines.append("\u041f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430 \u0435\u0434\u0438\u043d\u0438\u0446 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0430.")
	if state == State.DONE:
		lines.append("t_true: %s %s" % [_format_num(t_true), SYMBOL_SEC])
		lines.append("outcome: %s" % _outcome_to_text(outcome))
	else:
		lines.append("t_true: \u0441\u043a\u0440\u044b\u0442\u043e \u0434\u043e \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f")
	lines.append("\u0420\u0435\u0436\u0438\u043c \u043f\u0443\u043b\u0430: %s (%s)" % ["\u044f\u043a\u043e\u0440\u043d\u044b\u0439" if pool_type == "ANCHOR" else "\u043e\u0431\u044b\u0447\u043d\u044b\u0439", anchor_type])
	details_sheet_text.text = "\n".join(lines)

func _format_num(value: float) -> String:
	return "%.1f" % value

func _format_key_num(value: float) -> String:
	var text_value: String = "%.2f" % value
	while text_value.ends_with("0"):
		text_value = text_value.substr(0, text_value.length() - 1)
	if text_value.ends_with("."):
		text_value = text_value.substr(0, text_value.length() - 1)
	return text_value

func _play_alarm_flash() -> void:
	alarm_flash.color = Color(1.0, 0.05, 0.05, 0.0)
	var tw: Tween = create_tween()
	tw.tween_property(alarm_flash, "color:a", 0.35, 0.10)
	tw.tween_property(alarm_flash, "color:a", 0.0, 0.24)

func _on_stability_changed(new_value: float, _change: float) -> void:
	stability_label.text = "\u0421\u0422\u0410\u0411\u0418\u041b\u042c\u041d\u041e\u0421\u0422\u042c: %d%%" % int(new_value)
</file>

<file path="scenes/SuspectQuestA.tscn">
[gd_scene load_steps=5 format=3 uid="uid://suspectquest_a"]

[ext_resource type="Script" path="res://scripts/SuspectQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_pencil.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/noir_pencil_overlay.gdshader" id="3_shader"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_crt"]
shader = ExtResource("3_shader")
shader_parameter/intensity = 0.34
shader_parameter/grain_strength = 0.35
shader_parameter/hatch_strength = 0.3
shader_parameter/vignette_strength = 0.45
shader_parameter/fx_quality = 1
shader_parameter/pulse = 0.0
shader_parameter/jitter_strength = 0.0

[node name="SuspectQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.0509804, 0.0509804, 0.0509804, 1)

[node name="CanvasLayer" type="CanvasLayer" parent="."]
layer = 100

[node name="NoirOverlay" type="ColorRect" parent="CanvasLayer"]
material = SubResource("ShaderMaterial_crt")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
color = Color(1, 1, 1, 0)

[node name="MainLayout" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Header" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
alignment = 1

[node name="BtnQuestBack" type="Button" parent="MainLayout/Header"]
custom_minimum_size = Vector2(120, 56)
layout_mode = 2
text = "НАЗАД"

[node name="LblClueTitle" type="Label" parent="MainLayout/Header"]
layout_mode = 2
text = "УЛИКА #A-01"
horizontal_alignment = 1

[node name="LblSessionId" type="Label" parent="MainLayout/Header"]
layout_mode = 2
size_flags_horizontal = 10
text = "СЕССИЯ ИНИЦ."
horizontal_alignment = 2

[node name="SettingsRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="PaletteTitle" type="Label" parent="MainLayout/SettingsRow"]
layout_mode = 2
text = "ПАЛИТРА"

[node name="PaletteSelect" type="OptionButton" parent="MainLayout/SettingsRow"]
custom_minimum_size = Vector2(120, 0)
layout_mode = 2

[node name="FxTitle" type="Label" parent="MainLayout/SettingsRow"]
layout_mode = 2
text = "ЭФФЕКТЫ"

[node name="FxSelect" type="OptionButton" parent="MainLayout/SettingsRow"]
custom_minimum_size = Vector2(110, 0)
layout_mode = 2

[node name="BarsRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
alignment = 1

[node name="DecryptBar" type="ProgressBar" parent="MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 0.0
show_percentage = false

[node name="EnergyBar" type="ProgressBar" parent="MainLayout/BarsRow"]
custom_minimum_size = Vector2(0, 8)
layout_mode = 2
size_flags_horizontal = 3
value = 100.0
show_percentage = false

[node name="TerminalFrame" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScrollContainer" type="ScrollContainer" parent="MainLayout/TerminalFrame"]
layout_mode = 2

[node name="CodeLabel" type="RichTextLabel" parent="MainLayout/TerminalFrame/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "[code]Инициализация...[/code]"
fit_content = false

[node name="StatusRow" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
alignment = 1

[node name="LblStatus" type="Label" parent="MainLayout/StatusRow"]
layout_mode = 2
size_flags_horizontal = 3
text = "ДОСТУП ОЖИДАЕТ"

[node name="LblAttempts" type="Label" parent="MainLayout/StatusRow"]
layout_mode = 2
text = "ОШ: 0/3"

[node name="InputFrame" type="PanelContainer" parent="MainLayout"]
layout_mode = 2

[node name="InputDisplay" type="Label" parent="MainLayout/InputFrame"]
custom_minimum_size = Vector2(0, 64)
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "----"
horizontal_alignment = 1

[node name="Numpad" type="GridContainer" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.6
theme_override_constants/h_separation = 8
theme_override_constants/v_separation = 8
columns = 3

[node name="Btn7" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "7"

[node name="Btn8" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "8"

[node name="Btn9" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "9"

[node name="Btn4" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "4"

[node name="Btn5" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "5"

[node name="Btn6" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "6"

[node name="Btn1" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "1"

[node name="Btn2" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "2"

[node name="Btn3" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "3"

[node name="BtnClr" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "СБР"

[node name="Btn0" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "0"

[node name="BtnBack" type="Button" parent="MainLayout/Numpad"]
custom_minimum_size = Vector2(64, 64)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "<-"

[node name="Actions" type="HBoxContainer" parent="MainLayout"]
layout_mode = 2
theme_override_constants/separation = 16
alignment = 1

[node name="BtnAnalyze" type="Button" parent="MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
text = "АНАЛИЗ"

[node name="BtnEnter" type="Button" parent="MainLayout/Actions"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ВВОД"

[node name="BtnNext" type="Button" parent="MainLayout/Actions"]
visible = false
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"PrimaryButton"
text = "ДАЛЕЕ"

[node name="DiagnosticsPanel" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="DiagnosticsPanel"]
layout_mode = 2
theme_override_constants/separation = 16

[node name="Label" type="Label" parent="DiagnosticsPanel/VBoxContainer"]
layout_mode = 2
text = "ДИАГНОСТИЧЕСКИЙ ТРЕЙС"
horizontal_alignment = 1

[node name="ExplainList" type="RichTextLabel" parent="DiagnosticsPanel/VBoxContainer"]
layout_mode = 2
fit_content = false
size_flags_vertical = 1

[node name="TraceList" type="RichTextLabel" parent="DiagnosticsPanel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
bbcode_enabled = true
text = "Журнал трассировки..."
fit_content = false

[node name="BtnCloseDiag" type="Button" parent="DiagnosticsPanel/VBoxContainer"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "ЗАКРЫТЬ"
</file>

<file path="scripts/DisarmQuestC.gd">
extends Control

const LEVELS_PATH := "res://data/quest_c_levels.json"

enum State {
	INIT,
	LINE_SELECT,
	FIX_MENU,
	READY_TO_VERIFY,
	VERIFY,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	DIAGNOSTIC
}

@onready var lbl_clue_title: Label = $MainLayout/HeaderRow/LblClueTitle
@onready var lbl_session: Label = $MainLayout/HeaderRow/LblSession
@onready var btn_back: Button = $MainLayout/HeaderRow/BtnBack
@onready var expected_panel: PanelContainer = $MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel
@onready var actual_panel: PanelContainer = $MainLayout/StatusMonitor/MonitorsRow/ActualPanel
@onready var lbl_expected_value: Label = $MainLayout/StatusMonitor/MonitorsRow/ExpectedPanel/ExpectedVBox/LblExpectedValue
@onready var lbl_actual_value: Label = $MainLayout/StatusMonitor/MonitorsRow/ActualPanel/ActualVBox/LblActualValue
@onready var code_view: CodeEdit = $MainLayout/BodyRow/CodeFrame/CodeRoot/CodeView
@onready var line_highlight: ColorRect = $MainLayout/BodyRow/CodeFrame/CodeRoot/LineHighlight
@onready var lbl_hint: Label = $MainLayout/BodyRow/SideInfo/LblHint
@onready var lbl_misclicks: Label = $MainLayout/BodyRow/SideInfo/MisclickCounter
@onready var btn_analyze: Button = $MainLayout/ActionsRow/BtnAnalyze
@onready var btn_verify: Button = $MainLayout/ActionsRow/BtnVerify
@onready var btn_next: Button = $MainLayout/ActionsRow/BtnNext
@onready var diagnostics_blocker: ColorRect = $DiagnosticsBlocker
@onready var fix_menu: PopupPanel = $FixMenuC
@onready var diagnostics_panel: PanelContainer = $DiagnosticsPanelC

var levels: Array = []
var current_level_idx := 0
var current_task: Dictionary = {}
var state: State = State.INIT
var variant_hash := ""
var task_started_ticks := 0
var paused_total_ms := 0
var pause_started_ticks := -1
var hint_open_ticks := 0
var hint_total_ms := 0
var selected_line_index := -1
var selected_option_id := ""
var misclicks_before_correct := 0
var wrong_fix_attempts_before_correct := 0
var has_selected_correct_line := false
var level_result_sent := false
var suppress_caret_event := false
var line_pick_armed := false
var highlight_tween: Tween
var task_session: Dictionary = {}
var cached_line_height := 26
var last_scroll_vertical := -1

func _ready() -> void:
	_configure_code_view()
	_connect_signals()
	_load_levels()
	if levels.is_empty():
		lbl_hint.text = "Данные уровня C не загружены."
		return

	var idx: int = int(GlobalMetrics.current_level_index)
	if idx < 0 or idx >= levels.size():
		idx = 0
	_start_level(idx)

func _configure_code_view() -> void:
	code_view.editable = false
	_try_set_control_property("wrap_mode", 0)
	_try_set_control_property("line_wrapping_mode", 0)
	_try_set_control_property("caret_draw_when_editable_disabled", true)
	_try_set_control_property("gutters_draw_line_numbers", true)
	_try_set_control_property("gutter_draw_line_numbers", true)
	_try_set_control_property("gutters_zero_pad_line_numbers", true)
	_try_set_control_property("gutter_zero_pad_line_numbers", true)

	line_highlight.visible = false
	line_highlight.color = Color(0.93, 0.93, 0.91, 0.14)
	if code_view.has_method("get_line_height"):
		cached_line_height = int(code_view.call("get_line_height"))

func _try_set_control_property(prop_name: String, value: Variant) -> void:
	for prop_var in code_view.get_property_list():
		if typeof(prop_var) != TYPE_DICTIONARY:
			continue
		var prop: Dictionary = prop_var
		if str(prop.get("name", "")) == prop_name:
			code_view.set(prop_name, value)
			return

func _connect_signals() -> void:
	code_view.caret_changed.connect(_on_code_caret_changed)
	code_view.gui_input.connect(_on_code_gui_input)
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_verify.pressed.connect(_on_verify_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	diagnostics_panel.visibility_changed.connect(_on_diagnostics_visibility_changed)
	var on_option_selected := Callable(self, "_on_fix_option_selected")
	var on_apply_requested := Callable(self, "_on_fix_apply_requested")
	var on_canceled := Callable(self, "_on_fix_menu_canceled")
	if not fix_menu.is_connected("option_selected", on_option_selected):
		fix_menu.connect("option_selected", on_option_selected)
	if not fix_menu.is_connected("apply_requested", on_apply_requested):
		fix_menu.connect("apply_requested", on_apply_requested)
	if not fix_menu.is_connected("canceled", on_canceled):
		fix_menu.connect("canceled", on_canceled)

func _load_levels() -> void:
	levels.clear()
	if not FileAccess.file_exists(LEVELS_PATH):
		push_error("DisarmQuestC levels file missing: " + LEVELS_PATH)
		return

	var file: FileAccess = FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		push_error("Unable to open " + LEVELS_PATH)
		return

	var json := JSON.new()
	if json.parse(file.get_as_text()) != OK:
		push_error("JSON parse error in quest_c_levels.json: " + json.get_error_message())
		return

	if typeof(json.data) != TYPE_ARRAY:
		push_error("quest_c_levels.json must be an array.")
		return

	for level_var in json.data:
		if typeof(level_var) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = level_var
		if _validate_level(level):
			levels.append(level)
		else:
			push_warning("Skipping invalid C level: " + str(level.get("id", "UNKNOWN")))

func _validate_level(level: Dictionary) -> bool:
	var required := [
		"id",
		"bucket",
		"briefing",
		"expected_s",
		"actual_s",
		"code_lines",
		"bug"
	]
	for key in required:
		if not level.has(key):
			return false

	if str(level.get("id", "")).strip_edges().is_empty():
		return false
	if str(level.get("bucket", "")).strip_edges().is_empty():
		return false
	if str(level.get("briefing", "")).strip_edges().is_empty():
		return false
	if not _is_numeric(level.get("expected_s", null)):
		return false
	if not _is_numeric(level.get("actual_s", null)):
		return false

	if typeof(level.get("code_lines", [])) != TYPE_ARRAY:
		return false
	var code_lines: Array = level.get("code_lines", [])
	if code_lines.is_empty():
		return false
	for code_line_var in code_lines:
		if typeof(code_line_var) != TYPE_STRING:
			return false
		if str(code_line_var).is_empty():
			return false

	var bug: Dictionary = level.get("bug", {})
	if typeof(bug) != TYPE_DICTIONARY:
		return false
	var correct_line_index := int(bug.get("correct_line_index", -1))
	if correct_line_index < 0 or correct_line_index >= code_lines.size():
		return false

	var fix_options: Array = bug.get("fix_options", [])
	if fix_options.size() != 3:
		return false

	var required_ids: Dictionary = {"A": true, "B": true, "C": true}
	var ids_seen: Dictionary = {}
	for fix_var in fix_options:
		if typeof(fix_var) != TYPE_DICTIONARY:
			return false
		var fix: Dictionary = fix_var
		var option_id := str(fix.get("option_id", "")).strip_edges().to_upper()
		if not required_ids.has(option_id):
			return false
		if ids_seen.has(option_id):
			return false
		if not fix.has("replace_line") or str(fix.get("replace_line", "")) == "":
			return false
		if not _is_numeric(fix.get("result_s", null)):
			return false
		ids_seen[option_id] = true

	var explain_short_raw: Variant = level.get("explain_short", [])
	if typeof(explain_short_raw) != TYPE_ARRAY:
		return false
	var explain_short: Array = explain_short_raw
	for line_var in explain_short:
		if typeof(line_var) != TYPE_STRING:
			return false

	var correct_option_id := str(bug.get("correct_option_id", "")).strip_edges().to_upper()
	return required_ids.has(correct_option_id) and ids_seen.has("A") and ids_seen.has("B") and ids_seen.has("C")

func _is_numeric(value: Variant) -> bool:
	var value_type := typeof(value)
	return value_type == TYPE_INT or value_type == TYPE_FLOAT

func build_variant_key(level: Dictionary) -> String:
	var bug: Dictionary = level.get("bug", {})
	var code_blob := "\n".join(level.get("code_lines", []))
	var fix_parts: Array[String] = []
	for fix_var in bug.get("fix_options", []):
		if typeof(fix_var) != TYPE_DICTIONARY:
			continue
		var fix: Dictionary = fix_var
		fix_parts.append("%s:%s:%s" % [
			str(fix.get("option_id", "")),
			str(fix.get("replace_line", "")),
			str(fix.get("result_s", ""))
		])
	fix_parts.sort()
	return "%s|exp:%s|act:%s|%s|line:%s|opts:%s" % [
		str(level.get("id", "")),
		str(level.get("expected_s", "")),
		str(level.get("actual_s", "")),
		code_blob,
		str(bug.get("correct_line_index", -1)),
		",".join(fix_parts)
	]

func _start_level(idx: int) -> void:
	if idx >= levels.size():
		idx = 0
	current_level_idx = idx
	current_task = (levels[idx] as Dictionary).duplicate(true)
	variant_hash = str(hash(build_variant_key(current_task)))
	task_started_ticks = Time.get_ticks_msec()
	paused_total_ms = 0
	pause_started_ticks = -1
	hint_open_ticks = 0
	hint_total_ms = 0
	selected_line_index = -1
	selected_option_id = ""
	misclicks_before_correct = 0
	wrong_fix_attempts_before_correct = 0
	has_selected_correct_line = false
	level_result_sent = false
	line_pick_armed = false
	last_scroll_vertical = -1
	state = State.LINE_SELECT

	task_session = {
		"task_id": str(current_task.get("id", "C-00")),
		"variant_hash": variant_hash,
		"started_at_ticks": task_started_ticks,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": [],
		"hint_total_ms": 0,
		"paused_total_ms": 0
	}

	lbl_clue_title.text = "ДЕЛО C: РАЗМИНИРОВАНИЕ"
	lbl_session.text = "СЕССИЯ: %s" % str(current_task.get("id", "C-00"))
	lbl_expected_value.text = "s = %s" % str(current_task.get("expected_s", "?"))
	lbl_actual_value.text = "s = %s" % str(current_task.get("actual_s", "?"))
	lbl_hint.text = "Нажмите на строку с ошибкой, затем выберите исправление."
	_update_misclick_label()

	btn_verify.disabled = true
	btn_next.visible = false
	diagnostics_blocker.visible = false
	diagnostics_panel.visible = false
	fix_menu.hide()
	_render_code()
	_set_actual_panel_error(true, false)
	_log_event("task_start", {"bucket": str(current_task.get("bucket", "unknown"))})

func _render_code(caret_line: int = 0) -> void:
	var base_lines: Array = current_task.get("code_lines", [])
	_set_code_lines(base_lines, caret_line)

func _set_code_lines(lines: Array, caret_line: int) -> void:
	suppress_caret_event = true
	code_view.text = "\n".join(lines)
	if lines.is_empty():
		code_view.set_caret_line(0)
	else:
		var safe_line: int = clampi(caret_line, 0, lines.size() - 1)
		code_view.set_caret_line(safe_line)
	code_view.set_caret_column(0)
	suppress_caret_event = false

func _get_fix_option(option_id: String) -> Dictionary:
	var normalized_option_id := option_id.strip_edges().to_upper()
	var fix_options: Array = current_task.get("bug", {}).get("fix_options", [])
	for fix_var in fix_options:
		if typeof(fix_var) != TYPE_DICTIONARY:
			continue
		var fix: Dictionary = fix_var
		if str(fix.get("option_id", "")).strip_edges().to_upper() == normalized_option_id:
			return fix
	return {}

func _apply_fix_preview() -> void:
	if selected_line_index < 0:
		return
	var base_lines: Array = current_task.get("code_lines", [])
	if selected_line_index >= base_lines.size():
		return
	var fix: Dictionary = _get_fix_option(selected_option_id)
	if fix.is_empty():
		return
	var preview_lines: Array = base_lines.duplicate()
	preview_lines[selected_line_index] = str(fix.get("replace_line", ""))
	_set_code_lines(preview_lines, selected_line_index)
	_update_line_highlight()

func _on_code_caret_changed() -> void:
	if suppress_caret_event:
		return
	if state == State.FEEDBACK_SUCCESS:
		return
	if not line_pick_armed:
		return
	line_pick_armed = false

	selected_line_index = code_view.get_caret_line()
	selected_option_id = ""
	btn_verify.disabled = true
	_render_code(selected_line_index)
	_log_event("line_clicked", {"line": selected_line_index})

	var correct_line := int(current_task.get("bug", {}).get("correct_line_index", -1))
	if selected_line_index == correct_line:
		has_selected_correct_line = true
	elif not has_selected_correct_line:
		misclicks_before_correct += 1
		_update_misclick_label()

	_update_line_highlight()
	_open_fix_menu()

func _on_code_gui_input(event: InputEvent) -> void:
	if state == State.FEEDBACK_SUCCESS:
		return
	if state == State.DIAGNOSTIC:
		return
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.pressed and mouse_event.button_index == MOUSE_BUTTON_LEFT:
			line_pick_armed = true
	elif event is InputEventScreenTouch:
		var touch_event: InputEventScreenTouch = event
		if touch_event.pressed:
			line_pick_armed = true

func _update_line_highlight(restart_animation: bool = true) -> void:
	if selected_line_index < 0:
		line_highlight.visible = false
		return

	var visible_line_index := selected_line_index - _get_scroll_vertical()
	line_highlight.position = Vector2(6, 6 + (visible_line_index * cached_line_height))
	line_highlight.size = Vector2(code_view.size.x - 12, float(cached_line_height))
	line_highlight.visible = true

	if restart_animation:
		if highlight_tween != null:
			highlight_tween.kill()
		highlight_tween = create_tween().set_loops()
		highlight_tween.tween_property(line_highlight, "modulate:a", 0.26, 0.28)
		highlight_tween.tween_property(line_highlight, "modulate:a", 0.12, 0.28)

func _get_scroll_vertical() -> int:
	if code_view.has_method("get_v_scroll"):
		return int(code_view.call("get_v_scroll"))
	if code_view.has_method("get_scroll_vertical"):
		return int(code_view.call("get_scroll_vertical"))
	for prop_var in code_view.get_property_list():
		if typeof(prop_var) != TYPE_DICTIONARY:
			continue
		var prop: Dictionary = prop_var
		var prop_name := str(prop.get("name", ""))
		if prop_name == "scroll_vertical" or prop_name == "v_scroll":
			return int(code_view.get(prop_name))
	return 0

func _process(_delta: float) -> void:
	if not line_highlight.visible:
		return
	var scroll_vertical := _get_scroll_vertical()
	if scroll_vertical != last_scroll_vertical:
		last_scroll_vertical = scroll_vertical
		_update_line_highlight(false)

func _open_fix_menu() -> void:
	if selected_line_index < 0:
		return

	var lines: Array = current_task.get("code_lines", [])
	var original_line := ""
	if selected_line_index >= 0 and selected_line_index < lines.size():
		original_line = str(lines[selected_line_index])

	fix_menu.call(
		"setup",
		selected_line_index + 1,
		original_line,
		current_task.get("bug", {}).get("fix_options", []),
		selected_option_id
	)
	state = State.FIX_MENU
	_log_event("fix_menu_open", {"line": selected_line_index})
	fix_menu.popup_centered_ratio(0.68)

func _on_fix_option_selected(option_id: String) -> void:
	selected_option_id = option_id.strip_edges().to_upper()
	_apply_fix_preview()
	_log_event("fix_selected", {"option_id": selected_option_id, "line": selected_line_index})

func _on_fix_apply_requested(option_id: String) -> void:
	selected_option_id = option_id.strip_edges().to_upper()
	btn_verify.disabled = selected_line_index < 0 or selected_option_id == ""
	_apply_fix_preview()
	lbl_hint.text = "Исправление применено. Нажмите ПРОВЕРИТЬ."
	state = State.READY_TO_VERIFY
	_log_event("fix_applied", {"option_id": selected_option_id, "line": selected_line_index})

func _on_fix_menu_canceled() -> void:
	if state != State.FEEDBACK_SUCCESS:
		selected_option_id = ""
		btn_verify.disabled = true
		if selected_line_index >= 0:
			_render_code(selected_line_index)
			_update_line_highlight()
		state = State.LINE_SELECT

func _on_verify_pressed() -> void:
	if btn_verify.disabled:
		return
	if selected_line_index < 0 or selected_option_id == "":
		return

	state = State.VERIFY
	_log_event("verify_pressed", {"line": selected_line_index, "option_id": selected_option_id})

	var bug: Dictionary = current_task.get("bug", {})
	var correct_line := int(bug.get("correct_line_index", -1))
	var correct_option := str(bug.get("correct_option_id", "")).strip_edges().to_upper()
	var is_correct := (selected_line_index == correct_line and selected_option_id == correct_option)
	var effective_time_ms := _effective_elapsed_ms(Time.get_ticks_msec())
	var paused_ms_snapshot := paused_total_ms
	var hint_ms_snapshot := hint_total_ms

	if selected_line_index == correct_line and selected_option_id != correct_option:
		wrong_fix_attempts_before_correct += 1

	var attempt := {
		"kind": "debugging",
		"level_id": str(current_task.get("id", "C-00")),
		"task_id": str(current_task.get("id", "C-00")),
		"variant_hash": variant_hash,
		"selected_line_index": selected_line_index,
		"fix_option_id": selected_option_id,
		"correct": is_correct,
		"effective_time_ms": effective_time_ms,
		"paused_total_ms": paused_ms_snapshot,
		"hint_total_ms": hint_ms_snapshot,
		"misclicks_before_correct": misclicks_before_correct,
		"wrong_fix_attempts_before_correct": wrong_fix_attempts_before_correct
	}
	(task_session["attempts"] as Array).append(attempt)

	if is_correct:
		_handle_success()
	else:
		_handle_fail(correct_line)

func _handle_success() -> void:
	state = State.FEEDBACK_SUCCESS
	lbl_actual_value.text = "s = %s" % str(current_task.get("expected_s", "?"))
	lbl_hint.text = "ДОСТУП РАЗРЕШЁН"
	btn_verify.disabled = true
	btn_next.visible = true
	_set_actual_panel_error(false)
	_register_result(true)

func _handle_fail(correct_line: int) -> void:
	state = State.FEEDBACK_FAIL
	_set_actual_panel_error(true)

	var selected_result: Variant = _get_selected_fix_result()
	if selected_line_index == correct_line and selected_result != null:
		lbl_actual_value.text = "s = %s" % str(selected_result)
		lbl_hint.text = "Неверное исправление: результат не совпадает."
	else:
		lbl_hint.text = "Выбрана неверная строка."

func _set_actual_panel_error(is_error: bool, pulse: bool = true) -> void:
	if is_error:
		actual_panel.modulate = Color(0.78, 0.78, 0.76, 1.0)
		if pulse:
			var tw := create_tween()
			tw.tween_property(actual_panel, "modulate", Color(0.9, 0.9, 0.88, 1.0), 0.12)
			tw.tween_property(actual_panel, "modulate", Color(0.78, 0.78, 0.76, 1.0), 0.14)
			tw.tween_property(actual_panel, "modulate", Color(0.9, 0.9, 0.88, 1.0), 0.14)
			tw.tween_property(actual_panel, "modulate", Color(0.78, 0.78, 0.76, 1.0), 0.16)
	else:
		actual_panel.modulate = Color(0.92, 0.92, 0.9, 1.0)

func _get_selected_fix_result() -> Variant:
	var fix_options: Array = current_task.get("bug", {}).get("fix_options", [])
	var normalized_option_id := selected_option_id.strip_edges().to_upper()
	for fix_var in fix_options:
		if typeof(fix_var) != TYPE_DICTIONARY:
			continue
		var fix: Dictionary = fix_var
		if str(fix.get("option_id", "")).strip_edges().to_upper() == normalized_option_id:
			return fix.get("result_s", null)
	return null

func _on_analyze_pressed() -> void:
	if diagnostics_panel.visible:
		return
	var analysis_lines: Array = []
	analysis_lines.append("Ожидаемое: s=%s" % str(current_task.get("expected_s", "?")))
	analysis_lines.append("Фактическое: s=%s" % str(current_task.get("actual_s", "?")))
	if selected_line_index >= 0:
		analysis_lines.append("Выбранная строка: %d" % (selected_line_index + 1))
	if selected_option_id != "":
		var fix_result: Variant = _get_selected_fix_result()
		var fix_line := ""
		var fix: Dictionary = _get_fix_option(selected_option_id)
		if not fix.is_empty():
			fix_line = str(fix.get("replace_line", ""))
		analysis_lines.append("Ваш вариант: %s -> s=%s" % [selected_option_id, str(fix_result)])
		if fix_line != "":
			analysis_lines.append("Заменить на: %s" % fix_line)
	analysis_lines.append("")
	for line_var in current_task.get("explain_short", []):
		analysis_lines.append(str(line_var))
	diagnostics_panel.call("setup", "ДИАГНОСТИКА: %s" % str(current_task.get("id", "C-00")), analysis_lines)
	diagnostics_panel.visible = true

func _on_diagnostics_visibility_changed() -> void:
	if diagnostics_panel.visible:
		diagnostics_blocker.visible = true
		if pause_started_ticks == -1 and hint_open_ticks == 0:
			hint_open_ticks = Time.get_ticks_msec()
		_log_event("analyze_open", {})
		state = State.DIAGNOSTIC
	else:
		diagnostics_blocker.visible = false
		if hint_open_ticks > 0:
			var delta := Time.get_ticks_msec() - hint_open_ticks
			hint_total_ms += delta
			task_session["hint_total_ms"] = hint_total_ms
			_log_event("analyze_close", {"duration_ms": delta})
			hint_open_ticks = 0
		if state != State.FEEDBACK_SUCCESS:
			state = State.LINE_SELECT

func _notification(what: int) -> void:
	if task_started_ticks <= 0:
		return

	if what == MainLoop.NOTIFICATION_APPLICATION_PAUSED:
		_on_app_paused()
	elif what == MainLoop.NOTIFICATION_APPLICATION_RESUMED:
		_on_app_resumed()

func _on_app_paused() -> void:
	# Debounce duplicate pause callbacks on some Android devices.
	if pause_started_ticks != -1:
		return

	var now_ticks := Time.get_ticks_msec()
	pause_started_ticks = now_ticks

	# If diagnostics is open, stop hint timer before pause window.
	if hint_open_ticks > 0:
		hint_total_ms += maxi(0, now_ticks - hint_open_ticks)
		task_session["hint_total_ms"] = hint_total_ms
		hint_open_ticks = 0

	_log_event("app_paused", {})

func _on_app_resumed() -> void:
	# Debounce duplicate resume callbacks.
	if pause_started_ticks == -1:
		return

	var now_ticks := Time.get_ticks_msec()
	var pause_delta := maxi(0, now_ticks - pause_started_ticks)
	paused_total_ms += pause_delta
	pause_started_ticks = -1
	task_session["paused_total_ms"] = paused_total_ms

	# If diagnostics is still visible, resume hint timer from now.
	if diagnostics_panel.visible:
		hint_open_ticks = now_ticks

	_log_event("app_resumed", {"paused_ms": pause_delta})

func _on_next_pressed() -> void:
	_log_event("task_end", {"status": "next_pressed"})
	_start_level(current_level_idx + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _register_result(is_correct: bool) -> void:
	if level_result_sent:
		return
	level_result_sent = true
	var end_ticks := Time.get_ticks_msec()
	task_session["ended_at_ticks"] = end_ticks
	task_session["hint_total_ms"] = hint_total_ms
	task_session["paused_total_ms"] = paused_total_ms
	task_session["is_correct"] = is_correct
	_log_event("task_end", {"status": "complete", "is_correct": is_correct})

	var elapsed_ms := _effective_elapsed_ms(end_ticks)
	var payload := {
		"match_key": "DISARM_C|%s" % str(current_task.get("id", "C-00")),
		"is_correct": is_correct,
		"is_fit": is_correct,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"task_id": str(current_task.get("id", "C-00")),
		"variant_hash": variant_hash,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _effective_elapsed_ms(now_ticks: int) -> int:
	var paused_ms := paused_total_ms
	if pause_started_ticks != -1:
		paused_ms += maxi(0, now_ticks - pause_started_ticks)

	var hint_ms := hint_total_ms
	if hint_open_ticks > 0:
		hint_ms += maxi(0, now_ticks - hint_open_ticks)

	return maxi(0, (now_ticks - task_started_ticks) - paused_ms - hint_ms)

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": _effective_elapsed_ms(Time.get_ticks_msec()),
		"payload": payload
	})
	task_session["events"] = events

func _update_misclick_label() -> void:
	lbl_misclicks.text = "ПРОМАХИ: %d" % misclicks_before_correct
</file>

<file path="scripts/RestoreQuestB.gd">
extends Control

const LEVELS_PATH := "res://data/quest_b_levels.json"
const CODE_BLOCK_SCENE := preload("res://scripts/ui/CodeBlock.gd")
const MAX_ATTEMPTS := 3

const AUDIO_CLICK := preload("res://audio/click.wav")
const AUDIO_ERROR := preload("res://audio/error.wav")
const AUDIO_RELAY := preload("res://audio/relay.wav")

enum State {
	INIT,
	SOLVING_EMPTY,
	SOLVING_FILLED,
	SUBMITTING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	DIAGNOSTIC,
	SAFE_MODE
}

@onready var lbl_clue_title: Label = $MainLayout/Header/LblClueTitle
@onready var lbl_session: Label = $MainLayout/Header/LblSessionId
@onready var btn_back: Button = $MainLayout/Header/BtnBack
@onready var decrypt_bar: ProgressBar = $MainLayout/BarsRow/DecryptBar
@onready var energy_bar: ProgressBar = $MainLayout/BarsRow/EnergyBar
@onready var lbl_target: Label = $MainLayout/TargetDisplay/LblTarget
@onready var code_display: RichTextLabel = $MainLayout/TerminalFrame/CodeScroll/CodeDisplay
@onready var drop_zone: PanelContainer = $MainLayout/SlotRow/DropZone
@onready var lbl_slot_hint: Label = $MainLayout/SlotRow/LblSlotHint
@onready var blocks_container: HBoxContainer = $MainLayout/InventoryFrame/InventoryMargin/InventoryScroll/BlocksContainer
@onready var btn_analyze: Button = $MainLayout/Actions/BtnAnalyze
@onready var btn_submit: Button = $MainLayout/Actions/BtnSubmit
@onready var btn_next: Button = $MainLayout/Actions/BtnNext
@onready var diagnostics_blocker: ColorRect = $DiagnosticsBlocker
@onready var diag_panel: PanelContainer = $DiagnosticsPanelB

var levels: Array = []
var current_level_idx := 0
var current_task: Dictionary = {}
var state: State = State.INIT
var energy := 100.0
var wrong_count := 0
var task_started_at := 0
var t_start_ticks := 0
var paused_total_ms := 0
var pause_started_ticks := -1
var hint_total_ms := 0
var hint_open_time := 0
var switches_before_submit := 0
var is_safe_mode := false
var variant_hash := ""
var level_result_sent := false
var task_session: Dictionary = {}

func _ready() -> void:
	_load_levels_from_json()
	_connect_signals()

	diag_panel.mouse_filter = Control.MOUSE_FILTER_STOP
	diagnostics_blocker.mouse_filter = Control.MOUSE_FILTER_STOP
	diagnostics_blocker.visible = false
	diag_panel.visible = false

	current_level_idx = GlobalMetrics.current_level_index
	if current_level_idx < 0 or current_level_idx >= levels.size():
		current_level_idx = 0

	_start_level(current_level_idx)

func _load_levels_from_json() -> void:
	levels.clear()
	if not FileAccess.file_exists(LEVELS_PATH):
		push_error("Levels file not found: " + LEVELS_PATH)
		return

	var file := FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if file == null:
		push_error("Unable to open levels file: " + LEVELS_PATH)
		return

	var json := JSON.new()
	if json.parse(file.get_as_text()) != OK:
		push_error("JSON parse error in quest_b_levels.json: " + json.get_error_message())
		return

	if typeof(json.data) != TYPE_ARRAY:
		push_error("quest_b_levels.json root must be an array.")
		return

	for raw_level in json.data:
		if typeof(raw_level) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = raw_level
		if _validate_level(level):
			levels.append(level)
		else:
			push_warning("Skipping invalid RestoreQuestB level: " + str(level.get("id", "UNKNOWN")))

func _validate_level(level: Dictionary) -> bool:
	var slot: Dictionary = level.get("slot", {})
	var blocks: Array = level.get("blocks", [])
	var slot_type: String = str(slot.get("slot_type", ""))
	if slot_type != "INT" and slot_type != "OP":
		return false
	if blocks.is_empty():
		return false

	var has_correct := false
	var correct_id := str(level.get("correct_block_id", ""))
	for b in blocks:
		if typeof(b) != TYPE_DICTIONARY:
			return false
		var block: Dictionary = b
		if str(block.get("slot_type", "")) != slot_type:
			return false
		if str(block.get("block_id", "")) == correct_id:
			has_correct = true
	return has_correct

func _connect_signals() -> void:
	drop_zone.block_dropped.connect(_on_block_dropped)
	btn_back.pressed.connect(_on_back_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	diag_panel.visibility_changed.connect(_on_diag_visibility_changed)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func build_variant_key(task: Dictionary) -> String:
	var code: String = "\n".join(task.get("code_template", []))
	var target := str(task.get("target_s", ""))
	var slot: Dictionary = task.get("slot", {})
	var slot_type := str(slot.get("slot_type", ""))
	var ids: Array[String] = []
	for b in task.get("blocks", []):
		if typeof(b) == TYPE_DICTIONARY:
			ids.append(str((b as Dictionary).get("block_id", "")))
	ids.sort()
	return "%s|%s|%s|%s|%s" % [str(task.get("id", "")), code, target, slot_type, ",".join(ids)]

func _start_level(idx: int) -> void:
	if levels.is_empty():
		return
	if idx >= levels.size():
		idx = 0

	current_level_idx = idx
	current_task = (levels[idx] as Dictionary).duplicate(true)
	variant_hash = str(hash(build_variant_key(current_task)))
	t_start_ticks = Time.get_ticks_msec()
	task_started_at = t_start_ticks
	paused_total_ms = 0
	pause_started_ticks = -1
	level_result_sent = false

	task_session = {
		"task_id": str(current_task.get("id", "B-00")),
		"variant_hash": variant_hash,
		"started_at_ticks": t_start_ticks,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": [],
		"hint_total_ms": 0,
		"paused_total_ms": 0
	}

	state = State.SOLVING_EMPTY
	energy = 100.0
	wrong_count = 0
	hint_total_ms = 0
	hint_open_time = 0
	switches_before_submit = 0
	is_safe_mode = false

	lbl_clue_title.text = "ВОССТАНОВЛЕНИЕ " + str(current_task.get("id", "B-00"))
	lbl_session.text = "СЕСС " + str(randi() % 9000 + 1000)
	lbl_target.text = "ЦЕЛЬ: s = " + str(current_task.get("target_s", "?"))
	lbl_slot_hint.text = "<-- Перетащите блок сюда"

	_render_code()
	_render_inventory()
	drop_zone.call("setup", str(current_task.get("slot", {}).get("slot_type", "INT")))
	drop_zone.modulate = Color(1, 1, 1, 1)

	btn_submit.disabled = true
	btn_analyze.disabled = false
	btn_next.visible = false
	energy_bar.value = energy

	diagnostics_blocker.visible = false
	diag_panel.visible = false

	_log_event("task_start", {"bucket": str(current_task.get("bucket", "unknown"))})

func _render_code() -> void:
	var txt := ""
	for line in current_task.get("code_template", []):
		var processed := str(line).replace("[SLOT]", "[color=#EDECE8][SLOT][/color]")
		txt += processed + "\n"
	code_display.text = txt

func _render_inventory() -> void:
	for child in blocks_container.get_children():
		child.queue_free()

	for b_data in current_task.get("blocks", []):
		if typeof(b_data) != TYPE_DICTIONARY:
			continue
		var btn := Button.new()
		btn.set_script(CODE_BLOCK_SCENE)
		btn.call("setup", b_data)
		btn.custom_minimum_size = Vector2(160, 80)
		blocks_container.add_child(btn)

func _on_block_dropped(data: Dictionary) -> void:
	_play_sound(AUDIO_CLICK)

	var prev_id: Variant = drop_zone.call("get_last_prev_block_id")
	var new_id: Variant = data.get("block_id", null)
	if prev_id != null and new_id != null and str(prev_id) != str(new_id):
		switches_before_submit += 1

	state = State.SOLVING_FILLED
	btn_submit.disabled = false
	lbl_slot_hint.text = "Готово к проверке."

	_log_event("slot_changed", {"prev": prev_id, "new": new_id})

func _on_submit_pressed() -> void:
	if state != State.SOLVING_FILLED:
		return

	state = State.SUBMITTING
	btn_submit.disabled = true

	var selected_id: Variant = drop_zone.call("get_block_id")
	var correct_id: Variant = current_task.get("correct_block_id", null)
	var is_correct := str(selected_id) == str(correct_id)
	var end_ticks := Time.get_ticks_msec()
	var elapsed_input_ms := _effective_elapsed_ms(end_ticks)
	var is_terminal_fail := (not is_correct) and (wrong_count + 1 >= MAX_ATTEMPTS)
	var state_after := "FEEDBACK_SUCCESS" if is_correct else ("SAFE_MODE" if is_terminal_fail else "FEEDBACK_FAIL")

	var attempt := {
		"kind": "block_selection",
		"selected_block_id": selected_id,
		"correct_block_id": correct_id,
		"switches_before_submit": switches_before_submit,
		"duration_input_ms": elapsed_input_ms,
		"duration_input_ms_excluding_hint": elapsed_input_ms,
		"hint_open_at_submit": diag_panel.visible,
		"correct": is_correct,
		"state_after": state_after
	}
	(task_session["attempts"] as Array).append(attempt)
	_log_event("submit_pressed", {"correct": is_correct, "selected": selected_id})

	if is_correct:
		_handle_success(end_ticks)
	elif is_terminal_fail:
		wrong_count += 1
		_handle_fail_terminal(end_ticks)
	else:
		wrong_count += 1
		_handle_fail_retry(selected_id)

func _handle_success(end_ticks: int) -> void:
	state = State.FEEDBACK_SUCCESS
	_play_sound(AUDIO_RELAY)
	drop_zone.modulate = Color(0.96, 0.96, 0.94, 1.0)
	decrypt_bar.value += float(current_task.get("economy", {}).get("reward", 0))
	btn_analyze.disabled = true
	btn_submit.disabled = true
	btn_next.visible = true
	_register_result(true, end_ticks, "SUCCESS")

func _handle_fail_retry(selected_id) -> void:
	state = State.FEEDBACK_FAIL
	_play_sound(AUDIO_ERROR)
	energy = maxf(0.0, energy - float(current_task.get("economy", {}).get("wrong_penalty", 0)))
	energy_bar.value = energy
	drop_zone.call("reset")
	drop_zone.modulate = Color(0.88, 0.88, 0.86, 1.0)
	lbl_slot_hint.text = "Неверно. Попробуйте снова."
	state = State.SOLVING_EMPTY
	btn_submit.disabled = true
	_show_distractor_feedback(selected_id)

func _handle_fail_terminal(end_ticks: int) -> void:
	_play_sound(AUDIO_ERROR)
	energy = maxf(0.0, energy - float(current_task.get("economy", {}).get("wrong_penalty", 0)))
	energy_bar.value = energy
	_trigger_safe_mode(end_ticks)

func _trigger_safe_mode(end_ticks: int) -> void:
	state = State.SAFE_MODE
	is_safe_mode = true
	_on_analyze_pressed(true)
	btn_analyze.disabled = true
	btn_submit.disabled = true
	btn_next.visible = true
	_log_event("safe_mode_triggered", {})
	_register_result(false, end_ticks, "SAFE_MODE")

func _on_analyze_pressed(free := false) -> void:
	if diag_panel.visible:
		return

	if not free:
		var cost := int(current_task.get("economy", {}).get("analyze_cost", 0))
		if energy < float(cost):
			_play_sound(AUDIO_ERROR)
			return
		energy -= float(cost)
		energy_bar.value = energy

	diag_panel.call(
		"setup",
		current_task.get("explain_short", []),
		current_task.get("trace_correct", [])
	)
	diag_panel.visible = true

func _on_diag_visibility_changed() -> void:
	if diag_panel.visible:
		diagnostics_blocker.visible = true
		if pause_started_ticks == -1:
			hint_open_time = Time.get_ticks_msec()
		_log_event("analyze_open", {})
	else:
		diagnostics_blocker.visible = false
		var duration := _consume_open_hint_duration(Time.get_ticks_msec())
		if duration > 0:
			_log_event("analyze_close", {"duration_ms": duration})

func _notification(what: int) -> void:
	if t_start_ticks <= 0:
		return
	if what == MainLoop.NOTIFICATION_APPLICATION_PAUSED:
		_on_app_paused()
	elif what == MainLoop.NOTIFICATION_APPLICATION_RESUMED:
		_on_app_resumed()

func _on_app_paused() -> void:
	if pause_started_ticks != -1:
		return
	var now_ticks := Time.get_ticks_msec()
	pause_started_ticks = now_ticks
	_consume_open_hint_duration(now_ticks)
	_log_event("app_paused", {})

func _on_app_resumed() -> void:
	if pause_started_ticks == -1:
		return
	var now_ticks := Time.get_ticks_msec()
	var paused_ms := maxi(0, now_ticks - pause_started_ticks)
	paused_total_ms += paused_ms
	pause_started_ticks = -1
	task_session["paused_total_ms"] = paused_total_ms
	if diag_panel.visible:
		hint_open_time = now_ticks
	_log_event("app_resumed", {"paused_ms": paused_ms})

func _on_next_pressed() -> void:
	if diag_panel.visible:
		diag_panel.visible = false
	_log_event("next_pressed", {"from_task": str(current_task.get("id", "B-00"))})
	_start_level(current_level_idx + 1)

func _register_result(is_correct: bool, end_ticks: int, reason: String) -> void:
	if level_result_sent:
		return
	level_result_sent = true

	var elapsed_ms := _effective_elapsed_ms(end_ticks)
	task_session["ended_at_ticks"] = end_ticks
	task_session["hint_total_ms"] = hint_total_ms
	task_session["paused_total_ms"] = paused_total_ms
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	var payload := {
		"match_key": "RESTORE_B|%s" % str(current_task.get("id", "B-00")),
		"is_correct": is_correct,
		"is_fit": is_correct,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"task_id": str(current_task.get("id", "B-00")),
		"variant_hash": variant_hash,
		"task_session": task_session
	}
	GlobalMetrics.register_trial(payload)

func _log_event(name: String, payload: Dictionary) -> void:
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": _effective_elapsed_ms(Time.get_ticks_msec()),
		"payload": payload
	})
	task_session["events"] = events

func _effective_elapsed_ms(now_ticks: int) -> int:
	return maxi(0, (now_ticks - t_start_ticks) - paused_total_ms - hint_total_ms)

func _consume_open_hint_duration(until_ticks: int) -> int:
	if hint_open_time <= 0:
		return 0
	var duration := maxi(0, until_ticks - hint_open_time)
	hint_total_ms += duration
	task_session["hint_total_ms"] = hint_total_ms
	hint_open_time = 0
	return duration

func _show_distractor_feedback(selected_id) -> void:
	var map: Variant = current_task.get("distractor_feedback", {})
	if typeof(map) != TYPE_DICTIONARY:
		return
	var key := str(selected_id)
	if not map.has(key):
		return
	var feedback: Variant = map[key]
	if typeof(feedback) != TYPE_DICTIONARY:
		return

	var s_final = str((feedback as Dictionary).get("s_final", "?"))
	var hint = str((feedback as Dictionary).get("hint", ""))
	var target = str(current_task.get("target_s", "?"))
	var explain_lines := [
		"Получилось s=%s, нужно s=%s." % [s_final, target],
		hint
	]
	diag_panel.call("setup", explain_lines, [])
	diag_panel.visible = true
	_log_event("distractor_feedback_shown", {"selected": key, "s_final": s_final})

func _play_sound(stream: AudioStream) -> void:
	var player := AudioStreamPlayer.new()
	player.stream = stream
	add_child(player)
	player.play()
	player.finished.connect(player.queue_free)
</file>

<file path="scripts/SuspectQuestA.gd">
extends Control

const THEME_NOIR: Theme = preload("res://ui/theme_noir_pencil.tres")

const AUDIO_CLICK: AudioStream = preload("res://audio/click.wav")
const AUDIO_ERROR: AudioStream = preload("res://audio/error.wav")
const AUDIO_RELAY: AudioStream = preload("res://audio/relay.wav")

const LEVELS_PATH := "res://data/suspect_a_levels.json"
const MAX_ATTEMPTS := 3
const PALETTE_ID_NOIR := 0
const FX_ID_LOW := 0
const FX_ID_HIGH := 1

const STATUS_COLOR_NEUTRAL := Color(0.72, 0.72, 0.7)
const STATUS_COLOR_READY := Color(0.93, 0.93, 0.91)
const STATUS_COLOR_FAIL := Color(0.82, 0.82, 0.8)
const STATUS_COLOR_WARN := Color(0.78, 0.78, 0.76)
const STATUS_COLOR_SUCCESS := Color(0.97, 0.97, 0.95)

enum State {
	INIT,
	BRIEFING,
	SOLVING,
	FEEDBACK_SUCCESS,
	FEEDBACK_FAIL,
	SAFE_MODE,
	DIAGNOSTIC
}

@export_enum("noir") var terminal_palette: String = "noir"
@export_enum("low", "high") var fx_quality: String = "low"
@export var typewriter_delay_sec: float = 0.03

@onready var main_layout: VBoxContainer = $MainLayout
@onready var noir_overlay: ColorRect = $CanvasLayer/NoirOverlay
@onready var code_label: RichTextLabel = $MainLayout/TerminalFrame/ScrollContainer/CodeLabel
@onready var code_scroll: ScrollContainer = $MainLayout/TerminalFrame/ScrollContainer
@onready var input_display: Label = $MainLayout/InputFrame/InputDisplay
@onready var lbl_status: Label = $MainLayout/StatusRow/LblStatus
@onready var lbl_attempts: Label = $MainLayout/StatusRow/LblAttempts
@onready var decrypt_bar: ProgressBar = $MainLayout/BarsRow/DecryptBar
@onready var energy_bar: ProgressBar = $MainLayout/BarsRow/EnergyBar
@onready var diag_panel: PanelContainer = $DiagnosticsPanel
@onready var diag_trace: RichTextLabel = $DiagnosticsPanel/VBoxContainer/TraceList
@onready var diag_explain: RichTextLabel = $DiagnosticsPanel/VBoxContainer/ExplainList
@onready var btn_enter: Button = $MainLayout/Actions/BtnEnter
@onready var btn_analyze: Button = $MainLayout/Actions/BtnAnalyze
@onready var btn_next: Button = $MainLayout/Actions/BtnNext
@onready var btn_close_diag: Button = $DiagnosticsPanel/VBoxContainer/BtnCloseDiag
@onready var btn_quest_back: Button = $MainLayout/Header/BtnQuestBack
@onready var lbl_clue_title: Label = $MainLayout/Header/LblClueTitle
@onready var lbl_session: Label = $MainLayout/Header/LblSessionId
@onready var palette_select: OptionButton = $MainLayout/SettingsRow/PaletteSelect
@onready var fx_select: OptionButton = $MainLayout/SettingsRow/FxSelect
@onready var numpad: GridContainer = $MainLayout/Numpad

var levels: Array = []
var current_level_idx := 0
var current_task: Dictionary = {}
var user_input := ""
var state: State = State.INIT
var energy := 100.0
var wrong_count := 0
var task_started_at := 0
var task_finished := false
var task_result_sent := false
var is_safe_mode := false
var is_code_ready := false
var variant_hash := ""
var task_session: Dictionary = {}

var sfx_player: AudioStreamPlayer

func _ready() -> void:
	_setup_runtime_controls()
	_apply_theme()
	_configure_overlay_shader()
	_init_audio_player()
	_connect_signals()
	_apply_mobile_min_sizes()

	if not _load_levels_from_json():
		_show_boot_error("Не удалось загрузить уровни подозреваемых.")
		return

	if levels.size() != 18:
		push_warning("Suspect levels expected 18, got %d" % levels.size())

	GlobalMetrics.current_level_index = 0
	_load_level(0)

func _apply_theme() -> void:
	theme = THEME_NOIR

func _setup_runtime_controls() -> void:
	palette_select.clear()
	palette_select.add_item("NOIR", PALETTE_ID_NOIR)
	palette_select.select(PALETTE_ID_NOIR)
	palette_select.disabled = true

	fx_select.clear()
	fx_select.add_item("НИЗКИЙ", FX_ID_LOW)
	fx_select.add_item("ВЫСОКИЙ", FX_ID_HIGH)
	fx_select.select(FX_ID_HIGH if fx_quality == "high" else FX_ID_LOW)

	palette_select.item_selected.connect(_on_palette_selected)
	fx_select.item_selected.connect(_on_fx_selected)

func _configure_overlay_shader() -> void:
	var shader_mat := noir_overlay.material as ShaderMaterial
	if shader_mat == null:
		return
	var high_fx := fx_quality == "high"
	shader_mat.set_shader_parameter("fx_quality", 1 if high_fx else 0)
	shader_mat.set_shader_parameter("intensity", 0.34)
	shader_mat.set_shader_parameter("grain_strength", 0.35 if high_fx else 0.24)
	shader_mat.set_shader_parameter("hatch_strength", 0.30 if high_fx else 0.08)
	shader_mat.set_shader_parameter("vignette_strength", 0.45)
	shader_mat.set_shader_parameter("pulse", 0.0)
	shader_mat.set_shader_parameter("jitter_strength", 0.0)

func _init_audio_player() -> void:
	sfx_player = AudioStreamPlayer.new()
	sfx_player.name = "SfxPlayer"
	add_child(sfx_player)

func _connect_signals() -> void:
	for btn in numpad.get_children():
		if btn is Button:
			(btn as Button).pressed.connect(_on_numpad_pressed.bind(btn))

	btn_enter.pressed.connect(_on_enter_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	btn_close_diag.pressed.connect(_on_close_diag_pressed)
	btn_quest_back.pressed.connect(_on_back_pressed)

func _on_palette_selected(index: int) -> void:
	palette_select.get_item_id(index)
	terminal_palette = "noir"
	_apply_theme()
	_configure_overlay_shader()

func _on_fx_selected(index: int) -> void:
	var item_id: int = fx_select.get_item_id(index)
	fx_quality = "high" if item_id == FX_ID_HIGH else "low"
	_configure_overlay_shader()

func _apply_mobile_min_sizes() -> void:
	palette_select.custom_minimum_size = Vector2(120, 44)
	fx_select.custom_minimum_size = Vector2(110, 44)
	for btn in numpad.get_children():
		if btn is Button:
			(btn as Button).custom_minimum_size = Vector2(64, 64)
	btn_enter.custom_minimum_size = Vector2(0, 56)
	btn_analyze.custom_minimum_size = Vector2(0, 56)
	btn_next.custom_minimum_size = Vector2(0, 56)

func _load_levels_from_json() -> bool:
	var f := FileAccess.open(LEVELS_PATH, FileAccess.READ)
	if f == null:
		push_error("Cannot open %s" % LEVELS_PATH)
		return false

	var parsed = JSON.parse_string(f.get_as_text())
	if typeof(parsed) != TYPE_ARRAY:
		push_error("%s is not an array" % LEVELS_PATH)
		return false

	var loaded_levels: Array = parsed
	var valid_levels: Array = []
	for item in loaded_levels:
		if typeof(item) != TYPE_DICTIONARY:
			continue
		var level: Dictionary = item
		if _validate_level(level):
			valid_levels.append(level)
		else:
			push_error("Invalid suspect level: %s" % str(level.get("id", "UNKNOWN")))

	levels = valid_levels
	return levels.size() > 0

func _validate_level(level: Dictionary) -> bool:
	var required_keys := ["id", "bucket", "briefing", "code", "expected", "trace", "explain", "economy"]
	for key in required_keys:
		if not level.has(key):
			return false

	if typeof(level.get("code")) != TYPE_ARRAY:
		return false
	if typeof(level.get("trace")) != TYPE_ARRAY:
		return false
	if typeof(level.get("explain")) != TYPE_ARRAY:
		return false
	if typeof(level.get("economy")) != TYPE_DICTIONARY:
		return false

	var trace: Array = level.get("trace", [])
	if trace.is_empty():
		return false

	for step in trace:
		if typeof(step) != TYPE_DICTIONARY:
			return false
		var d: Dictionary = step
		if not d.has("i") or not d.has("cond") or not d.has("s_before") or not d.has("s_after"):
			return false

	return true

func _show_boot_error(text: String) -> void:
	lbl_status.text = text
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_FAIL)
	btn_enter.disabled = true
	btn_analyze.disabled = true
	btn_next.disabled = true

func _load_level(idx: int) -> void:
	if levels.is_empty():
		return

	if idx >= levels.size():
		idx = 0
	current_level_idx = idx

	current_task = (levels[idx] as Dictionary).duplicate(true)
	variant_hash = str(hash(JSON.stringify(current_task)))
	task_started_at = Time.get_ticks_msec()

	task_session = {
		"task_id": str(current_task.get("id", "A-00")),
		"variant_hash": variant_hash,
		"started_at_ticks": task_started_at,
		"ended_at_ticks": 0,
		"attempts": [],
		"events": []
	}

	state = State.BRIEFING
	wrong_count = 0
	energy = 100.0
	user_input = ""
	is_safe_mode = false
	is_code_ready = false
	task_finished = false
	task_result_sent = false

	lbl_clue_title.text = "УЛИКА #%s" % str(current_task.get("id", "A-00"))
	lbl_session.text = "СЕСС %04d" % (randi() % 10000)
	lbl_status.text = "ДЕШИФРОВКА..."
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_NEUTRAL)
	lbl_attempts.text = "ОШ: 0/%d" % MAX_ATTEMPTS
	decrypt_bar.value = float(current_level_idx) / maxf(1.0, float(levels.size() - 1)) * 100.0
	energy_bar.value = energy

	btn_enter.disabled = true
	btn_analyze.disabled = true
	btn_next.visible = false
	diag_panel.visible = false

	_update_input_display()
	_log_event("task_start", {"bucket": str(current_task.get("bucket", "unknown"))})

	var briefing := str(current_task.get("briefing", ""))
	code_label.text = "[color=#7A7A7A]%s[/color]\n\n" % briefing
	await _typewrite_code(current_task.get("code", []))

	is_code_ready = true
	state = State.SOLVING
	btn_enter.disabled = false
	btn_analyze.disabled = false
	lbl_status.text = "ВВОД ГОТОВ"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_READY)

func _typewrite_code(lines: Array) -> void:
	for line_variant in lines:
		var line := str(line_variant)
		code_label.append_text("[code]%s[/code]\n" % line)
		code_scroll.scroll_vertical = 1000000
		await get_tree().create_timer(typewriter_delay_sec).timeout
	_log_event("code_shown", {"line_count": lines.size()})

func _on_numpad_pressed(btn_node: Node) -> void:
	if state != State.SOLVING or not is_code_ready or task_finished:
		return

	var btn := btn_node as Button
	if btn == null:
		return

	_play_sfx(AUDIO_CLICK)
	var char := btn.text
	if char == "CLR" or char == "СБР":
		user_input = ""
	elif char == "<-":
		if user_input.length() > 0:
			user_input = user_input.left(user_input.length() - 1)
	elif user_input.length() < 4:
		user_input += char

	_update_input_display()

func _update_input_display() -> void:
	input_display.text = "----" if user_input.is_empty() else user_input

func _normalize(raw: String) -> Dictionary:
	var stripped := raw.strip_edges().replace(" ", "")
	if stripped.is_empty():
		return {"ok": false, "error": "EMPTY"}
	if not stripped.is_valid_int():
		return {"ok": false, "error": "NAN"}
	var value := int(stripped)
	if value < 0 or value > 9999:
		return {"ok": false, "error": "RANGE"}
	return {"ok": true, "val": value, "str": str(value)}

func _on_enter_pressed() -> void:
	if state != State.SOLVING or not is_code_ready or task_finished:
		return

	var now := Time.get_ticks_msec()
	var normalized := _normalize(user_input)
	if not bool(normalized.get("ok", false)):
		_play_sfx(AUDIO_ERROR)
		_trigger_glitch()
		_shake_screen()
		lbl_status.text = "НЕКОРРЕКТНЫЙ ВВОД"
		lbl_status.add_theme_color_override("font_color", STATUS_COLOR_FAIL)
		task_session["attempts"].append({
			"kind": "numpad",
			"raw": user_input,
			"norm": "",
			"duration_input_ms": now - task_started_at,
			"correct": false,
			"parse_error": str(normalized.get("error", "UNKNOWN")),
			"state_after": "INVALID_INPUT",
			"energy_after": energy,
			"wrong_count_after": wrong_count
		})
		return

	var expected := int(current_task.get("expected", 0))
	var is_correct := int(normalized.get("val", -1)) == expected
	var state_after := "SOLVING"

	if is_correct:
		_handle_success_feedback()
		state_after = "FEEDBACK_SUCCESS"
	else:
		_handle_fail_feedback()
		if is_safe_mode:
			state_after = "SAFE_MODE"
		elif state == State.FEEDBACK_FAIL:
			state_after = "FEEDBACK_FAIL"

	var attempt := {
		"kind": "numpad",
		"raw": user_input,
		"norm": str(normalized.get("str", "")),
		"duration_input_ms": now - task_started_at,
		"hint_open_at_enter": diag_panel.visible,
		"correct": is_correct,
		"state_after": state_after,
		"energy_after": energy,
		"wrong_count_after": wrong_count
	}
	task_session["attempts"].append(attempt)

	if is_correct:
		_finalize_task_result(true, "SUCCESS")
	elif is_safe_mode:
		_finalize_task_result(false, "SAFE_MODE")

	if not is_correct and not is_safe_mode:
		user_input = ""
		_update_input_display()

func _handle_success_feedback() -> void:
	state = State.FEEDBACK_SUCCESS
	lbl_status.text = "ДОСТУП РАЗРЕШЁН"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_SUCCESS)
	btn_enter.disabled = true
	btn_analyze.disabled = true
	btn_next.visible = true
	decrypt_bar.value = minf(100.0, decrypt_bar.value + float(current_task.get("economy", {}).get("reward", 0)))
	_play_sfx(AUDIO_RELAY)
	_play_success_clean_effect()

func _handle_fail_feedback() -> void:
	wrong_count += 1
	lbl_attempts.text = "ОШ: %d/%d" % [wrong_count, MAX_ATTEMPTS]
	lbl_status.text = "ДОСТУП ЗАПРЕЩЁН"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_FAIL)

	var wrong_penalty := int(current_task.get("economy", {}).get("wrong", 10))
	energy = maxf(0.0, energy - float(wrong_penalty))
	energy_bar.value = energy

	_play_sfx(AUDIO_ERROR)
	_trigger_glitch()
	_shake_screen()

	if wrong_count >= MAX_ATTEMPTS:
		_trigger_safe_mode()
	else:
		state = State.FEEDBACK_FAIL
		state = State.SOLVING

func _trigger_safe_mode() -> void:
	state = State.SAFE_MODE
	is_safe_mode = true
	btn_enter.disabled = true
	btn_next.visible = true
	lbl_status.text = "БЕЗОПАСНЫЙ РЕЖИМ АКТИВЕН"
	lbl_status.add_theme_color_override("font_color", STATUS_COLOR_WARN)

	btn_analyze.disabled = false
	_on_analyze_pressed(true)
	btn_analyze.disabled = true
	_log_event("safe_mode_triggered", {})

func _on_analyze_pressed(free: bool = false) -> void:
	if not is_code_ready:
		return
	if state != State.SOLVING and state != State.SAFE_MODE:
		return

	if not free:
		var analyze_cost := int(current_task.get("economy", {}).get("analyze", 20))
		if energy < float(analyze_cost):
			lbl_status.text = "НЕДОСТАТОЧНО ЭНЕРГИИ"
			lbl_status.add_theme_color_override("font_color", STATUS_COLOR_WARN)
			_play_sfx(AUDIO_ERROR)
			return
		energy -= float(analyze_cost)
		energy_bar.value = energy

	diag_panel.visible = true
	_render_diagnostic()
	_log_event("analyze_open", {"free": free})
	state = State.DIAGNOSTIC if state == State.SOLVING else state

func _render_diagnostic() -> void:
	var explain_lines: Array = current_task.get("explain", [])
	var explain_text := "[b]ANALYSIS[/b]\n"
	for line_var in explain_lines:
		explain_text += "- %s\n" % str(line_var)
	diag_explain.text = explain_text

	var trace: Array = current_task.get("trace", [])
	var trace_text := ""
	for step_var in trace:
		var step: Dictionary = step_var
		trace_text += "i=%s | cond=%s | s: %s -> %s\n" % [
			str(step.get("i", "?")),
			str(step.get("cond", "?")),
			str(step.get("s_before", "?")),
			str(step.get("s_after", "?"))
		]
	diag_trace.text = trace_text

func _on_close_diag_pressed() -> void:
	if not diag_panel.visible:
		return
	diag_panel.visible = false
	_log_event("analyze_close", {})
	if state == State.DIAGNOSTIC and not is_safe_mode and not task_finished:
		state = State.SOLVING

func _on_next_pressed() -> void:
	if not task_finished:
		return
	_log_event("next_pressed", {"from_task": str(current_task.get("id", "A-00"))})
	_load_level(current_level_idx + 1)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _finalize_task_result(is_correct: bool, reason: String) -> void:
	if task_result_sent:
		return

	task_result_sent = true
	task_finished = true
	var ended := Time.get_ticks_msec()
	task_session["ended_at_ticks"] = ended
	_log_event("task_end", {"reason": reason, "is_correct": is_correct})

	var level_id := str(current_task.get("id", "A-00"))
	var bucket := str(current_task.get("bucket", "unknown"))
	var elapsed_ms := ended - task_started_at

	var result_data := {
		"quest": "suspect_script",
		"stage": "A",
		"match_key": "SUSPECT_A|%s" % level_id,
		"task_id": level_id,
		"bucket": bucket,
		"variant_hash": variant_hash,
		"is_correct": is_correct,
		"is_fit": is_correct,
		"safe_mode": is_safe_mode,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"task_session": task_session
	}

	GlobalMetrics.register_trial(result_data)

func _play_sfx(stream: AudioStream) -> void:
	if sfx_player == null:
		return
	sfx_player.stop()
	sfx_player.stream = stream
	sfx_player.play()

func _trigger_glitch() -> void:
	var shader_mat := noir_overlay.material as ShaderMaterial
	if shader_mat == null:
		return
	var is_high_fx := fx_quality == "high"
	var pulse_strength := 1.0 if is_high_fx else 0.65
	var jitter := 0.8 if is_high_fx else 0.35
	shader_mat.set_shader_parameter("pulse", pulse_strength)
	shader_mat.set_shader_parameter("jitter_strength", jitter)
	var tw := create_tween()
	tw.tween_method(func(v: float): shader_mat.set_shader_parameter("pulse", v), pulse_strength, 0.0, 0.26)
	tw.parallel().tween_method(func(v: float): shader_mat.set_shader_parameter("jitter_strength", v), jitter, 0.0, 0.22)

func _shake_screen() -> void:
	var original_pos := main_layout.position
	var tw := create_tween()
	for _i in range(4):
		tw.tween_property(main_layout, "position", original_pos + Vector2(randf_range(-2.0, 2.0), randf_range(-1.5, 1.5)), 0.04)
	tw.tween_property(main_layout, "position", original_pos, 0.05)

func _play_success_clean_effect() -> void:
	var shader_mat := noir_overlay.material as ShaderMaterial
	if shader_mat == null:
		return
	var is_high_fx := fx_quality == "high"
	var base_grain := 0.35 if is_high_fx else 0.24
	var base_hatch := 0.30 if is_high_fx else 0.08
	var reduced_grain := base_grain * 0.42
	var reduced_hatch := base_hatch * 0.35
	var tw := create_tween()
	tw.tween_method(func(v: float): shader_mat.set_shader_parameter("grain_strength", v), base_grain, reduced_grain, 0.18)
	tw.parallel().tween_method(func(v: float): shader_mat.set_shader_parameter("hatch_strength", v), base_hatch, reduced_hatch, 0.18)
	tw.tween_interval(0.14)
	tw.tween_method(func(v: float): shader_mat.set_shader_parameter("grain_strength", v), reduced_grain, base_grain, 0.28)
	tw.parallel().tween_method(func(v: float): shader_mat.set_shader_parameter("hatch_strength", v), reduced_hatch, base_hatch, 0.28)

func _log_event(name: String, payload: Dictionary) -> void:
	var elapsed := Time.get_ticks_msec() - task_started_at
	var events: Array = task_session.get("events", [])
	events.append({
		"name": name,
		"t_ms": elapsed,
		"payload": payload
	})
	task_session["events"] = events
</file>

<file path="scenes/LearnSelect.gd">
extends Control

const PHONE_LANDSCAPE_MAX_HEIGHT := 520.0
const MOBILE_BREAKPOINT := 840.0
const TABLET_BREAKPOINT := 1300.0

@onready var safe_area: MarginContainer = $SafeArea
@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var title_label: Label = $SafeArea/MainLayout/Title
@onready var quest_grid: GridContainer = $SafeArea/MainLayout/QuestGrid
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel

@onready var btn_clues: Button = $SafeArea/MainLayout/QuestGrid/CluesButton
@onready var btn_radio: Button = $SafeArea/MainLayout/QuestGrid/RadioButton
@onready var btn_decryptor: Button = $SafeArea/MainLayout/QuestGrid/DecryptorButton
@onready var btn_lie: Button = $SafeArea/MainLayout/QuestGrid/LieDetectorButton
@onready var btn_script: Button = $SafeArea/MainLayout/QuestGrid/SuspectScriptButton
@onready var btn_city: Button = $SafeArea/MainLayout/QuestGrid/CityMapButton
@onready var btn_archive: Button = $SafeArea/MainLayout/QuestGrid/DataArchiveButton
@onready var btn_report: Button = $SafeArea/MainLayout/QuestGrid/FinalReportButton
@onready var btn_network_trace: Button = $SafeArea/MainLayout/QuestGrid/NetworkTraceButton

const COLOR_READY := Color(0.88, 0.88, 0.88, 1.0)
const COLOR_LOCKED := Color(0.92, 0.36, 0.4, 1.0)

const TITLE_TEXT := "ОБУЧЕНИЕ"
const STATUS_READY := "Выберите учебный модуль"
const STATUS_LOCKED := "Этот модуль пока не готов"

const BTN_CLUES_TEXT := "Цифровая реанимация (скоро)"
const BTN_RADIO_TEXT := "Радиоперехват A"
const BTN_DECRYPTOR_TEXT := "Дешифрование A"
const BTN_LIE_TEXT := "Детектор лжи A"
const BTN_SCRIPT_TEXT := "Скрипт подозреваемого (скоро)"
const BTN_CITY_TEXT := "Карта города (скоро)"
const BTN_ARCHIVE_TEXT := "Архив данных (скоро)"
const BTN_REPORT_TEXT := "Финальный отчет (скоро)"
const BTN_NETWORK_TRACE_TEXT := "Сетевой след (скоро)"

func _ready() -> void:
	title_label.text = TITLE_TEXT
	status_label.text = STATUS_READY
	status_label.modulate = COLOR_READY

	_set_button_labels()
	_connect_buttons()
	_disable_unready()
	_on_viewport_size_changed()
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)
	call_deferred("_animate_intro")

func _set_button_labels() -> void:
	btn_clues.text = BTN_CLUES_TEXT
	btn_radio.text = BTN_RADIO_TEXT
	btn_decryptor.text = BTN_DECRYPTOR_TEXT
	btn_lie.text = BTN_LIE_TEXT
	btn_script.text = BTN_SCRIPT_TEXT
	btn_city.text = BTN_CITY_TEXT
	btn_archive.text = BTN_ARCHIVE_TEXT
	btn_report.text = BTN_REPORT_TEXT
	btn_network_trace.text = BTN_NETWORK_TRACE_TEXT

func _connect_buttons() -> void:
	btn_decryptor.pressed.connect(_on_decryptor_pressed)
	btn_lie.pressed.connect(_on_lie_detector_pressed)
	btn_radio.pressed.connect(_on_radio_pressed)
	btn_clues.pressed.connect(_on_locked_pressed)
	btn_script.pressed.connect(_on_locked_pressed)
	btn_city.pressed.connect(_on_locked_pressed)
	btn_archive.pressed.connect(_on_locked_pressed)
	btn_report.pressed.connect(_on_locked_pressed)
	btn_network_trace.pressed.connect(_on_locked_pressed)

func _disable_unready() -> void:
	btn_clues.disabled = true
	btn_radio.disabled = false
	btn_script.disabled = true
	btn_city.disabled = true
	btn_archive.disabled = true
	btn_report.disabled = true
	btn_network_trace.disabled = true

func _on_decryptor_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	get_tree().change_scene_to_file("res://scenes/Decryptor.tscn")

func _on_lie_detector_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/LogicQuestA.tscn")

func _on_radio_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/RadioQuestA.tscn")

func _on_locked_pressed() -> void:
	status_label.text = STATUS_LOCKED
	status_label.modulate = COLOR_LOCKED

func _on_viewport_size_changed() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var width: float = viewport_size.x
	if _is_phone_landscape(viewport_size):
		quest_grid.columns = 3
		_apply_layout_profile(38, 15, 70, 8, 10, 6)
	elif width < MOBILE_BREAKPOINT:
		quest_grid.columns = 1
		_apply_layout_profile(48, 18, 100, 12, 16, 12)
	elif width < TABLET_BREAKPOINT:
		quest_grid.columns = 2
		_apply_layout_profile(54, 19, 108, 14, 20, 14)
	else:
		quest_grid.columns = 3
		_apply_layout_profile(58, 20, 118, 14, 24, 16)

func _is_phone_landscape(size: Vector2) -> bool:
	return size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

func _apply_layout_profile(title_size: int, info_size: int, button_height: float, gap: int, margin_side: int, margin_vertical: int) -> void:
	title_label.add_theme_font_size_override("font_size", title_size)
	status_label.add_theme_font_size_override("font_size", info_size)
	status_label.custom_minimum_size.y = max(32.0, button_height * 0.4)
	main_layout.add_theme_constant_override("separation", gap + 6)
	quest_grid.add_theme_constant_override("h_separation", gap)
	quest_grid.add_theme_constant_override("v_separation", gap)
	safe_area.add_theme_constant_override("margin_left", margin_side)
	safe_area.add_theme_constant_override("margin_right", margin_side)
	safe_area.add_theme_constant_override("margin_top", margin_vertical)
	safe_area.add_theme_constant_override("margin_bottom", margin_vertical)
	for btn in _all_module_buttons():
		btn.custom_minimum_size = Vector2(0.0, button_height)
		btn.add_theme_font_size_override("font_size", clamp(info_size + 1, 16, 20))

func _animate_intro() -> void:
	title_label.modulate.a = 0.0
	var tween: Tween = create_tween()
	tween.tween_property(title_label, "modulate:a", 1.0, 0.3)

	for i in range(_all_module_buttons().size()):
		var btn: Button = _all_module_buttons()[i]
		btn.modulate.a = 0.0
		btn.scale = Vector2(0.97, 0.97)
		btn.pivot_offset = btn.size * 0.5
		var item_tween: Tween = create_tween()
		var delay: float = 0.06 * float(i)
		item_tween.tween_property(btn, "modulate:a", 1.0, 0.2).set_delay(delay)
		item_tween.parallel().tween_property(btn, "scale", Vector2.ONE, 0.24).set_delay(delay).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)

func _all_module_buttons() -> Array[Button]:
	return [
		btn_clues,
		btn_radio,
		btn_decryptor,
		btn_lie,
		btn_script,
		btn_city,
		btn_archive,
		btn_report,
		btn_network_trace
	]
</file>

<file path="scripts/case_07/da7_cases_a.gd">
extends Node

const SCHEMA_VERSION := "DA7.A.v3"
const LEVEL := "A"

const CASES_A: Array = [
	{
		"id": "DA7-A-01",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "ACCESS_LOG_07",
		"briefing": "Зеркало архива восстановлено. Следы доступа частично обфусцированы. Проверьте только реальные записи с высоким уровнем доступа.",
		"objective": "Определите ID, где Доступ >= 3.",
		"prompt": "Какие записи удовлетворяют Доступ >= 3?",
		"table": {
			"columns": [
				{"col_id": "id", "title": "ID"},
				{"col_id": "name", "title": "Имя"},
				{"col_id": "acc", "title": "Доступ"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"id": "101", "name": "Альфа", "acc": "2"}},
				{"row_id": "r2", "cells": {"id": "102", "name": "Бета", "acc": "3"}},
				{"row_id": "r3", "cells": {"id": "103", "name": "Гамма", "acc": "4"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Оформить отчёт: список высокого доступа содержит ID 101", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Отправить пакет доказательств: ID 102 и 103", "f_reason": null},
			{"id": "opt_3", "text": "Эскалировать все строки как высокий доступ", "f_reason": "MISSED_ROW"},
			{"id": "opt_4", "text": "Подтвердить только ID 103", "f_reason": "MISSED_ROW"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Строки r2 и r3 удовлетворяют Доступ >= 3. Строка r1 ниже порога.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Значения Доступ прочитаны неверно. Используйте столбец Доступ как ключ фильтра.",
				"MISSED_ROW": "Хотя бы одна подходящая строка пропущена или лишняя строка включена."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r2", "r3"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-02",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "SYSTEM_STATUS_12",
		"briefing": "Оперативный канал сообщает о всплесках нестабильности. Извлеките только явные записи с ОШИБКОЙ из хронологии инцидента.",
		"objective": "Определите отметки времени, где Статус == ОШИБКА.",
		"prompt": "Какие отметки времени помечены как ОШИБКА?",
		"table": {
			"columns": [
				{"col_id": "time", "title": "Время"},
				{"col_id": "status", "title": "Статус"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"time": "09:00", "status": "НОРМА"}},
				{"row_id": "r2", "cells": {"time": "09:05", "status": "ОШИБКА"}},
				{"row_id": "r3", "cells": {"time": "09:10", "status": "ПРЕДУПРЕЖДЕНИЕ"}},
				{"row_id": "r4", "cells": {"time": "09:15", "status": "ОШИБКА"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Отметить 09:00 и 09:10 как критические сбои", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Открыть тикет инцидента для 09:05 и 09:15", "f_reason": null},
			{"id": "opt_3", "text": "Эскалировать только 09:05", "f_reason": "MISSED_ROW"},
			{"id": "opt_4", "text": "Пометить каждую строку как ОШИБКА", "f_reason": "COUNT_HEADER_AS_RECORD"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Только строки с явным статусом ОШИБКА — r2 и r4.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Фильтр должен строиться по Статус; одних значений времени недостаточно.",
				"MISSED_ROW": "Одна строка с ОШИБКОЙ была пропущена.",
				"COUNT_HEADER_AS_RECORD": "Не считайте заголовки или нерелевантные статусы строками инцидента."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r2", "r4"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-03",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "RELATION_MAP_03",
		"briefing": "Карта сущностей восстановлена с резервного узла. Подтвердите зависимость пользователь-пост перед связыванием архивов.",
		"objective": "Определите тип связи: один пользователь может написать много постов.",
		"prompt": "Какая связь соответствует Пользователи.id -> Посты.user_id?",
		"table": {
			"columns": [
				{"col_id": "table", "title": "Таблица"},
				{"col_id": "key", "title": "Ключ"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"table": "Пользователи", "key": "id (PK)"}},
				{"row_id": "r2", "cells": {"table": "Посты", "key": "user_id (FK)"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Подтвердить связь один-к-одному", "f_reason": "CONFUSED_PK_FIELD"},
			{"id": "opt_2", "text": "Подтвердить связь один-ко-многим", "f_reason": null},
			{"id": "opt_3", "text": "Подтвердить связь многие-ко-многим", "f_reason": "CONFUSED_ROW_COLUMN"},
			{"id": "opt_4", "text": "Отклонить связь", "f_reason": "CONFUSED_PK_FIELD"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Пользователи.id (PK), на который ссылается Посты.user_id (FK), образует связь 1:M.",
			"on_wrong_by_reason": {
				"CONFUSED_PK_FIELD": "Связь PK->FK здесь допускает несколько постов на одного пользователя.",
				"CONFUSED_ROW_COLUMN": "Тип связи определяется семантикой ключей, а не порядком таблиц в сетке."
			}
		},
		"highlight": {
			"mode": "COLUMNS",
			"target_col_ids": ["key"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-04",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "ORDERS_AUDIT_22",
		"briefing": "Платёжные логи содержат заказы с разными суммами. Выделите только транзакции с малой суммой для ручной проверки.",
		"objective": "Определите заказы, где Сумма < 100.",
		"prompt": "Какие заказы удовлетворяют Сумма < 100?",
		"table": {
			"columns": [
				{"col_id": "ord", "title": "Заказ"},
				{"col_id": "sum", "title": "Сумма"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"ord": "A-10", "sum": "150"}},
				{"row_id": "r2", "cells": {"ord": "A-11", "sum": "80"}},
				{"row_id": "r3", "cells": {"ord": "A-12", "sum": "99"}},
				{"row_id": "r4", "cells": {"ord": "A-13", "sum": "100"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Заморозить для проверки заказы A-11 и A-12", "f_reason": null},
			{"id": "opt_2", "text": "Заморозить A-11, A-12 и A-13", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_3", "text": "Заморозить только A-10", "f_reason": "MISSED_ROW"},
			{"id": "opt_4", "text": "Заморозить только A-13", "f_reason": "MISSED_COLUMN"}
		],
		"answer_id": "opt_1",
		"reveal": {
			"on_correct": "A-11 (80) и A-12 (99) строго меньше 100.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Используйте строгое '< 100'. Значение 100 исключается.",
				"MISSED_ROW": "Вы выбрали неподходящие строки и пропустили корректные малые суммы."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r2", "r3"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-05",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "STATUS_FILTER_31",
		"briefing": "Шаблон запроса повреждён. Восстановите оператор, исключающий состояние ЗАКРЫТ.",
		"objective": "Выберите оператор для условия: статус не равно ЗАКРЫТ.",
		"prompt": "Какое выражение корректно означает 'статус не равно ЗАКРЫТ'?",
		"table": {
			"columns": [
				{"col_id": "field", "title": "Поле"},
				{"col_id": "value", "title": "Значение"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"field": "статус", "value": "ЗАКРЫТ"}},
				{"row_id": "r2", "cells": {"field": "статус", "value": "ОТКРЫТ"}},
				{"row_id": "r3", "cells": {"field": "статус", "value": "ОЖИДАНИЕ"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Применить фильтр: статус == ЗАКРЫТ", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Применить фильтр: статус != ЗАКРЫТ", "f_reason": null},
			{"id": "opt_3", "text": "Применить фильтр: статус > ЗАКРЫТ", "f_reason": "CONFUSED_ROW_COLUMN"},
			{"id": "opt_4", "text": "Применить фильтр: статус <= ЗАКРЫТ", "f_reason": "CONFUSED_ROW_COLUMN"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "Оператор '!=' исключает ЗАКРЫТ и оставляет ОТКРЫТ/ОЖИДАНИЕ.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Проверка равенства выбирает сам ЗАКРЫТ, а не множество исключения.",
				"CONFUSED_ROW_COLUMN": "Операторы сравнения строк здесь не выражают логическое исключение."
			}
		},
		"highlight": {
			"mode": "CELL",
			"target_cell": {"row_id": "r1", "col_id": "value"}
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	{
		"id": "DA7-A-06",
		"schema_version": SCHEMA_VERSION,
		"level": LEVEL,
		"topic": "DB_BASICS",
		"interaction_type": "SINGLE_CHOICE",
		"case_title": "CLIENT_CITY_19",
		"briefing": "Региональный экспортный список повреждён. Восстановите только ID клиентов, связанных с записями Алматы.",
		"objective": "Выберите клиентов, где Город == Алматы.",
		"prompt": "Какие клиенты из Алматы?",
		"table": {
			"columns": [
				{"col_id": "cid", "title": "CID"},
				{"col_id": "city", "title": "Город"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"cid": "C1", "city": "Алматы"}},
				{"row_id": "r2", "cells": {"cid": "C2", "city": "Астана"}},
				{"row_id": "r3", "cells": {"cid": "C3", "city": "Алматы"}}
			]
		},
		"options": [
			{"id": "opt_1", "text": "Выдать ордер только для C2", "f_reason": "MISSED_COLUMN"},
			{"id": "opt_2", "text": "Выдать ордер для C1 и C3", "f_reason": null},
			{"id": "opt_3", "text": "Выдать ордер для всех клиентов", "f_reason": "COUNT_HEADER_AS_RECORD"},
			{"id": "opt_4", "text": "Закрыть дело: подходящих клиентов нет", "f_reason": "MISSED_ROW"}
		],
		"answer_id": "opt_2",
		"reveal": {
			"on_correct": "C1 и C3 помечены как Город = Алматы.",
			"on_wrong_by_reason": {
				"MISSED_COLUMN": "Фильтр должен совпадать по Город, а не по порядку CID.",
				"COUNT_HEADER_AS_RECORD": "Не эскалируйте неподходящие строки.",
				"MISSED_ROW": "Корректные строки Алматы были пропущены."
			}
		},
		"highlight": {
			"mode": "ROWS",
			"target_row_ids": ["r1", "r3"]
		},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	}
]
</file>

<file path="ui/theme_terminal_amber.tres">
[gd_resource type="Theme" load_steps=8 format=3 uid="uid://bc6epa3jyjbri"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.09, 0.07, 0.04, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.3, 0.24, 0.13, 0.7)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.17, 0.12, 0.05, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.8, 0.38, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.12, 0.09, 0.04, 0.95)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.690196, 0, 0.85)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.22, 0.15, 0.06, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.85, 0.5, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.12, 0.09, 0.04, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 0.690196, 0, 0.85)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.08, 0.06, 0.03, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(1, 0.690196, 0, 0.92)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[resource]
default_font_size = 18
Button/colors/font_color = Color(1, 0.690196, 0, 1)
Button/colors/font_disabled_color = Color(0.42, 0.35, 0.23, 1)
Button/colors/font_hover_color = Color(1, 0.82, 0.45, 1)
Button/colors/font_pressed_color = Color(1, 0.9, 0.65, 1)
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(1, 0.690196, 0, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(1, 0.690196, 0, 1)
</file>

<file path="ui/theme_terminal_green.tres">
[gd_resource type="Theme" load_steps=8 format=3 uid="uid://cfgksggpp15wa"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.05, 0.06, 0.05, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.13, 0.22, 0.13, 0.7)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.08, 0.13, 0.08, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.3, 1, 0.45, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.05, 0.08, 0.05, 0.95)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0, 1, 0.254902, 0.85)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.12, 0.18, 0.12, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.55, 1, 0.62, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.05, 0.08, 0.05, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0, 1, 0.254902, 0.85)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.03, 0.05, 0.03, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0, 1, 0.254902, 0.92)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[resource]
default_font_size = 18
Button/colors/font_color = Color(0, 1, 0.254902, 1)
Button/colors/font_disabled_color = Color(0.27, 0.35, 0.27, 1)
Button/colors/font_hover_color = Color(0.45, 1, 0.55, 1)
Button/colors/font_pressed_color = Color(0.75, 1, 0.75, 1)
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(0, 1, 0.254902, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0, 1, 0.254902, 1)
</file>

<file path="ui/theme_untformatic.tres">
[gd_resource type="Theme" load_steps=8 format=3 uid="uid://jxdl2tctb0ca"]

[sub_resource type="StyleBoxFlat" id="sb_btn_disabled"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.06, 0.07, 0.09, 0.9)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.2, 0.25, 0.3, 0.7)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_hover"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.1, 0.13, 0.17, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.4, 0.8, 1, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_normal"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.07, 0.09, 0.12, 0.95)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.203922, 0.658824, 1, 0.85)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_btn_pressed"]
content_margin_left = 10.0
content_margin_top = 8.0
content_margin_right = 10.0
content_margin_bottom = 8.0
bg_color = Color(0.14, 0.18, 0.24, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.6, 0.9, 1, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="sb_panel"]
content_margin_left = 12.0
content_margin_top = 10.0
content_margin_right = 12.0
content_margin_bottom = 10.0
bg_color = Color(0.07, 0.09, 0.12, 0.97)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.203922, 0.658824, 1, 0.8)
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id="sb_progress_bg"]
bg_color = Color(0.04, 0.05, 0.06, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="sb_progress_fill"]
bg_color = Color(0.203922, 0.658824, 1, 0.9)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[resource]
default_font_size = 18
Button/colors/font_color = Color(0.8, 0.92, 1, 1)
Button/colors/font_disabled_color = Color(0.45, 0.52, 0.6, 1)
Button/colors/font_hover_color = Color(0.9, 0.97, 1, 1)
Button/colors/font_pressed_color = Color(1, 1, 1, 1)
Button/styles/disabled = SubResource("sb_btn_disabled")
Button/styles/hover = SubResource("sb_btn_hover")
Button/styles/normal = SubResource("sb_btn_normal")
Button/styles/pressed = SubResource("sb_btn_pressed")
Label/colors/font_color = Color(0.8, 0.92, 1, 1)
PanelContainer/styles/panel = SubResource("sb_panel")
ProgressBar/styles/background = SubResource("sb_progress_bg")
ProgressBar/styles/fill = SubResource("sb_progress_fill")
RichTextLabel/colors/default_color = Color(0.8, 0.92, 1, 1)
</file>

<file path="scenes/CityMapQuestA.gd">
extends Control

const LEVEL_PATH := "res://data/city_map/level_6_1.json"
const LOG_PREFIX := "case_6_1"
const DEFAULT_ACCENT := Color(0.40, 0.72, 1.0, 1.0)
const ARROW_ANGLE_RAD := 0.52
const ARROW_LEN := 16.0

@onready var content_split: BoxContainer = $SafeArea/MainVBox/ContentSplit
@onready var graph_container: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer
@onready var edges_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/EdgesLayer
@onready var nodes_layer: Control = $SafeArea/MainVBox/ContentSplit/GraphPanel/GraphMargin/GraphContainer/NodesLayer
@onready var btn_back: Button = $SafeArea/MainVBox/Header/BtnBack
@onready var btn_reset: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnReset
@onready var btn_submit: Button = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/ButtonsRow/BtnSubmit
@onready var sum_input: LineEdit = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumInput
@onready var path_display: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/PathDisplay
@onready var sum_live_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/SumLiveLabel
@onready var status_label: Label = $SafeArea/MainVBox/ContentSplit/InfoPanel/InfoMargin/InfoVBox/StatusLabel
@onready var label_state: Label = $SafeArea/MainVBox/Header/LabelState
@onready var label_timer: Label = $SafeArea/MainVBox/Header/LabelTimer
@onready var footer_label: Label = $SafeArea/MainVBox/Footer/FooterLabel
@onready var briefing_title: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingTitle
@onready var briefing_text: Label = $SafeArea/MainVBox/BriefingCard/BriefingMargin/BriefingVBox/BriefingText

var level_data: Dictionary = {}
var node_defs: Dictionary = {}
var adjacency: Dictionary = {}
var edge_visuals: Dictionary = {}
var node_buttons: Dictionary = {}
var config_hash: String = ""
var input_regex := RegEx.new()

var min_sum: int = 0
var accent_color: Color = DEFAULT_ACCENT
var node_radius_px: float = 25.0

var current_node: String = ""
var path: Array[String] = []
var path_sum: int = 0
var stability: float = 100.0
var t_elapsed_seconds: int = 0
var is_game_over: bool = false
var first_attempt_edge: String = ""
var level_started_ms: int = 0
var first_action_ms: int = -1

var n_calc: int = 0
var n_opt: int = 0
var n_parse: int = 0
var n_reset: int = 0

func _ready() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_submit.pressed.connect(_on_submit_pressed)
	sum_input.text_changed.connect(_on_sum_input_changed)
	graph_container.resized.connect(_on_graph_resized)

	_load_level_data(LEVEL_PATH)
	_apply_content_layout_mode()
	_setup_timer()
	call_deferred("_post_ready")

func _post_ready() -> void:
	_set_briefing()
	_rebuild_graph_ui()
	_reset_round_state(true)
	_update_timer_display()
	_recalculate_stability()

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED:
		if not is_node_ready():
			return
		_apply_content_layout_mode()
		_rebuild_graph_ui()
		_update_visuals()
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_OUT:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = true
	elif what == NOTIFICATION_WM_WINDOW_FOCUS_IN:
		if has_node("ResearchTimer"):
			get_node("ResearchTimer").paused = false

func _apply_content_layout_mode() -> void:
	content_split.vertical = get_viewport_rect().size.x < get_viewport_rect().size.y

func _setup_timer() -> void:
	var timer := Timer.new()
	timer.name = "ResearchTimer"
	timer.wait_time = 1.0
	timer.autostart = true
	timer.timeout.connect(_on_timer_tick)
	add_child(timer)

func _on_timer_tick() -> void:
	if is_game_over:
		return
	t_elapsed_seconds += 1
	_update_timer_display()
	if t_elapsed_seconds > int(level_data.get("time_limit_sec", 120)):
		_recalculate_stability()

func _load_level_data(path_to_file: String) -> void:
	var file := FileAccess.open(path_to_file, FileAccess.READ)
	if file == null:
		push_error("Failed to open level data: %s" % path_to_file)
		return

	var raw_json := file.get_as_text()
	config_hash = raw_json.sha256_text()
	var parsed: Variant = JSON.parse_string(raw_json)
	if typeof(parsed) != TYPE_DICTIONARY:
		push_error("Invalid level JSON in %s" % path_to_file)
		return

	level_data = parsed
	node_defs.clear()
	adjacency.clear()

	for node_var in level_data.get("nodes", []):
		var node: Dictionary = node_var
		node_defs[str(node.get("id", ""))] = node

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty():
			continue
		if not adjacency.has(from_id):
			adjacency[from_id] = {}
		adjacency[from_id][to_id] = int(edge.get("w", 0))

	input_regex = RegEx.new()
	var regex_pattern := "^[0-9]+$"
	if level_data.has("rules") and level_data.rules.has("input_regex"):
		regex_pattern = str(level_data.rules.input_regex)
	input_regex.compile(regex_pattern)

	min_sum = int(level_data.get("min_sum", -1))
	if min_sum < 0:
		min_sum = _calculate_min_sum()

	if level_data.has("ui"):
		if level_data.ui.has("accent_color"):
			accent_color = Color(level_data.ui.accent_color)
		if level_data.ui.has("node_radius_px"):
			var raw_radius := float(level_data.ui.node_radius_px)
			node_radius_px = raw_radius * 0.5 if raw_radius > 32.0 else raw_radius
			node_radius_px = maxf(16.0, node_radius_px)

func _set_briefing() -> void:
	briefing_title.text = "АУДИТ МАРШРУТА"
	briefing_text.text = "Доберитесь до узла E по направленным дорогам. Введите итоговую сумму пути и отправьте. Проходит только минимальный маршрут."
	footer_label.text = "Ориентированный граф: нажимать можно только исходящие дороги из текущего узла."

func _calculate_min_sum() -> int:
	var start_node := str(level_data.get("start_node", ""))
	var end_node := str(level_data.get("end_node", ""))
	if start_node.is_empty() or end_node.is_empty():
		return 0

	var dist: Dictionary = {}
	var unvisited: Array[String] = []
	for node_id in node_defs.keys():
		dist[node_id] = 1_000_000_000
		unvisited.append(node_id)
	dist[start_node] = 0

	while not unvisited.is_empty():
		var current := ""
		var best := 1_000_000_000
		for node_id in unvisited:
			var value := int(dist.get(node_id, 1_000_000_000))
			if value < best:
				best = value
				current = node_id

		if current.is_empty() or current == end_node:
			break
		unvisited.erase(current)

		var neighbors: Dictionary = adjacency.get(current, {})
		for next_id in neighbors.keys():
			var alt := best + int(neighbors[next_id])
			if alt < int(dist.get(next_id, 1_000_000_000)):
				dist[next_id] = alt

	var result := int(dist.get(end_node, 1_000_000_000))
	return 0 if result >= 1_000_000_000 else result

func _on_graph_resized() -> void:
	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return
	_rebuild_graph_ui()
	_update_visuals()

func _rebuild_graph_ui() -> void:
	for child in edges_layer.get_children():
		child.queue_free()
	for child in nodes_layer.get_children():
		child.queue_free()
	edge_visuals.clear()
	node_buttons.clear()

	if graph_container.size.x <= 0.0 or graph_container.size.y <= 0.0:
		return

	for edge_var in level_data.get("edges", []):
		var edge: Dictionary = edge_var
		var from_id := str(edge.get("from", ""))
		var to_id := str(edge.get("to", ""))
		if from_id.is_empty() or to_id.is_empty() or not node_defs.has(from_id) or not node_defs.has(to_id):
			continue

		var start_pos := _node_screen_pos(node_defs[from_id])
		var end_pos := _node_screen_pos(node_defs[to_id])

		var line := Line2D.new()
		line.width = 4.0
		line.points = PackedVector2Array([start_pos, end_pos])
		line.gradient = _build_gradient(Color(0.18, 0.22, 0.30, 0.28), Color(0.30, 0.38, 0.52, 0.48))
		edges_layer.add_child(line)

		var arrow := _create_arrow_polygon(start_pos, end_pos)
		edges_layer.add_child(arrow)

		var label := Label.new()
		label.text = str(edge.get("w", 0))
		label.add_theme_font_size_override("font_size", 15)
		label.position = _edge_label_pos(start_pos, end_pos)
		label.add_theme_color_override("font_color", Color(0.62, 0.74, 0.90))
		edges_layer.add_child(label)

		var key := _edge_key(from_id, to_id)
		edge_visuals[key] = {
			"line": line,
			"arrow": arrow,
			"label": label
		}

	for node_id in node_defs.keys():
		var node: Dictionary = node_defs[node_id]
		var btn := Button.new()
		btn.text = str(node.get("label", node_id))
		var diameter := node_radius_px * 2.0
		btn.size = Vector2(diameter, diameter)
		btn.position = _node_screen_pos(node) - Vector2(node_radius_px, node_radius_px)
		btn.pressed.connect(_on_node_pressed.bind(node_id))
		nodes_layer.add_child(btn)
		node_buttons[node_id] = btn

func _edge_label_pos(start_pos: Vector2, end_pos: Vector2) -> Vector2:
	var dir := (end_pos - start_pos).normalized()
	var normal := Vector2(-dir.y, dir.x)
	return ((start_pos + end_pos) * 0.5) + (normal * 12.0) - Vector2(10.0, 10.0)

func _create_arrow_polygon(start_pos: Vector2, end_pos: Vector2) -> Polygon2D:
	var dir := (end_pos - start_pos).normalized()
	var tip := end_pos - dir * (node_radius_px + 4.0)
	var base := tip - dir * ARROW_LEN
	var side_len := ARROW_LEN * 0.65

	var polygon := Polygon2D.new()
	polygon.polygon = PackedVector2Array([
		tip,
		base + dir.rotated(ARROW_ANGLE_RAD) * side_len,
		base + dir.rotated(-ARROW_ANGLE_RAD) * side_len
	])
	polygon.color = Color(0.45, 0.66, 0.96, 0.95)
	return polygon

func _build_gradient(start_color: Color, end_color: Color) -> Gradient:
	var gradient := Gradient.new()
	gradient.set_color(0, start_color)
	gradient.set_color(1, end_color)
	return gradient

func _node_screen_pos(node_data: Dictionary) -> Vector2:
	var pos: Dictionary = node_data.get("pos", {})
	var x := float(pos.get("x", 0.0))
	var y := float(pos.get("y", 0.0))

	if x >= 0.0 and x <= 1.0 and y >= 0.0 and y <= 1.0:
		var padding := node_radius_px + 4.0
		var usable := graph_container.size - Vector2(padding * 2.0, padding * 2.0)
		usable.x = maxf(1.0, usable.x)
		usable.y = maxf(1.0, usable.y)
		return Vector2(padding + x * usable.x, padding + y * usable.y)

	return Vector2(x, y)

func _reset_round_state(full_reset: bool) -> void:
	current_node = str(level_data.get("start_node", "A"))
	path = [current_node]
	path_sum = 0
	sum_input.clear()
	status_label.text = ""
	first_action_ms = -1
	first_attempt_edge = ""

	if full_reset:
		level_started_ms = Time.get_ticks_msec()

	_update_visuals()

func _update_visuals() -> void:
	path_display.text = "ПУТЬ: %s" % " -> ".join(path)
	sum_live_label.text = "СУММА: %d" % path_sum

	for node_id in node_buttons.keys():
		var btn: Button = node_buttons[node_id]
		var is_current: bool = node_id == current_node
		var is_available: bool = adjacency.has(current_node) and adjacency[current_node].has(node_id)
		btn.disabled = is_current or not is_available or is_game_over
		if is_current:
			btn.modulate = Color(0.95, 0.86, 0.45)
		elif is_available:
			btn.modulate = Color(1, 1, 1)
		else:
			btn.modulate = Color(0.42, 0.46, 0.56)

	for key in edge_visuals.keys():
		_set_edge_style(key, "dim")

	if adjacency.has(current_node):
		for next_id in adjacency[current_node].keys():
			_set_edge_style(_edge_key(current_node, str(next_id)), "available")

	for i in range(path.size() - 1):
		_set_edge_style(_edge_key(path[i], path[i + 1]), "traversed")

func _set_edge_style(key: String, state: String) -> void:
	if not edge_visuals.has(key):
		return

	var visual: Dictionary = edge_visuals[key]
	var line: Line2D = visual["line"]
	var arrow: Polygon2D = visual["arrow"]
	var label: Label = visual["label"]

	var start_color := Color(0.18, 0.22, 0.30, 0.28)
	var end_color := Color(0.30, 0.38, 0.52, 0.48)

	if state == "available":
		start_color = Color(0.24, 0.40, 0.62, 0.48)
		end_color = accent_color
		end_color.a = 0.95
	elif state == "traversed":
		start_color = accent_color.lightened(0.10)
		start_color.a = 0.80
		end_color = Color(0.92, 0.97, 1.0, 1.0)

	line.gradient = _build_gradient(start_color, end_color)
	arrow.color = end_color
	label.add_theme_color_override("font_color", end_color.lightened(0.10))

func _edge_key(from_id: String, to_id: String) -> String:
	return "%s->%s" % [from_id, to_id]

func _on_node_pressed(node_id: String) -> void:
	if is_game_over:
		return
	if not adjacency.has(current_node) or not adjacency[current_node].has(node_id):
		return

	if first_attempt_edge.is_empty():
		first_attempt_edge = _edge_key(current_node, node_id)
		first_action_ms = Time.get_ticks_msec() - level_started_ms

	path_sum += int(adjacency[current_node][node_id])
	path.append(node_id)
	current_node = node_id
	_update_visuals()

func _on_reset_pressed() -> void:
	if is_game_over:
		return
	n_reset += 1
	_reset_round_state(false)
	_recalculate_stability()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_sum_input_changed(new_text: String) -> void:
	var digits := ""
	for ch in new_text:
		if ch >= "0" and ch <= "9":
			digits += ch
	if digits != new_text:
		sum_input.text = digits
		sum_input.caret_column = digits.length()

func _on_submit_pressed() -> void:
	if is_game_over:
		return

	var verdict := _judge_solution(sum_input.text.strip_edges())
	_log_attempt(verdict)

	if verdict.result_code == "OK":
		status_label.text = "Маршрут принят. Оптимальная сумма подтверждена."
		status_label.add_theme_color_override("font_color", Color(0.38, 1.0, 0.62))
		is_game_over = true
		btn_submit.disabled = true
		btn_reset.disabled = true
		_update_visuals()
		return

	status_label.text = _result_message(str(verdict.result_code))
	status_label.add_theme_color_override("font_color", Color(1.0, 0.62, 0.28))
	_recalculate_stability()

func _result_message(result_code: String) -> String:
	match result_code:
		"ERR_INCOMPLETE":
			return "Дойдите до узла E перед отправкой."
		"ERR_PARSE":
			return "Вводите только цифры."
		"ERR_CALC":
			return "Введённая сумма не совпадает с выбранным маршрутом."
		"ERR_NOT_OPT":
			return "Маршрут корректный, но не оптимальный."
		"ERR_PATH_INVALID":
			return "Маршрут недопустим для ориентированных рёбер."
		_:
			return "Необработанный результат: %s" % result_code

func _judge_solution(input_text: String) -> Dictionary:
	var sum_actual := _compute_path_sum()
	var sum_input_value: Variant = null
	var result_code := "OK"

	if sum_actual < 0:
		result_code = "ERR_PATH_INVALID"
	elif current_node != str(level_data.get("end_node", "E")):
		result_code = "ERR_INCOMPLETE"
	elif input_regex.search(input_text) == null:
		n_parse += 1
		result_code = "ERR_PARSE"
	else:
		sum_input_value = int(input_text)
		if int(sum_input_value) != sum_actual:
			n_calc += 1
			result_code = "ERR_CALC"
		elif sum_actual != min_sum:
			n_opt += 1
			result_code = "ERR_NOT_OPT"

	return {
		"result_code": result_code,
		"sum_actual": sum_actual,
		"sum_input": sum_input_value
	}

func _compute_path_sum() -> int:
	var total := 0
	for i in range(path.size() - 1):
		var from_id := path[i]
		var to_id := path[i + 1]
		if not adjacency.has(from_id) or not adjacency[from_id].has(to_id):
			return -1
		total += int(adjacency[from_id][to_id])
	return total

func _recalculate_stability() -> void:
	var trust_cfg: Dictionary = level_data.get("trust", {})
	var overtime_div := int(trust_cfg.get("overtime_div", 2))
	overtime_div = maxi(1, overtime_div)
	var overtime: int = maxi(0, t_elapsed_seconds - int(level_data.get("time_limit_sec", 120)))
	var overtime_penalty := int(floor(float(overtime) / float(overtime_div)))

	var penalties := (
		n_calc * int(trust_cfg.get("penalty_calc", 25))
		+ n_opt * int(trust_cfg.get("penalty_opt", 25))
		+ n_parse * int(trust_cfg.get("penalty_parse", 5))
		+ n_reset * int(trust_cfg.get("penalty_reset", 5))
		+ overtime_penalty
	)

	stability = clampf(float(trust_cfg.get("initial", 100)) - float(penalties), 0.0, 100.0)
	label_state.text = "СТАБИЛЬНОСТЬ: %d%%" % int(stability)

	if stability <= 10.0 and not is_game_over:
		is_game_over = true
		status_label.text = "МИССИЯ ПРОВАЛЕНА: КРИТИЧЕСКАЯ СТАБИЛЬНОСТЬ."
		status_label.add_theme_color_override("font_color", Color(1.0, 0.30, 0.30))
		btn_submit.disabled = true
		btn_reset.disabled = true
		_update_visuals()

func _update_timer_display() -> void:
	var time_limit := int(level_data.get("time_limit_sec", 120))
	var remaining: int = maxi(0, time_limit - t_elapsed_seconds)
	var mm: int = remaining / 60
	var ss: int = remaining % 60
	label_timer.text = "ВРЕМЯ: %02d:%02d" % [mm, ss]
	if t_elapsed_seconds > time_limit:
		label_timer.add_theme_color_override("font_color", Color(1.0, 0.36, 0.36))
	else:
		label_timer.add_theme_color_override("font_color", Color(1, 1, 1))

func _log_attempt(verdict: Dictionary) -> void:
	var sum_actual := int(verdict.get("sum_actual", -1))
	var sum_input_value: Variant = verdict.get("sum_input", null)
	var result_code := str(verdict.get("result_code", "ERR_UNKNOWN"))

	var attempt_no := GlobalMetrics.session_history.size() + 1
	var log_data := {
		"schema_version": "city_map.v2.1.0",
		"quest_id": "CITY_MAP",
		"stage": "A",
		"task_id": str(level_data.get("level_id", "6_1")),
		"match_key": "CITY_MAP|A|%s|v%s" % [str(level_data.get("level_id", "6_1")), config_hash.substr(0, 8)],
		"variant_hash": config_hash,
		"contract_version": str(level_data.get("contract_version", "city_map.v2.1.0")),
		"attempt_no": attempt_no,
		"result_code": result_code,
		"calc_ok": sum_input_value != null and int(sum_input_value) == sum_actual,
		"optimal_ok": sum_actual == min_sum and result_code == "OK",
		"first_attempt_edge": null if first_attempt_edge.is_empty() else first_attempt_edge,
		"t_elapsed_seconds": t_elapsed_seconds,
		"path": path.duplicate(),
		"sum_actual": sum_actual,
		"sum_input": sum_input_value,
		"min_sum": min_sum,
		"stability_final": int(stability),
		"n_calc": n_calc,
		"n_opt": n_opt,
		"n_parse": n_parse,
		"n_reset": n_reset,
		"is_correct": result_code == "OK",
		"is_fit": result_code == "OK",
		"stability_delta": 0,
		"elapsed_ms": t_elapsed_seconds * 1000,
		"duration": float(t_elapsed_seconds),
		"time_to_first_action_ms": first_action_ms if first_action_ms >= 0 else t_elapsed_seconds * 1000,
		"error_type": "NONE" if result_code == "OK" else result_code
	}

	GlobalMetrics.register_trial(log_data)
	_save_json_log(log_data)

func _save_json_log(data: Dictionary) -> void:
	var dir := DirAccess.open("user://")
	if dir == null:
		return
	if not dir.dir_exists("research_logs"):
		dir.make_dir("research_logs")

	var filename := "user://research_logs/%s_%d.json" % [LOG_PREFIX, Time.get_unix_time_from_system()]
	var file := FileAccess.open(filename, FileAccess.WRITE)
	if file != null:
		file.store_string(JSON.stringify(data, "\t"))
		file.close()
</file>

<file path="scenes/Decryptor.gd">
extends Control

@onready var btn_back = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnBack
@onready var mode_label = $UI/SafeArea/Main/HeaderBar/HeaderContent/ModeChip/ModeLabel
@onready var level_label = $UI/SafeArea/Main/HeaderBar/HeaderContent/LevelLabel
@onready var stability_text = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityText
@onready var stability_bar = $UI/SafeArea/Main/HeaderBar/HeaderContent/StabilityGroup/StabilityBar
@onready var shield_freq = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldFreq
@onready var shield_lazy = $UI/SafeArea/Main/HeaderBar/HeaderContent/Shields/ShieldLazy
@onready var btn_details = $UI/SafeArea/Main/HeaderBar/HeaderContent/BtnDetails
@onready var noir_overlay = $UI/NoirOverlay

@onready var target_panel = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel
@onready var target_title = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent/TargetTitle
@onready var target_value = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent/TargetValueBig
@onready var target_sub = $UI/SafeArea/Main/ContentSplit/LeftPanel/TargetPanel/TargetContent/TargetSub

@onready var input_panel = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel
@onready var input_bin = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBin
@onready var input_dec = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow/InputDec
@onready var input_oct = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow/InputOct
@onready var input_hex = $UI/SafeArea/Main/ContentSplit/LeftPanel/InputPanel/InputContent/InputBasesRow/InputHex

@onready var upper_bits = $UI/SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/UpperNibble/UpperBits
@onready var lower_bits = $UI/SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/NibblesCenter/NibblesRow/LowerNibble/LowerBits
@onready var weights_row = $UI/SafeArea/Main/ContentSplit/LeftPanel/SwitchesPanel/SwitchesContent/WeightsRow

@onready var rank_label = $UI/SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent/RankLabel
@onready var progress_label = $UI/SafeArea/Main/ContentSplit/RightPanel/RankPanel/RankContent/ProgressLabel
@onready var reg_a_value = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow/RegAValue
@onready var reg_b_value = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow/RegBValue
@onready var op_value = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/RegsRow/OpValue
@onready var shift_status = $UI/SafeArea/Main/ContentSplit/RightPanel/ProtocolPanel/ProtocolContent/ShiftStatus
@onready var live_log_text = $UI/SafeArea/Main/ContentSplit/RightPanel/LiveLogPanel/LiveLogContent/LiveLogText
@onready var hint_text = $UI/SafeArea/Main/ContentSplit/RightPanel/HintPanel/HintContent/HintText

@onready var btn_hint = $UI/SafeArea/Main/BottomBar/Actions/BtnHint
@onready var btn_check = $UI/SafeArea/Main/BottomBar/Actions/BtnCheck
@onready var btn_reset = $UI/SafeArea/Main/BottomBar/Actions/BtnReset

@onready var toast_panel = $UI/ToastLayer/Toast
@onready var toast_label = $UI/ToastLayer/Toast/ToastLabel

@onready var details_sheet = $UI/DetailsSheet
@onready var btn_close_details = $UI/DetailsSheet/DetailsContent/DetailsHeader/BtnCloseDetails
@onready var details_text = $UI/DetailsSheet/DetailsContent/DetailsScroll/DetailsText

@onready var safe_overlay = $UI/SafeModeOverlay
@onready var safe_summary = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeSummary
@onready var safe_bits_row = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeBitsRow
@onready var btn_retry = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions/BtnRetry
@onready var btn_continue = $UI/SafeModeOverlay/CenterContainer/SafePanel/SafeContent/SafeActions/BtnContinue

const COLOR_OK = Color(0.2, 1.0, 0.6, 1)
const COLOR_WARN = Color(1.0, 0.75, 0.2, 1)
const COLOR_ERR = Color(1.0, 0.3, 0.3, 1)

const SWIPE_MIN: float = 60.0
const SWIPE_MAX_Y: float = 40.0

var current_target: int = 0
var current_input: int = 0
var is_level_active: bool = false
var level_started_ms: int = 0
var first_action_ms: int = -1
var check_attempt_count: int = 0
var hint_used: bool = false

var bit_buttons: Array[Button] = []
var weight_labels: Array[Label] = []
var safe_bit_labels: Array[Label] = []

var log_lines: Array[String] = []
var last_hint_text: String = ""
var _shift_status_token: int = 0

var details_open: bool = false
var _swipe_start_pos: Vector2 = Vector2.ZERO
var _swipe_tracking: bool = false

func _ready():
	_build_bit_buttons()
	_build_weight_labels()
	_build_safe_bits()
	_wire_signals()
	_reset_shield_state()
	_hide_overlays()

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not GlobalMetrics.shield_triggered.is_connected(_on_shield_triggered):
		GlobalMetrics.shield_triggered.connect(_on_shield_triggered)

	await get_tree().process_frame
	_set_details_open(false, true)

	start_level(GlobalMetrics.current_level_index)

func _wire_signals() -> void:
	btn_back.pressed.connect(_on_menu_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_check.pressed.connect(_on_check_pressed)
	btn_reset.pressed.connect(_on_reset_pressed)
	btn_retry.pressed.connect(_on_retry_pressed)
	btn_continue.pressed.connect(_on_continue_pressed)

func _build_bit_buttons() -> void:
	bit_buttons.clear()
	bit_buttons.resize(8)
	for child in upper_bits.get_children():
		child.queue_free()
	for child in lower_bits.get_children():
		child.queue_free()

	for i in range(8):
		var bit_index = 7 - i
		var btn = Button.new()
		btn.toggle_mode = true
		btn.text = "0"
		btn.custom_minimum_size = Vector2(0, 64)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.toggled.connect(_on_bit_toggled.bind(bit_index))
		if i < 4:
			upper_bits.add_child(btn)
		else:
			lower_bits.add_child(btn)
		bit_buttons[bit_index] = btn

func _build_weight_labels() -> void:
	weight_labels.clear()
	for child in weights_row.get_children():
		child.queue_free()

	for _i in range(8):
		var lbl = Label.new()
		lbl.custom_minimum_size = Vector2(0, 18)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		weights_row.add_child(lbl)
		weight_labels.append(lbl)

func _build_safe_bits() -> void:
	safe_bit_labels.clear()
	for child in safe_bits_row.get_children():
		child.queue_free()

	for i in range(8):
		var lbl = Label.new()
		lbl.custom_minimum_size = Vector2(28, 28)
		lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		lbl.text = "%d" % (7 - i)
		safe_bits_row.add_child(lbl)
		safe_bit_labels.append(lbl)

func start_level(level_idx: int) -> void:
	GlobalMetrics.start_level(level_idx)
	is_level_active = true
	current_target = GlobalMetrics.current_target_value
	current_input = 0
	last_hint_text = ""
	level_started_ms = Time.get_ticks_msec()
	first_action_ms = -1
	check_attempt_count = 0
	hint_used = false

	var mode = GlobalMetrics.current_mode
	mode_label.text = mode
	_update_level_label(level_idx)
	_update_rank_info()
	_update_weights_for_mode(mode)
	_update_target_display(level_idx, mode)
	_update_protocol_diagnostics()
	hint_text.text = "Диагностики пока нет."
	_reset_bit_buttons()
	_update_input_display()
	_log_message("Система инициализирована. Цель зафиксирована.", COLOR_OK)
	_on_stability_changed(100.0, 0.0)

func _update_level_label(level_idx: int) -> void:
	var protocol = "A" if level_idx < 15 else "B"
	level_label.text = "ПРОТОКОЛ %s-%d" % [protocol, level_idx + 1]

func _update_rank_info() -> void:
	var rank_info: Dictionary = GlobalMetrics.get_rank_info()
	rank_label.text = str(rank_info.get("name", "НОВИЧОК"))
	progress_label.text = "УРОВЕНЬ %d / %d" % [GlobalMetrics.current_level_index + 1, GlobalMetrics.MAX_LEVELS]
	if rank_info.has("color"):
		rank_label.add_theme_color_override("font_color", rank_info["color"])

func _update_target_display(level_idx: int, mode: String) -> void:
	if level_idx >= 15:
		target_title.text = "ПРИМЕР"
		target_value.text = _format_example(mode)
		target_sub.text = "РЕЖИМ: %s" % mode
	else:
		target_title.text = "ЦЕЛЬ"
		target_value.text = _format_value(current_target, mode)
		if mode == "DEC":
			target_sub.text = ""
		else:
			target_sub.text = "DEC: %d" % current_target

	_pulse_panel(target_panel, Color(0.55, 1.0, 0.65, 1.0))

func _update_protocol_diagnostics() -> void:
	if GlobalMetrics.current_level_index >= 15:
		reg_a_value.text = "A: %s" % _format_value(GlobalMetrics.current_reg_a, GlobalMetrics.current_mode)
		reg_b_value.text = "B: %s" % _format_value(GlobalMetrics.current_reg_b, GlobalMetrics.current_mode)
		op_value.text = "OP: %s" % _operator_to_text(GlobalMetrics.current_operator)
		_set_shift_status("СДВИГ: свайп влево для применения", Color(0.7, 0.9, 0.7, 1.0), false)
	else:
		reg_a_value.text = "A: --"
		reg_b_value.text = "B: --"
		op_value.text = "OP: --"
		_set_shift_status("СДВИГ: ожидание", Color(0.65, 0.65, 0.65, 1.0), false)

func _operator_to_text(op: int) -> String:
	if op == GlobalMetrics.Operator.ADD:
		return "+"
	if op == GlobalMetrics.Operator.SUB:
		return "-"
	return "<<"
func _update_weights_for_mode(mode: String) -> void:
	var weights: Array[int] = []
	if mode == "DEC":
		weights = [128, 64, 32, 16, 8, 4, 2, 1]
	elif mode == "OCT":
		weights = [2, 1, 4, 2, 1, 4, 2, 1]
	else:
		weights = [8, 4, 2, 1, 8, 4, 2, 1]

	for i in range(8):
		weight_labels[i].text = str(weights[i])

func _reset_bit_buttons() -> void:
	for i in range(8):
		var btn: Button = bit_buttons[i]
		btn.set_pressed_no_signal(false)
		btn.text = "0"
		btn.modulate = Color(1, 1, 1, 1)

func _update_input_display() -> void:
	var bin = String.num_int64(current_input, 2).pad_zeros(8)
	input_bin.text = "BIN: %s %s" % [bin.substr(0, 4), bin.substr(4, 4)]
	input_dec.text = "DEC: %d" % current_input
	input_oct.text = "OCT: %o" % current_input
	input_hex.text = "HEX: %X" % current_input

func _on_bit_toggled(pressed: bool, bit_index: int) -> void:
	_mark_first_action()
	AudioManager.play("click")
	if pressed:
		current_input |= (1 << bit_index)
		bit_buttons[bit_index].text = "1"
	else:
		current_input &= ~(1 << bit_index)
		bit_buttons[bit_index].text = "0"
	_clear_error_highlights()
	_animate_toggle(bit_buttons[bit_index])
	_update_input_display()

func _on_check_pressed() -> void:
	if not is_level_active:
		return

	_mark_first_action()
	check_attempt_count += 1
	var submitted_input := current_input
	var result: Dictionary = GlobalMetrics.check_solution(current_target, current_input)
	_register_trial(result, submitted_input)

	if result.success:
		AudioManager.play("relay")
		_show_toast("УСПЕХ", COLOR_OK)
		_pulse_panel(input_panel, COLOR_OK)
		_overlay_glitch(0.15, 0.12)
		is_level_active = false
		await get_tree().create_timer(1.0).timeout
		if GlobalMetrics.current_level_index < GlobalMetrics.MAX_LEVELS - 1:
			start_level(GlobalMetrics.current_level_index + 1)
		else:
			_log_message("ВСЕ УРОВНИ ЗАВЕРШЕНЫ.", COLOR_OK)
	else:
		AudioManager.play("error")
		_pulse_panel(input_panel, COLOR_ERR)
		_overlay_glitch(0.6, 0.2)
		if result.has("hints"):
			var h = result.hints
			last_hint_text = "Диагноз: %s | Зона: %s" % [_translate_hint(h.diagnosis), _translate_hint(h.zone)]
			hint_text.text = "%s\nHD: %d" % [last_hint_text, int(result.get("hamming", 0))]
			_log_message(last_hint_text, COLOR_WARN)
		_show_toast("НЕВЕРНО", COLOR_ERR)
		_apply_error_highlight(current_input ^ current_target)
func _on_hint_pressed() -> void:
	hint_used = true
	if last_hint_text == "":
		hint_text.text = "Диагностика недоступна. Сначала запустите проверку."
		_show_toast("ПОДСКАЗКА НЕДОСТУПНА", COLOR_WARN)
		return
	hint_text.text = last_hint_text
	_log_message(last_hint_text, COLOR_WARN)
	_show_toast("ПОДСКАЗКА ПОКАЗАНА", COLOR_WARN)
func _on_reset_pressed() -> void:
	current_input = 0
	_reset_bit_buttons()
	_update_input_display()
	_clear_error_highlights()
	_set_shift_status("СДВИГ: ожидание", Color(0.65, 0.65, 0.65, 1.0), false)

func _apply_error_highlight(xor_val: int) -> void:
	for bit in range(8):
		var btn: Button = bit_buttons[bit]
		if (xor_val & (1 << bit)) != 0:
			btn.modulate = Color(1, 0.6, 0.6, 1)
		else:
			btn.modulate = Color(1, 1, 1, 1)

func _clear_error_highlights() -> void:
	for bit in range(8):
		bit_buttons[bit].modulate = Color(1, 1, 1, 1)

func _on_stability_changed(new_val: float, _change: float) -> void:
	stability_bar.value = new_val
	stability_text.text = "СТАБИЛЬНОСТЬ: %d%%" % int(new_val)
	if new_val <= 0:
		_show_safe_mode()

func _on_shield_triggered(name: String, duration: float) -> void:
	if name == "FREQUENCY":
		_flash_shield(shield_freq)
	elif name == "LAZY":
		_flash_shield(shield_lazy)

	btn_check.disabled = true
	_overlay_glitch(0.6, 0.2)
	_show_toast("ЩИТ АКТИВЕН", COLOR_WARN)
	await get_tree().create_timer(duration).timeout
	btn_check.disabled = false
func _flash_shield(label: Label) -> void:
	label.modulate = Color(1, 1, 1, 1)
	var tween = create_tween()
	tween.tween_property(label, "modulate", Color(1, 1, 1, 0.25), 0.6)

func _reset_shield_state() -> void:
	shield_freq.modulate = Color(1, 1, 1, 0.25)
	shield_lazy.modulate = Color(1, 1, 1, 0.25)

func _show_safe_mode() -> void:
	safe_overlay.visible = true
	btn_check.disabled = true
	btn_hint.disabled = true

	var xor_val = current_input ^ current_target
	var wrong_bits = 0
	for bit in range(8):
		if (xor_val & (1 << bit)) != 0:
			wrong_bits += 1

	safe_summary.text = "Цель: %s\nВвод: %s\nОшибочных битов: %d" % [
		_format_value(current_target, GlobalMetrics.current_mode),
		_format_value(current_input, GlobalMetrics.current_mode),
		wrong_bits
	]

	for i in range(8):
		var bit_index = 7 - i
		var lbl = safe_bit_labels[i]
		if (xor_val & (1 << bit_index)) != 0:
			lbl.modulate = Color(1, 0.3, 0.3, 1)
		else:
			lbl.modulate = Color(0.7, 0.7, 0.7, 1)
func _on_retry_pressed() -> void:
	GlobalMetrics.stability = 100.0
	GlobalMetrics.stability_changed.emit(100.0, 0.0)
	safe_overlay.visible = false
	btn_check.disabled = false
	btn_hint.disabled = false
	start_level(GlobalMetrics.current_level_index)

func _on_continue_pressed() -> void:
	GlobalMetrics.stability = 30.0
	GlobalMetrics.stability_changed.emit(30.0, 0.0)
	safe_overlay.visible = false
	btn_check.disabled = false
	btn_hint.disabled = false

func _on_menu_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_details_pressed() -> void:
	_set_details_open(not details_open, false)

func _set_details_open(open: bool, immediate: bool) -> void:
	details_open = open
	if open:
		details_sheet.visible = true

	var target_offset = -details_sheet.size.y if open else 0.0
	if immediate:
		details_sheet.offset_top = target_offset
		if not open:
			details_sheet.visible = false
		return

	var tween = create_tween()
	tween.tween_property(details_sheet, "offset_top", target_offset, 0.22).set_trans(Tween.TRANS_QUAD).set_ease(Tween.EASE_OUT)
	if not open:
		tween.tween_callback(func(): details_sheet.visible = false)
func _hide_overlays() -> void:
	toast_panel.visible = false
	safe_overlay.visible = false
	details_sheet.visible = false

func _show_toast(msg: String, color: Color) -> void:
	toast_label.text = msg
	toast_label.add_theme_color_override("font_color", color)
	toast_panel.visible = true
	toast_panel.modulate = Color(1, 1, 1, 0)
	var tween = create_tween()
	tween.tween_property(toast_panel, "modulate", Color(1, 1, 1, 1), 0.15)
	tween.tween_interval(0.9)
	tween.tween_property(toast_panel, "modulate", Color(1, 1, 1, 0), 0.25)
	tween.tween_callback(func(): toast_panel.visible = false)

func _animate_toggle(btn: Button) -> void:
	btn.scale = Vector2(0.96, 0.96)
	var tween = create_tween()
	tween.tween_property(btn, "scale", Vector2(1, 1), 0.1)

func _pulse_panel(panel: Control, color: Color) -> void:
	panel.modulate = color
	var tween = create_tween()
	tween.tween_property(panel, "modulate", Color(1, 1, 1, 1), 0.25)

func _translate_hint(code: String) -> String:
	match code:
		"VALUE_LOW": return "Значение ниже цели"
		"VALUE_HIGH": return "Значение выше цели"
		"BIT_ERROR": return "Несовпадение битов"
		"BOTH_NIBBLES": return "Ошибки в обеих тетрадах"
		"LOWER_NIBBLE": return "Ошибки в младшей тетраде (биты 0-3)"
		"UPPER_NIBBLE": return "Ошибки в старшей тетраде (биты 4-7)"
		"NONE": return "Несовпадений нет"
	return code

func _set_shift_status(text: String, color: Color, auto_reset: bool) -> void:
	shift_status.text = text
	shift_status.add_theme_color_override("font_color", color)
	if not auto_reset:
		return
	_shift_status_token += 1
	var token = _shift_status_token
	_reset_shift_status_later(token)

func _reset_shift_status_later(token: int) -> void:
	await get_tree().create_timer(0.9).timeout
	if token != _shift_status_token:
		return
	if GlobalMetrics.current_level_index >= 15:
		_set_shift_status("СДВИГ: свайп влево для применения", Color(0.7, 0.9, 0.7, 1.0), false)
	else:
		_set_shift_status("СДВИГ: ожидание", Color(0.65, 0.65, 0.65, 1.0), false)

func _overlay_glitch(strength: float, duration: float) -> void:
	if noir_overlay != null and noir_overlay.has_method("glitch_burst"):
		noir_overlay.call("glitch_burst", strength, duration)

func _log_message(msg: String, color: Color) -> void:
	var time_str = Time.get_time_string_from_system()
	var line = "[%s] %s" % [time_str, msg]
	log_lines.append(line)
	if log_lines.size() > 200:
		log_lines.remove_at(0)
	var combined_log = "\n".join(log_lines)
	details_text.text = combined_log
	var tail = log_lines.slice(maxi(0, log_lines.size() - 18), log_lines.size())
	live_log_text.text = "\n".join(tail)
	live_log_text.add_theme_color_override("default_color", color)

func _format_value(val: int, mode: String) -> String:
	if mode == "DEC":
		return "%d" % val
	elif mode == "OCT":
		return "%o" % val
	elif mode == "HEX":
		return "%X" % val
	return "%d" % val

func _format_example(mode: String) -> String:
	var a = GlobalMetrics.current_reg_a
	var b = GlobalMetrics.current_reg_b
	var op = GlobalMetrics.current_operator
	var a_txt = _format_value(a, mode)
	var b_txt = _format_value(b, mode)
	if op == GlobalMetrics.Operator.ADD:
		return "%s + %s" % [a_txt, b_txt]
	elif op == GlobalMetrics.Operator.SUB:
		return "%s - %s" % [a_txt, b_txt]
	else:
		return "%s << %s" % [a_txt, b_txt]

func _unhandled_input(event):
	if event is InputEventScreenTouch:
		if event.pressed:
			if _is_in_switches(event.position):
				_swipe_start_pos = event.position
				_swipe_tracking = true
		else:
			if _swipe_tracking:
				var delta = event.position - _swipe_start_pos
				if abs(delta.x) >= SWIPE_MIN and abs(delta.y) <= SWIPE_MAX_Y:
					_apply_shift_left()
				_swipe_tracking = false
	elif event is InputEventMouseButton:
		if event.pressed:
			if _is_in_switches(event.position):
				_swipe_start_pos = event.position
				_swipe_tracking = true
		else:
			if _swipe_tracking:
				var delta_mouse = event.position - _swipe_start_pos
				if abs(delta_mouse.x) >= SWIPE_MIN and abs(delta_mouse.y) <= SWIPE_MAX_Y:
					_apply_shift_left()
				_swipe_tracking = false

func _is_in_switches(pos: Vector2) -> bool:
	return upper_bits.get_global_rect().has_point(pos) or lower_bits.get_global_rect().has_point(pos)

func _apply_shift_left() -> void:
	_mark_first_action()
	current_input = (current_input << 1) & 0xFF
	_sync_switches_to_input()
	_update_input_display()
	_set_shift_status("СДВИГ: применён", COLOR_OK, true)
	_log_message("Применён жест сдвига влево.", COLOR_OK)

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - level_started_ms

func _register_trial(result: Dictionary, submitted_input: int) -> void:
	var level_number := GlobalMetrics.current_level_index + 1
	var stage_id := "A" if GlobalMetrics.current_level_index < 15 else "B"
	var task_id := "%s_%02d" % [stage_id, level_number]
	var variant_source := "%s|%s|%d" % [GlobalMetrics.current_mode, stage_id, current_target]
	var payload := TrialV2.build("DECRYPTOR", stage_id, task_id, "NUMERIC_ENTRY", str(hash(variant_source)))
	var elapsed_ms: int = maxi(0, Time.get_ticks_msec() - level_started_ms)
	var is_success := bool(result.get("success", false))
	var error_code := str(result.get("error", "NONE"))
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_success
	payload["is_fit"] = is_success
	payload["stability_delta"] = 0
	payload["level_index"] = GlobalMetrics.current_level_index
	payload["mode"] = GlobalMetrics.current_mode
	payload["target_value"] = current_target
	payload["input_value"] = submitted_input
	payload["check_attempt_count"] = check_attempt_count
	payload["hint_used"] = hint_used
	payload["error_type"] = error_code
	payload["penalty_reported"] = float(result.get("penalty", 0.0))
	if result.has("hamming"):
		payload["hamming"] = int(result.get("hamming", 0))
	GlobalMetrics.register_trial(payload)

func _sync_switches_to_input() -> void:
	for bit in range(8):
		var pressed = ((current_input >> bit) & 1) == 1
		var btn: Button = bit_buttons[bit]
		btn.set_pressed_no_signal(pressed)
		btn.text = "1" if pressed else "0"
</file>

<file path="scenes/LogicQuestA.gd">
extends Control

# --- CONSTANTS & CONFIG ---
const PHASE_TRAINING = "TRAINING"
const PHASE_TRANSLATION = "TRANSLATION"
const PHASE_DETECTION = "DETECTION"

const GATE_AND = "AND"
const GATE_OR = "OR"
const GATE_NOT = "NOT"
const GATE_XOR = "XOR"
const GATE_NAND = "NAND"
const GATE_NOR = "NOR"

const MAX_ATTEMPTS = 3
const VERDICT_LOCK_TIME = 2.0

# Cases Data
const CASES = [
	{
		"id": "A1_01", "phase": PHASE_TRAINING, "gate": GATE_AND,
		"a_text": "КЛЮЧ", "b_text": "СТАРТ",
		"witness_text": "Машина заведется, если есть КЛЮЧ и нажата кнопка СТАРТ.",
		"min_seen": 2, "hints": ["Нужны оба условия.", "Это AND (И)."]
	},
	{
		"id": "A1_02", "phase": PHASE_TRAINING, "gate": GATE_OR,
		"a_text": "ДОЖДЬ", "b_text": "СНЕГ",
		"witness_text": "Вы промокнете, если идет ДОЖДЬ или СНЕГ (зонта нет).",
		"min_seen": 2, "hints": ["Достаточно одного условия.", "Это OR (ИЛИ)."]
	},
	{
		"id": "A1_03", "phase": PHASE_TRAINING, "gate": GATE_AND,
		"a_text": "ПАРОЛЬ", "b_text": "ТЕЛЕФОН",
		"witness_text": "Вход в почту разрешен, если введен ПАРОЛЬ и пройден ТЕЛЕФОН.",
		"min_seen": 2, "hints": ["Нужны оба условия.", "Это AND (И)."]
	},
	{
		"id": "A1_04", "phase": PHASE_TRAINING, "gate": GATE_OR,
		"a_text": "ВЫКЛ_1", "b_text": "ВЫКЛ_2",
		"witness_text": "Свет в коридоре горит, если включен ВЫКЛ_1 или ВЫКЛ_2.",
		"min_seen": 2, "hints": ["Достаточно одного выключателя.", "Это OR (ИЛИ)."]
	},
	{
		"id": "A1_05", "phase": PHASE_TRAINING, "gate": GATE_NOT,
		"a_text": "СИГНАЛ", "b_text": "---",
		"witness_text": "Детектор лжи инвертирует сигнал: если на входе НЕТ, на выходе ДА.",
		"min_seen": 2, "hints": ["Инверсия: 1->0, 0->1.", "Это NOT (НЕ)."]
	},
	{
		"id": "A2_01", "phase": PHASE_TRANSLATION, "gate": GATE_AND,
		"a_text": "A", "b_text": "B",
		"witness_text": "Логическое И обозначается символом &. Найдите его.",
		"min_seen": 2, "hints": ["& это И.", "Конъюнкция."]
	},
	{
		"id": "A2_02", "phase": PHASE_TRANSLATION, "gate": GATE_OR,
		"a_text": "A", "b_text": "B",
		"witness_text": "Логическое ИЛИ обозначается символом ∨. Найдите его.",
		"min_seen": 2, "hints": ["∨ это ИЛИ.", "Дизъюнкция."]
	},
	{
		"id": "A2_03", "phase": PHASE_TRANSLATION, "gate": GATE_NOT,
		"a_text": "A", "b_text": "---",
		"witness_text": "Инверсия обозначается символом ¬. Найдите его.",
		"min_seen": 2, "hints": ["¬ это НЕ.", "Отрицание."]
	},
	{
		"id": "A2_04", "phase": PHASE_TRANSLATION, "gate": GATE_XOR,
		"a_text": "A", "b_text": "B",
		"witness_text": "Исключающее ИЛИ обозначается символом ⊕. Найдите его.",
		"min_seen": 2, "hints": ["⊕ это XOR.", "Истина при разных входах."]
	},
	{
		"id": "A2_05", "phase": PHASE_TRANSLATION, "gate": GATE_NOR,
		"a_text": "A", "b_text": "B",
		"witness_text": "Стрелка Пирса (ИЛИ-НЕ) обозначается символом ⊽.",
		"min_seen": 2, "hints": ["Это инверсия ИЛИ.", "NOR."]
	},
	{
		"id": "A3_01", "phase": PHASE_DETECTION, "gate": GATE_NOR,
		"a_text": "КОД_1", "b_text": "КОД_2",
		"witness_text": "Сейф открылся (1), когда оба кода были неверны (0,0).",
		"min_seen": 3, "hints": ["Выход 1 только при 0,0.", "Это NOR."]
	},
	{
		"id": "A3_02", "phase": PHASE_DETECTION, "gate": GATE_XOR,
		"a_text": "ДАТЧИК_1", "b_text": "ДАТЧИК_2",
		"witness_text": "Сигнализация молчит (0), только когда сигналы совпадают.",
		"min_seen": 3, "hints": ["Истина при разных входах.", "Это XOR."]
	},
	{
		"id": "A3_03", "phase": PHASE_DETECTION, "gate": GATE_NOR,
		"a_text": "РЫЧАГ_1", "b_text": "РЫЧАГ_2",
		"witness_text": "Замок заклинит (0), если нажать хотя бы один рычаг.",
		"min_seen": 3, "hints": ["Выход 1 только при 0,0.", "Это NOR."]
	},
	{
		"id": "A3_04", "phase": PHASE_DETECTION, "gate": GATE_XOR,
		"a_text": "ЧАСТОТА_1", "b_text": "ЧАСТОТА_2",
		"witness_text": "Перехват данных (1) идет только при разных частотах.",
		"min_seen": 3, "hints": ["Разные входы дают 1.", "Это XOR."]
	},
	{
		"id": "A3_05", "phase": PHASE_DETECTION, "gate": GATE_NAND,
		"a_text": "X", "b_text": "Y",
		"witness_text": "Нужен вентиль, дающий ЛОЖЬ только при двух ИСТИНАХ.",
		"min_seen": 3, "hints": ["0 только при 1,1.", "Это NAND."]
	}
]
# --- UI NODES ---
@onready var stability_label = $MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/StabilityLabel
@onready var stats_label = $MainLayout/HeaderPanel/HeaderMargin/HeaderHBox/StatsLabel
@onready var story_text = $MainLayout/StoryPanel/StoryMargin/StoryText
@onready var journal_label = $MainLayout/BoardContainer/JournalLabel

@onready var input_a_btn = $MainLayout/BoardContainer/InputA_Btn
@onready var input_b_btn = $MainLayout/BoardContainer/InputB_Btn
@onready var gate_selector = $MainLayout/BoardContainer/GateSelector
@onready var lamp_rect = $MainLayout/BoardContainer/Lamp
@onready var lamp_label = $MainLayout/BoardContainer/Lamp/LampLabel

@onready var wire_a = $MainLayout/BoardContainer/WiresLayer/InputA_Wire
@onready var wire_b = $MainLayout/BoardContainer/WiresLayer/InputB_Wire
@onready var wire_out = $MainLayout/BoardContainer/WiresLayer/Output_Wire

@onready var feedback_label = $MainLayout/ControlsPanel/ControlsMargin/HBox/FeedbackLabel
@onready var btn_verdict = $MainLayout/ControlsPanel/ControlsMargin/HBox/BtnVerdict
@onready var btn_next = $MainLayout/ControlsPanel/ControlsMargin/HBox/BtnNext
@onready var btn_hint = $MainLayout/ControlsPanel/ControlsMargin/HBox/BtnHint

@onready var game_over_panel = $GameOverPanel
@onready var game_over_label = $GameOverPanel/CenterContainer/VBox/Title
@onready var click_player = $ClickPlayer

# --- STATE ---
var current_case_index: int = 0
var current_case: Dictionary = {}

var input_a: bool = false
var input_b: bool = false
var selected_gate_guess: String = ""

var seen_combinations: Dictionary = {}
var case_attempts: int = 0
var hints_used: int = 0
var start_time_msec: int = 0
var first_action_ms: int = -1
var verdict_count: int = 0

var last_verdict_time: float = 0.0
var verdict_timer: Timer = null
var is_safe_mode: bool = false

# Colors for Wires/Effects
const COLOR_WIRE_OFF = Color(0.15, 0.15, 0.15, 1) # Dark Grey
const COLOR_WIRE_ON = Color(1.2, 1.2, 1.2, 1)     # Glowing White (HDR)
const COLOR_LAMP_OFF = Color(0.1, 0.1, 0.1, 1)
const COLOR_LAMP_ON = Color(1.5, 1.5, 1.3, 1)     # Bright Warm White

func _ready():
	_setup_gate_selector()
	_update_stability_ui(GlobalMetrics.stability, 0)
	GlobalMetrics.stability_changed.connect(_update_stability_ui)
	GlobalMetrics.game_over.connect(_on_game_over)

	verdict_timer = Timer.new()
	verdict_timer.one_shot = true
	verdict_timer.timeout.connect(_on_verdict_unlock)
	add_child(verdict_timer)

	load_case(0)

func _setup_gate_selector():
	gate_selector.clear()
	gate_selector.add_item(" ... ", 0) # ID 0 = None
	# Using strict ENT symbols as requested
	gate_selector.add_item(" &  (И)", 1)
	gate_selector.add_item(" 1  (ИЛИ)", 2)
	gate_selector.add_item(" ¬  (НЕ)", 3)
	gate_selector.add_item(" ⊕  (ИСКЛ. ИЛИ)", 4)
	gate_selector.add_item(" |  (И-НЕ)", 5)
	gate_selector.add_item(" ↓  (ИЛИ-НЕ)", 6)

	gate_selector.set_item_metadata(1, GATE_AND)
	gate_selector.set_item_metadata(2, GATE_OR)
	gate_selector.set_item_metadata(3, GATE_NOT)
	gate_selector.set_item_metadata(4, GATE_XOR)
	gate_selector.set_item_metadata(5, GATE_NAND)
	gate_selector.set_item_metadata(6, GATE_NOR)

func load_case(idx: int):
	if idx >= CASES.size():
		idx = 0 # Loop for now

	current_case_index = idx
	current_case = CASES[idx]

	# Reset State
	input_a = false
	input_b = false
	selected_gate_guess = ""
	seen_combinations.clear()
	case_attempts = 0
	hints_used = 0
	start_time_msec = Time.get_ticks_msec()
	first_action_ms = -1
	verdict_count = 0
	is_safe_mode = false

	# Update UI Text
	story_text.text = current_case.witness_text
	_update_stats_ui()
	journal_label.text = "ЛОГ: СИСТЕМА ГОТОВА"

	# Reset Inputs
	input_a_btn.button_pressed = false
	input_b_btn.button_pressed = false
	input_a_btn.disabled = false
	input_b_btn.disabled = false
	btn_hint.disabled = false
	_update_input_labels()

	# Handle NOT gate (Single input)
	if current_case.gate == GATE_NOT:
		input_b_btn.visible = false
		wire_b.visible = false
	else:
		input_b_btn.visible = true
		wire_b.visible = true

	# Reset Selector & Output
	gate_selector.selected = 0
	gate_selector.disabled = false

	# Reset Controls
	btn_verdict.visible = true
	btn_verdict.disabled = false
	btn_next.visible = false
	feedback_label.text = ""

	_update_circuit()

func _update_input_labels():
	input_a_btn.text = "%s\n%s" % [current_case.a_text, "1" if input_a else "0"]
	if current_case.gate != GATE_NOT:
		input_b_btn.text = "%s\n%s" % [current_case.b_text, "1" if input_b else "0"]

func _on_input_a_toggled(pressed: bool):
	_mark_first_action()
	input_a = pressed
	_play_click()
	_update_input_labels()
	_update_circuit()

func _on_input_b_toggled(pressed: bool):
	_mark_first_action()
	input_b = pressed
	_play_click()
	_update_input_labels()
	_update_circuit()

func _update_circuit():
	# 1. Update Input Wires
	wire_a.default_color = COLOR_WIRE_ON if input_a else COLOR_WIRE_OFF
	wire_b.default_color = COLOR_WIRE_ON if input_b else COLOR_WIRE_OFF

	# 2. Calculate Logic
	var out_val = _calculate_gate_output(input_a, input_b, current_case.gate)

	# 3. Update Output Wire & Lamp
	wire_out.default_color = COLOR_WIRE_ON if out_val else COLOR_WIRE_OFF

	if out_val:
		lamp_rect.color = COLOR_LAMP_ON
		lamp_label.modulate = Color(0, 0, 0, 1) # Black text on bright lamp
	else:
		lamp_rect.color = COLOR_LAMP_OFF
		lamp_label.modulate = Color(0.3, 0.3, 0.3, 1) # Dim text

	# 4. Log
	var key = ""
	if current_case.gate == GATE_NOT:
		key = "A=%d" % [1 if input_a else 0]
	else:
		key = "A=%d B=%d" % [1 if input_a else 0, 1 if input_b else 0]

	if not seen_combinations.has(key):
		seen_combinations[key] = out_val
		_update_journal_log()
		_update_stats_ui()

func _calculate_gate_output(a: bool, b: bool, type: String) -> bool:
	match type:
		GATE_AND: return a and b
		GATE_OR: return a or b
		GATE_NOT: return not a
		GATE_XOR: return a != b
		GATE_NAND: return not (a and b)
		GATE_NOR: return not (a or b)
	return false

func _update_journal_log():
	var txt = "ЛОГ:\n"
	for k in seen_combinations:
		var res = "1" if seen_combinations[k] else "0"
		txt += "%s -> F=%s | " % [k, res]
	journal_label.text = txt

func _on_gate_selected(index):
	_mark_first_action()
	if index == 0:
		selected_gate_guess = ""
	else:
		selected_gate_guess = gate_selector.get_item_metadata(index)
		_play_click()

func _on_verdict_pressed():
	if is_safe_mode:
		return
	_mark_first_action()
	verdict_count += 1

	# Anti-spam
	var current_time = Time.get_ticks_msec() / 1000.0
	if current_time - last_verdict_time < 0.8:
		_show_feedback("Подождите перед следующим вердиктом.", Color(1, 0.5, 0))
		_lock_verdict(3.0)
		_register_trial("RATE_LIMITED", false)
		return
	last_verdict_time = current_time

	if selected_gate_guess == "":
		_show_feedback("СНАЧАЛА ВЫБЕРИТЕ ВЕНТИЛЬ", Color(1, 1, 0))
		_register_trial("EMPTY_SELECTION", false)
		return

	var min_seen = current_case.get("min_seen", 2)
	if seen_combinations.size() < min_seen:
		_show_feedback("НЕДОСТАТОЧНО ДАННЫХ (%d/%d)" % [seen_combinations.size(), min_seen], Color(1, 0.5, 0))
		_apply_penalty(2.0)
		_lock_verdict(2.0)
		_register_trial("INSUFFICIENT_DATA", false)
		return

	if selected_gate_guess == current_case.gate:
		_show_feedback("ДОСТУП РАЗРЕШЁН", Color(0, 1, 0))
		btn_verdict.visible = false
		btn_next.visible = true
		_disable_controls()
		_register_trial("SUCCESS", true)
	else:
		case_attempts += 1
		_update_stats_ui()

		var penalty = 10.0
		if case_attempts == 2:
			penalty = 15.0
		elif case_attempts >= 3:
			penalty = 25.0

		_apply_penalty(penalty)
		_show_feedback("ДОСТУП ЗАПРЕЩЁН (-%d)" % int(penalty), Color(1, 0, 0))
		var verdict_code := "WRONG_GATE"
		if case_attempts >= MAX_ATTEMPTS:
			_enter_safe_mode()
			verdict_code = "SAFE_MODE_TRIGGERED"
		_register_trial(verdict_code, false)

func _lock_verdict(duration: float):
	if is_safe_mode: return
	btn_verdict.disabled = true
	verdict_timer.start(duration)

func _on_verdict_unlock():
	if is_safe_mode: return
	if GlobalMetrics.stability > 0:
		btn_verdict.disabled = false

func _enter_safe_mode():
	is_safe_mode = true
	_disable_controls()
	btn_verdict.disabled = true
	btn_next.visible = true

	# Auto-select correct gate
	for i in range(gate_selector.item_count):
		if gate_selector.get_item_metadata(i) == current_case.gate:
			gate_selector.select(i)
			gate_selector.disabled = true
			break

	var gate_symbol = "?"
	match current_case.gate:
		GATE_AND: gate_symbol = "& (И)"
		GATE_OR: gate_symbol = "1 (ИЛИ)"
		GATE_NOT: gate_symbol = "¬ (НЕ)"
		GATE_XOR: gate_symbol = "⊕ (ИСКЛ. ИЛИ)"
		GATE_NAND: gate_symbol = "| (И-НЕ)"
		GATE_NOR: gate_symbol = "↓ (ИЛИ-НЕ)"

	_show_feedback("БЕЗОПАСНЫЙ РЕЖИМ: правильный вентиль %s. Выполнен авторазбор." % gate_symbol, Color(1, 0.5, 0))

func _show_feedback(msg: String, col: Color):
	feedback_label.text = msg
	feedback_label.add_theme_color_override("font_color", col)
	feedback_label.visible = true

func _apply_penalty(amount):
	GlobalMetrics.stability = max(0.0, GlobalMetrics.stability - amount)
	GlobalMetrics.stability_changed.emit(GlobalMetrics.stability, -amount)

func _update_stability_ui(val, _change):
	stability_label.text = "СТАБИЛЬНОСТЬ: %d%%" % int(val)
	if val < 30:
		stability_label.add_theme_color_override("font_color", Color(1, 0, 0))
	elif val < 70:
		stability_label.add_theme_color_override("font_color", Color(1, 1, 0))
	else:
		stability_label.add_theme_color_override("font_color", Color(0, 1, 0))

func _update_stats_ui():
	var min_seen = current_case.get("min_seen", 2)
	stats_label.text = "ДЕЛО: %02d | ПОП: %d/%d | ФАКТЫ: %d/%d" % [
		current_case_index + 1,
		case_attempts,
		MAX_ATTEMPTS,
		seen_combinations.size(),
		min_seen
	]

func _on_game_over():
	_enter_safe_mode()
	# The original game over panel is now redundant if we want "Safe Mode" style instead
	# But per instructions, if stability drops to 0, we enter Safe Mode.
	# We can keep the glitch effect if desired, but "Safe Mode" implies continuing.
	# Let's hide the old game over panel if it pops up via other paths, or just not use it.
	game_over_panel.visible = false

func _on_system_failure():
	# Deprecated by Safe Mode logic, but kept as fallback/extreme fail
	_enter_safe_mode()

func _on_restart_pressed():
	# Legacy restart, might not be needed if Safe Mode handles everything
	GlobalMetrics.stability = 100.0
	GlobalMetrics.stability_changed.emit(100.0, 0)
	game_over_panel.visible = false
	load_case(current_case_index)

func _on_back_button_pressed():
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_next_button_pressed():
	load_case(current_case_index + 1)

func _on_hint_pressed():
	_mark_first_action()
	if hints_used < current_case.hints.size():
		var h = current_case.hints[hints_used]
		hints_used += 1
		_show_feedback("ПОДСКАЗКА: " + h, Color(0.5, 0.8, 1))
		_apply_penalty(5.0)
	else:
		_show_feedback("ПОДСКАЗОК БОЛЬШЕ НЕТ", Color(0.5, 0.5, 0.5))

func _mark_first_action() -> void:
	if first_action_ms < 0:
		first_action_ms = Time.get_ticks_msec() - start_time_msec

func _register_trial(verdict_code: String, is_correct: bool) -> void:
	var case_id := str(current_case.get("id", "A_00"))
	var payload := TrialV2.build("LOGIC_QUEST", "A", case_id, "GATE_IDENTIFY")
	var elapsed_ms: int = maxi(0, Time.get_ticks_msec() - start_time_msec)
	payload["elapsed_ms"] = elapsed_ms
	payload["duration"] = float(elapsed_ms) / 1000.0
	payload["time_to_first_action_ms"] = first_action_ms if first_action_ms >= 0 else elapsed_ms
	payload["is_correct"] = is_correct
	payload["is_fit"] = is_correct
	payload["stability_delta"] = 0
	payload["verdict_code"] = verdict_code
	payload["selected_gate_id"] = selected_gate_guess
	payload["correct_gate_id"] = str(current_case.get("gate", ""))
	payload["seen_combinations"] = seen_combinations.size()
	payload["hints_used"] = hints_used
	payload["attempts"] = case_attempts
	payload["verdict_count"] = verdict_count
	GlobalMetrics.register_trial(payload)

func _play_click():
	if click_player.stream:
		click_player.play()

func _disable_controls():
	input_a_btn.disabled = true
	input_b_btn.disabled = true
	gate_selector.disabled = true
	btn_hint.disabled = true
</file>

<file path="scripts/case_07/da7_cases_b.gd">
extends Node

const SCHEMA_VERSION = "DA7.B.v1"
const LEVEL = "B"

# --- F_REASON Constants (Ladder Priority) ---
const F_REASON_FILTER = [
	"EMPTY_SELECTION",
	"PURE_OPPOSITE",
	"INCLUDED_BOUNDARY",
	"OVERSELECT_DECOY",
	"FALSE_POSITIVE",
	"OMISSION",
	"NONE"
]

const F_REASON_RELATION = [
	"RELATION_CONFUSION_1TO1_1TOM",
	"RELATION_CONFUSION_1TOM_MTOM",
	"FK_DIRECTION_SWAP",
	"GUESS_FAST_CLICK",
	"CORRECT"
]

const CASES_B: Array = [
	# --- 1. FILTER_ROWS (Strict >) ---
	{
		"id": "DA7-B-01",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Терминал: выберите агентов с уровнем доступа строго больше 3.",
		"predicate": {
			"field_col_id": "c_access",
			"operator": ">",
			"value": "3",
			"value_type": "INT",
			"strict_expected": true
		},
		"table": {
			"columns": [
				{"col_id": "c_name", "title": "Имя"},
				{"col_id": "c_access", "title": "Доступ"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_name": "Альфа", "c_access": "2"}},
				{"row_id": "r2", "cells": {"c_name": "Бета", "c_access": "5"}},
				{"row_id": "r3", "cells": {"c_name": "Гамма", "c_access": "3"}},
				{"row_id": "r4", "cells": {"c_name": "Дельта", "c_access": "4"}}
			]
		},
		"answer_row_ids": ["r2", "r4"],
		"boundary_row_ids": ["r3"],
		"opposite_row_ids": ["r1"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["strict_inequality", "boundary_case"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 2. FILTER_ROWS (Non-Strict >=) ---
	{
		"id": "DA7-B-02",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Система: выберите инциденты с уровнем серьёзности >= 2.",
		"predicate": {
			"field_col_id": "c_sev",
			"operator": ">=",
			"value": "2",
			"value_type": "INT",
			"strict_expected": false
		},
		"table": {
			"columns": [
				{"col_id": "c_id", "title": "ID"},
				{"col_id": "c_sev", "title": "Серьёзн."}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_id": "101", "c_sev": "1"}},
				{"row_id": "r2", "cells": {"c_id": "102", "c_sev": "2"}},
				{"row_id": "r3", "cells": {"c_id": "103", "c_sev": "3"}},
				{"row_id": "r4", "cells": {"c_id": "104", "c_sev": "1"}}
			]
		},
		"answer_row_ids": ["r2", "r3"],
		"boundary_row_ids": ["r2"],
		"opposite_row_ids": ["r1", "r4"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["non_strict_inequality", "boundary_in_answer"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 3. FILTER_ROWS (String equality ==) ---
	{
		"id": "DA7-B-03",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Поиск: выберите все строки со статусом ОШИБКА.",
		"predicate": {
			"field_col_id": "c_stat",
			"operator": "==",
			"value": "ОШИБКА",
			"value_type": "TEXT",
			"strict_expected": true
		},
		"table": {
			"columns": [
				{"col_id": "c_ts", "title": "Время"},
				{"col_id": "c_stat", "title": "Статус"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_ts": "09:00", "c_stat": "НОРМА"}},
				{"row_id": "r2", "cells": {"c_ts": "09:05", "c_stat": "ОШИБКА"}},
				{"row_id": "r3", "cells": {"c_ts": "09:10", "c_stat": "ПРЕДУПРЕЖДЕНИЕ"}},
				{"row_id": "r4", "cells": {"c_ts": "09:15", "c_stat": "ОШИБКА"}}
			]
		},
		"answer_row_ids": ["r2", "r4"],
		"boundary_row_ids": [],
		"opposite_row_ids": ["r1", "r3"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["equality_filter"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 4. FILTER_ROWS (Strict <) ---
	{
		"id": "DA7-B-04",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_FILTERING",
		"case_kind": "FILTER_ROWS",
		"interaction_type": "MULTI_SELECT_ROWS",
		"prompt": "Фильтр: найдите транзакции с суммой < 100.",
		"predicate": {
			"field_col_id": "c_sum",
			"operator": "<",
			"value": "100",
			"value_type": "INT",
			"strict_expected": true
		},
		"table": {
			"columns": [
				{"col_id": "c_id", "title": "TX_ID"},
				{"col_id": "c_sum", "title": "Сумма"}
			],
			"rows": [
				{"row_id": "r1", "cells": {"c_id": "1", "c_sum": "50"}},
				{"row_id": "r2", "cells": {"c_id": "2", "c_sum": "100"}},
				{"row_id": "r3", "cells": {"c_id": "3", "c_sum": "150"}},
				{"row_id": "r4", "cells": {"c_id": "4", "c_sum": "99"}}
			]
		},
		"answer_row_ids": ["r1", "r4"],
		"boundary_row_ids": ["r2"],
		"opposite_row_ids": ["r3"],
		"decoy_row_ids": [],
		"unrelated_row_ids": [],
		"difficulty_tags": ["strict_inequality", "boundary_case"],
		"anti_cheat": {"shuffle_rows": true, "shuffle_options": false},
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120}
	},
	# --- 5. RELATIONSHIP (1:M) ---
	{
		"id": "DA7-B-05",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_RELATIONSHIPS",
		"case_kind": "RELATION_TYPE",
		"interaction_type": "RELATIONSHIP_CHOICE",
		"prompt": "Схема: определите связь между Пользователи и Посты.",
		"schema_visual": {
			"left_table": {
				"title": "Пользователи",
				"columns": [{"col_id":"u_id","title":"ID"}, {"col_id":"u_name","title":"Имя"}],
				"rows_preview": [
					{"row_id":"u1", "cells":{"u_id":"1","u_name":"Алиса"}},
					{"row_id":"u2", "cells":{"u_id":"2","u_name":"Боб"}}
				]
			},
			"right_table": {
				"title": "Посты",
				"columns": [{"col_id":"p_id","title":"ID"}, {"col_id":"p_uid","title":"ID_пользователя"}, {"col_id":"p_txt","title":"Текст"}],
				"rows_preview": [
					{"row_id":"p1", "cells":{"p_id":"10","p_uid":"1","p_txt":"Привет"}},
					{"row_id":"p2", "cells":{"p_id":"11","p_uid":"1","p_txt":"Обновление"}},
					{"row_id":"p3", "cells":{"p_id":"12","p_uid":"2","p_txt":"Здравствуй"}}
				]
			},
			"link": {
				"hint_label": "Пользователи.ID -> Посты.ID_пользователя"
			}
		},
		"expected_relation": "1:M",
		"options": [
			{"id": "opt1", "text": "1:1 (Один-к-одному)", "f_reason": "RELATION_CONFUSION_1TO1_1TOM"},
			{"id": "opt2", "text": "1:M (Один-ко-многим)", "f_reason": null},
			{"id": "opt3", "text": "M:M (Многие-ко-многим)", "f_reason": "RELATION_CONFUSION_1TOM_MTOM"}
		],
		"answer_id": "opt2",
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120},
		"anti_cheat": {"shuffle_rows": false, "shuffle_options": true}
	},
	# --- 6. RELATIONSHIP (1:1) ---
	{
		"id": "DA7-B-06",
		"schema_version": "DA7.B.v1",
		"level": "B",
		"topic": "DB_RELATIONSHIPS",
		"case_kind": "RELATION_TYPE",
		"interaction_type": "RELATIONSHIP_CHOICE",
		"prompt": "Схема: определите связь между Сотрудники и Паспортные_данные (уникальный паспорт).",
		"schema_visual": {
			"left_table": {
				"title": "Сотрудники",
				"columns": [{"col_id":"e_id","title":"ID"}, {"col_id":"e_name","title":"Имя"}],
				"rows_preview": [
					{"row_id":"e1", "cells":{"e_id":"101","e_name":"Иван"}},
					{"row_id":"e2", "cells":{"e_id":"102","e_name":"Жанна"}}
				]
			},
			"right_table": {
				"title": "Паспортные_данные",
				"columns": [{"col_id":"pd_id","title":"ID_паспорта"}, {"col_id":"pd_eid","title":"ID_сотрудника"}, {"col_id":"pd_num","title":"Номер"}],
				"rows_preview": [
					{"row_id":"p1", "cells":{"pd_id":"55","pd_eid":"101","pd_num":"A-001"}},
					{"row_id":"p2", "cells":{"pd_id":"56","pd_eid":"102","pd_num":"B-002"}}
				]
			},
			"link": {
				"hint_label": "Сотрудники.ID -> Паспорт.ID_сотрудника (Уникально)"
			}
		},
		"expected_relation": "1:1",
		"options": [
			{"id": "opt1", "text": "1:1 (Один-к-одному)", "f_reason": null},
			{"id": "opt2", "text": "1:M (Один-ко-многим)", "f_reason": "RELATION_CONFUSION_1TO1_1TOM"},
			{"id": "opt3", "text": "M:M (Многие-ко-многим)", "f_reason": "RELATION_CONFUSION_1TOM_MTOM"}
		],
		"answer_id": "opt1",
		"timing_policy": {"mode": "LEARNING", "limit_sec": 120},
		"anti_cheat": {"shuffle_rows": false, "shuffle_options": true}
	}
]

static func validate_case_b(c: Dictionary) -> bool:
	var case_id: String = str(c.get("id", "UNKNOWN"))
	if str(c.get("schema_version", "")) != SCHEMA_VERSION:
		push_error("Case %s bad schema" % case_id)
		return false

	if str(c.get("interaction_type", "")) == "MULTI_SELECT_ROWS":
		# Validation for disjoint sets (basic existence checks).
		if not c.has("answer_row_ids") or not c.has("boundary_row_ids") or not c.has("opposite_row_ids") or not c.has("unrelated_row_ids") or not c.has("decoy_row_ids"):
			push_error("Case %s missing sets" % case_id)
			return false
		if not c.has("predicate"):
			push_error("Case %s missing predicate" % case_id)
			return false
		if not c.has("table"):
			push_error("Case %s missing table" % case_id)
			return false
		var table: Dictionary = c.get("table", {}) as Dictionary
		var rows: Array = table.get("rows", []) as Array
		var all_row_ids: Dictionary = {}
		for row_v in rows:
			if typeof(row_v) != TYPE_DICTIONARY:
				continue
			var row_id: String = str((row_v as Dictionary).get("row_id", ""))
			if row_id == "":
				continue
			all_row_ids[row_id] = true
		var answer_ids: Array = c.get("answer_row_ids", []) as Array
		var boundary_ids: Array = c.get("boundary_row_ids", []) as Array
		var opposite_ids: Array = c.get("opposite_row_ids", []) as Array
		var unrelated_ids: Array = c.get("unrelated_row_ids", []) as Array
		var decoy_ids: Array = c.get("decoy_row_ids", []) as Array
		if not _all_exist_in(answer_ids, all_row_ids) or not _all_exist_in(boundary_ids, all_row_ids) or not _all_exist_in(opposite_ids, all_row_ids) or not _all_exist_in(unrelated_ids, all_row_ids) or not _all_exist_in(decoy_ids, all_row_ids):
			push_error("Case %s has unknown row ids in sets" % case_id)
			return false
		# Boundary rows may overlap with answer rows for non-strict predicates (e.g. >=).
		var predicate: Dictionary = c.get("predicate", {}) as Dictionary
		var strict_expected: bool = bool(predicate.get("strict_expected", false))
		if not _are_disjoint([answer_ids, opposite_ids, unrelated_ids, decoy_ids]):
			push_error("Case %s has intersecting sets (A/O/U/D)" % case_id)
			return false
		if _has_intersection(boundary_ids, opposite_ids) or _has_intersection(boundary_ids, unrelated_ids) or _has_intersection(boundary_ids, decoy_ids):
			push_error("Case %s has invalid boundary overlap with O/U/D sets" % case_id)
			return false
		if strict_expected and _has_intersection(boundary_ids, answer_ids):
			push_error("Case %s has strict predicate but boundary overlaps answer set" % case_id)
			return false

	elif str(c.get("interaction_type", "")) == "RELATIONSHIP_CHOICE":
		if not c.has("schema_visual"):
			push_error("Case %s missing schema_visual" % case_id)
			return false
		if not c.has("options"):
			push_error("Case %s missing options" % case_id)
			return false

	return true

static func _all_exist_in(ids: Array, allowed: Dictionary) -> bool:
	for id_v in ids:
		var row_id: String = str(id_v)
		if not allowed.has(row_id):
			return false
	return true

static func _are_disjoint(grouped_ids: Array) -> bool:
	var seen: Dictionary = {}
	for group_v in grouped_ids:
		if typeof(group_v) != TYPE_ARRAY:
			continue
		var group: Array = group_v
		for id_v in group:
			var key: String = str(id_v)
			if seen.has(key):
				return false
			seen[key] = true
	return true

static func _has_intersection(arr1: Array, arr2: Array) -> bool:
	var lookup: Dictionary = {}
	for id_v in arr2:
		lookup[str(id_v)] = true
	for id_v in arr1:
		if lookup.has(str(id_v)):
			return true
	return false
</file>

<file path="scripts/case_07/da7_data_archive_a.gd">
extends Control

const CasesHub = preload("res://scripts/case_07/da7_cases.gd")

const BREAKPOINT_PX := 800
const SESSION_CASE_COUNT := 6
const TYPEWRITER_INTERVAL_SEC := 0.03

var session_cases: Array = []
var current_case_index: int = -1
var current_case: Dictionary = {}
var case_started_ts: int = 0
var first_action_ts: int = -1
var trial_locked: bool = false
var scroll_used: bool = false
var table_has_scroll: bool = false
var exit_btn: Button

var inspect_count: int = 0
var unique_rows_inspected: Dictionary = {}
var answered_without_inspection: bool = false
var last_inspected_row_id: String = ""

var row_item_by_id: Dictionary = {}
var col_index_by_id: Dictionary = {}
var row_data_by_id: Dictionary = {}

var _typewriter_steps: Array[Dictionary] = []
var _typewriter_step_index: int = -1
var _typewriter_target: RichTextLabel
var _typewriter_source: String = ""
var _typewriter_cursor: int = 0

@onready var title_label: RichTextLabel = $SafeArea/RootLayout/Header/Margin/Title
@onready var btn_back: Button = $SafeArea/RootLayout/BackRow/BtnBack
@onready var desktop_layout: HSplitContainer = $SafeArea/RootLayout/Body/DesktopLayout
@onready var mobile_layout: VBoxContainer = $SafeArea/RootLayout/Body/MobileLayout
@onready var table_section: VBoxContainer = $SafeArea/RootLayout/Body/DesktopLayout/TableSection
@onready var task_section: VBoxContainer = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection
@onready var data_tree: Tree = $SafeArea/RootLayout/Body/DesktopLayout/TableSection/DataTree
@onready var inspect_label: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox/InspectLabel
@onready var scan_label: Label = $SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox/ScanLabel
@onready var case_title_label: Label = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox/CaseTitleLabel
@onready var briefing_label: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox/BriefingLabel
@onready var objective_label: Label = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox/ObjectiveLabel
@onready var prompt_label: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/PromptLabel
@onready var options_grid: GridContainer = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/OptionsGrid
@onready var explain_line: RichTextLabel = $SafeArea/RootLayout/Body/DesktopLayout/TaskSection/ExplainLine
@onready var stability_label: Label = $SafeArea/RootLayout/Footer/StabilityLabel
@onready var stability_bar: ProgressBar = $SafeArea/RootLayout/Footer/StabilityBar
@onready var sfx_click: AudioStreamPlayer = $Runtime/Audio/SfxClick
@onready var sfx_error: AudioStreamPlayer = $Runtime/Audio/SfxError
@onready var sfx_relay: AudioStreamPlayer = $Runtime/Audio/SfxRelay
@onready var result_stamp: Control = $ResultStamp
@onready var typewriter_timer: Timer = $Runtime/TypewriterTimer

func _ready() -> void:
	randomize()
	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	if not btn_back.pressed.is_connected(_on_back_pressed):
		btn_back.pressed.connect(_on_back_pressed)
	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	if not data_tree.gui_input.is_connected(_on_scroll_input):
		data_tree.gui_input.connect(_on_scroll_input)
	if not prompt_label.gui_input.is_connected(_on_scroll_input):
		prompt_label.gui_input.connect(_on_scroll_input)
	if not data_tree.item_selected.is_connected(_on_tree_item_selected):
		data_tree.item_selected.connect(_on_tree_item_selected)
	if not typewriter_timer.timeout.is_connected(_on_typewriter_tick):
		typewriter_timer.timeout.connect(_on_typewriter_tick)

	_init_session()
	call_deferred("_on_viewport_size_changed")
	_load_next_case()

func _init_session() -> void:
	var all_cases: Array = CasesHub.get_cases("A")
	if all_cases.is_empty():
		_show_fatal("Кейсы уровня A не найдены. Проверьте scripts/case_07/da7_cases_a.gd")
		return

	all_cases.shuffle()
	session_cases = all_cases.slice(0, mini(SESSION_CASE_COUNT, all_cases.size()))
	current_case_index = -1
	GlobalMetrics.stability = 100.0
	_update_stability_ui()

func _load_next_case() -> void:
	if session_cases.is_empty():
		return

	current_case_index += 1
	if current_case_index >= session_cases.size():
		_finish_session()
		return

	current_case = (session_cases[current_case_index] as Dictionary).duplicate(true)
	case_started_ts = Time.get_ticks_msec()
	first_action_ts = -1
	scroll_used = false
	table_has_scroll = false
	trial_locked = false
	inspect_count = 0
	unique_rows_inspected.clear()
	answered_without_inspection = false
	last_inspected_row_id = ""
	row_item_by_id.clear()
	col_index_by_id.clear()
	row_data_by_id.clear()
	typewriter_timer.stop()
	_render_case()

func _render_case() -> void:
	title_label.text = "ДЕЛО #7: СЕКРЕТНЫЙ АРХИВ [A %d/%d]" % [current_case_index + 1, session_cases.size()]

	case_title_label.text = "ФАЙЛ: %s" % str(current_case.get("case_title", current_case.get("id", "НЕИЗВЕСТНЫЙ_ФАЙЛ")))
	briefing_label.bbcode_enabled = false
	briefing_label.text = str(current_case.get("briefing", ""))
	objective_label.text = "ЦЕЛЬ: %s" % str(current_case.get("objective", ""))

	prompt_label.bbcode_enabled = false
	prompt_label.text = str(current_case.get("prompt", ""))
	explain_line.bbcode_enabled = false
	explain_line.text = ""

	inspect_label.bbcode_enabled = false
	inspect_label.text = "Выберите строку для проверки улики."
	scan_label.text = "СКАН: 0"

	_render_table(current_case.get("table", {}) as Dictionary)
	_render_options(current_case.get("options", []) as Array)
	_start_typewriter_sequence()
	call_deferred("_update_silent_reading_possible_flag")

func _start_typewriter_sequence() -> void:
	typewriter_timer.stop()
	_typewriter_steps.clear()
	_typewriter_step_index = -1
	_typewriter_steps.append({
		"target": briefing_label,
		"text": str(current_case.get("briefing", ""))
	})
	_typewriter_steps.append({
		"target": prompt_label,
		"text": str(current_case.get("prompt", ""))
	})
	_start_next_typewriter_step()

func _start_next_typewriter_step() -> void:
	_typewriter_step_index += 1
	if _typewriter_step_index >= _typewriter_steps.size():
		typewriter_timer.stop()
		return

	var step: Dictionary = _typewriter_steps[_typewriter_step_index]
	var target_v: Variant = step.get("target", null)
	if not (target_v is RichTextLabel):
		_start_next_typewriter_step()
		return

	_typewriter_target = target_v as RichTextLabel
	_typewriter_source = str(step.get("text", ""))
	_typewriter_cursor = 0
	_typewriter_target.bbcode_enabled = false
	_typewriter_target.text = ""

	if _typewriter_source.is_empty():
		_start_next_typewriter_step()
		return

	typewriter_timer.wait_time = TYPEWRITER_INTERVAL_SEC
	typewriter_timer.start()

func _on_typewriter_tick() -> void:
	if not is_instance_valid(_typewriter_target):
		return

	if _typewriter_cursor < _typewriter_source.length():
		_typewriter_cursor += 1
		_typewriter_target.text = _typewriter_source.substr(0, _typewriter_cursor)
		typewriter_timer.start()
	else:
		_start_next_typewriter_step()

func _render_table(table_def: Dictionary) -> void:
	data_tree.clear()
	row_item_by_id.clear()
	col_index_by_id.clear()
	row_data_by_id.clear()

	var root: TreeItem = data_tree.create_item()
	data_tree.hide_root = true
	data_tree.select_mode = Tree.SELECT_ROW

	var cols: Array = table_def.get("columns", []) as Array
	if cols.is_empty():
		data_tree.columns = 1
		data_tree.set_column_title(0, "Данные")
		data_tree.column_titles_visible = true
		return

	data_tree.columns = cols.size()
	for i in range(cols.size()):
		var col_data_v: Variant = cols[i]
		if typeof(col_data_v) != TYPE_DICTIONARY:
			continue
		var col: Dictionary = col_data_v as Dictionary
		var col_id: String = str(col.get("col_id", ""))
		col_index_by_id[col_id] = i
		data_tree.set_column_title(i, str(col.get("title", "СТОЛБЕЦ")))
	data_tree.column_titles_visible = true

	var rows: Array = table_def.get("rows", []) as Array
	for row_v in rows:
		if typeof(row_v) != TYPE_DICTIONARY:
			continue
		var row_data: Dictionary = row_v as Dictionary
		var row_id: String = str(row_data.get("row_id", ""))
		if row_id.is_empty():
			continue
		var row_item: TreeItem = data_tree.create_item(root)
		row_item.set_metadata(0, row_id)
		row_item_by_id[row_id] = row_item
		row_data_by_id[row_id] = row_data

		var cells: Dictionary = row_data.get("cells", {}) as Dictionary
		for i in range(cols.size()):
			var col_v: Variant = cols[i]
			if typeof(col_v) != TYPE_DICTIONARY:
				continue
			var col_def: Dictionary = col_v as Dictionary
			var col_id := str(col_def.get("col_id", ""))
			row_item.set_text(i, str(cells.get(col_id, "")))

func _render_options(options: Array) -> void:
	for child in options_grid.get_children():
		child.queue_free()

	for opt_v in options:
		if typeof(opt_v) != TYPE_DICTIONARY:
			continue
		var opt: Dictionary = opt_v as Dictionary
		var btn: Button = Button.new()
		btn.custom_minimum_size = Vector2(0, 56)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.text = str(opt.get("text", "Вариант"))
		btn.pressed.connect(_on_option_selected.bind(str(opt.get("id", ""))))
		options_grid.add_child(btn)

func _on_tree_item_selected() -> void:
	if trial_locked:
		return

	var item: TreeItem = data_tree.get_selected()
	if item == null:
		return
	var row_id: String = str(item.get_metadata(0))
	if row_id.is_empty() or not row_data_by_id.has(row_id):
		return

	_register_first_action()
	inspect_count += 1
	unique_rows_inspected[row_id] = true
	last_inspected_row_id = row_id
	scan_label.text = "СКАН: %d" % inspect_count
	inspect_label.text = _build_inspect_line(row_id)
	if is_instance_valid(sfx_click):
		sfx_click.play()

func _build_inspect_line(row_id: String) -> String:
	var row_data: Dictionary = row_data_by_id.get(row_id, {}) as Dictionary
	var table_def: Dictionary = current_case.get("table", {}) as Dictionary
	var cols: Array = table_def.get("columns", []) as Array
	var cells: Dictionary = row_data.get("cells", {}) as Dictionary

	var parts: Array[String] = []
	for col_v in cols:
		if typeof(col_v) != TYPE_DICTIONARY:
			continue
		var col_def: Dictionary = col_v as Dictionary
		var col_id: String = str(col_def.get("col_id", ""))
		var col_title: String = str(col_def.get("title", col_id.to_upper()))
		parts.append("%s=%s" % [col_title, str(cells.get(col_id, ""))])

	return "СТРОКА %s: %s" % [row_id, " | ".join(parts)]

func _on_option_selected(selected_id: String) -> void:
	if trial_locked:
		return

	_register_first_action()
	answered_without_inspection = inspect_count == 0
	trial_locked = true
	typewriter_timer.stop()
	briefing_label.text = str(current_case.get("briefing", ""))
	prompt_label.text = str(current_case.get("prompt", ""))

	if is_instance_valid(sfx_click):
		sfx_click.play()

	var answer_id: String = str(current_case.get("answer_id", ""))
	var selected_option: Dictionary = _find_option(selected_id)
	var is_correct: bool = selected_id == answer_id

	if is_correct:
		if sfx_relay != null:
			sfx_relay.play()
	else:
		if sfx_error != null:
			sfx_error.play()

	_set_options_locked(true)
	_apply_highlight(current_case.get("highlight", {}) as Dictionary)
	_show_explain_line(is_correct, selected_option)
	if is_instance_valid(result_stamp) and result_stamp.has_method("show_result"):
		result_stamp.call("show_result", is_correct)

	_log_trial(selected_id, answer_id, is_correct)
	_update_stability_ui()

	await get_tree().create_timer(0.9).timeout

	if GlobalMetrics.stability <= 0.0:
		_game_over()
	else:
		_load_next_case()

func _show_explain_line(is_correct: bool, selected_option: Dictionary) -> void:
	var reveal: Dictionary = current_case.get("reveal", {}) as Dictionary
	var line: String = ""
	if is_correct:
		line = str(reveal.get("on_correct", "Подтверждено."))
	else:
		var reason: String = str(selected_option.get("f_reason", "WRONG_OPTION_GENERIC"))
		var reason_map: Dictionary = reveal.get("on_wrong_by_reason", {}) as Dictionary
		line = str(reason_map.get(reason, "Проверьте выделенные улики и повторите попытку."))
	explain_line.text = line

func _apply_highlight(highlight: Dictionary) -> void:
	if highlight.is_empty():
		return

	var mode: String = str(highlight.get("mode", "")).to_upper()
	var bg: Color = Color(0.42, 0.30, 0.10, 0.55)
	var fg: Color = Color(1.0, 0.94, 0.78, 1.0)

	match mode:
		"ROWS":
			var target_rows: Array = highlight.get("target_row_ids", []) as Array
			for row_id_v in target_rows:
				var row_id: String = str(row_id_v)
				_highlight_row(row_id, bg, fg)
		"COLUMNS":
			var target_cols: Array = highlight.get("target_col_ids", []) as Array
			for col_id_v in target_cols:
				var col_id: String = str(col_id_v)
				if not col_index_by_id.has(col_id):
					continue
				var col_idx: int = int(col_index_by_id[col_id])
				for row_id_v in row_item_by_id.keys():
					var item: TreeItem = row_item_by_id[row_id_v] as TreeItem
					_highlight_cell(item, col_idx, bg, fg)
		"CELL":
			var target_cell: Dictionary = highlight.get("target_cell", {}) as Dictionary
			var row_id: String = str(target_cell.get("row_id", ""))
			var col_id: String = str(target_cell.get("col_id", ""))
			if row_item_by_id.has(row_id) and col_index_by_id.has(col_id):
				var row_item: TreeItem = row_item_by_id[row_id] as TreeItem
				var col_idx: int = int(col_index_by_id[col_id])
				_highlight_cell(row_item, col_idx, bg, fg)

func _highlight_row(row_id: String, bg: Color, fg: Color) -> void:
	if not row_item_by_id.has(row_id):
		return
	var item: TreeItem = row_item_by_id[row_id] as TreeItem
	for col_idx in range(data_tree.columns):
		_highlight_cell(item, col_idx, bg, fg)

func _highlight_cell(item: TreeItem, col_idx: int, bg: Color, fg: Color) -> void:
	if item == null:
		return
	item.set_custom_bg_color(col_idx, bg)
	item.set_custom_color(col_idx, fg)

func _log_trial(selected_id: String, answer_id: String, is_correct: bool) -> void:
	var now_ms: int = Time.get_ticks_msec()
	var elapsed_ms: int = now_ms - case_started_ts
	var first_action_ms: int = elapsed_ms
	if first_action_ts >= case_started_ts:
		first_action_ms = first_action_ts - case_started_ts
	var silent_reading_possible: bool = (not table_has_scroll and not scroll_used and first_action_ms >= 30000)
	var case_id: String = str(current_case.get("id", "DA7-A-00"))
	var selected_option: Dictionary = _find_option(selected_id)
	var f_reason: Variant = null if is_correct else selected_option.get("f_reason", "WRONG_OPTION_GENERIC")
	var payload: Dictionary = {
		"question_id": case_id,
		"case_id": case_id,
		"quest_id": "DA7",
		"quest": "data_archive",
		"stage": "A",
		"level": "A",
		"topic": str(current_case.get("topic", "DB_BASICS")),
		"interaction_type": "SINGLE_CHOICE",
		"schema_version": str(current_case.get("schema_version", "DA7.A.v1")),
		"match_key": "DA7_A|%s" % case_id,
		"is_correct": is_correct,
		"f_reason": f_reason,
		"elapsed_ms": elapsed_ms,
		"duration": float(elapsed_ms) / 1000.0,
		"timing": {
			"effective_elapsed_ms": elapsed_ms,
			"time_to_first_action_ms": first_action_ms,
			"policy_mode": "LEARNING",
			"limit_sec": 120
		},
		"answer": {
			"selected_option_id": selected_id
		},
		"expected": {
			"answer_id": answer_id
		},
		"flags": {
			"silent_reading_possible": silent_reading_possible,
			"scroll_used": scroll_used,
			"answered_without_inspection": answered_without_inspection
		},
		"anti_cheat": current_case.get("anti_cheat", {}),
		"telemetry": {
			"time_to_first_action_ms": first_action_ms,
			"scroll_used": scroll_used,
			"inspect_count": inspect_count,
			"unique_rows_inspected": unique_rows_inspected.size(),
			"last_inspected_row_id": last_inspected_row_id
		}
	}
	GlobalMetrics.register_trial(payload)

func _find_option(selected_id: String) -> Dictionary:
	var options: Array = current_case.get("options", []) as Array
	for opt_v in options:
		if typeof(opt_v) != TYPE_DICTIONARY:
			continue
		var opt: Dictionary = opt_v as Dictionary
		if str(opt.get("id", "")) == selected_id:
			return opt
	return {}

func _register_first_action() -> void:
	if first_action_ts < 0:
		first_action_ts = Time.get_ticks_msec()

func _update_silent_reading_possible_flag() -> void:
	table_has_scroll = _tree_has_vertical_scroll(data_tree)

func _tree_has_vertical_scroll(tree: Tree) -> bool:
	if not is_instance_valid(tree):
		return false
	var stack: Array = [tree]
	while not stack.is_empty():
		var node: Node = stack.pop_back() as Node
		if node is VScrollBar:
			var bar: VScrollBar = node as VScrollBar
			return bar.max_value > 0.0 and bar.page < bar.max_value
		for child in node.get_children():
			stack.append(child)
	return false

func _on_scroll_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP or mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			scroll_used = true
	elif event is InputEventScreenDrag:
		scroll_used = true

func _set_options_locked(locked: bool) -> void:
	for child in options_grid.get_children():
		if child is Button:
			(child as Button).disabled = locked

func _finish_session() -> void:
	trial_locked = true
	typewriter_timer.stop()
	title_label.text = "СЕССИЯ ЗАВЕРШЕНА [A]"
	prompt_label.bbcode_enabled = true
	prompt_label.text = "[b]Тренировка архива завершена.[/b]"
	explain_line.text = ""
	_set_options_locked(true)
	_ensure_exit_button()

func _game_over() -> void:
	trial_locked = true
	typewriter_timer.stop()
	title_label.text = "МИССИЯ ПРОВАЛЕНА [A]"
	prompt_label.bbcode_enabled = true
	prompt_label.text = "[b]Стабильность упала до нуля.[/b]"
	explain_line.text = ""
	_set_options_locked(true)
	_ensure_exit_button()

func _ensure_exit_button() -> void:
	if exit_btn != null and is_instance_valid(exit_btn):
		return
	exit_btn = Button.new()
	exit_btn.text = "ВЫХОД"
	exit_btn.custom_minimum_size = Vector2(140, 48)
	exit_btn.pressed.connect(func() -> void:
		get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")
	)
	$SafeArea/RootLayout/Footer.add_child(exit_btn)

func _show_fatal(text: String) -> void:
	prompt_label.bbcode_enabled = false
	prompt_label.text = text
	trial_locked = true

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_stability_changed(_new_val: float, _delta: float) -> void:
	_update_stability_ui()

func _update_stability_ui() -> void:
	if is_instance_valid(stability_bar):
		stability_bar.value = GlobalMetrics.stability
	if is_instance_valid(stability_label):
		stability_label.text = "СТАБИЛЬНОСТЬ: %d%%" % int(GlobalMetrics.stability)

func _on_viewport_size_changed() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var is_mobile: bool = viewport_size.x < BREAKPOINT_PX
	desktop_layout.split_offset = int(viewport_size.x * 0.48)
	options_grid.columns = 1 if is_mobile else 2

	if is_mobile:
		if table_section.get_parent() != mobile_layout:
			table_section.reparent(mobile_layout)
		if task_section.get_parent() != mobile_layout:
			task_section.reparent(mobile_layout)
		mobile_layout.move_child(table_section, 0)
		mobile_layout.move_child(task_section, 1)
		mobile_layout.visible = true
		desktop_layout.visible = false
	else:
		if table_section.get_parent() != desktop_layout:
			table_section.reparent(desktop_layout)
		if task_section.get_parent() != desktop_layout:
			task_section.reparent(desktop_layout)
		desktop_layout.move_child(table_section, 0)
		desktop_layout.move_child(task_section, 1)
		desktop_layout.visible = true
		mobile_layout.visible = false
</file>

<file path="scenes/case_07/da7_data_archive_a.tscn">
[gd_scene load_steps=8 format=3 uid="uid://da7archive001"]

[ext_resource type="Script" path="res://scripts/case_07/da7_data_archive_a.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="AudioStream" path="res://audio/error.wav" id="3_error"]
[ext_resource type="AudioStream" path="res://audio/relay.wav" id="4_relay"]
[ext_resource type="AudioStream" path="res://audio/click.wav" id="5_click"]
[ext_resource type="PackedScene" path="res://scenes/ui/ResultStamp.tscn" id="6_stamp"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="7_noir_overlay"]

[node name="DA7_DataArchiveQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="BG" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("7_noir_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 0.0
offset_top = 0.0
offset_right = 0.0
offset_bottom = 0.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 10

[node name="BackRow" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/RootLayout/BackRow"]
custom_minimum_size = Vector2(120, 48)
layout_mode = 2
text = "НАЗАД"

[node name="Header" type="PanelContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_vertical = 0
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="SafeArea/RootLayout/Header"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 5

[node name="Title" type="RichTextLabel" parent="SafeArea/RootLayout/Header/Margin"]
layout_mode = 2
text = "ДЕЛО #7: СЕКРЕТНЫЙ АРХИВ"
fit_content = true
scroll_active = false
autowrap_mode = 0

[node name="Body" type="MarginContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 6
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 6

[node name="DesktopLayout" type="HSplitContainer" parent="SafeArea/RootLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 400

[node name="TableSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="TableTitle" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection"]
layout_mode = 2
text = "РЕЖИМ ДАННЫХ // ТОЛЬКО ЧТЕНИЕ"

[node name="DataTree" type="Tree" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection"]
layout_mode = 2
size_flags_vertical = 3
columns = 3
hide_root = true
select_mode = 1

[node name="InspectPanel" type="PanelContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection"]
custom_minimum_size = Vector2(0, 108)
layout_mode = 2

[node name="InspectMargin" type="MarginContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="InspectVBox" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="InspectLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox"]
custom_minimum_size = Vector2(0, 52)
layout_mode = 2
fit_content = false
scroll_active = false
autowrap_mode = 2
text = "Выберите строку для проверки улики."

[node name="ScanLabel" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TableSection/InspectPanel/InspectMargin/InspectVBox"]
layout_mode = 2
text = "СКАН: 0"

[node name="TaskSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="DossierPanel" type="PanelContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
layout_mode = 2

[node name="DossierMargin" type="MarginContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="DossierVBox" type="VBoxContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="CaseTitleLabel" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "ФАЙЛ: ACCESS_LOG_07"

[node name="BriefingLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
fit_content = false
scroll_active = false
autowrap_mode = 2
text = "Брифинг..."

[node name="ObjectiveLabel" type="Label" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection/DossierPanel/DossierMargin/DossierVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "ЦЕЛЬ"

[node name="PromptLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
custom_minimum_size = Vector2(0, 84)
layout_mode = 2
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "Загрузка параметров дела..."
fit_content = true

[node name="OptionsGrid" type="GridContainer" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/h_separation = 10
theme_override_constants/v_separation = 10
columns = 2

[node name="ExplainLine" type="RichTextLabel" parent="SafeArea/RootLayout/Body/DesktopLayout/TaskSection"]
custom_minimum_size = Vector2(0, 48)
layout_mode = 2
fit_content = false
scroll_active = false
autowrap_mode = 2
text = ""

[node name="MobileLayout" type="VBoxContainer" parent="SafeArea/RootLayout/Body"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Footer" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 20

[node name="StabilityLabel" type="Label" parent="SafeArea/RootLayout/Footer"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/RootLayout/Footer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 4
step = 1.0
value = 100.0

[node name="ResultStamp" parent="." instance=ExtResource("6_stamp")]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="Runtime" type="Node" parent="."]

[node name="Audio" type="Node" parent="Runtime"]

[node name="SfxClick" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("5_click")

[node name="SfxError" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("3_error")

[node name="SfxRelay" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("4_relay")

[node name="TypewriterTimer" type="Timer" parent="Runtime"]
one_shot = true
wait_time = 0.03

[node name="TelemetryTimer" type="Timer" parent="Runtime"]
</file>

<file path="scenes/case_07/da7_data_archive_b.tscn">
[gd_scene load_steps=7 format=3 uid="uid://da7archive002"]

[ext_resource type="Script" path="res://scripts/case_07/da7_data_archive_b.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_noir_detective.tres" id="2_theme"]
[ext_resource type="AudioStream" path="res://audio/error.wav" id="3_error"]
[ext_resource type="AudioStream" path="res://audio/relay.wav" id="4_relay"]
[ext_resource type="Script" path="res://scripts/ui/ConnectorOverlay.gd" id="5_connector"]
[ext_resource type="PackedScene" path="res://ui/overlays/NoirOverlay.tscn" id="6_noir_overlay"]

[node name="DA7_DataArchiveQuestB" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="BG" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="NoirOverlay" parent="." instance=ExtResource("6_noir_overlay")]

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootLayout" type="VBoxContainer" parent="SafeArea"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 0.0
offset_top = 0.0
offset_right = 0.0
offset_bottom = 0.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 10

[node name="BackRow" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2

[node name="BtnBack" type="Button" parent="SafeArea/RootLayout/BackRow"]
custom_minimum_size = Vector2(120, 48)
layout_mode = 2
text = "НАЗАД"

[node name="Header" type="PanelContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_vertical = 0
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="SafeArea/RootLayout/Header"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 5

[node name="Title" type="RichTextLabel" parent="SafeArea/RootLayout/Header/Margin"]
layout_mode = 2
text = "ДЕЛО #7: СЕКРЕТНЫЙ АРХИВ [УРОВЕНЬ B]"
fit_content = true
scroll_active = false
autowrap_mode = 0

[node name="Body" type="VBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 0

[node name="FilterModeRoot" type="HSplitContainer" parent="SafeArea/RootLayout/Body"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 400

[node name="TableSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/FilterModeRoot"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="TableTitle" type="Label" parent="SafeArea/RootLayout/Body/FilterModeRoot/TableSection"]
layout_mode = 2
text = "РЕЖИМ ФИЛЬТРА // МУЛЬТИВЫБОР"

[node name="DataTree" type="Tree" parent="SafeArea/RootLayout/Body/FilterModeRoot/TableSection"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
columns = 3
hide_root = true
select_mode = 1

[node name="TaskSection" type="VBoxContainer" parent="SafeArea/RootLayout/Body/FilterModeRoot"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PromptLabel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2
theme_override_font_sizes/normal_font_size = 20
bbcode_enabled = true
text = "Загрузка параметров дела..."
fit_content = true

[node name="ControlRow" type="HBoxContainer" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 1

[node name="BtnClear" type="Button" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow"]
custom_minimum_size = Vector2(140, 56)
layout_mode = 2
text = "ОЧИСТИТЬ [X]"

[node name="BtnSubmit" type="Button" parent="SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow"]
custom_minimum_size = Vector2(180, 56)
layout_mode = 2
text = "ОТПРАВИТЬ [ВВОД]"

[node name="RelationModeRoot" type="VBoxContainer" parent="SafeArea/RootLayout/Body"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="PromptLabelRel" type="RichTextLabel" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2
text = "Анализ связи..."
fit_content = true

[node name="SchemaContainer" type="HBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
alignment = 1

[node name="LeftTable" type="VBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable"]
layout_mode = 2
text = "Таблица A"
horizontal_alignment = 1

[node name="TreeL" type="Tree" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
hide_root = true

[node name="CenterConnector" type="VBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer"]
layout_mode = 2
alignment = 1

[node name="ArrowLabel" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector"]
layout_mode = 2
horizontal_alignment = 1
text = ""

[node name="ArrowLine" type="ColorRect" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector"]
custom_minimum_size = Vector2(96, 3)
layout_mode = 2
color = Color(0.88, 0.64, 0.16, 1)

[node name="HintLabel" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector"]
layout_mode = 2
theme_override_colors/font_color = Color(0.6, 0.6, 0.6, 1)
text = "FK ссылка"

[node name="RightTable" type="VBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable"]
layout_mode = 2
text = "Таблица B"
horizontal_alignment = 1

[node name="TreeR" type="Tree" parent="SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
hide_root = true

[node name="OptionsRow" type="HBoxContainer" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 1

[node name="ConnectorOverlay" type="Control" parent="SafeArea/RootLayout/Body/RelationModeRoot"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("5_connector")

[node name="Footer" type="HBoxContainer" parent="SafeArea/RootLayout"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 20

[node name="StabilityLabel" type="Label" parent="SafeArea/RootLayout/Footer"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "СТАБИЛЬНОСТЬ: 100%"

[node name="StabilityBar" type="ProgressBar" parent="SafeArea/RootLayout/Footer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 4
step = 1.0
value = 100.0

[node name="Runtime" type="Node" parent="."]

[node name="Audio" type="Node" parent="Runtime"]

[node name="SfxClick" type="AudioStreamPlayer" parent="Runtime/Audio"]

[node name="SfxError" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("3_error")

[node name="SfxRelay" type="AudioStreamPlayer" parent="Runtime/Audio"]
stream = ExtResource("4_relay")

[node name="TypewriterTimer" type="Timer" parent="Runtime"]
wait_time = 0.06

[node name="TelemetryTimer" type="Timer" parent="Runtime"]
</file>

<file path="scripts/case_07/da7_data_archive_b.gd">
extends Control

# Data & Config
const CasesHub = preload("res://scripts/case_07/da7_cases.gd")
const CasesModuleB = preload("res://scripts/case_07/da7_cases_b.gd")
const BREAKPOINT_PX = 800
const SESSION_CASE_COUNT = 6
const LAYOUT_MOBILE = "mobile"
const LAYOUT_DESKTOP = "desktop"
const TYPEWRITER_INTERVAL_SEC := 0.06
const SUBMIT_BASE_TEXT := "SUBMIT [ENTER]"

# State
var session_cases: Array = []
var current_case_index: int = 0
var current_case: Dictionary = {}
var is_trial_active: bool = false
var is_game_over: bool = false
var mode: String = "" # "FILTER" or "RELATION"

# Telemetry State
var stability_start: float = 0.0
var ui_ready_ts: int = 0
var time_to_first_action_ms: int = -1
var time_to_first_toggle_ms: int = -1
var scroll_used: bool = false
var table_has_scroll: bool = false
var clear_used: bool = false
var clear_count: int = 0
var toggle_count: int = 0
var unique_rows_toggled: Dictionary = {} # row_id -> bool
var click_timestamps: Array[float] = []
var lag_compensation_ms: float = 0.0
var current_layout_mode: String = LAYOUT_DESKTOP
var _suppress_tree_edited: bool = false
var _typewriter_active: bool = false
var _typewriter_accum: float = 0.0

# Nodes
@onready var filter_mode_root: HSplitContainer = $SafeArea/RootLayout/Body/FilterModeRoot
@onready var relation_mode_root: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot
@onready var body_container: VBoxContainer = $SafeArea/RootLayout/Body

# Filter Mode Nodes
@onready var data_tree: Tree = $SafeArea/RootLayout/Body/FilterModeRoot/TableSection/DataTree
@onready var prompt_label: RichTextLabel = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/PromptLabel
@onready var btn_submit: Button = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow/BtnSubmit
@onready var btn_clear: Button = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow/BtnClear
@onready var filter_table_section: VBoxContainer = $SafeArea/RootLayout/Body/FilterModeRoot/TableSection
@onready var filter_task_section: VBoxContainer = $SafeArea/RootLayout/Body/FilterModeRoot/TaskSection
var filter_mobile_layout: VBoxContainer

# Relation Mode Nodes
@onready var rel_prompt: RichTextLabel = $SafeArea/RootLayout/Body/RelationModeRoot/PromptLabelRel
@onready var relation_schema_container: HBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer
@onready var rel_tree_l: Tree = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable/TreeL
@onready var rel_tree_r: Tree = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable/TreeR
@onready var rel_title_l: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable/Title
@onready var rel_title_r: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable/Title
@onready var rel_link_label: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector/HintLabel
@onready var rel_arrow_label: Label = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector/ArrowLabel
@onready var rel_left_table: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/LeftTable
@onready var rel_center_connector: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/CenterConnector
@onready var rel_right_table: VBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/SchemaContainer/RightTable
@onready var rel_options_row: HBoxContainer = $SafeArea/RootLayout/Body/RelationModeRoot/OptionsRow
@onready var connector_overlay: Control = $SafeArea/RootLayout/Body/RelationModeRoot/ConnectorOverlay
var relation_mobile_schema: VBoxContainer

# Common Nodes
@onready var stability_bar: ProgressBar = get_node_or_null("SafeArea/RootLayout/Footer/StabilityBar")
@onready var stability_label: Label = get_node_or_null("SafeArea/RootLayout/Footer/StabilityLabel")
@onready var title_label: RichTextLabel = $SafeArea/RootLayout/Header/Margin/Title
@onready var btn_back: Button = $SafeArea/RootLayout/BackRow/BtnBack
@onready var sfx_error: AudioStreamPlayer = $Runtime/Audio/SfxError
@onready var sfx_relay: AudioStreamPlayer = $Runtime/Audio/SfxRelay

func _ready():
	randomize()
	_build_mobile_containers()
	# Connect Filter Buttons
	btn_submit.pressed.connect(_on_submit_pressed)
	btn_submit.pressed.connect(_register_interaction)
	btn_clear.pressed.connect(_on_clear_pressed)
	btn_clear.pressed.connect(_register_interaction)
	btn_back.pressed.connect(_on_back_pressed)

	_init_session()

	get_tree().root.size_changed.connect(_on_viewport_size_changed)
	call_deferred("_on_viewport_size_changed")

	_load_next_case()

func _process(delta):
	if is_trial_active:
		if delta > 0.25:
			lag_compensation_ms += delta * 1000.0
	if _typewriter_active:
		_typewriter_accum += delta
		while _typewriter_accum >= TYPEWRITER_INTERVAL_SEC and _typewriter_active:
			_typewriter_accum -= TYPEWRITER_INTERVAL_SEC
			var lbl: RichTextLabel = _get_active_prompt_label()
			if lbl.visible_characters < lbl.get_total_character_count():
				lbl.visible_characters += 1
			else:
				lbl.visible_characters = -1
				_typewriter_active = false

func _init_session():
	var all_cases: Array = CasesHub.get_cases("B")
	var valid_cases: Array = []
	for c_v in all_cases:
		if typeof(c_v) != TYPE_DICTIONARY:
			continue
		var c: Dictionary = c_v as Dictionary
		if CasesModuleB.validate_case_b(c):
			valid_cases.append(c)

	valid_cases.shuffle()
	session_cases = valid_cases.slice(0, min(SESSION_CASE_COUNT, valid_cases.size()))
	current_case_index = -1

	GlobalMetrics.stability = 100.0
	_update_stability_ui()

func _load_next_case():
	current_case_index += 1
	if current_case_index >= session_cases.size():
		_finish_session()
		return

	current_case = session_cases[current_case_index] as Dictionary
	is_trial_active = true

	# Reset Telemetry
	ui_ready_ts = Time.get_ticks_msec()
	time_to_first_action_ms = -1
	time_to_first_toggle_ms = -1
	scroll_used = false
	table_has_scroll = false
	clear_used = false
	clear_count = 0
	toggle_count = 0
	unique_rows_toggled.clear()
	click_timestamps.clear()
	lag_compensation_ms = 0.0
	stability_start = GlobalMetrics.stability
	_suppress_tree_edited = false

	var interaction_type: String = str(current_case.get("interaction_type", ""))
	if interaction_type == "MULTI_SELECT_ROWS":
		mode = "FILTER"
		filter_mode_root.visible = true
		relation_mode_root.visible = false
		_set_filter_input_locked(false)
		_render_filter_ui()
	elif interaction_type == "RELATIONSHIP_CHOICE":
		mode = "RELATION"
		filter_mode_root.visible = false
		relation_mode_root.visible = true
		_render_relation_ui()

	_on_viewport_size_changed()
	_start_typewriter()

# --- Render Logic ---

func _render_filter_ui():
	data_tree.clear()
	var root: TreeItem = data_tree.create_item()
	data_tree.hide_root = true

	var table_data: Dictionary = current_case.get("table", {}) as Dictionary
	var cols: Array = table_data.get("columns", []) as Array
	data_tree.columns = cols.size() + 1 # +1 for Checkbox
	data_tree.set_column_title(0, "SEL")
	for i in range(cols.size()):
		var col_def: Dictionary = cols[i]
		data_tree.set_column_title(i+1, str(col_def.get("title", "COL")))
	data_tree.column_titles_visible = true

	# Connect item_edited only once? No, signals are per object.
	# Tree signals are on the Tree.
	if not data_tree.item_edited.is_connected(_on_tree_item_edited):
		data_tree.item_edited.connect(_on_tree_item_edited)
	if not data_tree.item_selected.is_connected(_on_tree_item_selected):
		data_tree.item_selected.connect(_on_tree_item_selected)
	if not data_tree.gui_input.is_connected(_on_data_tree_gui_input):
		data_tree.gui_input.connect(_on_data_tree_gui_input)

	var rows: Array = (table_data.get("rows", []) as Array).duplicate()
	var anti_cheat: Dictionary = current_case.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_rows", false)):
		rows.shuffle()

	for row_data in rows:
		if typeof(row_data) != TYPE_DICTIONARY:
			continue
		var row_dict: Dictionary = row_data as Dictionary
		var item: TreeItem = data_tree.create_item(root)
		item.set_metadata(0, str(row_dict.get("row_id", "")))

		# Checkbox setup
		item.set_cell_mode(0, TreeItem.CELL_MODE_CHECK)
		item.set_checked(0, false)
		item.set_editable(0, true)
		item.set_text(0, "") # No text next to checkbox

		for i in range(cols.size()):
			var col_def: Dictionary = cols[i]
			var col_id: String = str(col_def.get("col_id", ""))
			var cells: Dictionary = row_dict.get("cells", {}) as Dictionary
			item.set_text(i+1, str(cells.get(col_id, "")))
			# Only column 0 is editable (checkbox)

	prompt_label.text = str(current_case.get("prompt", ""))
	prompt_label.visible_characters = 0
	_refresh_submit_enabled()
	call_deferred("_update_table_scroll_flag")

func _render_relation_ui():
	# Clear previous options
	for child in rel_options_row.get_children():
		child.queue_free()

	var schema: Dictionary = current_case.get("schema_visual", {}) as Dictionary
	var left_table: Dictionary = schema.get("left_table", {}) as Dictionary
	var right_table: Dictionary = schema.get("right_table", {}) as Dictionary
	var link: Dictionary = schema.get("link", {}) as Dictionary

	_fill_mini_tree(rel_tree_l, left_table)
	rel_title_l.text = str(left_table.get("title", "Левая"))

	_fill_mini_tree(rel_tree_r, right_table)
	rel_title_r.text = str(right_table.get("title", "Правая"))

	rel_link_label.text = str(link.get("hint_label", "FK ссылка"))
	rel_arrow_label.text = ""
	rel_prompt.text = str(current_case.get("prompt", ""))
	rel_prompt.visible_characters = 0
	_update_relation_connector()

	# Options
	var opts: Array = (current_case.get("options", []) as Array).duplicate()
	var anti_cheat: Dictionary = current_case.get("anti_cheat", {}) as Dictionary
	if bool(anti_cheat.get("shuffle_options", false)):
		opts.shuffle()

	for opt in opts:
		if typeof(opt) != TYPE_DICTIONARY:
			continue
		var opt_data: Dictionary = opt as Dictionary
		var btn: Button = Button.new()
		btn.text = str(opt_data.get("text", "ВАРИАНТ"))
		btn.name = "Btn_" + str(opt_data.get("id", ""))
		btn.custom_minimum_size = Vector2(0, 56)
		btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		btn.pressed.connect(_register_interaction)
		btn.pressed.connect(_on_relation_option_selected.bind(opt_data))
		rel_options_row.add_child(btn)

func _fill_mini_tree(tree: Tree, table_def: Dictionary):
	tree.clear()
	var root: TreeItem = tree.create_item()
	tree.hide_root = true

	var cols: Array = table_def.get("columns", []) as Array
	tree.columns = cols.size()
	for i in range(cols.size()):
		var col_def: Dictionary = cols[i]
		tree.set_column_title(i, str(col_def.get("title", "COL")))
	tree.column_titles_visible = true

	var preview_rows: Array = table_def.get("rows_preview", []) as Array
	# Limit preview? Spec says 6.
	for i in range(min(preview_rows.size(), 6)):
		if typeof(preview_rows[i]) != TYPE_DICTIONARY:
			continue
		var row_data: Dictionary = preview_rows[i] as Dictionary
		var item: TreeItem = tree.create_item(root)
		for j in range(cols.size()):
			var col_def: Dictionary = cols[j]
			var col_id: String = str(col_def.get("col_id", ""))
			var row_cells: Dictionary = row_data.get("cells", {}) as Dictionary
			item.set_text(j, str(row_cells.get(col_id, "")))

# --- Interactions ---

func _register_interaction():
	if not is_trial_active: return
	if time_to_first_action_ms < 0:
		time_to_first_action_ms = Time.get_ticks_msec() - ui_ready_ts

	var now: float = float(Time.get_ticks_msec())
	click_timestamps.append(now)
	while click_timestamps.size() > 5:
		click_timestamps.pop_front()

func _on_tree_item_edited():
	# Fired when checkbox is toggled
	if not is_trial_active:
		return
	if _suppress_tree_edited:
		return
	var edited_column: int = data_tree.get_edited_column()
	if edited_column != 0:
		return

	var item: TreeItem = data_tree.get_edited()
	if not item:
		return
	_register_interaction()

	# Detect toggle
	toggle_count += 1
	var row_id: String = str(item.get_metadata(0))
	unique_rows_toggled[row_id] = true

	if time_to_first_toggle_ms < 0:
		time_to_first_toggle_ms = Time.get_ticks_msec() - ui_ready_ts
	_refresh_submit_enabled()

func _on_tree_item_selected():
	pass

func _on_data_tree_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mouse_event: InputEventMouseButton = event
		if mouse_event.button_index == MOUSE_BUTTON_WHEEL_UP or mouse_event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			scroll_used = true
	elif event is InputEventScreenDrag:
		scroll_used = true

func _on_clear_pressed():
	if not is_trial_active:
		return
	var cleared_any: bool = false
	_suppress_tree_edited = true
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			if item.is_checked(0):
				cleared_any = true
				item.set_checked(0, false)
			item = item.get_next()
	_suppress_tree_edited = false
	if cleared_any:
		clear_used = true
		clear_count += 1
	_refresh_submit_enabled()

func _on_submit_pressed():
	if not is_trial_active:
		return
	is_trial_active = false
	_set_filter_input_locked(true)
	_stop_typewriter()

	var selected_ids: Array = []
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			if item.is_checked(0):
				selected_ids.append(str(item.get_metadata(0)))
			item = item.get_next()

	var analysis: Dictionary = _calculate_f_reason_filter(selected_ids)
	analysis["selected_row_ids"] = selected_ids
	var is_correct: bool = str(analysis.get("reason", "MIXED_ERROR")) == "NONE"
	var reason_value: Variant = null if is_correct else str(analysis.get("reason", "MIXED_ERROR"))
	_handle_result(is_correct, reason_value, analysis)

func _on_relation_option_selected(opt: Dictionary):
	if not is_trial_active:
		return
	is_trial_active = false
	_stop_typewriter()

	var selected_option_id: String = str(opt.get("id", ""))
	var answer_id: String = str(current_case.get("answer_id", ""))
	var is_correct: bool = selected_option_id == answer_id
	var reason: Variant = null
	if not is_correct:
		reason = str(opt.get("f_reason", "WRONG_RELATION"))

	# Disable buttons
	for child in rel_options_row.get_children():
		if child is Button:
			(child as Button).disabled = true

	_handle_result(is_correct, reason, {"selected_option_id": selected_option_id})

func _handle_result(is_correct: bool, reason: Variant, extra_data: Dictionary):
	if not is_correct:
		if sfx_error:
			sfx_error.play()
	else:
		if sfx_relay:
			sfx_relay.play()

	_log_trial(is_correct, reason, extra_data)
	_update_stability_ui()

	await get_tree().create_timer(1.0).timeout

	if GlobalMetrics.stability <= 0:
		_game_over()
	else:
		_load_next_case()

# --- Logic Ladder ---

func _calculate_f_reason_filter(selected: Array) -> Dictionary:
	var S: Array = selected.duplicate()
	var A: Array = current_case.get("answer_row_ids", []) as Array
	var B: Array = current_case.get("boundary_row_ids", []) as Array
	var O: Array = current_case.get("opposite_row_ids", []) as Array
	var U: Array = current_case.get("unrelated_row_ids", []) as Array
	var D: Array = current_case.get("decoy_row_ids", []) as Array
	var predicate: Dictionary = current_case.get("predicate", {}) as Dictionary
	var strict_expected: bool = bool(predicate.get("strict_expected", false))

	var missing_ids: Array = _array_diff(A, S)
	var extra_ids: Array = _array_diff(S, A)
	var boundary_selected: Array = _array_intersection(S, B)
	var opposite_selected: Array = _array_intersection(S, O)
	var decoy_selected: Array = _array_intersection(S, D)
	var unrelated_selected: Array = _array_intersection(S, U)
	var extra_outside_main: Array = _array_diff(_array_diff(_array_diff(_array_diff(S, A), B), O), D)

	var has_omission: bool = missing_ids.size() > 0
	var reason: String = "NONE"

	if S.is_empty():
		reason = "EMPTY_SELECTION"
	elif _is_subset(S, O):
		reason = "PURE_OPPOSITE"
	elif strict_expected and boundary_selected.size() > 0:
		reason = "INCLUDED_BOUNDARY"
	elif decoy_selected.size() > 0:
		reason = "OVERSELECT_DECOY"
	elif unrelated_selected.size() > 0 or extra_outside_main.size() > 0:
		reason = "FALSE_POSITIVE"
	elif has_omission:
		reason = "OMISSION"
	elif _sets_equal(S, A):
		reason = "NONE"

	return {
		"reason": reason,
		"sets": {
			"missing_ids": missing_ids,
			"extra_ids": extra_ids,
			"boundary_selected": boundary_selected,
			"opposite_selected": opposite_selected,
			"decoy_selected": decoy_selected,
			"unrelated_selected": unrelated_selected,
			"extra_outside_main": extra_outside_main
		}
	}

# --- Telemetry ---

func _log_trial(is_correct: bool, f_reason: Variant, data: Dictionary):
	var now_ms: int = Time.get_ticks_msec()
	var raw_elapsed_ms: int = now_ms - ui_ready_ts
	var effective_elapsed_ms: int = int(max(0.0, raw_elapsed_ms - lag_compensation_ms))
	var timing_policy: Dictionary = current_case.get("timing_policy", {}) as Dictionary
	var limit_sec: int = int(timing_policy.get("limit_sec", 120))
	var over_soft: bool = effective_elapsed_ms > (limit_sec * 1000)

	var burst: bool = false
	if click_timestamps.size() >= 4 and (click_timestamps[-1] - click_timestamps[0]) <= 700.0:
		burst = true

	var case_id: String = str(current_case.get("id", "DA7-B-00"))
	var schema_version: String = str(current_case.get("schema_version", "DA7.B.v1"))
	var estimated_end_stability: float = stability_start if is_correct else max(0.0, stability_start - 10.0)
	var payload: Dictionary = {
		"question_id": case_id,
		"case_id": case_id,
		"quest_id": "DA7",
		"quest": "data_archive",
		"stage": "B",
		"level": str(current_case.get("level", "B")),
		"schema_version": schema_version,
		"topic": str(current_case.get("topic", "DB_FILTERING")),
		"case_kind": str(current_case.get("case_kind", "")),
		"interaction_type": str(current_case.get("interaction_type", "")),
		"match_key": "DA7_B|%s|%s" % [case_id, mode],
		"is_correct": is_correct,
		"f_reason": f_reason,
		"elapsed_ms": effective_elapsed_ms,
		"duration": float(effective_elapsed_ms) / 1000.0,
		"timing": {
			"effective_elapsed_ms": effective_elapsed_ms,
			"time_to_first_action_ms": time_to_first_action_ms,
			"time_to_first_toggle_ms": time_to_first_toggle_ms,
			"policy_mode": str(timing_policy.get("mode", "LEARNING")),
			"limit_sec": limit_sec
		},
		"answer": {},
		"expected": {},
		"flags": {
			"silent_reading_possible": (time_to_first_action_ms >= 30000 and not scroll_used and not table_has_scroll),
			"had_scroll": scroll_used,
			"table_has_scroll": table_has_scroll
		},
		"anti_cheat": current_case.get("anti_cheat", {}),
		"layout_mode": current_layout_mode,
		"telemetry": {
			"time_to_first_action_ms": time_to_first_action_ms,
			"time_to_first_toggle_ms": time_to_first_toggle_ms,
			"time_to_submit_ms": raw_elapsed_ms,
			"raw_elapsed_ms": raw_elapsed_ms,
			"lag_compensation_ms": lag_compensation_ms,
			"effective_elapsed_ms": effective_elapsed_ms,
			"toggle_count": toggle_count,
			"unique_rows_toggled_count": unique_rows_toggled.size(),
			"clear_used": clear_used,
			"clear_count": clear_count,
			"scroll_used": scroll_used,
			"rapid_toggle_burst": burst,
			"over_soft_limit": over_soft
		},
		"stability": {
			"start": stability_start,
			"end": estimated_end_stability,
			"delta": estimated_end_stability - stability_start
		}
	}

	if mode == "FILTER":
		var sets: Dictionary = data.get("sets", {}) as Dictionary
		var selected_ids: Array = data.get("selected_row_ids", []) as Array
		payload["task"] = {"predicate": current_case.get("predicate", {})}
		payload["answer"] = {
			"selected_row_ids": selected_ids,
			"diagnostic_sets": sets,
			"missing_ids": sets.get("missing_ids", []),
			"extra_ids": sets.get("extra_ids", []),
			"boundary_selected": sets.get("boundary_selected", []),
			"opposite_selected": sets.get("opposite_selected", []),
			"decoy_selected": sets.get("decoy_selected", []),
			"unrelated_selected": sets.get("unrelated_selected", []),
			"extra_outside_main": sets.get("extra_outside_main", [])
		}
		payload["expected"] = {
			"answer_row_ids": current_case.get("answer_row_ids", []),
			"boundary_row_ids": current_case.get("boundary_row_ids", []),
			"opposite_row_ids": current_case.get("opposite_row_ids", []),
			"unrelated_row_ids": current_case.get("unrelated_row_ids", []),
			"decoy_row_ids": current_case.get("decoy_row_ids", [])
		}

	elif mode == "RELATION":
		var schema_visual: Dictionary = current_case.get("schema_visual", {}) as Dictionary
		payload["schema_visual"] = {"link": schema_visual.get("link", {})}
		payload["answer"] = {
			"selected_option_id": str(data.get("selected_option_id", ""))
		}
		payload["expected"] = {
			"answer_id": str(current_case.get("answer_id", "")),
			"expected_relation": str(current_case.get("expected_relation", ""))
		}

	GlobalMetrics.register_trial(payload)

# --- Utils ---
func _update_stability_ui():
	if is_instance_valid(stability_bar):
		stability_bar.value = GlobalMetrics.stability
	if is_instance_valid(stability_label):
		stability_label.text = "СТАБИЛЬНОСТЬ: %d%%" % int(GlobalMetrics.stability)

func _start_typewriter():
	var lbl: RichTextLabel = _get_active_prompt_label()
	lbl.visible_characters = 0
	_typewriter_accum = 0.0
	_typewriter_active = true

func _stop_typewriter() -> void:
	_typewriter_active = false
	_typewriter_accum = 0.0
	var lbl: RichTextLabel = _get_active_prompt_label()
	lbl.visible_characters = -1

func _get_active_prompt_label() -> RichTextLabel:
	return prompt_label if mode == "FILTER" else rel_prompt

func _on_viewport_size_changed():
	var win_size: Vector2 = get_viewport_rect().size
	var is_mobile: bool = win_size.x < BREAKPOINT_PX
	current_layout_mode = LAYOUT_MOBILE if is_mobile else LAYOUT_DESKTOP
	filter_mode_root.split_offset = int(win_size.x * 0.48)
	filter_mode_root.dragger_visibility = SplitContainer.DRAGGER_HIDDEN if is_mobile else SplitContainer.DRAGGER_VISIBLE
	_apply_filter_layout_mode(is_mobile)
	_apply_relation_layout_mode(is_mobile)
	if mode == "FILTER":
		call_deferred("_update_table_scroll_flag")

func _finish_session():
	is_game_over = true
	title_label.text = "СЕССИЯ ЗАВЕРШЕНА [B]"
	prompt_label.text = "Архивы защищены."
	rel_prompt.text = "Архивы защищены."

	# Remove controls
	if mode == "FILTER":
		$SafeArea/RootLayout/Body/FilterModeRoot/TaskSection/ControlRow.queue_free()
	else:
		rel_options_row.queue_free()

	var btn_exit: Button = Button.new()
	btn_exit.text = "ВЫХОД"
	btn_exit.pressed.connect(func(): get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn"))

	# Add exit button somewhere visible
	$SafeArea/RootLayout/Footer.add_child(btn_exit)

func _game_over():
	is_game_over = true
	title_label.text = "МИССИЯ ПРОВАЛЕНА"
	var btn_exit: Button = Button.new()
	btn_exit.text = "ВЫХОД"
	btn_exit.pressed.connect(func(): get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn"))
	$SafeArea/RootLayout/Footer.add_child(btn_exit)

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _build_mobile_containers() -> void:
	filter_mobile_layout = VBoxContainer.new()
	filter_mobile_layout.name = "FilterMobileLayout"
	filter_mobile_layout.visible = false
	filter_mobile_layout.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	filter_mobile_layout.size_flags_vertical = Control.SIZE_EXPAND_FILL
	filter_mobile_layout.set("theme_override_constants/separation", 10)
	body_container.add_child(filter_mobile_layout)

	relation_mobile_schema = VBoxContainer.new()
	relation_mobile_schema.name = "RelationMobileSchema"
	relation_mobile_schema.visible = false
	relation_mobile_schema.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	relation_mobile_schema.size_flags_vertical = Control.SIZE_EXPAND_FILL
	relation_mobile_schema.set("theme_override_constants/separation", 8)
	relation_mode_root.add_child(relation_mobile_schema)
	relation_mode_root.move_child(relation_mobile_schema, 1)

func _apply_filter_layout_mode(is_mobile: bool) -> void:
	if is_mobile:
		if filter_table_section.get_parent() != filter_mobile_layout:
			filter_table_section.reparent(filter_mobile_layout)
		if filter_task_section.get_parent() != filter_mobile_layout:
			filter_task_section.reparent(filter_mobile_layout)
		filter_mobile_layout.move_child(filter_table_section, 0)
		filter_mobile_layout.move_child(filter_task_section, 1)
		filter_mode_root.visible = false
		filter_mobile_layout.visible = (mode == "FILTER")
	else:
		if filter_table_section.get_parent() != filter_mode_root:
			filter_table_section.reparent(filter_mode_root)
		if filter_task_section.get_parent() != filter_mode_root:
			filter_task_section.reparent(filter_mode_root)
		filter_mode_root.move_child(filter_table_section, 0)
		filter_mode_root.move_child(filter_task_section, 1)
		filter_mode_root.visible = (mode == "FILTER")
		filter_mobile_layout.visible = false

func _apply_relation_layout_mode(is_mobile: bool) -> void:
	if is_mobile:
		if rel_left_table.get_parent() != relation_mobile_schema:
			rel_left_table.reparent(relation_mobile_schema)
		if rel_center_connector.get_parent() != relation_mobile_schema:
			rel_center_connector.reparent(relation_mobile_schema)
		if rel_right_table.get_parent() != relation_mobile_schema:
			rel_right_table.reparent(relation_mobile_schema)
		relation_mobile_schema.move_child(rel_left_table, 0)
		relation_mobile_schema.move_child(rel_center_connector, 1)
		relation_mobile_schema.move_child(rel_right_table, 2)
		relation_schema_container.visible = false
		relation_mobile_schema.visible = (mode == "RELATION")
	else:
		if rel_left_table.get_parent() != relation_schema_container:
			rel_left_table.reparent(relation_schema_container)
		if rel_center_connector.get_parent() != relation_schema_container:
			rel_center_connector.reparent(relation_schema_container)
		if rel_right_table.get_parent() != relation_schema_container:
			rel_right_table.reparent(relation_schema_container)
		relation_schema_container.move_child(rel_left_table, 0)
		relation_schema_container.move_child(rel_center_connector, 1)
		relation_schema_container.move_child(rel_right_table, 2)
		relation_schema_container.visible = (mode == "RELATION")
		relation_mobile_schema.visible = false
	_update_relation_connector()

func _update_relation_connector() -> void:
	if not is_instance_valid(connector_overlay):
		return
	if mode != "RELATION":
		connector_overlay.visible = false
		return
	connector_overlay.visible = true
	var orientation: String = "vertical" if current_layout_mode == LAYOUT_MOBILE else "horizontal"
	var schema_visual: Dictionary = current_case.get("schema_visual", {}) as Dictionary
	var links_config: Array = schema_visual.get("links", []) as Array
	if links_config.size() > 0 and connector_overlay.has_method("set_links"):
		var overlay_links: Array = []
		for _link in links_config:
			overlay_links.append({"from": rel_left_table, "to": rel_right_table})
		connector_overlay.call_deferred("set_links", overlay_links, relation_mode_root, "edge", orientation)
	elif connector_overlay.has_method("set_endpoints"):
		if connector_overlay.has_method("set_anchor_mode"):
			connector_overlay.call("set_anchor_mode", "edge", orientation)
		connector_overlay.call_deferred("set_endpoints", rel_left_table, rel_right_table, relation_mode_root)

func _set_filter_input_locked(locked: bool) -> void:
	if locked:
		btn_submit.disabled = true
	else:
		_refresh_submit_enabled()
	btn_clear.disabled = locked
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			item.set_editable(0, not locked)
			item = item.get_next()

func _refresh_submit_enabled() -> void:
	if mode != "FILTER" or not is_trial_active:
		btn_submit.disabled = true
		btn_submit.text = SUBMIT_BASE_TEXT
		return
	var selected_count: int = _selected_count()
	btn_submit.disabled = selected_count == 0
	btn_submit.text = "%s (%d)" % [SUBMIT_BASE_TEXT, selected_count]

func _selected_count() -> int:
	var count: int = 0
	var root: TreeItem = data_tree.get_root()
	if root:
		var item: TreeItem = root.get_first_child()
		while item:
			if item.is_checked(0):
				count += 1
			item = item.get_next()
	return count

func _update_table_scroll_flag() -> void:
	table_has_scroll = _tree_has_vertical_scroll(data_tree)

func _tree_has_vertical_scroll(tree: Tree) -> bool:
	if not is_instance_valid(tree):
		return false
	var stack: Array = [tree]
	while not stack.is_empty():
		var node: Node = stack.pop_back() as Node
		if node is VScrollBar:
			var bar: VScrollBar = node as VScrollBar
			return bar.max_value > 0.0 and bar.page < bar.max_value
		for child in node.get_children():
			stack.append(child)
	return false

func _array_intersection(arr1: Array, arr2: Array) -> Array:
	var lookup: Dictionary = {}
	for x in arr2:
		lookup[x] = true
	var out: Array = []
	for x in arr1:
		if lookup.has(x):
			out.append(x)
	return out

func _array_diff(arr1: Array, arr2: Array) -> Array:
	var lookup: Dictionary = {}
	for x in arr2:
		lookup[x] = true
	var out: Array = []
	for x in arr1:
		if not lookup.has(x):
			out.append(x)
	return out

func _is_subset(subset_arr: Array, set_arr: Array) -> bool:
	var lookup: Dictionary = {}
	for x in set_arr:
		lookup[x] = true
	for x in subset_arr:
		if not lookup.has(x):
			return false
	return true

func _sets_equal(arr1: Array, arr2: Array) -> bool:
	if arr1.size() != arr2.size():
		return false
	return _is_subset(arr1, arr2) and _is_subset(arr2, arr1)
</file>

<file path="scripts/GlobalMetrics.gd">
extends Node

# LogicEngine v6.2 Specification

signal stability_changed(new_value, change)
signal shield_triggered(shield_name, penalty)
signal hint_unlocked(level, text)
signal game_over

# Core Resources
var _stability: float = 100.0
var stability: float:
	get:
		return _stability
	set(value):
		_stability = clamp(value, 0.0, 100.0)
		if _stability <= 0.0:
			game_over.emit()
var current_level_index: int = 0
var current_mode: String = "DEC"
var current_target_value: int = 0

# Analysis History
var session_history: Array = []

func register_trial(data: Dictionary):
	session_history.append(data)

	var match_key = data.get("match_key", "UNKNOWN")
	var is_correct = data.get("is_correct", false)

	var duration = data.get("duration", data.get("elapsed_ms", 0.0) / 1000.0)
	print("MATCH: ", match_key, " | Correct: ", is_correct, " | Time: ", duration)

	var stability_delta = data.get("stability_delta", null)

	if stability_delta != null:
		stability = max(0.0, stability + float(stability_delta))
		emit_signal("stability_changed", stability, float(stability_delta))
	else:
		var is_fit = data.get("is_fit", null)
		var penalty_condition = false

		if is_fit != null:
			penalty_condition = (is_fit == false)
		else:

			penalty_condition = (is_correct == false)

		if penalty_condition:
			stability = max(0.0, stability - 10.0)
			emit_signal("stability_changed", stability, -10.0)

const MATRIX_SIZE := 6
const MATRIX_WEIGHTS := [32, 16, 8, 4, 2, 1]
var matrix_quest: Dictionary = {}
var matrix_target: Array = []
var matrix_row_constraints: Array = []
var matrix_col_constraints: Array = []
var matrix_current: Array = []
var matrix_changed_cells: Dictionary = {}
var _solver_row_constraints: Array = []
var _solver_col_targets: Array = []
var _solver_col_parity: Array = []
var _solver_visibility: Array = []
var _solver_col_sums: Array = []
var _solver_solutions: int = 0

enum Operator { ADD, SUB, SHIFT_L }
var current_reg_a: int = 0
var current_reg_b: int = 0
var current_operator: Operator = Operator.ADD

# Anti-Spam / Shields
var check_timestamps: Array[float] = []
var last_checked_bits: Array = [] # History of bit arrays
var blocked_until: float = 0.0

# Level Configuration (Complexity A)
# 15 Levels: 1-5 DEC, 6-10 OCT, 11-15 HEX
const MAX_LEVELS = 30

func _ready():
	randomize()
	reset_engine()

func reset_engine():
	stability = 100.0
	current_level_index = 0
	current_target_value = 0
	current_reg_a = 0
	current_reg_b = 0
	current_operator = Operator.ADD
	check_timestamps.clear()
	last_checked_bits.clear()
	blocked_until = 0.0
	matrix_quest.clear()
	matrix_target.clear()
	matrix_row_constraints.clear()
	matrix_col_constraints.clear()
	matrix_current.clear()
	matrix_changed_cells.clear()

func start_level(index: int):
	current_level_index = index
	# Determine mode based on level index (0-based)
	if index < 5:
		current_mode = "DEC"
	elif index < 10:
		current_mode = "OCT"
	elif index < 15:
		current_mode = "HEX"
	else:
		# Complexity B uses a single system (HEX) for arithmetic focus
		current_mode = "HEX"

	# Reset shields for the new level/attempt if desired,
	# but typically stability persists or resets per level depending on design.
	# TDD says: "Stability begins with 100% on each level"
	stability = 100.0
	emit_signal("stability_changed", stability, 0)
	check_timestamps.clear()
	last_checked_bits.clear()

	if index >= 15:
		_generate_arithmetic_example()
	else:
		current_target_value = randi_range(1, 255)

# Returns (success: bool, info: Dictionary)
func check_solution(target_val: int, input_val: int) -> Dictionary:
	var current_time = Time.get_ticks_msec() / 1000.0

	if current_time < blocked_until:
		return {
			"success": false,
			"error": "SHIELD_ACTIVE",
			"message": "Щит активен. Дождитесь перезарядки.",
			"penalty": 0
		}

	# 1. Frequency Shield
	_update_frequency_log(current_time)
	if check_timestamps.size() > 4:
		blocked_until = current_time + 5.0 # Block for 5 seconds
		emit_signal("shield_triggered", "FREQUENCY", 5.0)
		return {
			"success": false,
			"error": "SHIELD_FREQ",
			"message": "Сработал частотный щит: слишком много проверок.",
			"penalty": 0
		}

	# 2. Logic Check
	var hd = _calculate_hamming_distance(target_val, input_val)

	# Lazy Search Shield Check (if HD > 2 and user is making small changes)
	# (Simplified implementation: check if input changed little from last time)
	if _check_lazy_search(input_val, hd):
		# Apply delay penalty
		blocked_until = current_time + 3.0
		emit_signal("shield_triggered", "LAZY", 3.0)
		# We still process the error but maybe with extra penalty?
		# TDD says "penalty delay". We just blocked.

	_record_input_history(input_val)

	if hd == 0:
		return {
			"success": true,
			"message": "Доступ разрешён. Ввод совпадает с целью.",
			"stability": stability
		}
	else:
		# Calculate Penalty
		var penalty = 0.0
		if hd == 1: penalty = 10.0
		elif hd == 2: penalty = 15.0
		elif hd == 3: penalty = 25.0
		elif hd == 4: penalty = 35.0
		elif hd >= 5: penalty = 50.0 # Chaos
		else: penalty = 50.0 # Fallback

		stability = max(0.0, stability - penalty)
		emit_signal("stability_changed", stability, -penalty)

		# Generate Hints
		var hints = _generate_hints(target_val, input_val, hd)

		return {
			"success": false,
			"error": "INCORRECT",
			"hamming": hd,
			"penalty": penalty,
			"hints": hints,
			"message": "Неверный ввод. Расстояние Хэмминга: %d" % hd
		}

func _calculate_hamming_distance(a: int, b: int) -> int:
	var x = a ^ b
	var dist = 0
	while x > 0:
		dist += 1
		x &= x - 1
	return dist

func _update_frequency_log(time_sec: float):
	check_timestamps.append(time_sec)
	# Remove checks older than 15 seconds
	var cutoff = time_sec - 15.0
	while check_timestamps.size() > 0 and check_timestamps[0] < cutoff:
		check_timestamps.pop_front()

func _check_lazy_search(current_input: int, current_hd: int) -> bool:
	if current_hd <= 2: return false

	var inputs = last_checked_bits.duplicate()
	inputs.append(current_input)
	# Need at least 4 inputs to analyze 3 transitions
	if inputs.size() < 4:
		return false

	var unique_changed: Dictionary = {}
	var start = inputs.size() - 4
	for i in range(start, inputs.size() - 1):
		var diff = inputs[i] ^ inputs[i + 1]
		for bit in range(8):
			if (diff & (1 << bit)) != 0:
				unique_changed[bit] = true

	return unique_changed.size() < 3

func _generate_arithmetic_example():
	# Pick an operator for Complexity B
	var op_pick = randi() % 3
	current_operator = Operator.ADD if op_pick == 0 else Operator.SUB if op_pick == 1 else Operator.SHIFT_L

	if current_operator == Operator.ADD:
		current_reg_a = randi_range(0, 255)
		current_reg_b = randi_range(0, 255 - current_reg_a)
		current_target_value = current_reg_a + current_reg_b
	elif current_operator == Operator.SUB:
		current_reg_a = randi_range(0, 255)
		current_reg_b = randi_range(0, current_reg_a)
		current_target_value = current_reg_a - current_reg_b
	else:
		# SHIFT_L by 1..3, ensure result <= 255
		current_reg_b = randi_range(1, 3)
		var max_a = 255 >> current_reg_b
		current_reg_a = randi_range(0, max_a)
		current_target_value = current_reg_a << current_reg_b

func _record_input_history(val: int):
	last_checked_bits.append(val)
	if last_checked_bits.size() > 10:
		last_checked_bits.pop_front()

func _generate_hints(target: int, input: int, hd: int) -> Dictionary:
	# Level 1: Diagnosis
	var diagnosis = "BIT_ERROR"
	if target > input: diagnosis = "VALUE_LOW"
	elif target < input: diagnosis = "VALUE_HIGH"

	# Level 2: Nibble (Zone)
	# Check lower 4 bits (0-3) vs upper 4 bits (4-7)
	var x = target ^ input
	var low_err = (x & 0x0F) != 0
	var high_err = (x & 0xF0) != 0
	var zone = "NONE"
	if low_err and high_err: zone = "BOTH_NIBBLES"
	elif low_err: zone = "LOWER_NIBBLE"
	elif high_err: zone = "UPPER_NIBBLE"

	return {
		"diagnosis": diagnosis,
		"zone": zone
	}

func get_rank_info() -> Dictionary:
	var idx = current_level_index
	if idx < 5:
		return {"name": "СТАЖЁР", "color": Color("888888")}
	if idx < 10:
		return {"name": "СИГНАЛИСТ", "color": Color("33ff33")}
	if idx < 15:
		return {"name": "КРИПТОАНАЛИТИК", "color": Color("33aaff")}
	if idx < 30:
		return {"name": "СИСТЕМНЫЙ ИНЖЕНЕР", "color": Color("ffcc00")}
	return {"name": "МАСТЕР МОНОЛИТА", "color": Color("ff33ff")}

# --- Matrix (Complexity C) ---
func start_matrix_quest():
	# Reset shields and stability for a new matrix quest
	stability = 100.0
	emit_signal("stability_changed", stability, 0)
	check_timestamps.clear()
	last_checked_bits.clear()
	blocked_until = 0.0
	_generate_matrix_quest()
	_init_matrix_current()
	_clear_matrix_changes()

func record_matrix_change(row: int, col: int):
	var key = "%d,%d" % [row, col]
	matrix_changed_cells[key] = true

func validate_matrix_logic() -> Dictionary:
	var hd_result = _calculate_matrix_hd()
	return {
		"hd": hd_result.hd,
		"row_ok": hd_result.row_ok,
		"col_ok": hd_result.col_ok
	}

func check_matrix_solution() -> Dictionary:
	var current_time = Time.get_ticks_msec() / 1000.0

	if current_time < blocked_until:
		return {
			"success": false,
			"error": "SHIELD_ACTIVE",
			"message": "Щит активен. Дождитесь перезарядки.",
			"penalty": 0
		}

	# 1. Frequency Shield
	_update_frequency_log(current_time)
	if check_timestamps.size() > 4:
		blocked_until = current_time + 5.0
		emit_signal("shield_triggered", "FREQUENCY", 5.0)
		_clear_matrix_changes()
		return {
			"success": false,
			"error": "SHIELD_FREQ",
			"message": "Сработал частотный щит: слишком много проверок.",
			"penalty": 0
		}

	# 2. Matrix HD
	var hd_result = _calculate_matrix_hd()
	var hd = hd_result.hd

	# Lazy Search Shield (matrix)
	if _check_lazy_search_matrix(hd):
		blocked_until = current_time + 5.0
		emit_signal("shield_triggered", "LAZY", 5.0)
		_clear_matrix_changes()
		return {
			"success": false,
			"error": "SHIELD_LAZY",
			"message": "Блокировка: недостаточно проверки вариантов.",
			"penalty": 0
		}

	_clear_matrix_changes()

	if hd == 0:
		return {
			"success": true,
			"message": "Доступ разрешён. Ввод совпадает с целью.",
			"stability": stability
		}

	var penalty = 0.0
	if hd == 1:
		penalty = 15.0
	elif hd == 2:
		penalty = 25.0
	else:
		penalty = 40.0

	stability = max(0.0, stability - penalty)
	emit_signal("stability_changed", stability, -penalty)

	return {
		"success": false,
		"error": "INCORRECT",
		"hamming": hd,
		"penalty": penalty,
		"message": "Неверный ввод. Расстояние Хэмминга: %d" % hd
	}

func _check_lazy_search_matrix(hd: int) -> bool:
	if hd <= 2:
		return false
	return matrix_changed_cells.size() < 3

func _calculate_matrix_hd() -> Dictionary:
	var row_ok: Array = []
	var col_ok: Array = []
	var hd = 0

	# Row checks (visible only)
	for r in range(MATRIX_SIZE):
		var row_constraint = matrix_row_constraints[r]
		var visible = row_constraint.is_hex_visible
		var row_has_unset = false
		var row_value = 0
		for c in range(MATRIX_SIZE):
			var cell = matrix_current[r][c]
			if cell == -1:
				row_has_unset = true
			elif cell == 1:
				row_value += MATRIX_WEIGHTS[c]
		var is_ok = false
		if visible and not row_has_unset and row_value == row_constraint.hex_value:
			is_ok = true
		row_ok.append(is_ok)
		if visible:
			if row_has_unset or row_value != row_constraint.hex_value:
				hd += 1

	# Column checks (always visible)
	for c in range(MATRIX_SIZE):
		var col_constraint = matrix_col_constraints[c]
		var col_has_unset = false
		var ones = 0
		for r in range(MATRIX_SIZE):
			var cell = matrix_current[r][c]
			if cell == -1:
				col_has_unset = true
			elif cell == 1:
				ones += 1
		var parity = ones % 2
		var is_ok = (not col_has_unset
			and ones == col_constraint.ones_count
			and parity == col_constraint.parity)
		col_ok.append(is_ok)
		if col_has_unset or ones != col_constraint.ones_count:
			hd += 1

	return {
		"hd": hd,
		"row_ok": row_ok,
		"col_ok": col_ok
	}

func _init_matrix_current():
	matrix_current.clear()
	for r in range(MATRIX_SIZE):
		var row: Array = []
		for _c in range(MATRIX_SIZE):
			row.append(-1)
		matrix_current.append(row)

func _clear_matrix_changes():
	matrix_changed_cells.clear()

func _generate_matrix_quest():
	var attempts = 0
	while attempts < 200:
		attempts += 1
		var target = _random_matrix()
		var row_constraints = _build_row_constraints(target)
		var col_constraints = _build_col_constraints(target)

		var visibility = _pick_row_visibility(row_constraints, col_constraints)
		if visibility.size() == MATRIX_SIZE:
			for r in range(MATRIX_SIZE):
				row_constraints[r].is_hex_visible = visibility[r]

			matrix_target = target
			matrix_row_constraints = row_constraints
			matrix_col_constraints = col_constraints
			matrix_quest = {
				"target_matrix": matrix_target,
				"row_constraints": matrix_row_constraints,
				"col_constraints": matrix_col_constraints
			}
			return

	# Fallback: all rows visible
	matrix_target = _random_matrix()
	matrix_row_constraints = _build_row_constraints(matrix_target)
	matrix_col_constraints = _build_col_constraints(matrix_target)
	matrix_quest = {
		"target_matrix": matrix_target,
		"row_constraints": matrix_row_constraints,
		"col_constraints": matrix_col_constraints
	}

func _random_matrix() -> Array:
	var matrix: Array = []
	for _r in range(MATRIX_SIZE):
		var row: Array = []
		for _c in range(MATRIX_SIZE):
			row.append(randi() % 2)
		matrix.append(row)
	return matrix

func _build_row_constraints(target: Array) -> Array:
	var constraints: Array = []
	for r in range(MATRIX_SIZE):
		var row_value = _row_value_from_bits(target[r])
		constraints.append({
			"hex_value": row_value,
			"is_hex_visible": true
		})
	return constraints

func _build_col_constraints(target: Array) -> Array:
	var constraints: Array = []
	for c in range(MATRIX_SIZE):
		var ones = 0
		for r in range(MATRIX_SIZE):
			ones += target[r][c]
		var parity = ones % 2
		constraints.append({
			"ones_count": ones,
			"parity": parity
		})
	return constraints

func _row_value_from_bits(bits: Array) -> int:
	var sum = 0
	for c in range(MATRIX_SIZE):
		if bits[c] == 1:
			sum += MATRIX_WEIGHTS[c]
	return sum

func _row_bits_from_value(value: int) -> Array:
	var bits: Array = []
	for c in range(MATRIX_SIZE):
		bits.append(1 if (value & MATRIX_WEIGHTS[c]) != 0 else 0)
	return bits

func _pick_row_visibility(row_constraints: Array, col_constraints: Array) -> Array:
	var rows: Array = []
	for i in range(MATRIX_SIZE):
		rows.append(i)
	for hide_count in [2, 1]:
		var combos = _combinations(rows, hide_count)
		combos.shuffle()
		for combo in combos:
			var visibility: Array = []
			for r in rows:
				visibility.append(not combo.has(r))
			if _count_matrix_solutions(row_constraints, col_constraints, visibility) == 1:
				return visibility
	return []

func _count_matrix_solutions(row_constraints: Array, col_constraints: Array, visibility: Array) -> int:
	_solver_row_constraints = row_constraints
	_solver_col_targets = []
	_solver_col_parity = []
	for c in range(MATRIX_SIZE):
		_solver_col_targets.append(col_constraints[c].ones_count)
		_solver_col_parity.append(col_constraints[c].parity)
	_solver_visibility = visibility
	_solver_col_sums = []
	for _i in range(MATRIX_SIZE):
		_solver_col_sums.append(0)
	_solver_solutions = 0

	_solver_backtrack(0)
	return _solver_solutions

func _solver_row_fits(bits: Array, row_idx: int) -> bool:
	var remaining = MATRIX_SIZE - (row_idx + 1)
	for c in range(MATRIX_SIZE):
		var new_sum = _solver_col_sums[c] + bits[c]
		if new_sum > _solver_col_targets[c]:
			return false
		if new_sum + remaining < _solver_col_targets[c]:
			return false
	return true

func _solver_backtrack(row_idx: int) -> void:
	if _solver_solutions > 1:
		return
	if row_idx >= MATRIX_SIZE:
		for c in range(MATRIX_SIZE):
			if _solver_col_sums[c] != _solver_col_targets[c]:
				return
			if (_solver_col_sums[c] % 2) != _solver_col_parity[c]:
				return
		_solver_solutions += 1
		return

	if _solver_visibility[row_idx]:
		var bits = _row_bits_from_value(_solver_row_constraints[row_idx].hex_value)
		if _solver_row_fits(bits, row_idx):
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] += bits[c]
			_solver_backtrack(row_idx + 1)
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] -= bits[c]
	else:
		for mask in range(1 << MATRIX_SIZE):
			var bits: Array = []
			for c in range(MATRIX_SIZE):
				var bit = 1 if (mask & MATRIX_WEIGHTS[c]) != 0 else 0
				bits.append(bit)
			if not _solver_row_fits(bits, row_idx):
				continue
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] += bits[c]
			_solver_backtrack(row_idx + 1)
			for c in range(MATRIX_SIZE):
				_solver_col_sums[c] -= bits[c]

func _combinations(items: Array, count: int) -> Array:
	var results: Array = []
	if count == 1:
		for item in items:
			results.append([item])
		return results
	if count == 2:
		for i in range(items.size()):
			for j in range(i + 1, items.size()):
				results.append([items[i], items[j]])
		return results
	return results
</file>

<file path="scenes/RadioQuestA.gd">
extends Control

const ANCHOR_POOL: Array[int] = [100, 500, 1000]
const POWERS_OF_2: Array[int] = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096]
const TRAPS: Array[int] = [10, 50, 2000]
const SAMPLE_SLOTS: int = 7
const ANALYZE_REVEAL_SECONDS: float = 1.8
const PHONE_LANDSCAPE_MAX_HEIGHT: float = 520.0

const COLOR_IDLE: Color = Color(0.18, 0.18, 0.18, 1.0)
const COLOR_GOOD: Color = Color(0.20, 0.90, 0.30, 1.0)
const COLOR_WARN: Color = Color(0.95, 0.75, 0.20, 1.0)
const COLOR_BAD: Color = Color(0.95, 0.25, 0.25, 1.0)

const TXT_TITLE: String = "\u0420\u0410\u0414\u0418\u041e\u041f\u0415\u0420\u0415\u0425\u0412\u0410\u0422 | A"
const TXT_BACK: String = "\u041d\u0410\u0417\u0410\u0414"
const TXT_MISSION: String = "\u0417\u0410\u0414\u0410\u041d\u0418\u0415"
const TXT_RULE: String = "\u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 i, \u0433\u0434\u0435 2^i >= N"
const TXT_DECODER: String = "\u0414\u0415\u041a\u041e\u0414\u0415\u0420"
const TXT_KNOB_HINT: String = "\u041f\u043e\u0432\u0435\u0440\u043d\u0438\u0442\u0435 \u0440\u0443\u0447\u043a\u0443, \u0437\u0430\u0442\u0435\u043c \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0410\u041d\u0410\u041b\u0418\u0417\u00bb"
const TXT_BTN_HINT: String = "\u041f\u041e\u0414\u0421\u041a\u0410\u0417\u041a\u0410"
const TXT_BTN_ANALYZE: String = "\u0410\u041d\u0410\u041b\u0418\u0417"
const TXT_BTN_CAPTURE: String = "\u0417\u0410\u0425\u0412\u0410\u0422"
const TXT_BTN_NEXT: String = "\u0414\u0410\u041b\u0415\u0415"
const TXT_BTN_DETAILS_CLOSED: String = "\u041f\u041e\u0414\u0420\u041e\u0411\u041d\u0415\u0415 \u25be"
const TXT_BTN_DETAILS_OPEN: String = "\u0421\u041a\u0420\u042b\u0422\u042c \u25b4"
const TXT_DETAILS_TITLE: String = "\u041f\u041e\u042f\u0421\u041d\u0415\u041d\u0418\u0415"
const TXT_DETAILS_CLOSE: String = "\u0417\u0410\u041a\u0420\u042b\u0422\u042c"

const TXT_STATUS_PLAN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 i, \u0437\u0430\u0442\u0435\u043c \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0410\u041d\u0410\u041b\u0418\u0417\u00bb."
const TXT_STATUS_HINT: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u043e 2^i >= N \u0438 \u043c\u0438\u043d\u0438\u043c\u0443\u043c i."
const TXT_ANALYZE_UNDERFIT: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0435 \u043f\u043e\u043c\u0435\u0449\u0430\u0435\u0442\u0441\u044f. \u0423\u0432\u0435\u043b\u0438\u0447\u044c\u0442\u0435 i."
const TXT_ANALYZE_OVERKILL: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041f\u043e\u043c\u0435\u0449\u0430\u0435\u0442\u0441\u044f, \u043d\u043e \u0435\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u0440\u0430\u0441\u0445\u043e\u0434 \u0431\u0438\u0442."
const TXT_ANALYZE_OK: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435."
const TXT_ANALYZE_DONE: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0410\u043d\u0430\u043b\u0438\u0437 \u0437\u0430\u0432\u0435\u0440\u0448\u0451\u043d. \u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u00ab\u0417\u0410\u0425\u0412\u0410\u0422\u00bb."
const TXT_RESULT_BAD: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041d\u0435\u0432\u0435\u0440\u043d\u043e. \u041f\u0430\u043a\u0435\u0442 \u043d\u0435 \u043f\u043e\u043c\u0435\u0441\u0442\u0438\u043b\u0441\u044f."
const TXT_RESULT_GOOD: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u041e\u0442\u043b\u0438\u0447\u043d\u043e. \u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435."
const TXT_RESULT_WARN: String = "\u0421\u0422\u0410\u0422\u0423\u0421: \u0412\u0435\u0440\u043d\u043e, \u043d\u043e \u0441 \u043f\u0435\u0440\u0435\u0440\u0430\u0441\u0445\u043e\u0434\u043e\u043c."

@onready var safe_area: MarginContainer = $SafeArea
@onready var root_vbox: VBoxContainer = $SafeArea/RootVBox
@onready var body_split: HSplitContainer = $SafeArea/RootVBox/BodyHSplit
@onready var mission_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard
@onready var scope_card: PanelContainer = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard
@onready var right_vbox: VBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox

@onready var btn_back: Button = $SafeArea/RootVBox/Header/HeaderHBox/BtnBack
@onready var title_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/TitleLabel
@onready var meta_label: Label = $SafeArea/RootVBox/Header/HeaderHBox/MetaLabel

@onready var mission_title: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox/MissionTitle
@onready var target_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox/TargetLabel
@onready var rule_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox/RuleLabel
@onready var wave_layer: Control = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin/ScopeLayer
@onready var wave_line: Line2D = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin/ScopeLayer/WaveLine
@onready var bits_value_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow/BitsValueLabel
@onready var fit_value_label: Label = $SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow/FitValueLabel

@onready var decoder_title: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/DecoderTitle
@onready var bit_knob: Control = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/BitKnob
@onready var knob_hint: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/KnobHint
@onready var btn_hint: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnHint
@onready var btn_analyze: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnAnalyze
@onready var btn_capture: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnCapture
@onready var btn_next: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow/BtnNext
@onready var sample_strip: HBoxContainer = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip
@onready var status_label: Label = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/StatusLabel
@onready var btn_details: Button = $SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/BtnDetails
@onready var footer_label: Label = $SafeArea/RootVBox/Footer/FooterMargin/FooterLabel

@onready var dimmer: ColorRect = $Dimmer
@onready var details_sheet: PanelContainer = $DetailsSheet
@onready var details_title: Label = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsTitle
@onready var details_text: RichTextLabel = $DetailsSheet/DetailsMargin/DetailsVBox/DetailsText
@onready var btn_close_details: Button = $DetailsSheet/DetailsMargin/DetailsVBox/BtnCloseDetails

var target_n: int = 0
var target_bits: int = 0
var current_bits: int = 1
var pool_type: String = "NORMAL"

var trial_active: bool = false
var hint_used: bool = false
var forced_sampling: bool = false
var is_timed_mode: bool = false
var trial_duration: float = 30.0
var time_remaining: float = 0.0

var start_time: float = 0.0
var first_action_timestamp: float = -1.0
var prev_time_to_first_action: float = 0.0

var analyze_count: int = 0
var knob_change_count: int = 0
var direction_change_count: int = 0
var cross_target_count: int = 0
var last_diff_sign: int = 0

var current_trial_idx: int = 0
var anchor_countdown: int = 0
var sample_refs: Array[Dictionary] = []

var analysis_committed: bool = false
var analyze_reveal_until: float = 0.0
var last_analysis_fit: bool = false
var last_analysis_minimal: bool = false
var last_analysis_overkill: bool = false

var osc_phase: float = 0.0
var _ui_ready: bool = false
var _current_stability: float = 100.0

func _ready() -> void:
	randomize()
	_apply_static_texts()
	_connect_signals()
	_collect_sample_refs()
	_reset_sample_strip()
	_set_details_visible(false)
	_apply_safe_area_padding()
	_configure_layout()

	if not GlobalMetrics.stability_changed.is_connected(_on_stability_changed):
		GlobalMetrics.stability_changed.connect(_on_stability_changed)
	_on_stability_changed(GlobalMetrics.stability, 0.0)

	anchor_countdown = randi_range(7, 10)
	_start_trial()
	_ui_ready = true

func _notification(what: int) -> void:
	if what == NOTIFICATION_RESIZED and _ui_ready:
		_apply_safe_area_padding()
		_configure_layout()

func _process(delta: float) -> void:
	osc_phase += delta * 2.6

	if trial_active and is_timed_mode:
		time_remaining = maxf(0.0, time_remaining - delta)
		if time_remaining <= 0.0:
			_finish_trial(true)

	if trial_active and analysis_committed and btn_capture.disabled:
		var now_sec: float = Time.get_ticks_msec() / 1000.0
		if now_sec >= analyze_reveal_until:
			btn_capture.disabled = false
			status_label.text = TXT_ANALYZE_DONE
			status_label.add_theme_color_override("font_color", COLOR_GOOD)

	_update_header_meta()
	_update_waveform()

func _apply_static_texts() -> void:
	title_label.text = TXT_TITLE
	btn_back.text = TXT_BACK
	mission_title.text = TXT_MISSION
	rule_label.text = TXT_RULE
	decoder_title.text = TXT_DECODER
	knob_hint.text = TXT_KNOB_HINT
	btn_hint.text = TXT_BTN_HINT
	btn_analyze.text = TXT_BTN_ANALYZE
	btn_capture.text = TXT_BTN_CAPTURE
	btn_next.text = TXT_BTN_NEXT
	btn_details.text = TXT_BTN_DETAILS_CLOSED
	details_title.text = TXT_DETAILS_TITLE
	btn_close_details.text = TXT_DETAILS_CLOSE

func _connect_signals() -> void:
	btn_back.pressed.connect(_on_back_pressed)
	btn_hint.pressed.connect(_on_hint_pressed)
	btn_analyze.pressed.connect(_on_analyze_pressed)
	btn_capture.pressed.connect(_on_capture_pressed)
	btn_next.pressed.connect(_on_next_pressed)
	btn_details.pressed.connect(_on_details_pressed)
	btn_close_details.pressed.connect(_on_details_close_pressed)
	dimmer.gui_input.connect(_on_dimmer_gui_input)

	var knob_callback: Callable = Callable(self, "_on_knob_value_changed")
	if not bit_knob.is_connected("value_changed", knob_callback):
		bit_knob.connect("value_changed", knob_callback)

func _collect_sample_refs() -> void:
	sample_refs.clear()
	for child_var in sample_strip.get_children():
		var child_node: Node = child_var as Node
		var bg_node: ColorRect = child_node.get_node_or_null("BG") as ColorRect
		var mark_node: Label = child_node.get_node_or_null("AnchorMark") as Label
		if bg_node != null and mark_node != null:
			sample_refs.append({"bg": bg_node, "mark": mark_node})

func _reset_sample_strip() -> void:
	for slot_var in sample_refs:
		var slot: Dictionary = slot_var as Dictionary
		var bg: ColorRect = slot["bg"] as ColorRect
		var mark: Label = slot["mark"] as Label
		bg.color = COLOR_IDLE
		mark.visible = false
	current_trial_idx = 0

func _start_trial() -> void:
	trial_active = true
	hint_used = false
	start_time = Time.get_ticks_msec() / 1000.0
	first_action_timestamp = -1.0

	analyze_count = 0
	knob_change_count = 0
	direction_change_count = 0
	cross_target_count = 0
	last_diff_sign = 0

	analysis_committed = false
	analyze_reveal_until = 0.0
	last_analysis_fit = false
	last_analysis_minimal = false
	last_analysis_overkill = false

	btn_capture.visible = true
	btn_capture.disabled = true
	btn_analyze.disabled = false
	btn_next.visible = false
	btn_hint.disabled = false
	bit_knob.mouse_filter = Control.MOUSE_FILTER_STOP

	forced_sampling = prev_time_to_first_action > 10.0
	is_timed_mode = forced_sampling
	time_remaining = trial_duration if is_timed_mode else 0.0

	if anchor_countdown <= 0:
		target_n = ANCHOR_POOL.pick_random()
		pool_type = "ANCHOR"
		anchor_countdown = randi_range(7, 10)
	else:
		pool_type = "NORMAL"
		anchor_countdown -= 1
		var pool: Array[int] = []
		pool.append_array(POWERS_OF_2)
		pool.append_array(TRAPS)
		target_n = pool.pick_random()

	target_bits = int(ceil(log(float(target_n)) / log(2.0)))
	target_label.text = "N = %d" % target_n

	current_bits = 1
	bit_knob.set("value", 1)
	_apply_user_bits(1, false)

	status_label.text = TXT_STATUS_PLAN
	status_label.add_theme_color_override("font_color", Color(0.85, 0.85, 0.85, 1.0))
	footer_label.text = ""
	_update_header_meta()
	_update_details_text()

func _mark_first_action() -> void:
	if first_action_timestamp < 0.0:
		first_action_timestamp = Time.get_ticks_msec() / 1000.0

func _on_knob_value_changed(new_value: int) -> void:
	if not trial_active or analysis_committed:
		return
	_apply_user_bits(new_value, true)

func _apply_user_bits(i_value: int, from_user: bool) -> void:
	if from_user:
		_mark_first_action()

	current_bits = clampi(i_value, 1, 12)
	var pow_val: int = int(pow(2.0, current_bits))
	var is_fit: bool = pow_val >= target_n

	if from_user:
		knob_change_count += 1
		var diff_sign: int = signi(target_bits - current_bits)
		if last_diff_sign != 0 and diff_sign != 0 and diff_sign != last_diff_sign:
			direction_change_count += 1
			cross_target_count += 1
		last_diff_sign = diff_sign

	bits_value_label.text = "i = %d \u0431\u0438\u0442" % current_bits
	fit_value_label.text = "\u041f\u041e\u041c\u0415\u0429\u0410\u0415\u0422\u0421\u042f: %s" % ("\u0414\u0410" if is_fit else "\u041d\u0415\u0422")
	fit_value_label.add_theme_color_override("font_color", COLOR_GOOD if is_fit else COLOR_BAD)
	_update_details_text()

func _on_hint_pressed() -> void:
	if not trial_active:
		return
	_mark_first_action()
	hint_used = true
	status_label.text = TXT_STATUS_HINT
	status_label.add_theme_color_override("font_color", Color(0.55, 0.85, 1.0, 1.0))
	_update_details_text()

func _on_analyze_pressed() -> void:
	if not trial_active or analysis_committed:
		return

	_mark_first_action()
	analyze_count += 1
	analysis_committed = true
	btn_analyze.disabled = true
	btn_capture.disabled = true
	bit_knob.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var capacity: int = int(pow(2.0, current_bits))
	last_analysis_fit = capacity >= target_n
	last_analysis_minimal = current_bits == target_bits
	last_analysis_overkill = last_analysis_fit and not last_analysis_minimal

	if not last_analysis_fit:
		status_label.text = TXT_ANALYZE_UNDERFIT
		status_label.add_theme_color_override("font_color", COLOR_WARN)
	elif last_analysis_overkill:
		status_label.text = TXT_ANALYZE_OVERKILL
		status_label.add_theme_color_override("font_color", COLOR_WARN)
	else:
		status_label.text = TXT_ANALYZE_OK
		status_label.add_theme_color_override("font_color", COLOR_GOOD)

	analyze_reveal_until = Time.get_ticks_msec() / 1000.0 + ANALYZE_REVEAL_SECONDS
	_update_details_text()

func _on_capture_pressed() -> void:
	if not trial_active or btn_capture.disabled:
		return
	_mark_first_action()
	_finish_trial(false)

func _finish_trial(is_timeout: bool) -> void:
	if not trial_active:
		return

	trial_active = false
	btn_capture.visible = false
	btn_analyze.disabled = true
	btn_next.visible = true
	btn_hint.disabled = true
	bit_knob.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var end_time: float = Time.get_ticks_msec() / 1000.0
	var duration: float = end_time - start_time
	var capacity: int = int(pow(2.0, current_bits))

	var is_fit: bool = capacity >= target_n
	var is_minimal: bool = current_bits == target_bits
	var is_overkill: bool = is_fit and not is_minimal

	if is_timeout:
		is_fit = false
		is_minimal = false
		is_overkill = false

	if not is_fit:
		status_label.text = TXT_RESULT_BAD
		status_label.add_theme_color_override("font_color", COLOR_BAD)
	elif is_minimal:
		status_label.text = TXT_RESULT_GOOD
		status_label.add_theme_color_override("font_color", COLOR_GOOD)
	else:
		status_label.text = TXT_RESULT_WARN
		status_label.add_theme_color_override("font_color", COLOR_WARN)

	_update_sample_slot(is_fit, is_minimal)

	if first_action_timestamp > 0.0:
		prev_time_to_first_action = first_action_timestamp - start_time
	else:
		prev_time_to_first_action = duration

	var payload: Dictionary = {
		"quest_id": "radio_intercept",
		"stage_id": "A",
		"match_key": "RI_A_%s_%s_N%d" % ["TIMED" if is_timed_mode else "UNTIMED", pool_type, target_n],
		"pool_type": pool_type,
		"N": target_n,
		"i_min": target_bits,
		"chosen_i": current_bits,
		"capacity": capacity,
		"is_fit": is_fit,
		"is_correct": is_fit,
		"is_minimal": is_minimal,
		"is_overkill": is_overkill,
		"used_hint": hint_used,
		"forced_sampling": forced_sampling,
		"analyze_count": analyze_count,
		"knob_change_count": knob_change_count,
		"direction_change_count": direction_change_count,
		"cross_target_count": cross_target_count,
		"elapsed_ms": duration * 1000.0
	}
	GlobalMetrics.register_trial(payload)
	_update_details_text()

func _update_sample_slot(is_fit: bool, is_minimal: bool) -> void:
	if sample_refs.is_empty():
		return
	var slot: Dictionary = sample_refs[current_trial_idx] as Dictionary
	var bg: ColorRect = slot["bg"] as ColorRect
	var mark: Label = slot["mark"] as Label
	if not is_fit:
		bg.color = COLOR_BAD
	elif is_minimal:
		bg.color = COLOR_GOOD
	else:
		bg.color = COLOR_WARN
	mark.visible = pool_type == "ANCHOR"
	current_trial_idx = (current_trial_idx + 1) % min(SAMPLE_SLOTS, sample_refs.size())

func _on_next_pressed() -> void:
	_start_trial()

func _on_back_pressed() -> void:
	get_tree().change_scene_to_file("res://scenes/QuestSelect.tscn")

func _on_details_pressed() -> void:
	_set_details_visible(true)

func _on_details_close_pressed() -> void:
	_set_details_visible(false)

func _on_dimmer_gui_input(event: InputEvent) -> void:
	if (event is InputEventMouseButton and event.pressed) or (event is InputEventScreenTouch and event.pressed):
		_set_details_visible(false)

func _set_details_visible(visible: bool) -> void:
	details_sheet.visible = visible
	dimmer.visible = visible
	btn_details.text = TXT_BTN_DETAILS_OPEN if visible else TXT_BTN_DETAILS_CLOSED

func _update_details_text() -> void:
	var capacity: int = int(pow(2.0, current_bits))
	var lines: Array[String] = []
	lines.append("N: %d" % target_n)
	lines.append("i_min: %d" % target_bits)
	lines.append("i_selected: %d" % current_bits)
	lines.append("2^i: %d" % capacity)
	lines.append("mode: %s" % ("TIMED" if is_timed_mode else "UNTIMED"))
	lines.append("pool: %s" % pool_type)
	if hint_used:
		lines.append("hint: used")
	if analysis_committed:
		lines.append("analysis: done")
	details_text.text = "\n".join(lines)

func _update_header_meta() -> void:
	var mode_text: String = "\u0421 \u0422\u0410\u0419\u041c\u0415\u0420\u041e\u041c" if is_timed_mode else "\u0411\u0415\u0417 \u0422\u0410\u0419\u041c\u0415\u0420\u0410"
	var timer_text: String = ""
	if is_timed_mode:
		timer_text = " | T: %.1f\u0441" % time_remaining
	meta_label.text = "\u0420\u0415\u0416\u0418\u041c: %s | \u0421\u0422\u0410\u0411: %d%%%s" % [mode_text, int(_current_stability), timer_text]

func _on_stability_changed(new_value: float, _delta: float) -> void:
	_current_stability = new_value
	_update_header_meta()

func _apply_safe_area_padding() -> void:
	var left: float = 16.0
	var top: float = 12.0
	var right: float = 16.0
	var bottom: float = 12.0

	var safe_rect: Rect2i = DisplayServer.get_display_safe_area()
	if safe_rect.size.x > 0 and safe_rect.size.y > 0:
		var viewport_size: Vector2 = get_viewport_rect().size
		left = maxf(left, float(safe_rect.position.x))
		top = maxf(top, float(safe_rect.position.y))
		right = maxf(right, viewport_size.x - float(safe_rect.position.x + safe_rect.size.x))
		bottom = maxf(bottom, viewport_size.y - float(safe_rect.position.y + safe_rect.size.y))

	safe_area.add_theme_constant_override("margin_left", int(round(left)))
	safe_area.add_theme_constant_override("margin_top", int(round(top)))
	safe_area.add_theme_constant_override("margin_right", int(round(right)))
	safe_area.add_theme_constant_override("margin_bottom", int(round(bottom)))

func _configure_layout() -> void:
	var size: Vector2 = get_viewport_rect().size
	var phone_landscape: bool = size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

	if phone_landscape:
		body_split.split_offset = int(size.x * 0.54)
		root_vbox.add_theme_constant_override("separation", 8)
		bit_knob.custom_minimum_size = Vector2(180, 180)
		mission_card.custom_minimum_size.y = 110
		scope_card.custom_minimum_size.y = 170
		bits_value_label.add_theme_font_size_override("font_size", 28)
		fit_value_label.add_theme_font_size_override("font_size", 20)
		status_label.add_theme_font_size_override("font_size", 16)
		meta_label.add_theme_font_size_override("font_size", 16)
		for btn in [btn_back, btn_hint, btn_analyze, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 56
	elif size.x < 1280.0:
		body_split.split_offset = int(size.x * 0.55)
		root_vbox.add_theme_constant_override("separation", 10)
		bit_knob.custom_minimum_size = Vector2(200, 200)
		mission_card.custom_minimum_size.y = 122
		scope_card.custom_minimum_size.y = 220
		bits_value_label.add_theme_font_size_override("font_size", 32)
		fit_value_label.add_theme_font_size_override("font_size", 22)
		status_label.add_theme_font_size_override("font_size", 18)
		meta_label.add_theme_font_size_override("font_size", 17)
		for btn in [btn_back, btn_hint, btn_analyze, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58
	else:
		body_split.split_offset = int(size.x * 0.56)
		root_vbox.add_theme_constant_override("separation", 10)
		bit_knob.custom_minimum_size = Vector2(220, 220)
		mission_card.custom_minimum_size.y = 130
		scope_card.custom_minimum_size.y = 260
		bits_value_label.add_theme_font_size_override("font_size", 34)
		fit_value_label.add_theme_font_size_override("font_size", 24)
		status_label.add_theme_font_size_override("font_size", 18)
		meta_label.add_theme_font_size_override("font_size", 18)
		for btn in [btn_back, btn_hint, btn_analyze, btn_capture, btn_next, btn_details, btn_close_details]:
			btn.custom_minimum_size.y = 58

func _update_waveform() -> void:
	if wave_layer.size.x <= 1.0 or wave_layer.size.y <= 1.0:
		return

	if analysis_committed:
		_draw_analysis_wave(wave_layer.size)
	else:
		_draw_idle_wave(wave_layer.size)

func _draw_idle_wave(draw_size: Vector2) -> void:
	var points: PackedVector2Array = PackedVector2Array()
	var center_y: float = draw_size.y * 0.5
	for x in range(0, int(draw_size.x) + 1, 6):
		var t: float = float(x) / maxf(1.0, draw_size.x)
		var y: float = center_y
		y += sin(t * TAU * 2.2 + 0.7) * draw_size.y * 0.12
		y += sin(t * TAU * 9.0 + 1.1) * draw_size.y * 0.05
		y += cos(t * TAU * 18.0 + 0.4) * draw_size.y * 0.03
		points.append(Vector2(x, y))
	wave_line.points = points

func _draw_analysis_wave(draw_size: Vector2) -> void:
	var points: PackedVector2Array = PackedVector2Array()
	var center_y: float = draw_size.y * 0.5
	var main_amp: float = draw_size.y * 0.22
	var noise_amp: float = 0.0

	if not last_analysis_fit:
		noise_amp = draw_size.y * 0.24
	elif last_analysis_overkill:
		noise_amp = draw_size.y * 0.08
		main_amp = draw_size.y * 0.16
	else:
		noise_amp = draw_size.y * 0.02
		main_amp = draw_size.y * 0.20

	for x in range(0, int(draw_size.x) + 1, 6):
		var t: float = float(x) / maxf(1.0, draw_size.x)
		var y: float = center_y + sin((t * TAU * 2.0) + osc_phase) * main_amp
		if noise_amp > 0.0:
			y += sin((t * TAU * 13.0) + osc_phase * 1.7) * noise_amp * 0.5
			y += cos((t * TAU * 29.0) + osc_phase * 0.9) * noise_amp * 0.4
		points.append(Vector2(x, y))
	wave_line.points = points
</file>

<file path="scenes/RadioQuestA.tscn">
[gd_scene load_steps=5 format=3]

[ext_resource type="Script" path="res://scenes/RadioQuestA.gd" id="1_script"]
[ext_resource type="Theme" path="res://ui/theme_terminal_green.tres" id="2_theme"]
[ext_resource type="Shader" path="res://ui/shaders/crt_overlay.gdshader" id="3_shader"]
[ext_resource type="Script" path="res://scenes/BitKnob.gd" id="4_knob_script"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_crt"]
shader = ExtResource("3_shader")
shader_parameter/tint_color = Color(0, 1, 0.25, 1)
shader_parameter/intensity = 0.12
shader_parameter/fx_quality = 1
shader_parameter/glitch_strength = 0.0

[node name="RadioQuestA" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_script")

[node name="Background" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.01, 0.03, 0.015, 1)

[node name="CRTLayer" type="CanvasLayer" parent="."]

[node name="CRTOverlay" type="ColorRect" parent="CRTLayer"]
material = SubResource("ShaderMaterial_crt")
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="SafeArea" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="RootVBox" type="VBoxContainer" parent="SafeArea"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Header" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 62)
layout_mode = 2

[node name="HeaderHBox" type="HBoxContainer" parent="SafeArea/RootVBox/Header"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnBack" type="Button" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(120, 58)
layout_mode = 2
text = "BACK"

[node name="TitleLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 28
text = "RADIO INTERCEPT | A"

[node name="MetaLabel" type="Label" parent="SafeArea/RootVBox/Header/HeaderHBox"]
custom_minimum_size = Vector2(360, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 18
horizontal_alignment = 2
text = "MODE | STABILITY"

[node name="BodyHSplit" type="HSplitContainer" parent="SafeArea/RootVBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
split_offset = 760

[node name="LeftPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LeftMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="LeftVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="MissionCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
custom_minimum_size = Vector2(0, 130)
layout_mode = 2

[node name="MissionMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="MissionVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin"]
layout_mode = 2
theme_override_constants/separation = 4

[node name="MissionTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "MISSION"

[node name="TargetLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 26
text = "N = 128"

[node name="RuleLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/MissionCard/MissionMargin/MissionVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Find minimal i where 2^i >= N"

[node name="ScopeCard" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="ScopeMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard"]
layout_mode = 2
theme_override_constants/margin_left = 8
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 8
theme_override_constants/margin_bottom = 8

[node name="ScopeLayer" type="Control" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="WaveLine" type="Line2D" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ScopeCard/ScopeMargin/ScopeLayer"]
width = 3.0
default_color = Color(0.2, 1, 0.2, 1)

[node name="ReadoutRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
theme_override_constants/separation = 12

[node name="BitsValueLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 34
text = "i = 1"

[node name="FitValueLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/LeftPane/LeftMargin/LeftVBox/ReadoutRow"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "FIT: NO"

[node name="RightPane" type="PanelContainer" parent="SafeArea/RootVBox/BodyHSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RightMargin" type="MarginContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 10

[node name="RightVBox" type="VBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 10

[node name="DecoderTitle" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "DECODER"

[node name="BitKnob" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(220, 220)
layout_mode = 2
size_flags_horizontal = 4
script = ExtResource("4_knob_script")

[node name="KnobHint" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Turn knob, then ANALYZE"

[node name="ActionsRow" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="BtnHint" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "HINT"

[node name="BtnAnalyze" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "ANALYZE"

[node name="BtnCapture" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "CAPTURE"

[node name="BtnNext" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/ActionsRow"]
visible = false
custom_minimum_size = Vector2(0, 58)
layout_mode = 2
size_flags_horizontal = 3
text = "NEXT"

[node name="SampleStrip" type="HBoxContainer" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 32)
layout_mode = 2
theme_override_constants/separation = 8
alignment = 1

[node name="Sample1" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample1"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample2" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample2"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample3" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample3"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample4" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample4"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample5" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample5"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample6" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample6"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Sample7" type="Control" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2

[node name="BG" type="ColorRect" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.2, 0.2, 0.2, 1)

[node name="AnchorMark" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox/SampleStrip/Sample7"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "A"
horizontal_alignment = 1
vertical_alignment = 1

[node name="StatusLabel" type="Label" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 88)
layout_mode = 2
theme_override_font_sizes/font_size = 18
autowrap_mode = 2
text = "Status"

[node name="BtnDetails" type="Button" parent="SafeArea/RootVBox/BodyHSplit/RightPane/RightMargin/RightVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "DETAILS"

[node name="Footer" type="PanelContainer" parent="SafeArea/RootVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2

[node name="FooterMargin" type="MarginContainer" parent="SafeArea/RootVBox/Footer"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 8
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 8

[node name="FooterLabel" type="Label" parent="SafeArea/RootVBox/Footer/FooterMargin"]
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = ""

[node name="Dimmer" type="ColorRect" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
color = Color(0, 0, 0, 0.6)

[node name="DetailsSheet" type="PanelContainer" parent="."]
visible = false
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -320.0
grow_horizontal = 2
grow_vertical = 0

[node name="DetailsMargin" type="MarginContainer" parent="DetailsSheet"]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 12

[node name="DetailsVBox" type="VBoxContainer" parent="DetailsSheet/DetailsMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="DetailsTitle" type="Label" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 22
text = "DETAILS"

[node name="DetailsText" type="RichTextLabel" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 170)
layout_mode = 2
size_flags_vertical = 3
fit_content = false
scroll_active = true
bbcode_enabled = false

[node name="BtnCloseDetails" type="Button" parent="DetailsSheet/DetailsMargin/DetailsVBox"]
custom_minimum_size = Vector2(0, 56)
layout_mode = 2
text = "CLOSE"
</file>

<file path="scenes/QuestSelect.gd">
extends Control

const PHONE_LANDSCAPE_MAX_HEIGHT := 520.0
const MOBILE_BREAKPOINT := 840.0
const TABLET_BREAKPOINT := 1300.0

@onready var safe_area: MarginContainer = $SafeArea
@onready var main_layout: VBoxContainer = $SafeArea/MainLayout
@onready var title_label: Label = $SafeArea/MainLayout/Title
@onready var quest_grid: GridContainer = $SafeArea/MainLayout/QuestGrid
@onready var modal: Panel = $ModalLayer/ModeSelectionModal
@onready var status_label: Label = $SafeArea/MainLayout/StatusLabel

@onready var btn_clues: Button = $SafeArea/MainLayout/QuestGrid/CluesButton
@onready var btn_radio: Button = $SafeArea/MainLayout/QuestGrid/RadioButton
@onready var btn_decryptor: Button = $SafeArea/MainLayout/QuestGrid/DecryptorButton
@onready var btn_lie: Button = $SafeArea/MainLayout/QuestGrid/LieDetectorButton
@onready var btn_script: Button = $SafeArea/MainLayout/QuestGrid/SuspectScriptButton
@onready var btn_city: Button = $SafeArea/MainLayout/QuestGrid/CityMapButton
@onready var btn_archive: Button = $SafeArea/MainLayout/QuestGrid/DataArchiveButton
@onready var btn_report: Button = $SafeArea/MainLayout/QuestGrid/FinalReportButton
@onready var btn_network_trace: Button = $SafeArea/MainLayout/QuestGrid/NetworkTraceButton

@onready var btn_complexity_a: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnComplexityA
@onready var btn_complexity_b: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnComplexityB
@onready var btn_complexity_c: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnComplexityC
@onready var btn_close: Button = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/BtnClose
@onready var modal_title: Label = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer/ModalTitle
@onready var modal_box: VBoxContainer = $ModalLayer/ModeSelectionModal/CenterContainer/VBoxContainer

const COLOR_READY := Color(0.88, 0.88, 0.88, 1.0)
const COLOR_LOCKED := Color(0.92, 0.36, 0.4, 1.0)

enum QuestType { DECRYPTOR, LOGIC_GATE, RADIO, SUSPECT, CITY_MAP, DATA_ARCHIVE, FINAL_REPORT, NETWORK_TRACE, CLUES }
var selected_quest_type := QuestType.DECRYPTOR

const TITLE_TEXT := "ВЫБОР КВЕСТА"
const STATUS_READY := "Выберите квест"
const STATUS_LOCKED := "Этот квест пока не готов"

const BTN_CLUES_TEXT := "Цифровая реанимация"
const BTN_RADIO_TEXT := "Радиоперехват"
const BTN_DECRYPTOR_TEXT := "Дешифрование"
const BTN_LIE_TEXT := "Детектор лжи"
const BTN_SCRIPT_TEXT := "Скрипт подозреваемого"
const BTN_CITY_TEXT := "Карта города"
const BTN_ARCHIVE_TEXT := "Архив данных"
const BTN_REPORT_TEXT := "Финальный отчет"
const BTN_NETWORK_TRACE_TEXT := "Сетевой след"

const MODAL_TITLE_TEXT := "ВЫБОР СЛОЖНОСТИ"
const COMPLEXITY_A_TEXT := "СЛОЖНОСТЬ A"
const COMPLEXITY_B_TEXT := "СЛОЖНОСТЬ B"
const COMPLEXITY_C_TEXT := "СЛОЖНОСТЬ C"
const BTN_CLOSE_TEXT := "НАЗАД"

func _ready() -> void:
	modal.visible = false
	title_label.text = TITLE_TEXT
	status_label.text = STATUS_READY
	status_label.modulate = COLOR_READY

	_set_button_labels()
	_set_modal_labels()
	_connect_buttons()
	_disable_unready()
	_on_viewport_size_changed()
	if not get_tree().root.size_changed.is_connected(_on_viewport_size_changed):
		get_tree().root.size_changed.connect(_on_viewport_size_changed)
	call_deferred("_animate_intro")

func _set_button_labels() -> void:
	btn_clues.text = BTN_CLUES_TEXT
	btn_radio.text = BTN_RADIO_TEXT
	btn_decryptor.text = BTN_DECRYPTOR_TEXT
	btn_lie.text = BTN_LIE_TEXT
	btn_script.text = BTN_SCRIPT_TEXT
	btn_city.text = BTN_CITY_TEXT
	btn_archive.text = BTN_ARCHIVE_TEXT
	btn_report.text = BTN_REPORT_TEXT
	btn_network_trace.text = BTN_NETWORK_TRACE_TEXT

func _set_modal_labels() -> void:
	modal_title.text = MODAL_TITLE_TEXT
	btn_complexity_a.text = COMPLEXITY_A_TEXT
	btn_complexity_b.text = COMPLEXITY_B_TEXT
	btn_complexity_c.text = COMPLEXITY_C_TEXT
	btn_close.text = BTN_CLOSE_TEXT

func _connect_buttons() -> void:
	btn_decryptor.pressed.connect(_on_decryptor_pressed)
	btn_lie.pressed.connect(_on_lie_detector_pressed)
	btn_radio.pressed.connect(_on_radio_pressed)
	btn_clues.pressed.connect(_on_clues_pressed)
	btn_script.pressed.connect(_on_script_pressed)
	btn_city.pressed.connect(_on_city_pressed)
	btn_archive.pressed.connect(_on_archive_pressed)
	btn_report.pressed.connect(_on_report_pressed)
	btn_network_trace.pressed.connect(_on_network_trace_pressed)

	btn_complexity_a.pressed.connect(_on_complexity_a_pressed)
	btn_complexity_b.pressed.connect(_on_complexity_b_pressed)
	btn_complexity_c.pressed.connect(_on_complexity_c_pressed)
	btn_close.pressed.connect(_on_close_modal_pressed)

func _disable_unready() -> void:
	btn_clues.disabled = false
	btn_radio.disabled = false
	btn_script.disabled = false
	btn_city.disabled = false
	btn_archive.disabled = false
	btn_report.disabled = false
	btn_network_trace.disabled = false
	btn_complexity_c.disabled = true

func _on_decryptor_pressed() -> void:
	selected_quest_type = QuestType.DECRYPTOR
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_lie_detector_pressed() -> void:
	selected_quest_type = QuestType.LOGIC_GATE
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_radio_pressed() -> void:
	selected_quest_type = QuestType.RADIO
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_clues_pressed() -> void:
	selected_quest_type = QuestType.CLUES
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_script_pressed() -> void:
	selected_quest_type = QuestType.SUSPECT
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_city_pressed() -> void:
	selected_quest_type = QuestType.CITY_MAP
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_archive_pressed() -> void:
	selected_quest_type = QuestType.DATA_ARCHIVE
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_report_pressed() -> void:
	selected_quest_type = QuestType.FINAL_REPORT
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_network_trace_pressed() -> void:
	selected_quest_type = QuestType.NETWORK_TRACE
	_set_complexity_enabled(true, true)
	modal.visible = true

func _on_complexity_a_pressed() -> void:
	GlobalMetrics.current_level_index = 0
	match selected_quest_type:
		QuestType.DECRYPTOR:
			get_tree().change_scene_to_file("res://scenes/Decryptor.tscn")
		QuestType.LOGIC_GATE:
			get_tree().change_scene_to_file("res://scenes/LogicQuestA.tscn")
		QuestType.RADIO:
			get_tree().change_scene_to_file("res://scenes/RadioQuestA.tscn")
		QuestType.SUSPECT:
			get_tree().change_scene_to_file("res://scenes/SuspectQuestA.tscn")
		QuestType.CITY_MAP:
			get_tree().change_scene_to_file("res://scenes/CityMapQuestA.tscn")
		QuestType.DATA_ARCHIVE:
			get_tree().change_scene_to_file("res://scenes/case_07/da7_data_archive_a.tscn")
		QuestType.FINAL_REPORT:
			get_tree().change_scene_to_file("res://scenes/case_08/fr8_final_report_a.tscn")
		QuestType.NETWORK_TRACE:
			get_tree().change_scene_to_file("res://scenes/NetworkTraceQuestA.tscn")
		QuestType.CLUES:
			get_tree().change_scene_to_file("res://scenes/case_01/DigitalResusQuestA.tscn")

func _on_complexity_b_pressed() -> void:
	if selected_quest_type == QuestType.FINAL_REPORT:
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/case_08/fr8_final_report_b.tscn")
		return
	if selected_quest_type == QuestType.DECRYPTOR:
		GlobalMetrics.current_level_index = 15
		get_tree().change_scene_to_file("res://scenes/Decryptor.tscn")
	elif selected_quest_type == QuestType.LOGIC_GATE:
		get_tree().change_scene_to_file("res://scenes/LogicQuestB.tscn")
	elif selected_quest_type == QuestType.RADIO:
		get_tree().change_scene_to_file("res://scenes/RadioQuestB.tscn")
	elif selected_quest_type == QuestType.SUSPECT:
		get_tree().change_scene_to_file("res://scenes/RestoreQuestB.tscn")
	elif selected_quest_type == QuestType.CITY_MAP:
		get_tree().change_scene_to_file("res://scenes/CityMapQuestB.tscn")
	elif selected_quest_type == QuestType.DATA_ARCHIVE:
		get_tree().change_scene_to_file("res://scenes/case_07/da7_data_archive_b.tscn")
	elif selected_quest_type == QuestType.NETWORK_TRACE:
		get_tree().change_scene_to_file("res://scenes/NetworkTraceQuestB.tscn")
	elif selected_quest_type == QuestType.CLUES:
		get_tree().change_scene_to_file("res://scenes/case_01/DigitalResusQuestB.tscn")

func _on_complexity_c_pressed() -> void:
	if selected_quest_type == QuestType.FINAL_REPORT:
		GlobalMetrics.current_level_index = 0
		get_tree().change_scene_to_file("res://scenes/case_08/fr8_final_report_c.tscn")
		return
	if selected_quest_type == QuestType.DECRYPTOR:
		get_tree().change_scene_to_file("res://scenes/MatrixDecryptor.tscn")
	elif selected_quest_type == QuestType.LOGIC_GATE:
		get_tree().change_scene_to_file("res://scenes/LogicQuestC.tscn")
	elif selected_quest_type == QuestType.RADIO:
		get_tree().change_scene_to_file("res://scenes/RadioQuestC.tscn")
	elif selected_quest_type == QuestType.SUSPECT:
		get_tree().change_scene_to_file("res://scenes/DisarmQuestC.tscn")
	elif selected_quest_type == QuestType.CITY_MAP:
		get_tree().change_scene_to_file("res://scenes/CityMapQuestC.tscn")
	elif selected_quest_type == QuestType.DATA_ARCHIVE:
		get_tree().change_scene_to_file("res://scenes/case_07/da7_data_archive_c.tscn")
	elif selected_quest_type == QuestType.NETWORK_TRACE:
		get_tree().change_scene_to_file("res://scenes/NetworkTraceQuestC.tscn")
	elif selected_quest_type == QuestType.CLUES:
		get_tree().change_scene_to_file("res://scenes/case_01/DigitalResusQuestC.tscn")

func _on_close_modal_pressed() -> void:
	modal.visible = false

func _set_complexity_enabled(enable_b: bool, enable_c: bool) -> void:
	btn_complexity_b.disabled = not enable_b
	btn_complexity_c.disabled = not enable_c

func _on_viewport_size_changed() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	var width: float = viewport_size.x
	if _is_phone_landscape(viewport_size):
		quest_grid.columns = 3
		_apply_layout_profile(38, 15, 70, 8, 10, 6)
		_apply_modal_profile(28, 19, clampf(viewport_size.x - 40.0, 320.0, 480.0), clampf(viewport_size.y - 24.0, 220.0, 320.0))
	elif width < MOBILE_BREAKPOINT:
		quest_grid.columns = 1
		_apply_layout_profile(48, 18, 100, 12, 16, 12)
		_apply_modal_profile(36, 24, clampf(viewport_size.x - 40.0, 320.0, 560.0), clampf(viewport_size.y - 60.0, 260.0, 420.0))
	elif width < TABLET_BREAKPOINT:
		quest_grid.columns = 2
		_apply_layout_profile(54, 19, 108, 14, 20, 14)
		_apply_modal_profile(40, 27, 560.0, 400.0)
	else:
		quest_grid.columns = 3
		_apply_layout_profile(58, 20, 118, 14, 24, 16)
		_apply_modal_profile(44, 30, 620.0, 420.0)

func _is_phone_landscape(size: Vector2) -> bool:
	return size.x > size.y and size.y <= PHONE_LANDSCAPE_MAX_HEIGHT

func _apply_layout_profile(title_size: int, info_size: int, button_height: float, gap: int, margin_side: int, margin_vertical: int) -> void:
	title_label.add_theme_font_size_override("font_size", title_size)
	status_label.add_theme_font_size_override("font_size", info_size)
	status_label.custom_minimum_size.y = max(32.0, button_height * 0.4)
	main_layout.add_theme_constant_override("separation", gap + 6)
	quest_grid.add_theme_constant_override("h_separation", gap)
	quest_grid.add_theme_constant_override("v_separation", gap)
	safe_area.add_theme_constant_override("margin_left", margin_side)
	safe_area.add_theme_constant_override("margin_right", margin_side)
	safe_area.add_theme_constant_override("margin_top", margin_vertical)
	safe_area.add_theme_constant_override("margin_bottom", margin_vertical)
	for btn in _all_quest_buttons():
		btn.custom_minimum_size = Vector2(0.0, button_height)
		btn.add_theme_font_size_override("font_size", clamp(info_size + 1, 16, 20))

func _apply_modal_profile(modal_title_size: int, button_font_size: int, min_width: float, min_height: float) -> void:
	modal_box.custom_minimum_size = Vector2(min_width, min_height)
	modal_title.add_theme_font_size_override("font_size", modal_title_size)
	btn_complexity_a.add_theme_font_size_override("font_size", button_font_size)
	btn_complexity_b.add_theme_font_size_override("font_size", button_font_size)
	btn_complexity_c.add_theme_font_size_override("font_size", button_font_size)
	btn_complexity_a.custom_minimum_size.y = max(56.0, float(button_font_size) * 2.25)
	btn_complexity_b.custom_minimum_size.y = max(56.0, float(button_font_size) * 2.25)
	btn_complexity_c.custom_minimum_size.y = max(56.0, float(button_font_size) * 2.25)
	btn_close.add_theme_font_size_override("font_size", max(18, button_font_size - 5))
	btn_close.custom_minimum_size.y = max(48.0, float(button_font_size) * 2.0)

func _animate_intro() -> void:
	title_label.modulate.a = 0.0
	var tween: Tween = create_tween()
	tween.tween_property(title_label, "modulate:a", 1.0, 0.3)

	for i in range(_all_quest_buttons().size()):
		var btn: Button = _all_quest_buttons()[i]
		btn.modulate.a = 0.0
		btn.scale = Vector2(0.97, 0.97)
		btn.pivot_offset = btn.size * 0.5
		var item_tween: Tween = create_tween()
		var delay: float = 0.06 * float(i)
		item_tween.tween_property(btn, "modulate:a", 1.0, 0.2).set_delay(delay)
		item_tween.parallel().tween_property(btn, "scale", Vector2.ONE, 0.24).set_delay(delay).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)

func _all_quest_buttons() -> Array[Button]:
	return [
		btn_clues,
		btn_radio,
		btn_decryptor,
		btn_lie,
		btn_script,
		btn_city,
		btn_archive,
		btn_report,
		btn_network_trace
	]
</file>

</files>
