extends PopupPanel

signal option_selected(option_id: String)
signal apply_requested(option_id: String)
signal canceled

@onready var lbl_title: Label = $Root/LblTitle
@onready var lbl_original: Label = $Root/LblOriginal
@onready var btn_opt_a: Button = $Root/Options/BtnOptA
@onready var btn_opt_b: Button = $Root/Options/BtnOptB
@onready var btn_opt_c: Button = $Root/Options/BtnOptC
@onready var btn_apply: Button = $Root/Actions/BtnApply
@onready var btn_close: Button = $Root/Actions/BtnClose

var selected_option_id := ""
var options_by_id: Dictionary = {}

func _normalize_option_id(value: Variant) -> String:
	return str(value).strip_edges().to_upper()

func _short_line(line_text: String, max_chars: int = 48) -> String:
	var clean := line_text.strip_edges()
	if clean.length() <= max_chars:
		return clean
	return clean.substr(0, max_chars - 3) + "..."

func _ready() -> void:
	btn_opt_a.pressed.connect(_on_option_pressed.bind("A"))
	btn_opt_b.pressed.connect(_on_option_pressed.bind("B"))
	btn_opt_c.pressed.connect(_on_option_pressed.bind("C"))
	btn_apply.pressed.connect(_on_apply_pressed)
	btn_close.pressed.connect(_on_close_pressed)
	btn_apply.disabled = true

func setup(line_number_1_based: int, original_line: String, fix_options: Array, preselected_option_id: String = "") -> void:
	lbl_title.text = "ИСПРАВИТЬ СТРОКУ %02d" % line_number_1_based
	lbl_original.text = "оригинал: %s" % _short_line(original_line, 64)

	options_by_id.clear()
	var option_buttons := {
		"A": btn_opt_a,
		"B": btn_opt_b,
		"C": btn_opt_c
	}
	var ordered_ids := ["A", "B", "C"]

	for option_id in ordered_ids:
		var btn: Button = option_buttons[option_id]
		btn.text = "%s) --" % option_id
		btn.disabled = true

	for opt_var in fix_options:
		if typeof(opt_var) != TYPE_DICTIONARY:
			continue
		var opt: Dictionary = opt_var
		var option_id := _normalize_option_id(opt.get("option_id", ""))
		if not option_buttons.has(option_id):
			continue
		options_by_id[option_id] = opt
		var btn: Button = option_buttons[option_id]
		btn.disabled = false
		btn.text = "%s) %s  ->  s=%s" % [
			option_id,
			_short_line(str(opt.get("replace_line", ""))),
			str(opt.get("result_s", "?"))
		]

	var normalized_preselected := _normalize_option_id(preselected_option_id)
	selected_option_id = normalized_preselected if options_by_id.has(normalized_preselected) else ""
	_refresh_selection_visuals()

func _on_option_pressed(option_id: String) -> void:
	var normalized_option_id := _normalize_option_id(option_id)
	if not options_by_id.has(normalized_option_id):
		return
	selected_option_id = normalized_option_id
	_refresh_selection_visuals()
	option_selected.emit(normalized_option_id)

func _refresh_selection_visuals() -> void:
	var map := {
		"A": btn_opt_a,
		"B": btn_opt_b,
		"C": btn_opt_c
	}
	for option_id in map.keys():
		var btn: Button = map[option_id]
		if option_id == selected_option_id:
			btn.modulate = Color(0.95, 0.95, 0.93, 1.0)
		else:
			btn.modulate = Color(0.78, 0.78, 0.76, 1.0)
	btn_apply.disabled = selected_option_id == ""

func _on_apply_pressed() -> void:
	if selected_option_id == "":
		return
	apply_requested.emit(selected_option_id)
	hide()

func _on_close_pressed() -> void:
	canceled.emit()
	hide()

